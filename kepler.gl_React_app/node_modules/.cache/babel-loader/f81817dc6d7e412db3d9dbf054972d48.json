{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Texture2D, ProgramManager } from '@luma.gl/core';\nimport { AmbientLight } from './ambient-light';\nimport { DirectionalLight } from './directional-light';\nimport Effect from '../../lib/effect';\nimport { Matrix4, Vector3 } from 'math.gl';\nimport ShadowPass from '../../passes/shadow-pass';\nimport { default as shadow } from '../../shaderlib/shadow/shadow';\nvar DEFAULT_AMBIENT_LIGHT_PROPS = {\n  color: [255, 255, 255],\n  intensity: 1.0\n};\nvar DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{\n  color: [255, 255, 255],\n  intensity: 1.0,\n  direction: [-1, 3, -1]\n}, {\n  color: [255, 255, 255],\n  intensity: 0.9,\n  direction: [1, -8, -2.5]\n}];\nvar DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];\nvar LightingEffect = function (_Effect) {\n  _inherits(LightingEffect, _Effect);\n  function LightingEffect(props) {\n    var _this;\n    _classCallCheck(this, LightingEffect);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LightingEffect).call(this, props));\n    _this.ambientLight = null;\n    _this.directionalLights = [];\n    _this.pointLights = [];\n    _this.shadowColor = DEFAULT_SHADOW_COLOR;\n    _this.shadowPasses = [];\n    _this.shadowMaps = [];\n    _this.dummyShadowMap = null;\n    _this.shadow = false;\n    _this.programManager = null;\n    for (var key in props) {\n      var lightSource = props[key];\n      switch (lightSource.type) {\n        case 'ambient':\n          _this.ambientLight = lightSource;\n          break;\n        case 'directional':\n          _this.directionalLights.push(lightSource);\n          break;\n        case 'point':\n          _this.pointLights.push(lightSource);\n          break;\n        default:\n      }\n    }\n    _this._applyDefaultLights();\n    _this.shadow = _this.directionalLights.some(function (light) {\n      return light.shadow;\n    });\n    return _this;\n  }\n  _createClass(LightingEffect, [{\n    key: \"preRender\",\n    value: function preRender(gl, _ref) {\n      var layers = _ref.layers,\n        layerFilter = _ref.layerFilter,\n        viewports = _ref.viewports,\n        onViewportActive = _ref.onViewportActive,\n        views = _ref.views;\n      if (!this.shadow) return;\n      this.shadowMatrices = this._createLightMatrix();\n      if (this.shadowPasses.length === 0) {\n        this._createShadowPasses(gl);\n      }\n      if (!this.programManager) {\n        this.programManager = ProgramManager.getDefaultProgramManager(gl);\n        if (shadow) {\n          this.programManager.addDefaultModule(shadow);\n        }\n      }\n      if (!this.dummyShadowMap) {\n        this.dummyShadowMap = new Texture2D(gl, {\n          width: 1,\n          height: 1\n        });\n      }\n      for (var i = 0; i < this.shadowPasses.length; i++) {\n        var shadowPass = this.shadowPasses[i];\n        shadowPass.render({\n          layers: layers,\n          layerFilter: layerFilter,\n          viewports: viewports,\n          onViewportActive: onViewportActive,\n          views: views,\n          moduleParameters: {\n            shadowLightId: i,\n            dummyShadowMap: this.dummyShadowMap,\n            shadowMatrices: this.shadowMatrices\n          }\n        });\n      }\n    }\n  }, {\n    key: \"getModuleParameters\",\n    value: function getModuleParameters(layer) {\n      var parameters = this.shadow ? {\n        shadowMaps: this.shadowMaps,\n        dummyShadowMap: this.dummyShadowMap,\n        shadowColor: this.shadowColor,\n        shadowMatrices: this.shadowMatrices\n      } : {};\n      parameters.lightSources = {\n        ambientLight: this.ambientLight,\n        directionalLights: this.directionalLights.map(function (directionalLight) {\n          return directionalLight.getProjectedLight({\n            layer: layer\n          });\n        }),\n        pointLights: this.pointLights.map(function (pointLight) {\n          return pointLight.getProjectedLight({\n            layer: layer\n          });\n        })\n      };\n      return parameters;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = this.shadowPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var shadowPass = _step.value;\n          shadowPass[\"delete\"]();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      this.shadowPasses.length = 0;\n      this.shadowMaps.length = 0;\n      if (this.dummyShadowMap) {\n        this.dummyShadowMap[\"delete\"]();\n        this.dummyShadowMap = null;\n      }\n      if (this.shadow && this.programManager) {\n        this.programManager.removeDefaultModule(shadow);\n        this.programManager = null;\n      }\n    }\n  }, {\n    key: \"_createLightMatrix\",\n    value: function _createLightMatrix() {\n      var lightMatrices = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        for (var _iterator2 = this.directionalLights[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var light = _step2.value;\n          var viewMatrix = new Matrix4().lookAt({\n            eye: new Vector3(light.direction).negate()\n          });\n          lightMatrices.push(viewMatrix);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n      return lightMatrices;\n    }\n  }, {\n    key: \"_createShadowPasses\",\n    value: function _createShadowPasses(gl) {\n      for (var i = 0; i < this.directionalLights.length; i++) {\n        var shadowPass = new ShadowPass(gl);\n        this.shadowPasses[i] = shadowPass;\n        this.shadowMaps[i] = shadowPass.shadowMap;\n      }\n    }\n  }, {\n    key: \"_applyDefaultLights\",\n    value: function _applyDefaultLights() {\n      var ambientLight = this.ambientLight,\n        pointLights = this.pointLights,\n        directionalLights = this.directionalLights;\n      if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {\n        this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);\n        this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));\n      }\n    }\n  }]);\n  return LightingEffect;\n}(Effect);\nexport { LightingEffect as default };","map":{"version":3,"sources":["../../../../src/effects/lighting/lighting-effect.js"],"names":["Texture2D","ProgramManager","AmbientLight","DirectionalLight","Effect","Matrix4","Vector3","ShadowPass","default","shadow","DEFAULT_AMBIENT_LIGHT_PROPS","color","intensity","DEFAULT_DIRECTIONAL_LIGHT_PROPS","direction","DEFAULT_SHADOW_COLOR","LightingEffect","props","ambientLight","directionalLights","pointLights","shadowColor","shadowPasses","shadowMaps","dummyShadowMap","programManager","key","lightSource","type","push","_applyDefaultLights","some","light","gl","layers","layerFilter","viewports","onViewportActive","views","shadowMatrices","_createLightMatrix","length","_createShadowPasses","getDefaultProgramManager","addDefaultModule","width","height","i","shadowPass","render","moduleParameters","shadowLightId","layer","parameters","lightSources","map","getProjectedLight","removeDefaultModule","lightMatrices","viewMatrix","lookAt","eye","negate","shadowMap"],"mappings":"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","sourcesContent":["import {Texture2D, ProgramManager} from '@luma.gl/core';\nimport {AmbientLight} from './ambient-light';\nimport {DirectionalLight} from './directional-light';\nimport Effect from '../../lib/effect';\nimport {Matrix4, Vector3} from 'math.gl';\nimport ShadowPass from '../../passes/shadow-pass';\nimport {default as shadow} from '../../shaderlib/shadow/shadow';\n\nconst DEFAULT_AMBIENT_LIGHT_PROPS = {color: [255, 255, 255], intensity: 1.0};\nconst DEFAULT_DIRECTIONAL_LIGHT_PROPS = [\n  {\n    color: [255, 255, 255],\n    intensity: 1.0,\n    direction: [-1, 3, -1]\n  },\n  {\n    color: [255, 255, 255],\n    intensity: 0.9,\n    direction: [1, -8, -2.5]\n  }\n];\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];\n\n// Class to manage ambient, point and directional light sources in deck\nexport default class LightingEffect extends Effect {\n  constructor(props) {\n    super(props);\n    this.ambientLight = null;\n    this.directionalLights = [];\n    this.pointLights = [];\n\n    this.shadowColor = DEFAULT_SHADOW_COLOR;\n    this.shadowPasses = [];\n    this.shadowMaps = [];\n    this.dummyShadowMap = null;\n    this.shadow = false;\n    this.programManager = null;\n\n    for (const key in props) {\n      const lightSource = props[key];\n\n      switch (lightSource.type) {\n        case 'ambient':\n          this.ambientLight = lightSource;\n          break;\n\n        case 'directional':\n          this.directionalLights.push(lightSource);\n          break;\n\n        case 'point':\n          this.pointLights.push(lightSource);\n          break;\n        default:\n      }\n    }\n    this._applyDefaultLights();\n\n    this.shadow = this.directionalLights.some(light => light.shadow);\n  }\n\n  preRender(gl, {layers, layerFilter, viewports, onViewportActive, views}) {\n    if (!this.shadow) return;\n\n    // create light matrix every frame to make sure always updated from light source\n    this.shadowMatrices = this._createLightMatrix();\n\n    if (this.shadowPasses.length === 0) {\n      this._createShadowPasses(gl);\n    }\n    if (!this.programManager) {\n      // TODO - support multiple contexts\n      this.programManager = ProgramManager.getDefaultProgramManager(gl);\n      if (shadow) {\n        this.programManager.addDefaultModule(shadow);\n      }\n    }\n\n    if (!this.dummyShadowMap) {\n      this.dummyShadowMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    for (let i = 0; i < this.shadowPasses.length; i++) {\n      const shadowPass = this.shadowPasses[i];\n      shadowPass.render({\n        layers,\n        layerFilter,\n        viewports,\n        onViewportActive,\n        views,\n        moduleParameters: {\n          shadowLightId: i,\n          dummyShadowMap: this.dummyShadowMap,\n          shadowMatrices: this.shadowMatrices\n        }\n      });\n    }\n  }\n\n  getModuleParameters(layer) {\n    const parameters = this.shadow\n      ? {\n          shadowMaps: this.shadowMaps,\n          dummyShadowMap: this.dummyShadowMap,\n          shadowColor: this.shadowColor,\n          shadowMatrices: this.shadowMatrices\n        }\n      : {};\n\n    // when not rendering to screen, turn off lighting by adding empty light source object\n    // lights shader module relies on the `lightSources` to turn on/off lighting\n    parameters.lightSources = {\n      ambientLight: this.ambientLight,\n      directionalLights: this.directionalLights.map(directionalLight =>\n        directionalLight.getProjectedLight({layer})\n      ),\n      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({layer}))\n    };\n\n    return parameters;\n  }\n\n  cleanup() {\n    for (const shadowPass of this.shadowPasses) {\n      shadowPass.delete();\n    }\n    this.shadowPasses.length = 0;\n    this.shadowMaps.length = 0;\n\n    if (this.dummyShadowMap) {\n      this.dummyShadowMap.delete();\n      this.dummyShadowMap = null;\n    }\n\n    if (this.shadow && this.programManager) {\n      this.programManager.removeDefaultModule(shadow);\n      this.programManager = null;\n    }\n  }\n\n  _createLightMatrix() {\n    const lightMatrices = [];\n    for (const light of this.directionalLights) {\n      const viewMatrix = new Matrix4().lookAt({\n        eye: new Vector3(light.direction).negate()\n      });\n\n      lightMatrices.push(viewMatrix);\n    }\n    return lightMatrices;\n  }\n\n  _createShadowPasses(gl) {\n    for (let i = 0; i < this.directionalLights.length; i++) {\n      const shadowPass = new ShadowPass(gl);\n      this.shadowPasses[i] = shadowPass;\n      this.shadowMaps[i] = shadowPass.shadowMap;\n    }\n  }\n\n  _applyDefaultLights() {\n    const {ambientLight, pointLights, directionalLights} = this;\n    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {\n      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);\n      this.directionalLights.push(\n        new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]),\n        new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1])\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}