{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeSuffixAndDelimiters = removeSuffixAndDelimiters;\nexports.findPointFieldPairs = findPointFieldPairs;\nexports.sortDatasetByColumn = sortDatasetByColumn;\nexports.copyTable = copyTable;\nexports.copyTableAndUpdate = copyTableAndUpdate;\nexports[\"default\"] = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _console = require(\"global/console\");\nvar _defaultSettings = require(\"../../constants/default-settings\");\nvar _d3Array = require(\"d3-array\");\nvar _utils = require(\"../utils\");\nvar _gpuFilterUtils = require(\"../gpu-filter-utils\");\nvar _filterUtils = require(\"../filter-utils\");\nvar _dataUtils = require(\"../data-utils\");\nvar _dataScaleUtils = require(\"../data-scale-utils\");\nvar _dataContainerUtils = require(\"./data-container-utils\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n// Unique identifier of each field\nvar FID_KEY = 'name';\n/** @typedef {import('./kepler-table').KeplerTable} KeplerTableClass} */\n\n/**\n * @type {KeplerTableClass}\n */\n\nvar KeplerTable = /*#__PURE__*/function () {\n  function KeplerTable(_ref) {\n    var _ref$info = _ref.info,\n      info = _ref$info === void 0 ? {} : _ref$info,\n      data = _ref.data,\n      color = _ref.color,\n      metadata = _ref.metadata,\n      supportedFilterTypes = _ref.supportedFilterTypes;\n    (0, _classCallCheck2[\"default\"])(this, KeplerTable);\n    // TODO - what to do if validation fails? Can kepler handle exceptions?\n    // const validatedData = validateInputData(data);\n    // if (!validatedData) {\n    //   return this;\n    // }\n    var dataContainer = (0, _dataContainerUtils.createDataContainer)(data.rows, {\n      fields: data.fields\n    });\n    var datasetInfo = _objectSpread({\n      id: (0, _utils.generateHashId)(4),\n      label: 'new dataset'\n    }, info || {});\n    var dataId = datasetInfo.id;\n    var fields = data.fields.map(function (f, i) {\n      return _objectSpread(_objectSpread({}, f), {}, {\n        fieldIdx: i,\n        id: f.name,\n        displayName: f.displayName || f.name,\n        valueAccessor: _dataUtils.maybeToDate.bind(null,\n        // is time\n        f.type === _defaultSettings.ALL_FIELD_TYPES.timestamp, i, f.format, dataContainer)\n      });\n    });\n    var allIndexes = dataContainer.getPlainIndex();\n    this.id = datasetInfo.id;\n    this.label = datasetInfo.label;\n    this.color = color;\n    this.metadata = _objectSpread(_objectSpread({}, metadata), {}, {\n      id: datasetInfo.id,\n      label: datasetInfo.label\n    });\n    this.dataContainer = dataContainer;\n    this.allIndexes = allIndexes;\n    this.filteredIndex = allIndexes;\n    this.filteredIndexForDomain = allIndexes;\n    this.fieldPairs = findPointFieldPairs(fields);\n    this.fields = fields;\n    this.gpuFilter = (0, _gpuFilterUtils.getGpuFilterProps)([], dataId, fields);\n    if (supportedFilterTypes) {\n      this.supportedFilterTypes = supportedFilterTypes;\n    }\n  }\n  /**\n   * Get field\n   * @param columnName\n   */\n\n  (0, _createClass2[\"default\"])(KeplerTable, [{\n    key: \"getColumnField\",\n    value: function getColumnField(columnName) {\n      var field = this.fields.find(function (fd) {\n        return fd[FID_KEY] === columnName;\n      });\n      this._assetField(columnName, field);\n      return field;\n    }\n    /**\n     * Get fieldIdx\n     * @param columnName\n     */\n  }, {\n    key: \"getColumnFieldIdx\",\n    value: function getColumnFieldIdx(columnName) {\n      var fieldIdx = this.fields.findIndex(function (fd) {\n        return fd[FID_KEY] === columnName;\n      });\n      this._assetField(columnName, Boolean(fieldIdx > -1));\n      return fieldIdx;\n    }\n    /**\n     * Get the value of a cell\n     */\n  }, {\n    key: \"getValue\",\n    value: function getValue(columnName, rowIdx) {\n      var field = this.getColumnField(columnName);\n      return field ? field.valueAccessor({\n        index: rowIdx\n      }) : null;\n    }\n    /**\n     * Updates existing field with a new object\n     * @param fieldIdx\n     * @param newField\n     */\n  }, {\n    key: \"updateColumnField\",\n    value: function updateColumnField(fieldIdx, newField) {\n      this.fields = Object.assign((0, _toConsumableArray2[\"default\"])(this.fields), (0, _defineProperty2[\"default\"])({}, fieldIdx, newField));\n    }\n    /**\n     * Save filterProps to field and retrieve it\n     * @param {string} columnName\n     */\n  }, {\n    key: \"getColumnFilterProps\",\n    value: function getColumnFilterProps(columnName) {\n      var fieldIdx = this.getColumnFieldIdx(columnName);\n      if (fieldIdx < 0) {\n        return null;\n      }\n      var field = this.fields[fieldIdx];\n      if (field.hasOwnProperty('filterProps')) {\n        return field.filterProps;\n      }\n      var fieldDomain = this.getColumnFilterDomain(field);\n      if (!fieldDomain) {\n        return null;\n      }\n      var filterProps = (0, _filterUtils.getFilterProps)(field, fieldDomain);\n      var newField = _objectSpread(_objectSpread({}, field), {}, {\n        filterProps: filterProps\n      });\n      this.updateColumnField(fieldIdx, newField);\n      return filterProps;\n    }\n    /**\n     * Apply filters to dataset, return the filtered dataset with updated `gpuFilter`, `filterRecord`, `filteredIndex`, `filteredIndexForDomain`\n     * @param filters\n     * @param layers\n     * @param opt\n     */\n  }, {\n    key: \"filterTable\",\n    value: function filterTable(filters, layers, opt) {\n      var _this = this;\n      var dataContainer = this.dataContainer,\n        dataId = this.id,\n        oldFilterRecord = this.filterRecord,\n        fields = this.fields; // if there is no filters\n\n      var filterRecord = (0, _filterUtils.getFilterRecord)(dataId, filters, opt || {});\n      this.filterRecord = filterRecord;\n      this.gpuFilter = (0, _gpuFilterUtils.getGpuFilterProps)(filters, dataId, fields); // const newDataset = set(['filterRecord'], filterRecord, dataset);\n\n      if (!filters.length) {\n        this.filteredIndex = this.allIndexes;\n        this.filteredIndexForDomain = this.allIndexes;\n        return this;\n      }\n      this.changedFilters = (0, _filterUtils.diffFilters)(filterRecord, oldFilterRecord); // generate 2 sets of filter result\n      // filteredIndex used to calculate layer data\n      // filteredIndexForDomain used to calculate layer Domain\n\n      var shouldCalDomain = Boolean(this.changedFilters.dynamicDomain);\n      var shouldCalIndex = Boolean(this.changedFilters.cpu);\n      var filterResult = {};\n      if (shouldCalDomain || shouldCalIndex) {\n        var dynamicDomainFilters = shouldCalDomain ? filterRecord.dynamicDomain : null;\n        var cpuFilters = shouldCalIndex ? filterRecord.cpu : null;\n        var filterFuncs = filters.reduce(function (acc, filter) {\n          var fieldIndex = (0, _gpuFilterUtils.getDatasetFieldIndexForFilter)(_this.id, filter);\n          var field = fieldIndex !== -1 ? fields[fieldIndex] : null;\n          return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, filter.id, (0, _filterUtils.getFilterFunction)(field, _this.id, filter, layers, dataContainer)));\n        }, {});\n        filterResult = (0, _filterUtils.filterDataByFilterTypes)({\n          dynamicDomainFilters: dynamicDomainFilters,\n          cpuFilters: cpuFilters,\n          filterFuncs: filterFuncs\n        }, dataContainer);\n      }\n      this.filteredIndex = filterResult.filteredIndex || this.filteredIndex;\n      this.filteredIndexForDomain = filterResult.filteredIndexForDomain || this.filteredIndexForDomain;\n      return this;\n    }\n    /**\n     * Apply filters to a dataset all on CPU, assign to `filteredIdxCPU`, `filterRecordCPU`\n     * @param filters\n     * @param layers\n     */\n  }, {\n    key: \"filterTableCPU\",\n    value: function filterTableCPU(filters, layers) {\n      var opt = {\n        cpuOnly: true,\n        ignoreDomain: true\n      }; // no filter\n\n      if (!filters.length) {\n        this.filteredIdxCPU = this.allIndexes;\n        this.filterRecordCPU = (0, _filterUtils.getFilterRecord)(this.id, filters, opt);\n        return this;\n      } // no gpu filter\n\n      if (!filters.find(function (f) {\n        return f.gpu;\n      })) {\n        this.filteredIdxCPU = this.filteredIndex;\n        this.filterRecordCPU = (0, _filterUtils.getFilterRecord)(this.id, filters, opt);\n        return this;\n      } // make a copy for cpu filtering\n\n      var copied = copyTable(this);\n      copied.filterRecord = this.filterRecordCPU;\n      copied.filteredIndex = this.filteredIdxCPU || [];\n      var filtered = copied.filterTable(filters, layers, opt);\n      this.filteredIdxCPU = filtered.filteredIndex;\n      this.filterRecordCPU = filtered.filterRecord;\n      return this;\n    }\n    /**\n     * Calculate field domain based on field type and data\n     * for Filter\n     */\n  }, {\n    key: \"getColumnFilterDomain\",\n    value: function getColumnFilterDomain(field) {\n      var dataContainer = this.dataContainer;\n      var valueAccessor = field.valueAccessor;\n      var domain;\n      switch (field.type) {\n        case _defaultSettings.ALL_FIELD_TYPES.real:\n        case _defaultSettings.ALL_FIELD_TYPES.integer:\n          // calculate domain and step\n          return (0, _filterUtils.getNumericFieldDomain)(dataContainer, valueAccessor);\n        case _defaultSettings.ALL_FIELD_TYPES[\"boolean\"]:\n          return {\n            domain: [true, false]\n          };\n        case _defaultSettings.ALL_FIELD_TYPES.string:\n        case _defaultSettings.ALL_FIELD_TYPES.date:\n          domain = (0, _dataScaleUtils.getOrdinalDomain)(dataContainer, valueAccessor);\n          return {\n            domain: domain\n          };\n        case _defaultSettings.ALL_FIELD_TYPES.timestamp:\n          return (0, _filterUtils.getTimestampFieldDomain)(dataContainer, valueAccessor);\n        default:\n          return {\n            domain: (0, _dataScaleUtils.getOrdinalDomain)(dataContainer, valueAccessor)\n          };\n      }\n    }\n    /**\n     *  Get the domain of this column based on scale type\n     */\n  }, {\n    key: \"getColumnLayerDomain\",\n    value: function getColumnLayerDomain(field, scaleType) {\n      var dataContainer = this.dataContainer,\n        filteredIndexForDomain = this.filteredIndexForDomain;\n      if (!_defaultSettings.SCALE_TYPES[scaleType]) {\n        _console.console.error(\"scale type \".concat(scaleType, \" not supported\"));\n        return null;\n      }\n      var valueAccessor = field.valueAccessor;\n      var indexValueAccessor = function indexValueAccessor(i) {\n        return valueAccessor({\n          index: i\n        });\n      };\n      var sortFunction = (0, _dataUtils.getSortingFunction)(field.type);\n      switch (scaleType) {\n        case _defaultSettings.SCALE_TYPES.ordinal:\n        case _defaultSettings.SCALE_TYPES.point:\n          // do not recalculate ordinal domain based on filtered data\n          // don't need to update ordinal domain every time\n          return (0, _dataScaleUtils.getOrdinalDomain)(dataContainer, valueAccessor);\n        case _defaultSettings.SCALE_TYPES.quantile:\n          return (0, _dataScaleUtils.getQuantileDomain)(filteredIndexForDomain, indexValueAccessor, sortFunction);\n        case _defaultSettings.SCALE_TYPES.log:\n          return (0, _dataScaleUtils.getLogDomain)(filteredIndexForDomain, indexValueAccessor);\n        case _defaultSettings.SCALE_TYPES.quantize:\n        case _defaultSettings.SCALE_TYPES.linear:\n        case _defaultSettings.SCALE_TYPES.sqrt:\n        default:\n          return (0, _dataScaleUtils.getLinearDomain)(filteredIndexForDomain, indexValueAccessor);\n      }\n    }\n    /**\n     * Get a sample of rows to calculate layer boundaries\n     */\n    // getSampleData(rows)\n\n    /**\n     * Parse cell value based on column type and return a string representation\n     * Value the field value, type the field type\n     */\n    // parseFieldValue(value, type)\n    // sortDatasetByColumn()\n\n    /**\n     * Assert whether field exist\n     * @param fieldName\n     * @param condition\n     */\n  }, {\n    key: \"_assetField\",\n    value: function _assetField(fieldName, condition) {\n      if (!condition) {\n        _console.console.error(\"\".concat(fieldName, \" doesnt exist in dataset \").concat(this.id));\n      }\n    }\n  }]);\n  return KeplerTable;\n}(); // HELPER FUNCTIONS (MAINLY EXPORTED FOR TEST...)\n\nfunction removeSuffixAndDelimiters(layerName, suffix) {\n  return layerName.replace(new RegExp(suffix, 'ig'), '').replace(/[_,.]+/g, ' ').trim();\n}\n/**\n * Find point fields pairs from fields\n *\n * @param fields\n * @returns found point fields\n * @type {typeof import('./kepler-table').findPointFieldPairs}\n */\n\nfunction findPointFieldPairs(fields) {\n  var allNames = fields.map(function (f) {\n    return f.name.toLowerCase();\n  }); // get list of all fields with matching suffixes\n\n  var acc = [];\n  return allNames.reduce(function (carry, fieldName, idx) {\n    // This search for pairs will early exit if found.\n    var _iterator = _createForOfIteratorHelper(_defaultSettings.TRIP_POINT_FIELDS),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var suffixPair = _step.value;\n\n        // match first suffix```\n        if (fieldName.endsWith(suffixPair[0])) {\n          var _ret = function () {\n            // match second suffix\n            var otherPattern = new RegExp(\"\".concat(suffixPair[0], \"$\"));\n            var partner = fieldName.replace(otherPattern, suffixPair[1]);\n            var partnerIdx = allNames.findIndex(function (d) {\n              return d === partner;\n            });\n            if (partnerIdx > -1) {\n              var defaultName = removeSuffixAndDelimiters(fieldName, suffixPair[0]);\n              carry.push({\n                defaultName: defaultName,\n                pair: {\n                  lat: {\n                    fieldIdx: idx,\n                    value: fields[idx].name\n                  },\n                  lng: {\n                    fieldIdx: partnerIdx,\n                    value: fields[partnerIdx].name\n                  }\n                },\n                suffix: suffixPair\n              });\n              return {\n                v: carry\n              };\n            }\n          }();\n          if ((0, _typeof2[\"default\"])(_ret) === \"object\") return _ret.v;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return carry;\n  }, acc);\n}\n/**\n *\n * @param dataset\n * @param column\n * @param mode\n * @type {typeof import('./kepler-table').sortDatasetByColumn}\n */\n\nfunction sortDatasetByColumn(dataset, column, mode) {\n  var allIndexes = dataset.allIndexes,\n    fields = dataset.fields,\n    dataContainer = dataset.dataContainer;\n  var fieldIndex = fields.findIndex(function (f) {\n    return f.name === column;\n  });\n  if (fieldIndex < 0) {\n    return dataset;\n  }\n  var sortBy = _defaultSettings.SORT_ORDER[mode] || _defaultSettings.SORT_ORDER.ASCENDING;\n  if (sortBy === _defaultSettings.SORT_ORDER.UNSORT) {\n    return _objectSpread(_objectSpread({}, dataset), {}, {\n      sortColumn: {},\n      sortOrder: null\n    });\n  }\n  var sortFunction = sortBy === _defaultSettings.SORT_ORDER.ASCENDING ? _d3Array.ascending : _d3Array.descending;\n  var sortOrder = allIndexes.slice().sort(function (a, b) {\n    return sortFunction(dataContainer.valueAt(a, fieldIndex), dataContainer.valueAt(b, fieldIndex));\n  });\n  return _objectSpread(_objectSpread({}, dataset), {}, {\n    sortColumn: (0, _defineProperty2[\"default\"])({}, column, sortBy),\n    sortOrder: sortOrder\n  });\n}\nfunction copyTable(original) {\n  return Object.assign(Object.create(Object.getPrototypeOf(original)), original);\n}\nfunction copyTableAndUpdate(original) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.entries(options).reduce(function (acc, entry) {\n    acc[entry[0]] = entry[1];\n    return acc;\n  }, copyTable(original));\n}\nvar _default = KeplerTable;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../../../src/utils/table-utils/kepler-table.js"],"names":["FID_KEY","KeplerTable","info","data","color","metadata","supportedFilterTypes","dataContainer","rows","fields","datasetInfo","id","label","dataId","map","f","i","fieldIdx","name","displayName","valueAccessor","maybeToDate","bind","type","ALL_FIELD_TYPES","timestamp","format","allIndexes","getPlainIndex","filteredIndex","filteredIndexForDomain","fieldPairs","findPointFieldPairs","gpuFilter","columnName","field","find","fd","_assetField","findIndex","Boolean","rowIdx","getColumnField","index","newField","Object","assign","getColumnFieldIdx","hasOwnProperty","filterProps","fieldDomain","getColumnFilterDomain","updateColumnField","filters","layers","opt","filterRecord","oldFilterRecord","length","changedFilters","shouldCalDomain","dynamicDomain","shouldCalIndex","cpu","filterResult","dynamicDomainFilters","cpuFilters","filterFuncs","reduce","acc","filter","fieldIndex","cpuOnly","ignoreDomain","filteredIdxCPU","filterRecordCPU","gpu","copied","copyTable","filtered","filterTable","domain","real","integer","string","date","scaleType","SCALE_TYPES","Console","error","indexValueAccessor","sortFunction","ordinal","point","quantile","log","quantize","linear","sqrt","fieldName","condition","removeSuffixAndDelimiters","layerName","suffix","replace","RegExp","trim","allNames","toLowerCase","carry","idx","suffixPair","TRIP_POINT_FIELDS","endsWith","otherPattern","partner","partnerIdx","d","defaultName","push","pair","lat","value","lng","sortDatasetByColumn","dataset","column","mode","sortBy","SORT_ORDER","ASCENDING","UNSORT","sortColumn","sortOrder","ascending","descending","slice","sort","a","b","valueAt","original","create","getPrototypeOf","copyTableAndUpdate","options","entries","entry"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {console as Console} from 'global/console';\nimport {TRIP_POINT_FIELDS, SORT_ORDER} from 'constants/default-settings';\nimport {ascending, descending} from 'd3-array';\n\n// import {validateInputData} from 'processors/data-processor';\nimport {generateHashId} from 'utils/utils';\nimport {getGpuFilterProps, getDatasetFieldIndexForFilter} from 'utils/gpu-filter-utils';\nimport {\n  getFilterProps,\n  getFilterRecord,\n  diffFilters,\n  getFilterFunction,\n  filterDataByFilterTypes,\n  getNumericFieldDomain,\n  getTimestampFieldDomain\n} from 'utils/filter-utils';\nimport {maybeToDate, getSortingFunction} from 'utils/data-utils';\nimport {\n  getQuantileDomain,\n  getOrdinalDomain,\n  getLogDomain,\n  getLinearDomain\n} from 'utils/data-scale-utils';\n\nimport {ALL_FIELD_TYPES, SCALE_TYPES} from 'constants/default-settings';\n\nimport {createDataContainer} from './data-container-utils';\n\n// Unique identifier of each field\nconst FID_KEY = 'name';\n\n/** @typedef {import('./kepler-table').KeplerTable} KeplerTableClass} */\n\n/**\n * @type {KeplerTableClass}\n */\nclass KeplerTable {\n  constructor({info = {}, data, color, metadata, supportedFilterTypes}) {\n    // TODO - what to do if validation fails? Can kepler handle exceptions?\n    // const validatedData = validateInputData(data);\n    // if (!validatedData) {\n    //   return this;\n    // }\n\n    const dataContainer = createDataContainer(data.rows, {fields: data.fields});\n\n    const datasetInfo = {\n      id: generateHashId(4),\n      label: 'new dataset',\n      ...(info || {})\n    };\n    const dataId = datasetInfo.id;\n\n    const fields = data.fields.map((f, i) => ({\n      ...f,\n      fieldIdx: i,\n      id: f.name,\n      displayName: f.displayName || f.name,\n      valueAccessor: maybeToDate.bind(\n        null,\n        // is time\n        f.type === ALL_FIELD_TYPES.timestamp,\n        i,\n        f.format,\n        dataContainer\n      )\n    }));\n\n    const allIndexes = dataContainer.getPlainIndex();\n\n    this.id = datasetInfo.id;\n    this.label = datasetInfo.label;\n    this.color = color;\n    this.metadata = {\n      ...metadata,\n      id: datasetInfo.id,\n      label: datasetInfo.label\n    };\n\n    this.dataContainer = dataContainer;\n    this.allIndexes = allIndexes;\n    this.filteredIndex = allIndexes;\n    this.filteredIndexForDomain = allIndexes;\n    this.fieldPairs = findPointFieldPairs(fields);\n    this.fields = fields;\n    this.gpuFilter = getGpuFilterProps([], dataId, fields);\n    if (supportedFilterTypes) {\n      this.supportedFilterTypes = supportedFilterTypes;\n    }\n  }\n\n  /**\n   * Get field\n   * @param columnName\n   */\n  getColumnField(columnName) {\n    const field = this.fields.find(fd => fd[FID_KEY] === columnName);\n    this._assetField(columnName, field);\n    return field;\n  }\n\n  /**\n   * Get fieldIdx\n   * @param columnName\n   */\n  getColumnFieldIdx(columnName) {\n    const fieldIdx = this.fields.findIndex(fd => fd[FID_KEY] === columnName);\n    this._assetField(columnName, Boolean(fieldIdx > -1));\n    return fieldIdx;\n  }\n\n  /**\n   * Get the value of a cell\n   */\n  getValue(columnName, rowIdx) {\n    const field = this.getColumnField(columnName);\n    return field ? field.valueAccessor({index: rowIdx}) : null;\n  }\n\n  /**\n   * Updates existing field with a new object\n   * @param fieldIdx\n   * @param newField\n   */\n  updateColumnField(fieldIdx, newField) {\n    this.fields = Object.assign([...this.fields], {[fieldIdx]: newField});\n  }\n\n  /**\n   * Save filterProps to field and retrieve it\n   * @param {string} columnName\n   */\n  getColumnFilterProps(columnName) {\n    const fieldIdx = this.getColumnFieldIdx(columnName);\n    if (fieldIdx < 0) {\n      return null;\n    }\n    const field = this.fields[fieldIdx];\n    if (field.hasOwnProperty('filterProps')) {\n      return field.filterProps;\n    }\n\n    const fieldDomain = this.getColumnFilterDomain(field);\n    if (!fieldDomain) {\n      return null;\n    }\n\n    const filterProps = getFilterProps(field, fieldDomain);\n    const newField = {\n      ...field,\n      filterProps\n    };\n\n    this.updateColumnField(fieldIdx, newField);\n\n    return filterProps;\n  }\n\n  /**\n   * Apply filters to dataset, return the filtered dataset with updated `gpuFilter`, `filterRecord`, `filteredIndex`, `filteredIndexForDomain`\n   * @param filters\n   * @param layers\n   * @param opt\n   */\n  filterTable(filters, layers, opt) {\n    const {dataContainer, id: dataId, filterRecord: oldFilterRecord, fields} = this;\n\n    // if there is no filters\n    const filterRecord = getFilterRecord(dataId, filters, opt || {});\n\n    this.filterRecord = filterRecord;\n    this.gpuFilter = getGpuFilterProps(filters, dataId, fields);\n\n    // const newDataset = set(['filterRecord'], filterRecord, dataset);\n\n    if (!filters.length) {\n      this.filteredIndex = this.allIndexes;\n      this.filteredIndexForDomain = this.allIndexes;\n      return this;\n    }\n\n    this.changedFilters = diffFilters(filterRecord, oldFilterRecord);\n\n    // generate 2 sets of filter result\n    // filteredIndex used to calculate layer data\n    // filteredIndexForDomain used to calculate layer Domain\n    const shouldCalDomain = Boolean(this.changedFilters.dynamicDomain);\n    const shouldCalIndex = Boolean(this.changedFilters.cpu);\n\n    let filterResult = {};\n    if (shouldCalDomain || shouldCalIndex) {\n      const dynamicDomainFilters = shouldCalDomain ? filterRecord.dynamicDomain : null;\n      const cpuFilters = shouldCalIndex ? filterRecord.cpu : null;\n\n      const filterFuncs = filters.reduce((acc, filter) => {\n        const fieldIndex = getDatasetFieldIndexForFilter(this.id, filter);\n        const field = fieldIndex !== -1 ? fields[fieldIndex] : null;\n\n        return {\n          ...acc,\n          [filter.id]: getFilterFunction(field, this.id, filter, layers, dataContainer)\n        };\n      }, {});\n\n      filterResult = filterDataByFilterTypes(\n        {dynamicDomainFilters, cpuFilters, filterFuncs},\n        dataContainer\n      );\n    }\n\n    this.filteredIndex = filterResult.filteredIndex || this.filteredIndex;\n    this.filteredIndexForDomain =\n      filterResult.filteredIndexForDomain || this.filteredIndexForDomain;\n\n    return this;\n  }\n\n  /**\n   * Apply filters to a dataset all on CPU, assign to `filteredIdxCPU`, `filterRecordCPU`\n   * @param filters\n   * @param layers\n   */\n  filterTableCPU(filters, layers) {\n    const opt = {\n      cpuOnly: true,\n      ignoreDomain: true\n    };\n\n    // no filter\n    if (!filters.length) {\n      this.filteredIdxCPU = this.allIndexes;\n      this.filterRecordCPU = getFilterRecord(this.id, filters, opt);\n      return this;\n    }\n\n    // no gpu filter\n    if (!filters.find(f => f.gpu)) {\n      this.filteredIdxCPU = this.filteredIndex;\n      this.filterRecordCPU = getFilterRecord(this.id, filters, opt);\n      return this;\n    }\n\n    // make a copy for cpu filtering\n    const copied = copyTable(this);\n\n    copied.filterRecord = this.filterRecordCPU;\n    copied.filteredIndex = this.filteredIdxCPU || [];\n\n    const filtered = copied.filterTable(filters, layers, opt);\n\n    this.filteredIdxCPU = filtered.filteredIndex;\n    this.filterRecordCPU = filtered.filterRecord;\n\n    return this;\n  }\n\n  /**\n   * Calculate field domain based on field type and data\n   * for Filter\n   */\n  getColumnFilterDomain(field) {\n    const {dataContainer} = this;\n    const {valueAccessor} = field;\n\n    let domain;\n\n    switch (field.type) {\n      case ALL_FIELD_TYPES.real:\n      case ALL_FIELD_TYPES.integer:\n        // calculate domain and step\n        return getNumericFieldDomain(dataContainer, valueAccessor);\n\n      case ALL_FIELD_TYPES.boolean:\n        return {domain: [true, false]};\n\n      case ALL_FIELD_TYPES.string:\n      case ALL_FIELD_TYPES.date:\n        domain = getOrdinalDomain(dataContainer, valueAccessor);\n        return {domain};\n\n      case ALL_FIELD_TYPES.timestamp:\n        return getTimestampFieldDomain(dataContainer, valueAccessor);\n\n      default:\n        return {domain: getOrdinalDomain(dataContainer, valueAccessor)};\n    }\n  }\n\n  /**\n   *  Get the domain of this column based on scale type\n   */\n  getColumnLayerDomain(field, scaleType) {\n    const {dataContainer, filteredIndexForDomain} = this;\n\n    if (!SCALE_TYPES[scaleType]) {\n      Console.error(`scale type ${scaleType} not supported`);\n      return null;\n    }\n\n    const {valueAccessor} = field;\n    const indexValueAccessor = i => valueAccessor({index: i});\n    const sortFunction = getSortingFunction(field.type);\n\n    switch (scaleType) {\n      case SCALE_TYPES.ordinal:\n      case SCALE_TYPES.point:\n        // do not recalculate ordinal domain based on filtered data\n        // don't need to update ordinal domain every time\n        return getOrdinalDomain(dataContainer, valueAccessor);\n\n      case SCALE_TYPES.quantile:\n        return getQuantileDomain(filteredIndexForDomain, indexValueAccessor, sortFunction);\n\n      case SCALE_TYPES.log:\n        return getLogDomain(filteredIndexForDomain, indexValueAccessor);\n\n      case SCALE_TYPES.quantize:\n      case SCALE_TYPES.linear:\n      case SCALE_TYPES.sqrt:\n      default:\n        return getLinearDomain(filteredIndexForDomain, indexValueAccessor);\n    }\n  }\n\n  /**\n   * Get a sample of rows to calculate layer boundaries\n   */\n  // getSampleData(rows)\n\n  /**\n   * Parse cell value based on column type and return a string representation\n   * Value the field value, type the field type\n   */\n  // parseFieldValue(value, type)\n\n  // sortDatasetByColumn()\n\n  /**\n   * Assert whether field exist\n   * @param fieldName\n   * @param condition\n   */\n  _assetField(fieldName, condition) {\n    if (!condition) {\n      Console.error(`${fieldName} doesnt exist in dataset ${this.id}`);\n    }\n  }\n}\n\n// HELPER FUNCTIONS (MAINLY EXPORTED FOR TEST...)\n\nexport function removeSuffixAndDelimiters(layerName, suffix) {\n  return layerName\n    .replace(new RegExp(suffix, 'ig'), '')\n    .replace(/[_,.]+/g, ' ')\n    .trim();\n}\n\n/**\n * Find point fields pairs from fields\n *\n * @param fields\n * @returns found point fields\n * @type {typeof import('./kepler-table').findPointFieldPairs}\n */\nexport function findPointFieldPairs(fields) {\n  const allNames = fields.map(f => f.name.toLowerCase());\n\n  // get list of all fields with matching suffixes\n  const acc = [];\n  return allNames.reduce((carry, fieldName, idx) => {\n    // This search for pairs will early exit if found.\n    for (const suffixPair of TRIP_POINT_FIELDS) {\n      // match first suffix```\n      if (fieldName.endsWith(suffixPair[0])) {\n        // match second suffix\n        const otherPattern = new RegExp(`${suffixPair[0]}\\$`);\n        const partner = fieldName.replace(otherPattern, suffixPair[1]);\n\n        const partnerIdx = allNames.findIndex(d => d === partner);\n        if (partnerIdx > -1) {\n          const defaultName = removeSuffixAndDelimiters(fieldName, suffixPair[0]);\n\n          carry.push({\n            defaultName,\n            pair: {\n              lat: {\n                fieldIdx: idx,\n                value: fields[idx].name\n              },\n              lng: {\n                fieldIdx: partnerIdx,\n                value: fields[partnerIdx].name\n              }\n            },\n            suffix: suffixPair\n          });\n          return carry;\n        }\n      }\n    }\n    return carry;\n  }, acc);\n}\n\n/**\n *\n * @param dataset\n * @param column\n * @param mode\n * @type {typeof import('./kepler-table').sortDatasetByColumn}\n */\nexport function sortDatasetByColumn(dataset, column, mode) {\n  const {allIndexes, fields, dataContainer} = dataset;\n  const fieldIndex = fields.findIndex(f => f.name === column);\n  if (fieldIndex < 0) {\n    return dataset;\n  }\n\n  const sortBy = SORT_ORDER[mode] || SORT_ORDER.ASCENDING;\n\n  if (sortBy === SORT_ORDER.UNSORT) {\n    return {\n      ...dataset,\n      sortColumn: {},\n      sortOrder: null\n    };\n  }\n\n  const sortFunction = sortBy === SORT_ORDER.ASCENDING ? ascending : descending;\n  const sortOrder = allIndexes\n    .slice()\n    .sort((a, b) =>\n      sortFunction(dataContainer.valueAt(a, fieldIndex), dataContainer.valueAt(b, fieldIndex))\n    );\n\n  return {\n    ...dataset,\n    sortColumn: {\n      [column]: sortBy\n    },\n    sortOrder\n  };\n}\n\nexport function copyTable(original) {\n  return Object.assign(Object.create(Object.getPrototypeOf(original)), original);\n}\n\nexport function copyTableAndUpdate(original, options = {}) {\n  return Object.entries(options).reduce((acc, entry) => {\n    acc[entry[0]] = entry[1];\n    return acc;\n  }, copyTable(original));\n}\n\nexport default KeplerTable;\n"]},"metadata":{},"sourceType":"script"}