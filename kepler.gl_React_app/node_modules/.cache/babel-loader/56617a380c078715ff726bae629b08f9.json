{"ast":null,"code":"import { decodeRGB565, GL } from '@loaders.gl/math';\nexport function normalize3DTileColorAttribute(tile, colors, batchTable) {\n  if (!colors && (!tile || !tile.batchIds || !batchTable)) {\n    return null;\n  }\n  var batchIds = tile.batchIds,\n    isRGB565 = tile.isRGB565,\n    pointCount = tile.pointCount;\n  if (batchIds && batchTable) {\n    var colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (var i = 0; i < pointCount; i++) {\n      var batchId = batchIds[i];\n      var dimensions = batchTable.getProperty(batchId, 'dimensions');\n      var color = dimensions.map(function (d) {\n        return d * 255;\n      });\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n  if (isRGB565) {\n    var _colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (var _i = 0; _i < pointCount; _i++) {\n      var _color = decodeRGB565(colors[_i]);\n      _colorArray[_i * 3] = _color[0];\n      _colorArray[_i * 3 + 1] = _color[1];\n      _colorArray[_i * 3 + 2] = _color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: _colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n  if (colors && colors.length === pointCount * 3) {\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colors,\n      size: 3,\n      normalized: true\n    };\n  }\n  return {\n    type: GL.UNSIGNED_BYTE,\n    value: colors,\n    size: 4,\n    normalized: true\n  };\n}","map":{"version":3,"sources":["../../../../../src/lib/parsers/helpers/normalize-3d-tile-colors.js"],"names":["decodeRGB565","GL","normalize3DTileColorAttribute","tile","colors","batchTable","batchIds","isRGB565","pointCount","colorArray","Uint8ClampedArray","i","batchId","dimensions","getProperty","color","map","d","type","UNSIGNED_BYTE","value","size","normalized","length"],"mappings":"AAAA,SAAQA,YAAR,EAAsBC,EAAtB,QAA+B,kBAA/B;AAGA,OAAO,SAASC,6BAAT,CAAuCC,IAAvC,EAA6CC,MAA7C,EAAqDC,UAArD,EAAiE;EAEtE,IAAI,CAACD,MAAD,KAAY,CAACD,IAAD,IAAS,CAACA,IAAI,CAACG,QAAf,IAA2B,CAACD,UAAxC,CAAJ,EAAyD;IACvD,OAAO,IAAP;EACD;EAJqE,IAM/DC,QAN+D,GAM7BH,IAN6B,CAM/DG,QAN+D;IAMrDC,QANqD,GAM7BJ,IAN6B,CAMrDI,QANqD;IAM3CC,UAN2C,GAM7BL,IAN6B,CAM3CK,UAN2C;EAQtE,IAAIF,QAAQ,IAAID,UAAhB,EAA4B;IAC1B,IAAMI,UAAU,GAAG,IAAIC,iBAAJ,CAAsBF,UAAU,GAAG,CAAnC,CAAnB;IACA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,UAApB,EAAgCG,CAAC,EAAjC,EAAqC;MACnC,IAAMC,OAAO,GAAGN,QAAQ,CAACK,CAAD,CAAxB;MAEA,IAAME,UAAU,GAAGR,UAAU,CAACS,WAAXT,CAAuBO,OAAvBP,EAAgC,YAAhCA,CAAnB;MACA,IAAMU,KAAK,GAAG,UAAU,CAACC,GAAX,CAAe,UAAA,CAAC,EAAA;QAAA,OAAIC,CAAC,GAAG,GAAR;MAAA,CAAhB,CAAd;MACAR,UAAU,CAACE,CAAC,GAAG,CAAL,CAAVF,GAAoBM,KAAK,CAAC,CAAD,CAAzBN;MACAA,UAAU,CAACE,CAAC,GAAG,CAAJA,GAAQ,CAAT,CAAVF,GAAwBM,KAAK,CAAC,CAAD,CAA7BN;MACAA,UAAU,CAACE,CAAC,GAAG,CAAJA,GAAQ,CAAT,CAAVF,GAAwBM,KAAK,CAAC,CAAD,CAA7BN;IACD;IACD,OAAO;MACLS,IAAI,EAAEjB,EAAE,CAACkB,aADJ;MAELC,KAAK,EAAEX,UAFF;MAGLY,IAAI,EAAE,CAHD;MAILC,UAAU,EAAE;IAJP,CAAP;EAMD;EAGD,IAAIf,QAAJ,EAAc;IACZ,IAAME,WAAU,GAAG,IAAIC,iBAAJ,CAAsBF,UAAU,GAAG,CAAnC,CAAnB;IACA,KAAK,IAAIG,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGH,UAApB,EAAgCG,EAAC,EAAjC,EAAqC;MACnC,IAAMI,MAAK,GAAGf,YAAY,CAACI,MAAM,CAACO,EAAD,CAAP,CAA1B;MACAF,WAAU,CAACE,EAAC,GAAG,CAAL,CAAVF,GAAoBM,MAAK,CAAC,CAAD,CAAzBN;MACAA,WAAU,CAACE,EAAC,GAAG,CAAJA,GAAQ,CAAT,CAAVF,GAAwBM,MAAK,CAAC,CAAD,CAA7BN;MACAA,WAAU,CAACE,EAAC,GAAG,CAAJA,GAAQ,CAAT,CAAVF,GAAwBM,MAAK,CAAC,CAAD,CAA7BN;IACD;IACD,OAAO;MACLS,IAAI,EAAEjB,EAAE,CAACkB,aADJ;MAELC,KAAK,EAAEX,WAFF;MAGLY,IAAI,EAAE,CAHD;MAILC,UAAU,EAAE;IAJP,CAAP;EAMD;EAGD,IAAIlB,MAAM,IAAIA,MAAM,CAACmB,MAAPnB,KAAkBI,UAAU,GAAG,CAA7C,EAAgD;IAC9C,OAAO;MACLU,IAAI,EAAEjB,EAAE,CAACkB,aADJ;MAELC,KAAK,EAAEhB,MAFF;MAGLiB,IAAI,EAAE,CAHD;MAILC,UAAU,EAAE;IAJP,CAAP;EAMD;EAGD,OAAO;IACLJ,IAAI,EAAEjB,EAAE,CAACkB,aADJ;IAELC,KAAK,EAAEhB,MAFF;IAGLiB,IAAI,EAAE,CAHD;IAILC,UAAU,EAAE;EAJP,CAAP;AAMD","sourcesContent":["import {decodeRGB565, GL} from '@loaders.gl/math';\n\n/* eslint-disable complexity*/\nexport function normalize3DTileColorAttribute(tile, colors, batchTable) {\n  // no colors defined\n  if (!colors && (!tile || !tile.batchIds || !batchTable)) {\n    return null;\n  }\n\n  const {batchIds, isRGB565, pointCount} = tile;\n  // Batch table, look up colors in table\n  if (batchIds && batchTable) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (let i = 0; i < pointCount; i++) {\n      const batchId = batchIds[i];\n      // TODO figure out what is `dimensions` used for\n      const dimensions = batchTable.getProperty(batchId, 'dimensions');\n      const color = dimensions.map(d => d * 255);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // RGB565 case, convert to RGB\n  if (isRGB565) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (let i = 0; i < pointCount; i++) {\n      const color = decodeRGB565(colors[i]);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // RGB case (tile.isTranslucent)\n  if (colors && colors.length === pointCount * 3) {\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colors,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // DEFAULT: RGBA case\n  return {\n    type: GL.UNSIGNED_BYTE,\n    value: colors,\n    size: 4,\n    normalized: true\n  };\n}\n/* eslint-enable complexity*/\n"]},"metadata":{},"sourceType":"module"}