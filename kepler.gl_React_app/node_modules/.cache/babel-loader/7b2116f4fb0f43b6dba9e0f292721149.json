{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _constants = require(\"./constants\");\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar Feature = /*#__PURE__*/\nfunction () {\n  _createClass(Feature, null, [{\n    key: \"fromFeature\",\n    value: function fromFeature(feature) {\n      var id = feature.id,\n        _feature$geometry = feature.geometry,\n        coordinates = _feature$geometry.coordinates,\n        type = _feature$geometry.type,\n        _feature$properties = feature.properties,\n        renderType = _feature$properties.renderType,\n        otherProps = _objectWithoutProperties(_feature$properties, [\"renderType\"]);\n      switch (type) {\n        case _constants.GEOJSON_TYPE.POINT:\n          return new Feature({\n            id: id,\n            type: type,\n            renderType: renderType,\n            points: [coordinates],\n            otherProps: otherProps\n          });\n        case _constants.GEOJSON_TYPE.LINE_STRING:\n          return new Feature({\n            id: id,\n            type: type,\n            renderType: renderType,\n            points: coordinates,\n            otherProps: otherProps\n          });\n        case _constants.GEOJSON_TYPE.POLYGON:\n          var points = coordinates[0] && coordinates[0].slice(0, -1);\n          return new Feature({\n            id: id,\n            type: type,\n            renderType: renderType,\n            points: points,\n            isClosed: true,\n            otherProps: otherProps\n          });\n        default:\n          return null;\n      }\n    }\n  }]);\n  function Feature(props) {\n    _classCallCheck(this, Feature);\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"type\", void 0);\n    _defineProperty(this, \"renderType\", void 0);\n    _defineProperty(this, \"isClosed\", false);\n    _defineProperty(this, \"points\", void 0);\n    _defineProperty(this, \"otherProps\", void 0);\n    this.id = props.id;\n    this.type = props.type;\n    this.renderType = props.renderType;\n    this.points = props.points || [];\n    this.isClosed = props.isClosed;\n    this.otherProps = props.otherProps;\n  }\n  _createClass(Feature, [{\n    key: \"addPoint\",\n    value: function addPoint(pt) {\n      this.points.push(pt);\n      return true;\n    }\n  }, {\n    key: \"insertPoint\",\n    value: function insertPoint(pt, index) {\n      this.points.splice(index, 0, pt);\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox() {\n      if (!this.points || !this.points.length) {\n        return null;\n      }\n      var bbox = this.points.reduce(function (result, pt) {\n        result.xmin = Math.min(pt[0], result.xmin);\n        result.xmax = Math.min(pt[0], result.xmax);\n        result.ymin = Math.min(pt[1], result.ymin);\n        result.ymax = Math.min(pt[1], result.ymax);\n        return result;\n      }, {\n        xmin: Infinity,\n        xmax: -Infinity,\n        ymin: Infinity,\n        ymax: -Infinity\n      });\n      return bbox;\n    }\n  }, {\n    key: \"removePoint\",\n    value: function removePoint(index) {\n      var points = this.points;\n      if (index >= 0 && index < points.length) {\n        points.splice(index, 1);\n        if (points.length < 3) {\n          this.isClosed = false;\n        }\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"replacePoint\",\n    value: function replacePoint(index, pt) {\n      var points = this.points;\n      if (index >= 0 && index < points.length) {\n        points[index] = pt;\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"closePath\",\n    value: function closePath() {\n      var points = this.points;\n      if (points.length >= 3 && !this.isClosed) {\n        this.isClosed = true;\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"toFeature\",\n    value: function toFeature() {\n      var id = this.id,\n        points = this.points,\n        isClosed = this.isClosed,\n        renderType = this.renderType,\n        otherProps = this.otherProps;\n      var feature = null;\n      if (points.length < 2) {\n        feature = {\n          type: 'Feature',\n          geometry: {\n            type: _constants.GEOJSON_TYPE.POINT,\n            coordinates: points[0]\n          },\n          properties: _objectSpread({\n            renderType: renderType\n          }, otherProps),\n          id: id\n        };\n      } else if (points.length < 3 || !isClosed) {\n        feature = {\n          type: 'Feature',\n          geometry: {\n            type: _constants.GEOJSON_TYPE.LINE_STRING,\n            coordinates: points\n          },\n          properties: _objectSpread({\n            renderType: renderType,\n            bbox: this.getBoundingBox()\n          }, otherProps),\n          id: id\n        };\n      } else {\n        feature = {\n          type: 'Feature',\n          geometry: {\n            type: _constants.GEOJSON_TYPE.POLYGON,\n            coordinates: [_toConsumableArray(points).concat([points[0]])]\n          },\n          properties: _objectSpread({\n            renderType: renderType,\n            isClosed: isClosed,\n            bbox: this.getBoundingBox()\n          }, otherProps),\n          id: id\n        };\n      }\n      return feature;\n    }\n  }]);\n  return Feature;\n}();\nexports.default = Feature;","map":{"version":3,"sources":["../src/feature.js"],"names":["Feature","feature","id","geometry","coordinates","type","properties","renderType","otherProps","GEOJSON_TYPE","POINT","points","LINE_STRING","POLYGON","slice","isClosed","props","pt","push","index","splice","length","bbox","reduce","result","xmin","Math","min","xmax","ymin","ymax","Infinity","getBoundingBox"],"mappings":"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","sourcesContent":["// @flow\nimport type { Geometry, Position, Feature as GeoJson } from '@nebula.gl/edit-modes';\nimport type { Id, RenderType } from './types';\nimport { GEOJSON_TYPE } from './constants';\n\ntype FeatureProps = {\n  id: Id,\n  type: string,\n  renderType?: ?RenderType,\n  points?: ?any,\n  isClosed?: ?boolean,\n  otherProps?: ?any\n};\n\nexport default class Feature {\n  static fromFeature(feature: GeoJson) {\n    const {\n      id,\n      geometry: { coordinates, type },\n      properties: { renderType, ...otherProps }\n    } = feature;\n\n    switch (type) {\n      case GEOJSON_TYPE.POINT:\n        return new Feature({\n          id,\n          type,\n          renderType,\n          points: [coordinates],\n          otherProps\n        });\n\n      case GEOJSON_TYPE.LINE_STRING:\n        return new Feature({\n          id,\n          type,\n          renderType,\n          points: coordinates,\n          otherProps\n        });\n\n      case GEOJSON_TYPE.POLYGON:\n        const points = coordinates[0] && coordinates[0].slice(0, -1);\n        return new Feature({\n          id,\n          type,\n          renderType,\n          points,\n          isClosed: true,\n          otherProps\n        });\n\n      default:\n        return null;\n    }\n  }\n\n  constructor(props: FeatureProps) {\n    this.id = props.id;\n    this.type = props.type;\n    this.renderType = props.renderType;\n    this.points = props.points || [];\n    this.isClosed = props.isClosed;\n    this.otherProps = props.otherProps;\n  }\n\n  id: Id;\n  type: Geometry;\n  renderType: ?string;\n  isClosed: ?boolean = false;\n  points: Position[];\n  otherProps: ?any;\n\n  addPoint(pt: number[]) {\n    this.points.push(pt);\n    return true;\n  }\n\n  insertPoint(pt: number[], index: number) {\n    this.points.splice(index, 0, pt);\n  }\n\n  getBoundingBox() {\n    if (!this.points || !this.points.length) {\n      return null;\n    }\n    const bbox = this.points.reduce(\n      (result, pt) => {\n        result.xmin = Math.min(pt[0], result.xmin);\n        result.xmax = Math.min(pt[0], result.xmax);\n        result.ymin = Math.min(pt[1], result.ymin);\n        result.ymax = Math.min(pt[1], result.ymax);\n\n        return result;\n      },\n      { xmin: Infinity, xmax: -Infinity, ymin: Infinity, ymax: -Infinity }\n    );\n\n    return bbox;\n  }\n\n  removePoint(index: number) {\n    const { points } = this;\n    if (index >= 0 && index < points.length) {\n      points.splice(index, 1);\n      if (points.length < 3) {\n        this.isClosed = false;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  replacePoint(index: number, pt: Array<number>) {\n    const { points } = this;\n    if (index >= 0 && index < points.length) {\n      points[index] = pt;\n      return true;\n    }\n    return false;\n  }\n\n  closePath() {\n    const { points } = this;\n    if (points.length >= 3 && !this.isClosed) {\n      this.isClosed = true;\n      return true;\n    }\n    return false;\n  }\n\n  toFeature(): GeoJson {\n    const { id, points, isClosed, renderType, otherProps } = this;\n\n    let feature = null;\n    if (points.length < 2) {\n      feature = {\n        type: 'Feature',\n        geometry: {\n          type: GEOJSON_TYPE.POINT,\n          coordinates: points[0]\n        },\n        properties: {\n          renderType,\n          ...otherProps\n        },\n        id\n      };\n    } else if (points.length < 3 || !isClosed) {\n      feature = {\n        type: 'Feature',\n        geometry: {\n          type: GEOJSON_TYPE.LINE_STRING,\n          coordinates: points\n        },\n        properties: {\n          renderType,\n          bbox: this.getBoundingBox(),\n          ...otherProps\n        },\n        id\n      };\n    } else {\n      feature = {\n        type: 'Feature',\n        geometry: {\n          type: GEOJSON_TYPE.POLYGON,\n          coordinates: [[...points, points[0]]]\n        },\n        properties: {\n          renderType,\n          isClosed,\n          bbox: this.getBoundingBox(),\n          ...otherProps\n        },\n        id\n      };\n    }\n\n    return feature;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}