{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { hasFeature, FEATURES, Buffer } from '@luma.gl/core';\nimport ShaderAttribute from './shader-attribute';\nimport { glArrayFromType } from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport { toDoublePrecisionArray } from '../../utils/math-utils';\nimport log from '../../utils/log';\nfunction getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n  var stride = getStride(baseAccessor);\n  var vertexOffset = 'vertexOffset' in shaderAttributeOptions ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;\n  var elementOffset = shaderAttributeOptions.elementOffset || 0;\n  var offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);\n  return _objectSpread({}, shaderAttributeOptions, {\n    offset: offset,\n    stride: stride\n  });\n}\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  var resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n  return {\n    high: resolvedOptions,\n    low: _objectSpread({}, resolvedOptions, {\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    })\n  };\n}\nvar DataColumn = function () {\n  function DataColumn(gl, opts) {\n    _classCallCheck(this, DataColumn);\n    this.gl = gl;\n    this.id = opts.id;\n    this.size = opts.size;\n    var logicalType = opts.logicalType || opts.type;\n    var doublePrecision = logicalType === 5130;\n    var defaultValue = opts.defaultValue;\n    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);\n    opts.defaultValue = defaultValue;\n    var bufferType = logicalType;\n    if (doublePrecision) {\n      bufferType = 5126;\n    } else if (!bufferType && opts.isIndexed) {\n      bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;\n    } else if (!bufferType) {\n      bufferType = 5126;\n    }\n    opts.logicalType = logicalType;\n    opts.type = bufferType;\n    var defaultType = glArrayFromType(logicalType || bufferType || 5126);\n    this.shaderAttributes = {};\n    this.doublePrecision = doublePrecision;\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n    opts.bytesPerElement = defaultType.BYTES_PER_ELEMENT;\n    this.defaultType = defaultType;\n    this.value = null;\n    this.settings = opts;\n    this.state = {\n      externalBuffer: null,\n      bufferAccessor: opts,\n      allocatedValue: null,\n      constant: false\n    };\n    this._buffer = null;\n    this.setData(opts);\n  }\n  _createClass(DataColumn, [{\n    key: \"delete\",\n    value: function _delete() {\n      if (this._buffer) {\n        this._buffer[\"delete\"]();\n        this._buffer = null;\n      }\n      typedArrayManager.release(this.state.allocatedValue);\n    }\n  }, {\n    key: \"getShaderAttributes\",\n    value: function getShaderAttributes(id, options) {\n      if (this.doublePrecision) {\n        var shaderAttributes = {};\n        var isBuffer64Bit = this.value instanceof Float64Array;\n        var doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});\n        shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n        shaderAttributes[\"\".concat(id, \"64Low\")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);\n        return shaderAttributes;\n      }\n      if (options) {\n        var shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n        return _defineProperty({}, id, new ShaderAttribute(this, shaderAttributeDef));\n      }\n      return _defineProperty({}, id, this);\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      if (this.state.constant) {\n        return null;\n      }\n      return this.state.externalBuffer || this._buffer;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      if (this.state.constant) {\n        return this.value;\n      }\n      return [this.getBuffer(), this.getAccessor()];\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor() {\n      return this.state.bufferAccessor;\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(opts) {\n      var state = this.state;\n      if (ArrayBuffer.isView(opts)) {\n        opts = {\n          value: opts\n        };\n      } else if (opts instanceof Buffer) {\n        opts = {\n          buffer: opts\n        };\n      }\n      var accessor = _objectSpread({}, this.settings, {}, opts);\n      state.bufferAccessor = accessor;\n      if (opts.constant) {\n        var value = opts.value;\n        value = this._normalizeValue(value, [], 0);\n        if (this.settings.normalized) {\n          value = this._normalizeConstant(value);\n        }\n        var hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n        if (!hasChanged) {\n          return false;\n        }\n        state.externalBuffer = null;\n        state.constant = true;\n        this.value = value;\n      } else if (opts.buffer) {\n        var buffer = opts.buffer;\n        state.externalBuffer = buffer;\n        state.constant = false;\n        this.value = opts.value;\n        var isBuffer64Bit = opts.value instanceof Float64Array;\n        accessor.type = opts.type || buffer.accessor.type;\n        accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n        accessor.stride = getStride(accessor);\n      } else if (opts.value) {\n        this._checkExternalBuffer(opts);\n        var _value = opts.value;\n        state.externalBuffer = null;\n        state.constant = false;\n        this.value = _value;\n        accessor.bytesPerElement = _value.BYTES_PER_ELEMENT;\n        accessor.stride = getStride(accessor);\n        var _buffer = this.buffer,\n          byteOffset = this.byteOffset;\n        if (this.doublePrecision && _value instanceof Float64Array) {\n          _value = toDoublePrecisionArray(_value, accessor);\n        }\n        if (_buffer.byteLength < _value.byteLength + byteOffset) {\n          _buffer.reallocate((_value.byteLength + byteOffset) * 2);\n        }\n        _buffer.setAccessor(null);\n        _buffer.subData({\n          data: _value,\n          offset: byteOffset\n        });\n        accessor.type = opts.type || _buffer.accessor.type;\n      }\n      return true;\n    }\n  }, {\n    key: \"updateSubBuffer\",\n    value: function updateSubBuffer() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var value = this.value;\n      var _opts$startOffset = opts.startOffset,\n        startOffset = _opts$startOffset === void 0 ? 0 : _opts$startOffset,\n        endOffset = opts.endOffset;\n      this.buffer.subData({\n        data: this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {\n          size: this.size,\n          startIndex: startOffset,\n          endIndex: endOffset\n        }) : value.subarray(startOffset, endOffset),\n        offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n      });\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(_ref3) {\n      var numInstances = _ref3.numInstances,\n        _ref3$copy = _ref3.copy,\n        copy = _ref3$copy === void 0 ? false : _ref3$copy;\n      var state = this.state;\n      var oldValue = state.allocatedValue;\n      var value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n        size: this.size,\n        type: this.defaultType,\n        copy: copy\n      });\n      this.value = value;\n      var buffer = this.buffer,\n        byteOffset = this.byteOffset;\n      if (buffer.byteLength < value.byteLength + byteOffset) {\n        buffer.reallocate(value.byteLength + byteOffset);\n        if (copy && oldValue) {\n          buffer.subData({\n            data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n            offset: byteOffset\n          });\n        }\n      }\n      state.allocatedValue = value;\n      state.constant = false;\n      state.externalBuffer = null;\n      state.bufferAccessor = this.settings;\n      return true;\n    }\n  }, {\n    key: \"_checkExternalBuffer\",\n    value: function _checkExternalBuffer(opts) {\n      var value = opts.value;\n      if (!opts.constant && value) {\n        var ArrayType = this.defaultType;\n        var illegalArrayType = false;\n        if (this.doublePrecision) {\n          illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n        }\n        if (illegalArrayType) {\n          throw new Error(\"Attribute \".concat(this.id, \" does not support \").concat(value.constructor.name));\n        }\n        if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n          log.warn(\"Attribute \".concat(this.id, \" is normalized\"))();\n        }\n      }\n    }\n  }, {\n    key: \"_normalizeConstant\",\n    value: function _normalizeConstant(value) {\n      switch (this.settings.type) {\n        case 5120:\n          return new Float32Array(value).map(function (x) {\n            return (x + 128) / 255 * 2 - 1;\n          });\n        case 5122:\n          return new Float32Array(value).map(function (x) {\n            return (x + 32768) / 65535 * 2 - 1;\n          });\n        case 5121:\n          return new Float32Array(value).map(function (x) {\n            return x / 255;\n          });\n        case 5123:\n          return new Float32Array(value).map(function (x) {\n            return x / 65535;\n          });\n        default:\n          return value;\n      }\n    }\n  }, {\n    key: \"_normalizeValue\",\n    value: function _normalizeValue(value, out, start) {\n      var _this$settings = this.settings,\n        defaultValue = _this$settings.defaultValue,\n        size = _this$settings.size;\n      if (Number.isFinite(value)) {\n        out[start] = value;\n        return out;\n      }\n      if (!value) {\n        out[start] = defaultValue[0];\n        return out;\n      }\n      switch (size) {\n        case 4:\n          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n        case 3:\n          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n        case 2:\n          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n        case 1:\n          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n          break;\n        default:\n          var i = size;\n          while (--i >= 0) {\n            out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n          }\n      }\n      return out;\n    }\n  }, {\n    key: \"_areValuesEqual\",\n    value: function _areValuesEqual(value1, value2) {\n      if (!value1 || !value2) {\n        return false;\n      }\n      var size = this.size;\n      for (var i = 0; i < size; i++) {\n        if (value1[i] !== value2[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      if (!this._buffer) {\n        var _this$settings2 = this.settings,\n          isIndexed = _this$settings2.isIndexed,\n          type = _this$settings2.type;\n        this._buffer = new Buffer(this.gl, {\n          id: this.id,\n          target: isIndexed ? 34963 : 34962,\n          accessor: {\n            type: type\n          }\n        });\n      }\n      return this._buffer;\n    }\n  }, {\n    key: \"byteOffset\",\n    get: function get() {\n      var accessor = this.getAccessor();\n      if (accessor.vertexOffset) {\n        return accessor.vertexOffset * getStride(accessor);\n      }\n      return 0;\n    }\n  }]);\n  return DataColumn;\n}();\nexport { DataColumn as default };","map":{"version":3,"sources":["../../../../src/lib/attribute/data-column.js"],"names":["hasFeature","FEATURES","Buffer","ShaderAttribute","glArrayFromType","typedArrayManager","toDoublePrecisionArray","log","getStride","accessor","stride","size","bytesPerElement","resolveShaderAttribute","baseAccessor","shaderAttributeOptions","offset","removed","vertexOffset","elementOffset","resolveDoublePrecisionShaderAttributes","resolvedOptions","high","low","DataColumn","gl","opts","id","logicalType","type","doublePrecision","defaultValue","Number","isFinite","Array","fill","bufferType","isIndexed","ELEMENT_INDEX_UINT32","defaultType","shaderAttributes","fp64","Float32Array","BYTES_PER_ELEMENT","value","settings","state","externalBuffer","bufferAccessor","allocatedValue","constant","_buffer","setData","target","getAccessor","release","options","isBuffer64Bit","Float64Array","doubleShaderAttributeDefs","shaderAttributeDef","getBuffer","ArrayBuffer","isView","buffer","_normalizeValue","normalized","_normalizeConstant","hasChanged","_areValuesEqual","_checkExternalBuffer","byteOffset","byteLength","reallocate","setAccessor","subData","data","startOffset","endOffset","startIndex","endIndex","subarray","numInstances","copy","oldValue","allocate","ArrayType","illegalArrayType","Error","constructor","name","warn","map","x","out","start","i","value1","value2"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport GL from '@luma.gl/constants';\nimport {hasFeature, FEATURES, Buffer} from '@luma.gl/core';\nimport ShaderAttribute from './shader-attribute';\nimport {glArrayFromType} from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport {toDoublePrecisionArray} from '../../utils/math-utils';\nimport log from '../../utils/log';\n\nfunction getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n\n  // All shader attributes share the parent's stride\n  const stride = getStride(baseAccessor);\n  // `vertexOffset` is used to access the neighboring vertex's value\n  // e.g. `nextPositions` in polygon\n  const vertexOffset =\n    'vertexOffset' in shaderAttributeOptions\n      ? shaderAttributeOptions.vertexOffset\n      : baseAccessor.vertexOffset || 0;\n  // `elementOffset` is defined when shader attribute's size is smaller than the parent's\n  // e.g. `translations` in transform matrix\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset =\n    // offsets defined by the attribute\n    vertexOffset * stride +\n    elementOffset * baseAccessor.bytesPerElement +\n    // offsets defined by external buffers if any\n    (baseAccessor.offset || 0);\n\n  return {\n    ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\n\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n\n  return {\n    high: resolvedOptions,\n    low: {\n      ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\n\nexport default class DataColumn {\n  /* eslint-disable max-statements */\n  constructor(gl, opts) {\n    this.gl = gl;\n    this.id = opts.id;\n    this.size = opts.size;\n\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === GL.DOUBLE;\n\n    let {defaultValue} = opts;\n    defaultValue = Number.isFinite(defaultValue)\n      ? [defaultValue]\n      : defaultValue || new Array(this.size).fill(0);\n    opts.defaultValue = defaultValue;\n\n    let bufferType = logicalType;\n    if (doublePrecision) {\n      bufferType = GL.FLOAT;\n    } else if (!bufferType && opts.isIndexed) {\n      bufferType =\n        gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? GL.UNSIGNED_INT : GL.UNSIGNED_SHORT;\n    } else if (!bufferType) {\n      bufferType = GL.FLOAT;\n    }\n    opts.logicalType = logicalType;\n    opts.type = bufferType;\n\n    // This is the attribute type defined by the layer\n    // If an external buffer is provided, this.type may be overwritten\n    // But we always want to use defaultType for allocation\n    let defaultType = glArrayFromType(logicalType || bufferType || GL.FLOAT);\n    this.shaderAttributes = {};\n    this.doublePrecision = doublePrecision;\n\n    // `fp64: false` tells a double-precision attribute to allocate Float32Arrays\n    // by default when using auto-packing. This is more efficient in use cases where\n    // high precision is unnecessary, but the `64Low` attribute is still required\n    // by the shader.\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n    opts.bytesPerElement = defaultType.BYTES_PER_ELEMENT;\n\n    this.defaultType = defaultType;\n    this.value = null;\n    this.settings = opts;\n    this.state = {\n      externalBuffer: null,\n      bufferAccessor: opts,\n      allocatedValue: null,\n      constant: false\n    };\n    this._buffer = null;\n\n    this.setData(opts);\n  }\n  /* eslint-enable max-statements */\n\n  get buffer() {\n    if (!this._buffer) {\n      const {isIndexed, type} = this.settings;\n      this._buffer = new Buffer(this.gl, {\n        id: this.id,\n        target: isIndexed ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER,\n        accessor: {type}\n      });\n    }\n    return this._buffer;\n  }\n\n  get byteOffset() {\n    const accessor = this.getAccessor();\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n    return 0;\n  }\n\n  delete() {\n    if (this._buffer) {\n      this._buffer.delete();\n      this._buffer = null;\n    }\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n\n  getShaderAttributes(id, options) {\n    if (this.doublePrecision) {\n      const shaderAttributes = {};\n      const isBuffer64Bit = this.value instanceof Float64Array;\n\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(\n        this.getAccessor(),\n        options || {}\n      );\n\n      shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n      shaderAttributes[`${id}64Low`] = isBuffer64Bit\n        ? new ShaderAttribute(this, doubleShaderAttributeDefs.low)\n        : new Float32Array(this.size); // use constant for low part if buffer is 32-bit\n      return shaderAttributes;\n    }\n    if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n      return {[id]: new ShaderAttribute(this, shaderAttributeDef)};\n    }\n    return {[id]: this};\n  }\n\n  getBuffer() {\n    if (this.state.constant) {\n      return null;\n    }\n    return this.state.externalBuffer || this._buffer;\n  }\n\n  getValue() {\n    if (this.state.constant) {\n      return this.value;\n    }\n    return [this.getBuffer(), this.getAccessor()];\n  }\n\n  getAccessor() {\n    return this.state.bufferAccessor;\n  }\n\n  // returns true if success\n  // eslint-disable-next-line max-statements\n  setData(opts) {\n    const {state} = this;\n    if (ArrayBuffer.isView(opts)) {\n      opts = {value: opts};\n    } else if (opts instanceof Buffer) {\n      opts = {buffer: opts};\n    }\n\n    const accessor = {...this.settings, ...opts};\n    state.bufferAccessor = accessor;\n\n    if (opts.constant) {\n      // set constant\n      let value = opts.value;\n      value = this._normalizeValue(value, [], 0);\n      if (this.settings.normalized) {\n        value = this._normalizeConstant(value);\n      }\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n      if (!hasChanged) {\n        return false;\n      }\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = value;\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value;\n      const isBuffer64Bit = opts.value instanceof Float64Array;\n\n      // Copy the type of the buffer into the accessor\n      accessor.type = opts.type || buffer.accessor.type;\n      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n      accessor.stride = getStride(accessor);\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n\n      let value = opts.value;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n\n      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n\n      const {buffer, byteOffset} = this;\n\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n      // TODO: support offset in buffer.setData?\n      if (buffer.byteLength < value.byteLength + byteOffset) {\n        // Over allocation is required because shader attributes may have bigger offsets\n        buffer.reallocate((value.byteLength + byteOffset) * 2);\n      }\n      // Hack: force Buffer to infer data type\n      buffer.setAccessor(null);\n      buffer.subData({data: value, offset: byteOffset});\n      accessor.type = opts.type || buffer.accessor.type;\n    }\n\n    return true;\n  }\n\n  updateSubBuffer(opts = {}) {\n    const {value} = this;\n    const {startOffset = 0, endOffset} = opts;\n    this.buffer.subData({\n      data:\n        this.doublePrecision && value instanceof Float64Array\n          ? toDoublePrecisionArray(value, {\n              size: this.size,\n              startIndex: startOffset,\n              endIndex: endOffset\n            })\n          : value.subarray(startOffset, endOffset),\n      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n    });\n  }\n\n  allocate({numInstances, copy = false}) {\n    const {state} = this;\n    const oldValue = state.allocatedValue;\n\n    // Allocate at least one element to ensure a valid buffer\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.defaultType,\n      copy\n    });\n    this.value = value;\n    const {buffer, byteOffset} = this;\n\n    if (buffer.byteLength < value.byteLength + byteOffset) {\n      buffer.reallocate(value.byteLength + byteOffset);\n\n      if (copy && oldValue) {\n        // Upload the full existing attribute value to the GPU, so that updateBuffer\n        // can choose to only update a partial range.\n        // TODO - copy old buffer to new buffer on the GPU\n        buffer.subData({\n          data:\n            oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n          offset: byteOffset\n        });\n      }\n    }\n\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    state.bufferAccessor = this.settings;\n    return true;\n  }\n\n  // PRIVATE HELPER METHODS\n  _checkExternalBuffer(opts) {\n    const {value} = opts;\n    if (!opts.constant && value) {\n      const ArrayType = this.defaultType;\n\n      let illegalArrayType = false;\n      if (this.doublePrecision) {\n        // not 32bit or 64bit\n        illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n      }\n      if (illegalArrayType) {\n        throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);\n      }\n      if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n        log.warn(`Attribute ${this.id} is normalized`)();\n      }\n    }\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n  _normalizeConstant(value) {\n    switch (this.settings.type) {\n      case GL.BYTE:\n        // normalize [-128, 127] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 128) / 255) * 2 - 1);\n\n      case GL.SHORT:\n        // normalize [-32768, 32767] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 32768) / 65535) * 2 - 1);\n\n      case GL.UNSIGNED_BYTE:\n        // normalize [0, 255] to [0, 1]\n        return new Float32Array(value).map(x => x / 255);\n\n      case GL.UNSIGNED_SHORT:\n        // normalize [0, 65535] to [0, 1]\n        return new Float32Array(value).map(x => x / 65535);\n\n      default:\n        // No normalization for gl.FLOAT and gl.HALF_FLOAT\n        return value;\n    }\n  }\n\n  /* check user supplied values and apply fallback */\n  _normalizeValue(value, out, start) {\n    const {defaultValue, size} = this.settings;\n\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n    if (!value) {\n      out[start] = defaultValue[0];\n      return out;\n    }\n\n    // Important - switch cases are 5x more performant than a for loop!\n    /* eslint-disable no-fallthrough, default-case */\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n\n      default:\n        // In the rare case where the attribute size > 4, do it the slow way\n        // This is used for e.g. transform matrices\n        let i = size;\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n    }\n\n    return out;\n  }\n\n  _areValuesEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n    const {size} = this;\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}