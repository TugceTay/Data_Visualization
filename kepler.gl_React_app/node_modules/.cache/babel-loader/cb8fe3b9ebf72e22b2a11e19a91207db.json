{"ast":null,"code":"import { isWebGL } from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport { Program, VertexArray, clear, TransformFeedback, Buffer, log, isObjectEmpty, uid, assert } from '@luma.gl/webgl';\nimport { getDebugTableForUniforms, getDebugTableForVertexArray, getDebugTableForProgramConfiguration } from '@luma.gl/webgl';\nimport { getBuffersFromGeometry } from './model-utils';\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\nconst NOOP = () => {};\nconst DRAW_PARAMS = {};\nexport default class Model {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      id = uid('model')\n    } = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0;\n    this.animated = false;\n    this.initialize(props);\n  }\n  initialize(props) {\n    this.props = {};\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n    this.userData = {};\n    this.needsRedraw = true;\n    this._attributes = {};\n    this.attributes = {};\n    this.uniforms = {};\n    this.pickable = true;\n    this._checkProgram();\n    this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;\n    this.vertexCount = props.vertexCount || 0;\n    this.geometryBuffers = {};\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n    this._setModelProps(props);\n    this.geometry = {};\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n  setProps(props) {\n    this._setModelProps(props);\n  }\n  delete() {\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n    this.vertexArray.delete();\n    this._deleteGeometryBuffers();\n  }\n  getDrawMode() {\n    return this.drawMode;\n  }\n  getVertexCount() {\n    return this.vertexCount;\n  }\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n  getAttributes() {\n    return this.attributes;\n  }\n  getProgram() {\n    return this.program;\n  }\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n  getUniforms() {\n    return this.uniforms;\n  }\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n    this._deleteGeometryBuffers();\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n  setAttributes() {\n    let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n  setUniforms() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Object.assign(this.uniforms, uniforms);\n    return this;\n  }\n  getModuleUniforms(opts) {\n    this._checkProgram();\n    const getUniforms = this.programManager.getUniforms(this.program);\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n    return {};\n  }\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n  draw() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._checkProgram();\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n    let logPriority;\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n    const {\n      isInstanced,\n      instanceCount\n    } = this;\n    const {\n      onBeforeRender = NOOP,\n      onAfterRender = NOOP\n    } = this.props;\n    onBeforeRender();\n    this.program.setUniforms(this.uniforms);\n    const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {\n      logPriority,\n      uniforms: null,\n      framebuffer,\n      parameters,\n      drawMode: this.getDrawMode(),\n      vertexCount: this.getVertexCount(),\n      vertexArray,\n      transformFeedback,\n      isIndexed,\n      indexType,\n      isInstanced,\n      instanceCount,\n      offset: isIndexed ? indexOffset : 0\n    }));\n    onAfterRender();\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n    return didDraw;\n  }\n  transform() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      discard = true,\n      feedbackBuffers,\n      unbindModels = []\n    } = opts;\n    let {\n      parameters\n    } = opts;\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n    if (discard) {\n      parameters = Object.assign({}, parameters, {\n        [35977]: discard\n      });\n    }\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {\n        parameters\n      }));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n    return this;\n  }\n  render() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n  _checkProgram() {\n    const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;\n    if (!needsUpdate) {\n      return;\n    }\n    let {\n      program\n    } = this.programProps;\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n    assert(program instanceof Program, 'Model needs a program');\n    this._programDirty = false;\n    if (program === this.program) {\n      return;\n    }\n    this.program = program;\n    if (this.vertexArray) {\n      this.vertexArray.setProps({\n        program: this.program,\n        attributes: this.vertexArray.attributes\n      });\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {\n        program: this.program\n      });\n    }\n    this.setUniforms(Object.assign({}, this.getModuleUniforms()));\n  }\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n    }\n  }\n  _setFeedbackBuffers() {\n    let feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n    const {\n      gl\n    } = this.program;\n    this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {\n      program: this.program\n    });\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n    this.lastLogTime = Date.now();\n    log.group(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id), {\n      collapsed: log.level <= 2\n    })();\n    return logLevel;\n  }\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    if (logLevel === undefined) {\n      return;\n    }\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: \"\".concat(this.id, \" attributes\"),\n      attributes: this._attributes\n    });\n    const {\n      table: uniformTable,\n      unusedTable,\n      unusedCount\n    } = getDebugTableForUniforms({\n      header: \"\".concat(this.id, \" uniforms\"),\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n    const {\n      table: missingTable,\n      count: missingCount\n    } = getDebugTableForUniforms({\n      header: \"\".concat(this.id, \" uniforms\"),\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n    }\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n    log.table(logLevel, attributeTable)();\n    log.table(logLevel, uniformTable)();\n    log.table(logLevel + 1, configTable)();\n    if (framebuffer) {\n      framebuffer.log({\n        logLevel: LOG_DRAW_PRIORITY,\n        message: \"Rendered to \".concat(framebuffer.id)\n      });\n    }\n    log.groupEnd(LOG_DRAW_PRIORITY)();\n  }\n}","map":{"version":3,"sources":["../../../src/lib/model.js"],"names":["isWebGL","ProgramManager","Program","VertexArray","clear","TransformFeedback","Buffer","log","isObjectEmpty","uid","assert","getDebugTableForUniforms","getDebugTableForVertexArray","getDebugTableForProgramConfiguration","getBuffersFromGeometry","LOG_DRAW_PRIORITY","LOG_DRAW_TIMEOUT","ERR_MODEL_PARAMS","NOOP","DRAW_PARAMS","Model","constructor","gl","props","id","lastLogTime","animated","initialize","programManager","getDefaultProgramManager","_programManagerState","_managedProgram","program","vs","fs","modules","defines","inject","varyings","bufferMode","transpileToGLSL100","programProps","vertexArray","_programDirty","userData","needsRedraw","_attributes","attributes","uniforms","pickable","_checkProgram","setUniforms","Object","assign","getModuleUniforms","moduleSettings","drawMode","undefined","vertexCount","geometryBuffers","isInstanced","instanced","instanceCount","_setModelProps","geometry","Number","isFinite","setProps","delete","key","release","_deleteGeometryBuffers","getDrawMode","getVertexCount","getInstanceCount","getAttributes","getProgram","setProgram","getUniforms","setDrawMode","setVertexCount","setInstanceCount","setGeometry","setAttributes","normalizedAttributes","name","attribute","getValue","opts","updateModuleSettings","draw","framebuffer","transformFeedback","parameters","logPriority","priority","_logDrawCallStart","drawParams","getDrawParams","isIndexed","indexType","indexOffset","vertexArrayInstanced","warn","onBeforeRender","onAfterRender","didDraw","offset","_logDrawCallEnd","transform","discard","feedbackBuffers","unbindModels","_setFeedbackBuffers","forEach","model","unbindBuffers","bindBuffers","render","_feedbackBuffers","needsUpdate","stateHash","get","buffer","_setAnimationProps","animationProps","setBuffers","logLevel","logDrawTimeout","Date","now","group","collapsed","level","attributeTable","header","table","uniformTable","unusedTable","unusedCount","missingTable","count","missingCount","undefinedOnly","keys","configTable","configuration","message","groupEnd"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\n\nimport GL from '@luma.gl/constants';\nimport {isWebGL} from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport {\n  Program,\n  VertexArray,\n  clear,\n  TransformFeedback,\n  Buffer,\n  log,\n  isObjectEmpty,\n  uid,\n  assert\n} from '@luma.gl/webgl';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nconst NOOP = () => {};\nconst DRAW_PARAMS = {};\n\nexport default class Model {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    this._setModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n\n    this.vertexArray.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  draw(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    let logPriority;\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isInstanced, instanceCount} = this;\n\n    const {onBeforeRender = NOOP, onAfterRender = NOOP} = this.props;\n\n    onBeforeRender();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign(DRAW_PARAMS, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    onAfterRender();\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n\n    return didDraw;\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _checkProgram() {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      // @ts-ignore TODO\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      // const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      // Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n\n    return logLevel;\n  }\n\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    // HACK: logLevel === undefined means logDrawCallStart didn't run\n    if (logLevel === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      // @ts-ignore\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(logLevel, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(logLevel, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(logLevel, attributeTable)();\n\n    log.table(logLevel, uniformTable)();\n\n    log.table(logLevel + 1, configTable)();\n\n    if (framebuffer) {\n      framebuffer.log({logLevel: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY)();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}