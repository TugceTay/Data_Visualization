{"ast":null,"code":"import { isWebGL2, assertWebGL2Context, withParameters } from '@luma.gl/gltools';\nimport Texture from './texture';\nimport { DATA_FORMAT_CHANNELS, TYPE_SIZES } from './texture-formats';\nimport Buffer from './buffer';\nexport default class Texture3D extends Texture {\n  get [Symbol.toStringTag]() {\n    return 'Texture3D';\n  }\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assertWebGL2Context(gl);\n    props = Object.assign({\n      depth: 1\n    }, props, {\n      target: 32879,\n      unpackFlipY: false\n    });\n    super(gl, props);\n    this.initialize(props);\n    Object.seal(this);\n  }\n  setImageData(_ref) {\n    let {\n      level = 0,\n      dataFormat = 6408,\n      width,\n      height,\n      depth = 1,\n      border = 0,\n      format,\n      type = 5121,\n      offset = 0,\n      data,\n      parameters = {}\n    } = _ref;\n    this._trackDeallocatedMemory('Texture');\n    this.gl.bindTexture(this.target, this.handle);\n    withParameters(this.gl, parameters, () => {\n      if (ArrayBuffer.isView(data)) {\n        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);\n      }\n      if (data instanceof Buffer) {\n        this.gl.bindBuffer(35052, data.handle);\n        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);\n      }\n    });\n    if (data && data.byteLength) {\n      this._trackAllocatedMemory(data.byteLength, 'Texture');\n    } else {\n      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n      const channelSize = TYPE_SIZES[this.type] || 1;\n      this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, 'Texture');\n    }\n    this.loaded = true;\n    return this;\n  }\n}","map":{"version":3,"sources":["../../../src/classes/texture-3d.js"],"names":["isWebGL2","assertWebGL2Context","withParameters","Texture","DATA_FORMAT_CHANNELS","TYPE_SIZES","Buffer","Texture3D","Symbol","toStringTag","isSupported","gl","constructor","props","assign","depth","target","unpackFlipY","initialize","Object","seal","setImageData","level","dataFormat","width","height","border","format","type","offset","data","parameters","_trackDeallocatedMemory","bindTexture","handle","ArrayBuffer","isView","texImage3D","bindBuffer","byteLength","_trackAllocatedMemory","channels","channelSize","loaded"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {isWebGL2, assertWebGL2Context, withParameters} from '@luma.gl/gltools';\nimport Texture from './texture';\nimport {DATA_FORMAT_CHANNELS, TYPE_SIZES} from './texture-formats';\nimport Buffer from './buffer';\n\nexport default class Texture3D extends Texture {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'Texture3D';\n  }\n\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGL2Context(gl);\n    props = Object.assign({depth: 1}, props, {target: GL.TEXTURE_3D, unpackFlipY: false});\n    super(gl, props);\n    this.initialize(props);\n\n    Object.seal(this);\n  }\n\n  // Image 3D copies from Typed Array or WebGLBuffer\n  setImageData({\n    level = 0,\n    dataFormat = GL.RGBA,\n    width,\n    height,\n    depth = 1,\n    border = 0,\n    format,\n    type = GL.UNSIGNED_BYTE,\n    offset = 0,\n    data,\n    parameters = {}\n  }) {\n    this._trackDeallocatedMemory('Texture');\n\n    this.gl.bindTexture(this.target, this.handle);\n\n    withParameters(this.gl, parameters, () => {\n      if (ArrayBuffer.isView(data)) {\n        // @ts-ignore\n        this.gl.texImage3D(\n          this.target,\n          level,\n          dataFormat,\n          width,\n          height,\n          depth,\n          border,\n          format,\n          type,\n          data\n        );\n      }\n\n      if (data instanceof Buffer) {\n        this.gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data.handle);\n        // @ts-ignore\n        this.gl.texImage3D(\n          this.target,\n          level,\n          dataFormat,\n          width,\n          height,\n          depth,\n          border,\n          format,\n          type,\n          offset\n        );\n      }\n    });\n\n    if (data && data.byteLength) {\n      this._trackAllocatedMemory(data.byteLength, 'Texture');\n    } else {\n      // NOTE(Tarek): Default to RGBA bytes\n      // @ts-ignore\n      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n      // @ts-ignore\n      const channelSize = TYPE_SIZES[this.type] || 1;\n\n      this._trackAllocatedMemory(\n        this.width * this.height * this.depth * channels * channelSize,\n        'Texture'\n      );\n    }\n\n    this.loaded = true;\n\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}