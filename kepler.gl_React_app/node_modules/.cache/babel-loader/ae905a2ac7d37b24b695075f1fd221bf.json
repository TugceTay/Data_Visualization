{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.aggregateRequiredColumns = exports.getFilterDataFunc = exports.getValueAggrFunc = exports.pointPosResolver = exports.pointPosAccessor = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.memoize\"));\nvar _baseLayer = _interopRequireDefault(require(\"./base-layer\"));\nvar _colorUtils = require(\"../utils/color-utils\");\nvar _aggregateUtils = require(\"../utils/aggregate-utils\");\nvar _defaultSettings = require(\"../constants/default-settings\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar pointPosAccessor = function pointPosAccessor(_ref) {\n  var lat = _ref.lat,\n    lng = _ref.lng;\n  return function (dc) {\n    return function (d) {\n      return [dc.valueAt(d.index, lng.fieldIdx), dc.valueAt(d.index, lat.fieldIdx)];\n    };\n  };\n};\nexports.pointPosAccessor = pointPosAccessor;\nvar pointPosResolver = function pointPosResolver(_ref2) {\n  var lat = _ref2.lat,\n    lng = _ref2.lng;\n  return \"\".concat(lat.fieldIdx, \"-\").concat(lng.fieldIdx);\n};\nexports.pointPosResolver = pointPosResolver;\nvar getValueAggrFunc = function getValueAggrFunc(field, aggregation) {\n  return function (points) {\n    return field ? (0, _aggregateUtils.aggregate)(points.map(function (p) {\n      return field.valueAccessor(p);\n    }), aggregation) : points.length;\n  };\n};\nexports.getValueAggrFunc = getValueAggrFunc;\nvar getFilterDataFunc = function getFilterDataFunc(filterRange, getFilterValue) {\n  return function (pt) {\n    return getFilterValue(pt).every(function (val, i) {\n      return val >= filterRange[i][0] && val <= filterRange[i][1];\n    });\n  };\n};\nexports.getFilterDataFunc = getFilterDataFunc;\nvar getLayerColorRange = function getLayerColorRange(colorRange) {\n  return colorRange.colors.map(_colorUtils.hexToRgb);\n};\nvar aggregateRequiredColumns = ['lat', 'lng'];\nexports.aggregateRequiredColumns = aggregateRequiredColumns;\nvar AggregationLayer = /*#__PURE__*/function (_Layer) {\n  (0, _inherits2[\"default\"])(AggregationLayer, _Layer);\n  var _super = _createSuper(AggregationLayer);\n  function AggregationLayer(props) {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, AggregationLayer);\n    _this = _super.call(this, props);\n    _this.getPositionAccessor = function (dataContainer) {\n      return pointPosAccessor(_this.config.columns)(dataContainer);\n    };\n    _this.getColorRange = (0, _lodash[\"default\"])(getLayerColorRange);\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(AggregationLayer, [{\n    key: \"isAggregated\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return aggregateRequiredColumns;\n    }\n  }, {\n    key: \"columnPairs\",\n    get: function get() {\n      return this.defaultPointColumnPairs;\n    }\n  }, {\n    key: \"noneLayerDataAffectingProps\",\n    get: function get() {\n      return [].concat((0, _toConsumableArray2[\"default\"])((0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(AggregationLayer.prototype), \"noneLayerDataAffectingProps\", this)), ['enable3d', 'colorRange', 'colorDomain', 'sizeRange', 'sizeScale', 'sizeDomain', 'percentile', 'coverage', 'elevationPercentile', 'elevationScale', 'enableElevationZoomFactor']);\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      return {\n        color: {\n          aggregation: 'colorAggregation',\n          channelScaleType: _defaultSettings.CHANNEL_SCALES.colorAggr,\n          defaultMeasure: 'property.pointCount',\n          domain: 'colorDomain',\n          field: 'colorField',\n          key: 'color',\n          property: 'color',\n          range: 'colorRange',\n          scale: 'colorScale'\n        },\n        size: {\n          aggregation: 'sizeAggregation',\n          channelScaleType: _defaultSettings.CHANNEL_SCALES.sizeAggr,\n          condition: function condition(config) {\n            return config.visConfig.enable3d;\n          },\n          defaultMeasure: 'property.pointCount',\n          domain: 'sizeDomain',\n          field: 'sizeField',\n          key: 'size',\n          property: 'height',\n          range: 'sizeRange',\n          scale: 'sizeScale'\n        }\n      };\n    }\n    /**\n     * Get the description of a visualChannel config\n     * @param key\n     * @returns {{label: string, measure: (string|string)}}\n     */\n  }, {\n    key: \"getVisualChannelDescription\",\n    value: function getVisualChannelDescription(key) {\n      // e.g. label: Color, measure: Average of ETA\n      var _this$visualChannels$ = this.visualChannels[key],\n        range = _this$visualChannels$.range,\n        field = _this$visualChannels$.field,\n        defaultMeasure = _this$visualChannels$.defaultMeasure,\n        aggregation = _this$visualChannels$.aggregation;\n      var fieldConfig = this.config[field];\n      return {\n        label: this.visConfigSettings[range].label,\n        measure: fieldConfig ? \"\".concat(this.config.visConfig[aggregation], \" of \").concat(fieldConfig.displayName || fieldConfig.name) : defaultMeasure\n      };\n    }\n  }, {\n    key: \"getHoverData\",\n    value: function getHoverData(object) {\n      // return aggregated object\n      return object;\n    }\n    /**\n     * Aggregation layer handles visual channel aggregation inside deck.gl layer\n     */\n  }, {\n    key: \"updateLayerVisualChannel\",\n    value: function updateLayerVisualChannel(_ref3, channel) {\n      var data = _ref3.data,\n        dataContainer = _ref3.dataContainer;\n      this.validateVisualChannel(channel);\n    }\n    /**\n     * Validate aggregation type on top of basic layer visual channel validation\n     * @param channel\n     */\n  }, {\n    key: \"validateVisualChannel\",\n    value: function validateVisualChannel(channel) {\n      // field type decides aggregation type decides scale type\n      this.validateFieldType(channel);\n      this.validateAggregationType(channel);\n      this.validateScale(channel);\n    }\n    /**\n     * Validate aggregation type based on selected field\n     */\n  }, {\n    key: \"validateAggregationType\",\n    value: function validateAggregationType(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var field = visualChannel.field,\n        aggregation = visualChannel.aggregation;\n      var aggregationOptions = this.getAggregationOptions(channel);\n      if (!aggregation) {\n        return;\n      }\n      if (!aggregationOptions.length) {\n        // if field cannot be aggregated, set field to null\n        this.updateLayerConfig((0, _defineProperty2[\"default\"])({}, field, null));\n      } else if (!aggregationOptions.includes(this.config.visConfig[aggregation])) {\n        // current aggregation type is not supported by this field\n        // set aggregation to the first supported option\n        this.updateLayerVisConfig((0, _defineProperty2[\"default\"])({}, aggregation, aggregationOptions[0]));\n      }\n    }\n  }, {\n    key: \"getAggregationOptions\",\n    value: function getAggregationOptions(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var field = visualChannel.field,\n        channelScaleType = visualChannel.channelScaleType;\n      return Object.keys(this.config[field] ? _defaultSettings.FIELD_OPTS[this.config[field].type].scale[channelScaleType] : _defaultSettings.DEFAULT_AGGREGATION[channelScaleType]);\n    }\n    /**\n     * Get scale options based on current field and aggregation type\n     * @param {string} channel\n     * @returns {string[]}\n     */\n  }, {\n    key: \"getScaleOptions\",\n    value: function getScaleOptions(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var field = visualChannel.field,\n        aggregation = visualChannel.aggregation,\n        channelScaleType = visualChannel.channelScaleType;\n      var aggregationType = this.config.visConfig[aggregation];\n      return this.config[field] ?\n      // scale options based on aggregation\n      _defaultSettings.FIELD_OPTS[this.config[field].type].scale[channelScaleType][aggregationType] :\n      // default scale options for point count\n      _defaultSettings.DEFAULT_AGGREGATION[channelScaleType][aggregationType];\n    }\n    /**\n     * Aggregation layer handles visual channel aggregation inside deck.gl layer\n     */\n  }, {\n    key: \"updateLayerDomain\",\n    value: function updateLayerDomain(datasets, newFilter) {\n      return this;\n    }\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer, getPosition) {\n      // get bounds from points\n      var bounds = this.getPointsBounds(dataContainer, getPosition);\n      this.updateMeta({\n        bounds: bounds\n      });\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(_ref4, getPosition) {\n      var dataContainer = _ref4.dataContainer,\n        filteredIndex = _ref4.filteredIndex;\n      var data = [];\n      for (var i = 0; i < filteredIndex.length; i++) {\n        var index = filteredIndex[i];\n        var pos = getPosition({\n          index: index\n        }); // if doesn't have point lat or lng, do not add the point\n        // deck.gl can't handle position = null\n\n        if (pos.every(Number.isFinite)) {\n          data.push({\n            index: index\n          });\n        }\n      }\n      return data;\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, oldLayerData) {\n      var _datasets$this$config = datasets[this.config.dataId],\n        gpuFilter = _datasets$this$config.gpuFilter,\n        dataContainer = _datasets$this$config.dataContainer;\n      var getPosition = this.getPositionAccessor(dataContainer);\n      var getColorValue = getValueAggrFunc(this.config.colorField, this.config.visConfig.colorAggregation);\n      var getElevationValue = getValueAggrFunc(this.config.sizeField, this.config.visConfig.sizeAggregation);\n      var hasFilter = Object.values(gpuFilter.filterRange).some(function (arr) {\n        return arr.some(function (v) {\n          return v !== 0;\n        });\n      });\n      var getFilterValue = gpuFilter.filterValueAccessor(dataContainer)();\n      var filterData = hasFilter ? getFilterDataFunc(gpuFilter.filterRange, getFilterValue) : undefined;\n      var _this$updateData = this.updateData(datasets, oldLayerData),\n        data = _this$updateData.data;\n      return _objectSpread(_objectSpread({\n        data: data,\n        getPosition: getPosition,\n        _filterData: filterData\n      }, getColorValue ? {\n        getColorValue: getColorValue\n      } : {}), getElevationValue ? {\n        getElevationValue: getElevationValue\n      } : {});\n    }\n  }, {\n    key: \"getDefaultDeckLayerProps\",\n    value: function getDefaultDeckLayerProps(opts) {\n      var baseProp = (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(AggregationLayer.prototype), \"getDefaultDeckLayerProps\", this).call(this, opts);\n      return _objectSpread(_objectSpread({}, baseProp), {}, {\n        highlightColor: _defaultSettings.HIGHLIGH_COLOR_3D,\n        // gpu data filtering is not supported in aggregation layer\n        extensions: [],\n        autoHighlight: this.config.visConfig.enable3d\n      });\n    }\n  }, {\n    key: \"getDefaultAggregationLayerProp\",\n    value: function getDefaultAggregationLayerProp(opts) {\n      var gpuFilter = opts.gpuFilter,\n        mapState = opts.mapState,\n        _opts$layerCallbacks = opts.layerCallbacks,\n        layerCallbacks = _opts$layerCallbacks === void 0 ? {} : _opts$layerCallbacks;\n      var visConfig = this.config.visConfig;\n      var eleZoomFactor = this.getElevationZoomFactor(mapState);\n      var updateTriggers = {\n        getColorValue: {\n          colorField: this.config.colorField,\n          colorAggregation: this.config.visConfig.colorAggregation\n        },\n        getElevationValue: {\n          sizeField: this.config.sizeField,\n          sizeAggregation: this.config.visConfig.sizeAggregation\n        },\n        _filterData: _objectSpread({\n          filterRange: gpuFilter.filterRange\n        }, gpuFilter.filterValueUpdateTriggers)\n      };\n      return _objectSpread(_objectSpread({}, this.getDefaultDeckLayerProps(opts)), {}, {\n        coverage: visConfig.coverage,\n        // color\n        colorRange: this.getColorRange(visConfig.colorRange),\n        colorScaleType: this.config.colorScale,\n        upperPercentile: visConfig.percentile[1],\n        lowerPercentile: visConfig.percentile[0],\n        colorAggregation: visConfig.colorAggregation,\n        // elevation\n        extruded: visConfig.enable3d,\n        elevationScale: visConfig.elevationScale * eleZoomFactor,\n        elevationScaleType: this.config.sizeScale,\n        elevationRange: visConfig.sizeRange,\n        elevationLowerPercentile: visConfig.elevationPercentile[0],\n        elevationUpperPercentile: visConfig.elevationPercentile[1],\n        // updateTriggers\n        updateTriggers: updateTriggers,\n        // callbacks\n        onSetColorDomain: layerCallbacks.onSetLayerDomain\n      });\n    }\n  }]);\n  return AggregationLayer;\n}(_baseLayer[\"default\"]);\nexports[\"default\"] = AggregationLayer;","map":{"version":3,"sources":["../../src/layers/aggregation-layer.js"],"names":["pointPosAccessor","lat","lng","dc","valueAt","d","index","fieldIdx","pointPosResolver","getValueAggrFunc","field","aggregation","map","valueAccessor","p","points","length","getFilterDataFunc","filterRange","getFilterValue","pt","every","val","i","getLayerColorRange","colorRange","colors","hexToRgb","aggregateRequiredColumns","AggregationLayer","Layer","props","getPositionAccessor","config","columns","dataContainer","getColorRange","defaultPointColumnPairs","color","channelScaleType","CHANNEL_SCALES","colorAggr","defaultMeasure","domain","key","property","range","scale","size","sizeAggr","condition","visConfig","enable3d","visualChannels","fieldConfig","label","visConfigSettings","measure","displayName","name","object","data","channel","validateVisualChannel","validateFieldType","validateAggregationType","validateScale","visualChannel","aggregationOptions","getAggregationOptions","updateLayerConfig","includes","updateLayerVisConfig","Object","keys","FIELD_OPTS","type","DEFAULT_AGGREGATION","aggregationType","datasets","newFilter","getPosition","bounds","getPointsBounds","updateMeta","filteredIndex","pos","Number","isFinite","push","oldLayerData","gpuFilter","dataId","getColorValue","colorField","colorAggregation","getElevationValue","sizeField","sizeAggregation","hasFilter","values","some","v","filterValueAccessor","filterData","undefined","updateData","_filterData","opts","baseProp","highlightColor","HIGHLIGH_COLOR_3D","extensions","autoHighlight","mapState","layerCallbacks","eleZoomFactor","getElevationZoomFactor","updateTriggers","filterValueUpdateTriggers","getDefaultDeckLayerProps","coverage","colorScaleType","colorScale","upperPercentile","percentile","lowerPercentile","extruded","elevationScale","elevationScaleType","sizeScale","elevationRange","sizeRange","elevationLowerPercentile","elevationPercentile","elevationUpperPercentile","onSetColorDomain","onSetLayerDomain"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport memoize from 'lodash.memoize';\nimport Layer from './base-layer';\nimport {hexToRgb} from 'utils/color-utils';\nimport {aggregate} from 'utils/aggregate-utils';\nimport {\n  HIGHLIGH_COLOR_3D,\n  CHANNEL_SCALES,\n  FIELD_OPTS,\n  DEFAULT_AGGREGATION\n} from 'constants/default-settings';\n\nexport const pointPosAccessor = ({lat, lng}) => dc => d => [\n  dc.valueAt(d.index, lng.fieldIdx),\n  dc.valueAt(d.index, lat.fieldIdx)\n];\n\nexport const pointPosResolver = ({lat, lng}) => `${lat.fieldIdx}-${lng.fieldIdx}`;\n\nexport const getValueAggrFunc = (field, aggregation) => {\n  return points => {\n    return field\n      ? aggregate(\n          points.map(p => {\n            return field.valueAccessor(p);\n          }),\n          aggregation\n        )\n      : points.length;\n  };\n};\n\nexport const getFilterDataFunc = (filterRange, getFilterValue) => pt =>\n  getFilterValue(pt).every((val, i) => val >= filterRange[i][0] && val <= filterRange[i][1]);\n\nconst getLayerColorRange = colorRange => colorRange.colors.map(hexToRgb);\n\nexport const aggregateRequiredColumns = ['lat', 'lng'];\n\nexport default class AggregationLayer extends Layer {\n  constructor(props) {\n    super(props);\n\n    this.getPositionAccessor = dataContainer =>\n      pointPosAccessor(this.config.columns)(dataContainer);\n    this.getColorRange = memoize(getLayerColorRange);\n  }\n\n  get isAggregated() {\n    return true;\n  }\n\n  get requiredLayerColumns() {\n    return aggregateRequiredColumns;\n  }\n\n  get columnPairs() {\n    return this.defaultPointColumnPairs;\n  }\n\n  get noneLayerDataAffectingProps() {\n    return [\n      ...super.noneLayerDataAffectingProps,\n      'enable3d',\n      'colorRange',\n      'colorDomain',\n      'sizeRange',\n      'sizeScale',\n      'sizeDomain',\n      'percentile',\n      'coverage',\n      'elevationPercentile',\n      'elevationScale',\n      'enableElevationZoomFactor'\n    ];\n  }\n\n  get visualChannels() {\n    return {\n      color: {\n        aggregation: 'colorAggregation',\n        channelScaleType: CHANNEL_SCALES.colorAggr,\n        defaultMeasure: 'property.pointCount',\n        domain: 'colorDomain',\n        field: 'colorField',\n        key: 'color',\n        property: 'color',\n        range: 'colorRange',\n        scale: 'colorScale'\n      },\n      size: {\n        aggregation: 'sizeAggregation',\n        channelScaleType: CHANNEL_SCALES.sizeAggr,\n        condition: config => config.visConfig.enable3d,\n        defaultMeasure: 'property.pointCount',\n        domain: 'sizeDomain',\n        field: 'sizeField',\n        key: 'size',\n        property: 'height',\n        range: 'sizeRange',\n        scale: 'sizeScale'\n      }\n    };\n  }\n\n  /**\n   * Get the description of a visualChannel config\n   * @param key\n   * @returns {{label: string, measure: (string|string)}}\n   */\n  getVisualChannelDescription(key) {\n    // e.g. label: Color, measure: Average of ETA\n    const {range, field, defaultMeasure, aggregation} = this.visualChannels[key];\n    const fieldConfig = this.config[field];\n    return {\n      label: this.visConfigSettings[range].label,\n      measure: fieldConfig\n        ? `${this.config.visConfig[aggregation]} of ${fieldConfig.displayName || fieldConfig.name}`\n        : defaultMeasure\n    };\n  }\n\n  getHoverData(object) {\n    // return aggregated object\n    return object;\n  }\n\n  /**\n   * Aggregation layer handles visual channel aggregation inside deck.gl layer\n   */\n  updateLayerVisualChannel({data, dataContainer}, channel) {\n    this.validateVisualChannel(channel);\n  }\n\n  /**\n   * Validate aggregation type on top of basic layer visual channel validation\n   * @param channel\n   */\n  validateVisualChannel(channel) {\n    // field type decides aggregation type decides scale type\n    this.validateFieldType(channel);\n    this.validateAggregationType(channel);\n    this.validateScale(channel);\n  }\n\n  /**\n   * Validate aggregation type based on selected field\n   */\n  validateAggregationType(channel) {\n    const visualChannel = this.visualChannels[channel];\n    const {field, aggregation} = visualChannel;\n    const aggregationOptions = this.getAggregationOptions(channel);\n\n    if (!aggregation) {\n      return;\n    }\n\n    if (!aggregationOptions.length) {\n      // if field cannot be aggregated, set field to null\n      this.updateLayerConfig({[field]: null});\n    } else if (!aggregationOptions.includes(this.config.visConfig[aggregation])) {\n      // current aggregation type is not supported by this field\n      // set aggregation to the first supported option\n      this.updateLayerVisConfig({[aggregation]: aggregationOptions[0]});\n    }\n  }\n\n  getAggregationOptions(channel) {\n    const visualChannel = this.visualChannels[channel];\n    const {field, channelScaleType} = visualChannel;\n\n    return Object.keys(\n      this.config[field]\n        ? FIELD_OPTS[this.config[field].type].scale[channelScaleType]\n        : DEFAULT_AGGREGATION[channelScaleType]\n    );\n  }\n\n  /**\n   * Get scale options based on current field and aggregation type\n   * @param {string} channel\n   * @returns {string[]}\n   */\n  getScaleOptions(channel) {\n    const visualChannel = this.visualChannels[channel];\n    const {field, aggregation, channelScaleType} = visualChannel;\n    const aggregationType = this.config.visConfig[aggregation];\n    return this.config[field]\n      ? // scale options based on aggregation\n        FIELD_OPTS[this.config[field].type].scale[channelScaleType][aggregationType]\n      : // default scale options for point count\n        DEFAULT_AGGREGATION[channelScaleType][aggregationType];\n  }\n\n  /**\n   * Aggregation layer handles visual channel aggregation inside deck.gl layer\n   */\n  updateLayerDomain(datasets, newFilter) {\n    return this;\n  }\n\n  updateLayerMeta(dataContainer, getPosition) {\n    // get bounds from points\n    const bounds = this.getPointsBounds(dataContainer, getPosition);\n\n    this.updateMeta({bounds});\n  }\n\n  calculateDataAttribute({dataContainer, filteredIndex}, getPosition) {\n    const data = [];\n\n    for (let i = 0; i < filteredIndex.length; i++) {\n      const index = filteredIndex[i];\n      const pos = getPosition({index});\n\n      // if doesn't have point lat or lng, do not add the point\n      // deck.gl can't handle position = null\n      if (pos.every(Number.isFinite)) {\n        data.push({\n          index\n        });\n      }\n    }\n\n    return data;\n  }\n\n  formatLayerData(datasets, oldLayerData) {\n    const {gpuFilter, dataContainer} = datasets[this.config.dataId];\n    const getPosition = this.getPositionAccessor(dataContainer);\n\n    const getColorValue = getValueAggrFunc(\n      this.config.colorField,\n      this.config.visConfig.colorAggregation\n    );\n\n    const getElevationValue = getValueAggrFunc(\n      this.config.sizeField,\n      this.config.visConfig.sizeAggregation\n    );\n    const hasFilter = Object.values(gpuFilter.filterRange).some(arr => arr.some(v => v !== 0));\n\n    const getFilterValue = gpuFilter.filterValueAccessor(dataContainer)();\n    const filterData = hasFilter\n      ? getFilterDataFunc(gpuFilter.filterRange, getFilterValue)\n      : undefined;\n\n    const {data} = this.updateData(datasets, oldLayerData);\n\n    return {\n      data,\n      getPosition,\n      _filterData: filterData,\n      ...(getColorValue ? {getColorValue} : {}),\n      ...(getElevationValue ? {getElevationValue} : {})\n    };\n  }\n\n  getDefaultDeckLayerProps(opts) {\n    const baseProp = super.getDefaultDeckLayerProps(opts);\n    return {\n      ...baseProp,\n      highlightColor: HIGHLIGH_COLOR_3D,\n      // gpu data filtering is not supported in aggregation layer\n      extensions: [],\n      autoHighlight: this.config.visConfig.enable3d\n    };\n  }\n\n  getDefaultAggregationLayerProp(opts) {\n    const {gpuFilter, mapState, layerCallbacks = {}} = opts;\n    const {visConfig} = this.config;\n    const eleZoomFactor = this.getElevationZoomFactor(mapState);\n\n    const updateTriggers = {\n      getColorValue: {\n        colorField: this.config.colorField,\n        colorAggregation: this.config.visConfig.colorAggregation\n      },\n      getElevationValue: {\n        sizeField: this.config.sizeField,\n        sizeAggregation: this.config.visConfig.sizeAggregation\n      },\n      _filterData: {\n        filterRange: gpuFilter.filterRange,\n        ...gpuFilter.filterValueUpdateTriggers\n      }\n    };\n\n    return {\n      ...this.getDefaultDeckLayerProps(opts),\n      coverage: visConfig.coverage,\n\n      // color\n      colorRange: this.getColorRange(visConfig.colorRange),\n      colorScaleType: this.config.colorScale,\n      upperPercentile: visConfig.percentile[1],\n      lowerPercentile: visConfig.percentile[0],\n      colorAggregation: visConfig.colorAggregation,\n\n      // elevation\n      extruded: visConfig.enable3d,\n      elevationScale: visConfig.elevationScale * eleZoomFactor,\n      elevationScaleType: this.config.sizeScale,\n      elevationRange: visConfig.sizeRange,\n      elevationLowerPercentile: visConfig.elevationPercentile[0],\n      elevationUpperPercentile: visConfig.elevationPercentile[1],\n\n      // updateTriggers\n      updateTriggers,\n\n      // callbacks\n      onSetColorDomain: layerCallbacks.onSetLayerDomain\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}