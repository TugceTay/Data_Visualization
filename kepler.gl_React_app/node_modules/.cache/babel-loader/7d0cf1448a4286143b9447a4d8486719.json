{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { Tesselator } from '@deck.gl/core';\nimport { normalizePath } from './path';\nvar START_CAP = 1;\nvar END_CAP = 2;\nvar INVALID = 4;\nvar PathTesselator = function (_Tesselator) {\n  _inherits(PathTesselator, _Tesselator);\n  function PathTesselator(opts) {\n    _classCallCheck(this, PathTesselator);\n    return _possibleConstructorReturn(this, _getPrototypeOf(PathTesselator).call(this, _objectSpread({}, opts, {\n      attributes: {\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {\n          size: 1,\n          type: Uint8ClampedArray\n        }\n      }\n    })));\n  }\n  _createClass(PathTesselator, [{\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(buffer) {\n      if (this.normalize) {\n        return _get(_getPrototypeOf(PathTesselator.prototype), \"getGeometryFromBuffer\", this).call(this, buffer);\n      }\n      return function () {\n        return null;\n      };\n    }\n  }, {\n    key: \"normalizeGeometry\",\n    value: function normalizeGeometry(path) {\n      if (this.normalize) {\n        return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n      }\n      return path;\n    }\n  }, {\n    key: \"get\",\n    value: function get(attributeName) {\n      return this.attributes[attributeName];\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(path) {\n      if (Array.isArray(path[0])) {\n        var size = 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n          for (var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var subPath = _step.value;\n            size += this.getGeometrySize(subPath);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n        return size;\n      }\n      var numPoints = this.getPathLength(path);\n      if (numPoints < 2) {\n        return 0;\n      }\n      if (this.isClosed(path)) {\n        return numPoints < 3 ? 0 : numPoints + 2;\n      }\n      return numPoints;\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(path, context) {\n      if (context.geometrySize === 0) {\n        return;\n      }\n      if (path && Array.isArray(path[0])) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n        try {\n          for (var _iterator2 = path[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var subPath = _step2.value;\n            var geometrySize = this.getGeometrySize(subPath);\n            context.geometrySize = geometrySize;\n            this.updateGeometryAttributes(subPath, context);\n            context.vertexStart += geometrySize;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } else {\n        this._updateSegmentTypes(path, context);\n        this._updatePositions(path, context);\n      }\n    }\n  }, {\n    key: \"_updateSegmentTypes\",\n    value: function _updateSegmentTypes(path, context) {\n      var segmentTypes = this.attributes.segmentTypes;\n      var isPathClosed = this.isClosed(path);\n      var vertexStart = context.vertexStart,\n        geometrySize = context.geometrySize;\n      segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n      if (isPathClosed) {\n        segmentTypes[vertexStart] = INVALID;\n        segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n      } else {\n        segmentTypes[vertexStart] += START_CAP;\n        segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n      }\n      segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n    }\n  }, {\n    key: \"_updatePositions\",\n    value: function _updatePositions(path, context) {\n      var positions = this.attributes.positions;\n      if (!positions) {\n        return;\n      }\n      var vertexStart = context.vertexStart,\n        geometrySize = context.geometrySize;\n      var p = new Array(3);\n      for (var i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n        this.getPointOnPath(path, ptIndex, p);\n        positions[i * 3] = p[0];\n        positions[i * 3 + 1] = p[1];\n        positions[i * 3 + 2] = p[2];\n      }\n    }\n  }, {\n    key: \"getPathLength\",\n    value: function getPathLength(path) {\n      return path.length / this.positionSize;\n    }\n  }, {\n    key: \"getPointOnPath\",\n    value: function getPointOnPath(path, index) {\n      var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var positionSize = this.positionSize;\n      if (index * positionSize >= path.length) {\n        index += 1 - path.length / positionSize;\n      }\n      var i = index * positionSize;\n      target[0] = path[i];\n      target[1] = path[i + 1];\n      target[2] = positionSize === 3 && path[i + 2] || 0;\n      return target;\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed(path) {\n      if (!this.normalize) {\n        return this.opts.loop;\n      }\n      var positionSize = this.positionSize;\n      var lastPointIndex = path.length - positionSize;\n      return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);\n    }\n  }]);\n  return PathTesselator;\n}(Tesselator);\nexport { PathTesselator as default };","map":{"version":3,"sources":["../../../src/path-layer/path-tesselator.js"],"names":["Tesselator","normalizePath","START_CAP","END_CAP","INVALID","PathTesselator","opts","attributes","positions","size","padding","initialize","type","fp64","Float64Array","Float32Array","segmentTypes","Uint8ClampedArray","buffer","normalize","path","positionSize","resolution","wrapLongitude","attributeName","Array","isArray","subPath","getGeometrySize","numPoints","getPathLength","isClosed","context","geometrySize","updateGeometryAttributes","vertexStart","_updateSegmentTypes","_updatePositions","isPathClosed","fill","p","i","ptIndex","getPointOnPath","length","index","target","loop","lastPointIndex"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {Tesselator} from '@deck.gl/core';\nimport {normalizePath} from './path';\n\nconst START_CAP = 1;\nconst END_CAP = 2;\nconst INVALID = 4;\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PathTesselator extends Tesselator {\n  constructor(opts) {\n    super({\n      ...opts,\n      attributes: {\n        // Padding covers shaderAttributes for last segment in largest case fp64\n        // additional vertex + hi & low parts, 3 * 6\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {size: 1, type: Uint8ClampedArray}\n      }\n    });\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization\n    return () => null;\n  }\n\n  normalizeGeometry(path) {\n    if (this.normalize) {\n      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n    }\n    return path;\n  }\n\n  /* Getters */\n  get(attributeName) {\n    return this.attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  getGeometrySize(path) {\n    if (Array.isArray(path[0])) {\n      let size = 0;\n      for (const subPath of path) {\n        size += this.getGeometrySize(subPath);\n      }\n      return size;\n    }\n    const numPoints = this.getPathLength(path);\n    if (numPoints < 2) {\n      // invalid path\n      return 0;\n    }\n    if (this.isClosed(path)) {\n      // minimum 3 vertices\n      return numPoints < 3 ? 0 : numPoints + 2;\n    }\n    return numPoints;\n  }\n\n  updateGeometryAttributes(path, context) {\n    if (context.geometrySize === 0) {\n      return;\n    }\n    if (path && Array.isArray(path[0])) {\n      for (const subPath of path) {\n        const geometrySize = this.getGeometrySize(subPath);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPath, context);\n        context.vertexStart += geometrySize;\n      }\n    } else {\n      this._updateSegmentTypes(path, context);\n      this._updatePositions(path, context);\n    }\n  }\n\n  _updateSegmentTypes(path, context) {\n    const {segmentTypes} = this.attributes;\n    const isPathClosed = this.isClosed(path);\n    const {vertexStart, geometrySize} = context;\n\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n    if (isPathClosed) {\n      segmentTypes[vertexStart] = INVALID;\n      segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n    } else {\n      segmentTypes[vertexStart] += START_CAP;\n      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n    }\n    segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n  }\n\n  _updatePositions(path, context) {\n    const {positions} = this.attributes;\n    if (!positions) {\n      return;\n    }\n    const {vertexStart, geometrySize} = context;\n    const p = new Array(3);\n\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n      this.getPointOnPath(path, ptIndex, p);\n      positions[i * 3] = p[0];\n      positions[i * 3 + 1] = p[1];\n      positions[i * 3 + 2] = p[2];\n    }\n  }\n\n  /* Utilities */\n  // Returns the number of points in the path\n  getPathLength(path) {\n    return path.length / this.positionSize;\n  }\n\n  // Returns a point on the path at the specified index\n  getPointOnPath(path, index, target = []) {\n    const {positionSize} = this;\n    if (index * positionSize >= path.length) {\n      // loop\n      index += 1 - path.length / positionSize;\n    }\n    const i = index * positionSize;\n    target[0] = path[i];\n    target[1] = path[i + 1];\n    target[2] = (positionSize === 3 && path[i + 2]) || 0;\n    return target;\n  }\n\n  // Returns true if the first and last points are identical\n  isClosed(path) {\n    if (!this.normalize) {\n      return this.opts.loop;\n    }\n    const {positionSize} = this;\n    const lastPointIndex = path.length - positionSize;\n    return (\n      path[0] === path[lastPointIndex] &&\n      path[1] === path[lastPointIndex + 1] &&\n      (positionSize === 2 || path[2] === path[lastPointIndex + 2])\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}