{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LegendRow = exports[\"default\"] = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _taggedTemplateLiteral2 = _interopRequireDefault(require(\"@babel/runtime/helpers/taggedTemplateLiteral\"));\nvar _react = _interopRequireWildcard(require(\"react\"));\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _styledComponents = _interopRequireDefault(require(\"styled-components\"));\nvar _reselect = require(\"reselect\");\nvar _d3Format = require(\"d3-format\");\nvar _moment = _interopRequireDefault(require(\"moment\"));\nvar _defaultSettings = require(\"../../constants/default-settings\");\nvar _filterUtils = require(\"../../utils/filter-utils\");\nvar _utils = require(\"../../utils/utils\");\nvar _templateObject;\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar ROW_H = 10;\nvar GAP = 4;\nvar RECT_W = 20;\nvar StyledLegend = _styledComponents[\"default\"].div(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2[\"default\"])([\"\\n  \", \";\\n\\n  max-height: 150px;\\n  overflow-y: auto;\\n\\n  svg {\\n    text {\\n      font-size: 9px;\\n      fill: \", \";\\n    }\\n  }\\n\"])), function (props) {\n  return props.theme.sidePanelScrollBar;\n}, function (props) {\n  return props.theme.textColor;\n});\nvar defaultFormat = function defaultFormat(d) {\n  return d;\n};\nvar getTimeLabelFormat = function getTimeLabelFormat(domain) {\n  var formatter = (0, _filterUtils.getTimeWidgetHintFormatter)(domain);\n  return function (val) {\n    return _moment[\"default\"].utc(val).format(formatter);\n  };\n};\nvar getNumericLabelFormat = function getNumericLabelFormat(domain) {\n  var diff = domain[1] - domain[0];\n  if (diff < 10) {\n    return (0, _d3Format.format)('.2f');\n  }\n  return (0, _d3Format.format)('.1f');\n};\nvar getQuantLabelFormat = function getQuantLabelFormat(domain, fieldType) {\n  // quant scale can only be assigned to linear Fields: real, timestamp, integer\n  return fieldType === _defaultSettings.ALL_FIELD_TYPES.timestamp ? getTimeLabelFormat(domain) : !fieldType ? defaultFormat : getNumericLabelFormat(domain);\n};\nvar getOrdinalLegends = function getOrdinalLegends(scale) {\n  var domain = scale.domain();\n  return {\n    data: domain.map(scale),\n    labels: domain\n  };\n};\nvar getQuantLegends = function getQuantLegends(scale, labelFormat) {\n  if (typeof scale.invertExtent !== 'function') {\n    // only quantile, quantize, threshold scale has invertExtent method\n    return {\n      data: [],\n      labels: []\n    };\n  }\n  var labels = scale.range().map(function (d) {\n    var invert = scale.invertExtent(d);\n    return \"\".concat(labelFormat(invert[0]), \" to \").concat(labelFormat(invert[1]));\n  });\n  return {\n    data: scale.range(),\n    labels: labels\n  };\n};\nvar ColorLegend = /*#__PURE__*/function (_Component) {\n  (0, _inherits2[\"default\"])(ColorLegend, _Component);\n  var _super = _createSuper(ColorLegend);\n  function ColorLegend() {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, ColorLegend);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"domainSelector\", function (props) {\n      return props.domain;\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"rangeSelector\", function (props) {\n      return props.range;\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"labelFormatSelector\", function (props) {\n      return props.labelFormat;\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"scaleTypeSelector\", function (props) {\n      return props.scaleType;\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"fieldTypeSelector\", function (props) {\n      return props.fieldType;\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"legendsSelector\", (0, _reselect.createSelector)(_this.domainSelector, _this.rangeSelector, _this.scaleTypeSelector, _this.labelFormatSelector, _this.fieldTypeSelector, function (domain, range, scaleType, labelFormat, fieldType) {\n      var empty = {\n        data: [],\n        labels: []\n      };\n      if (!range) {\n        return empty;\n      }\n      if ((0, _utils.isObject)(range.colorLegends)) {\n        return {\n          data: Object.keys(range.colorLegends),\n          labels: Object.values(range.colorLegends)\n        };\n      } else if (Array.isArray(range.colorMap)) {\n        return {\n          data: range.colorMap.map(function (cm) {\n            return cm[1];\n          }),\n          labels: range.colorMap.map(function (cm) {\n            return cm[0];\n          })\n        };\n      } else if (Array.isArray(range.colors)) {\n        if (!domain || !scaleType) {\n          return empty;\n        }\n        var scaleFunction = _defaultSettings.SCALE_FUNC[scaleType]; // color scale can only be quantize, quantile or ordinal\n        // @ts-ignore fix d3 scale\n\n        var scale = scaleFunction().domain(domain).range(range.colors);\n        if (scaleType === _defaultSettings.SCALE_TYPES.ordinal) {\n          return getOrdinalLegends(scale);\n        }\n        var formatLabel = labelFormat || getQuantLabelFormat(scale.domain(), fieldType);\n        return getQuantLegends(scale, formatLabel);\n      }\n      return empty;\n    }));\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(ColorLegend, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n        width = _this$props.width,\n        _this$props$displayLa = _this$props.displayLabel,\n        displayLabel = _this$props$displayLa === void 0 ? true : _this$props$displayLa;\n      var legends = this.legendsSelector(this.props);\n      var height = legends.data.length * (ROW_H + GAP);\n      return /*#__PURE__*/_react[\"default\"].createElement(StyledLegend, null, /*#__PURE__*/_react[\"default\"].createElement(\"svg\", {\n        width: width,\n        height: height\n      }, legends.data.map(function (color, idx) {\n        return /*#__PURE__*/_react[\"default\"].createElement(LegendRow, {\n          key: idx,\n          label: legends.labels[idx],\n          displayLabel: displayLabel,\n          color: color,\n          idx: idx\n        });\n      })));\n    }\n  }]);\n  return ColorLegend;\n}(_react.Component);\nexports[\"default\"] = ColorLegend;\n(0, _defineProperty2[\"default\"])(ColorLegend, \"propTypes\", {\n  width: _propTypes[\"default\"].number.isRequired,\n  scaleType: _propTypes[\"default\"].string,\n  domain: _propTypes[\"default\"].oneOfType([_propTypes[\"default\"].array, _propTypes[\"default\"].object]),\n  fieldType: _propTypes[\"default\"].string,\n  range: _propTypes[\"default\"].object,\n  labelFormat: _propTypes[\"default\"].func\n});\nvar LegendRow = function LegendRow(_ref) {\n  var _ref$label = _ref.label,\n    label = _ref$label === void 0 ? '' : _ref$label,\n    displayLabel = _ref.displayLabel,\n    color = _ref.color,\n    idx = _ref.idx;\n  return /*#__PURE__*/_react[\"default\"].createElement(\"g\", {\n    transform: \"translate(0, \".concat(idx * (ROW_H + GAP), \")\")\n  }, /*#__PURE__*/_react[\"default\"].createElement(\"rect\", {\n    width: RECT_W,\n    height: ROW_H,\n    style: {\n      fill: color\n    }\n  }), /*#__PURE__*/_react[\"default\"].createElement(\"text\", {\n    x: RECT_W + 8,\n    y: ROW_H - 1\n  }, displayLabel ? label.toString() : ''));\n};\nexports.LegendRow = LegendRow;","map":{"version":3,"sources":["../../../src/components/common/color-legend.js"],"names":["ROW_H","GAP","RECT_W","StyledLegend","styled","div","props","theme","sidePanelScrollBar","textColor","defaultFormat","d","getTimeLabelFormat","formatter","domain","moment","utc","val","format","getNumericLabelFormat","diff","getQuantLabelFormat","fieldType","ALL_FIELD_TYPES","timestamp","getOrdinalLegends","scale","data","map","labels","getQuantLegends","labelFormat","invertExtent","range","invert","ColorLegend","Component","width","PropTypes","number","isRequired","scaleType","string","oneOfType","array","object","func","domainSelector","rangeSelector","scaleTypeSelector","labelFormatSelector","fieldTypeSelector","empty","colorLegends","Object","keys","values","Array","isArray","colorMap","cm","colors","scaleFunction","SCALE_FUNC","SCALE_TYPES","ordinal","formatLabel","displayLabel","legends","legendsSelector","height","length","color","idx","LegendRow","label","fill","toString"],"mappings":";;;;;;;;;;;;;;;;AAoBA,IAAA,MAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;AACA,IAAA,UAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;AACA,IAAA,iBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AACA,IAAA,OAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;AACA,IAAA,gBAAA,GAAA,OAAA,CAAA,kCAAA,CAAA;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,KAAK,GAAG,EAAd;AACA,IAAMC,GAAG,GAAG,CAAZ;AACA,IAAMC,MAAM,GAAG,EAAf;AAEA,IAAMC,YAAY,GAAGC,iBAAAA,CAAAA,SAAAA,CAAAA,CAAOC,GAAV,CAAA,eAAA,KAAA,eAAA,GAAA,CAAA,CAAA,EAAA,uBAAA,CAAA,SAAA,CAAA,EAAA,CAAA,MAAA,EAAA,4GAAA,EAAA,iBAAA,CAAA,CAAA,CAAA,EACd,UAAA,KAAK,EAAA;EAAA,OAAIC,KAAK,CAACC,KAAND,CAAYE,kBAAhB;AAAA,CADS,EASJ,UAAA,KAAK,EAAA;EAAA,OAAIF,KAAK,CAACC,KAAND,CAAYG,SAAhB;AAAA,CATD,CAAlB;AAcA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAA,CAAC,EAAA;EAAA,OAAIC,CAAJ;AAAA,CAAvB;AAEA,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAAA,MAAM,EAAI;EACnC,IAAMC,SAAS,GAAG,CAAA,CAAA,EAAA,YAAA,CAAA,0BAAA,EAA2BC,MAA3B,CAAlB;EACA,OAAO,UAAA,GAAG,EAAA;IAAA,OAAIC,OAAAA,CAAAA,SAAAA,CAAAA,CAAOC,GAAPD,CAAWE,GAAXF,CAAAA,CAAgBG,MAAhBH,CAAuBF,SAAvBE,CAAJ;EAAA,CAAV;AACD,CAHD;AAKA,IAAMI,qBAAqB,GAAG,SAAxBA,qBAAwB,CAAA,MAAM,EAAI;EACtC,IAAMC,IAAI,GAAGN,MAAM,CAAC,CAAD,CAANA,GAAYA,MAAM,CAAC,CAAD,CAA/B;EAEA,IAAIM,IAAI,GAAG,EAAX,EAAe;IACb,OAAO,CAAA,CAAA,EAAA,SAAA,CAAA,MAAA,EAAO,KAAP,CAAP;EACD;EAED,OAAO,CAAA,CAAA,EAAA,SAAA,CAAA,MAAA,EAAO,KAAP,CAAP;AACD,CARD;AAUA,IAAMC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACP,MAAD,EAASQ,SAAT,EAAuB;EACjD;EACA,OAAOA,SAAS,KAAKC,gBAAAA,CAAAA,eAAAA,CAAgBC,SAA9BF,GACHV,kBAAkB,CAACE,MAAD,CADfQ,GAEH,CAACA,SAAD,GACAZ,aADA,GAEAS,qBAAqB,CAACL,MAAD,CAJzB;AAKD,CAPD;AASA,IAAMW,iBAAiB,GAAG,SAApBA,iBAAoB,CAAA,KAAK,EAAI;EACjC,IAAMX,MAAM,GAAGY,KAAK,CAACZ,MAANY,EAAf;EACA,OAAO;IACLC,IAAI,EAAEb,MAAM,CAACc,GAAPd,CAAWY,KAAXZ,CADD;IAELe,MAAM,EAAEf;EAFH,CAAP;AAID,CAND;AAQA,IAAMgB,eAAe,GAAG,SAAlBA,eAAkB,CAACJ,KAAD,EAAQK,WAAR,EAAwB;EAC9C,IAAI,OAAOL,KAAK,CAACM,YAAb,KAA8B,UAAlC,EAA8C;IAC5C;IACA,OAAO;MACLL,IAAI,EAAE,EADD;MAELE,MAAM,EAAE;IAFH,CAAP;EAID;EAED,IAAMA,MAAM,GAAG,KAAK,CAACI,KAAN,EAAA,CAAcL,GAAd,CAAkB,UAAA,CAAC,EAAI;IACpC,IAAMM,MAAM,GAAGR,KAAK,CAACM,YAANN,CAAmBf,CAAnBe,CAAf;IACA,OAAA,EAAA,CAAA,MAAA,CAAUK,WAAW,CAACG,MAAM,CAAC,CAAD,CAAP,CAArB,EAAA,MAAA,CAAA,CAAA,MAAA,CAAuCH,WAAW,CAACG,MAAM,CAAC,CAAD,CAAP,CAAlD,CAAA;EACD,CAHc,CAAf;EAKA,OAAO;IACLP,IAAI,EAAED,KAAK,CAACO,KAANP,EADD;IAELG,MAAM,EAANA;EAFK,CAAP;AAID,CAlBD;IAoBqBM,W;;;;;;;;;;uGAUF,UAAA,KAAK,EAAA;MAAA,OAAI7B,KAAK,CAACQ,MAAV;IAAA,C;sGACN,UAAA,KAAK,EAAA;MAAA,OAAIR,KAAK,CAAC2B,KAAV;IAAA,C;4GACC,UAAA,KAAK,EAAA;MAAA,OAAI3B,KAAK,CAACyB,WAAV;IAAA,C;0GACP,UAAA,KAAK,EAAA;MAAA,OAAIzB,KAAK,CAACmC,SAAV;IAAA,C;0GACL,UAAA,KAAK,EAAA;MAAA,OAAInC,KAAK,CAACgB,SAAV;IAAA,C;wGAEP,CAAA,CAAA,EAAA,SAAA,CAAA,cAAA,EAChB,KAAA,CAAKyB,cADW,EAEhB,KAAA,CAAKC,aAFW,EAGhB,KAAA,CAAKC,iBAHW,EAIhB,KAAA,CAAKC,mBAJW,EAKhB,KAAA,CAAKC,iBALW,EAMhB,UAACrC,MAAD,EAASmB,KAAT,EAAgBQ,SAAhB,EAA2BV,WAA3B,EAAwCT,SAAxC,EAAsD;MACpD,IAAM8B,KAAK,GAAG;QACZzB,IAAI,EAAE,EADM;QAEZE,MAAM,EAAE;MAFI,CAAd;MAIA,IAAI,CAACI,KAAL,EAAY;QACV,OAAOmB,KAAP;MACD;MACD,IAAI,CAAA,CAAA,EAAA,MAAA,CAAA,QAAA,EAASnB,KAAK,CAACoB,YAAf,CAAJ,EAAkC;QAChC,OAAO;UACL1B,IAAI,EAAE2B,MAAM,CAACC,IAAPD,CAAYrB,KAAK,CAACoB,YAAlBC,CADD;UAELzB,MAAM,EAAEyB,MAAM,CAACE,MAAPF,CAAcrB,KAAK,CAACoB,YAApBC;QAFH,CAAP;MAID,CALD,MAKO,IAAIG,KAAK,CAACC,OAAND,CAAcxB,KAAK,CAAC0B,QAApBF,CAAJ,EAAmC;QACxC,OAAO;UACL9B,IAAI,EAAE,KAAK,CAACgC,QAAN,CAAe/B,GAAf,CAAmB,UAAA,EAAE,EAAA;YAAA,OAAIgC,EAAE,CAAC,CAAD,CAAN;UAAA,CAArB,CADD;UAEL/B,MAAM,EAAE,KAAK,CAAC8B,QAAN,CAAe/B,GAAf,CAAmB,UAAA,EAAE,EAAA;YAAA,OAAIgC,EAAE,CAAC,CAAD,CAAN;UAAA,CAArB;QAFH,CAAP;MAID,CALM,MAKA,IAAIH,KAAK,CAACC,OAAND,CAAcxB,KAAK,CAAC4B,MAApBJ,CAAJ,EAAiC;QACtC,IAAI,CAAC3C,MAAD,IAAW,CAAC2B,SAAhB,EAA2B;UACzB,OAAOW,KAAP;QACD;QAED,IAAMU,aAAa,GAAGC,gBAAAA,CAAAA,UAAAA,CAAWtB,SAAXsB,CAAtB,CALsC,CAMtC;QACA;;QACA,IAAMrC,KAAK,GAAGoC,aAAa,EAAA,CACxBhD,MADWgD,CACJhD,MADIgD,CAAAA,CAEX7B,KAFW6B,CAEL7B,KAAK,CAAC4B,MAFDC,CAAd;QAIA,IAAIrB,SAAS,KAAKuB,gBAAAA,CAAAA,WAAAA,CAAYC,OAA9B,EAAuC;UACrC,OAAOxC,iBAAiB,CAACC,KAAD,CAAxB;QACD;QAED,IAAMwC,WAAW,GAAGnC,WAAW,IAAIV,mBAAmB,CAACK,KAAK,CAACZ,MAANY,EAAD,EAAiBJ,SAAjB,CAAtD;QAEA,OAAOQ,eAAe,CAACJ,KAAD,EAAQwC,WAAR,CAAtB;MACD;MACD,OAAOd,KAAP;IACD,CA7Ce,C;;;;;WAgDlB,SAAA,MAAA,GAAS;MAAA,IAAA,WAAA,GAC8B,IAAA,CAAK9C,KADnC;QACA+B,KADA,GAAA,WAAA,CACAA,KADA;QAAA,qBAAA,GAAA,WAAA,CACO8B,YADP;QACOA,YADP,GAAA,qBAAA,KAAA,KAAA,CAAA,GACsB,IADtB,GAAA,qBAAA;MAGP,IAAMC,OAAO,GAAG,IAAA,CAAKC,eAAL,CAAqB,IAAA,CAAK/D,KAA1B,CAAhB;MACA,IAAMgE,MAAM,GAAGF,OAAO,CAACzC,IAARyC,CAAaG,MAAbH,IAAuBpE,KAAK,GAAGC,GAA/BmE,CAAf;MAEA,OAAA,aACE,MAAA,CAAA,SAAA,CAAA,CAAA,aAAA,CAAC,YAAD,EAAA,IAAA,EAAA,aACE,MAAA,CAAA,SAAA,CAAA,CAAA,aAAA,CAAA,KAAA,EAAA;QAAK,KAAK,EAAE/B,KAAZ;QAAmB,MAAM,EAAEiC;MAA3B,CAAA,EACG,OAAO,CAAC3C,IAAR,CAAaC,GAAb,CAAiB,UAAC4C,KAAD,EAAQC,GAAR,EAAA;QAAA,OAAA,aAChB,MAAA,CAAA,SAAA,CAAA,CAAA,aAAA,CAAC,SAAD,EAAA;UACE,GAAG,EAAEA,GADP;UAEE,KAAK,EAAEL,OAAO,CAACvC,MAARuC,CAAeK,GAAfL,CAFT;UAGE,YAAY,EAAED,YAHhB;UAIE,KAAK,EAAEK,KAJT;UAKE,GAAG,EAAEC;QALP,CAAA,CADgB;MAAA,CAAjB,CADH,CADF,CADF;IAeD;;;EArFsCrC,MAAAA,CAAAA,S;;iCAApBD,W,eACA;EACjBE,KAAK,EAAEC,UAAAA,CAAAA,SAAAA,CAAAA,CAAUC,MAAVD,CAAiBE,UADP;EAEjBC,SAAS,EAAEH,UAAAA,CAAAA,SAAAA,CAAAA,CAAUI,MAFJ;EAGjB5B,MAAM,EAAEwB,UAAAA,CAAAA,SAAAA,CAAAA,CAAUK,SAAVL,CAAoB,CAACA,UAAAA,CAAAA,SAAAA,CAAAA,CAAUM,KAAX,EAAkBN,UAAAA,CAAAA,SAAAA,CAAAA,CAAUO,MAA5B,CAApBP,CAHS;EAIjBhB,SAAS,EAAEgB,UAAAA,CAAAA,SAAAA,CAAAA,CAAUI,MAJJ;EAKjBT,KAAK,EAAEK,UAAAA,CAAAA,SAAAA,CAAAA,CAAUO,MALA;EAMjBd,WAAW,EAAEO,UAAAA,CAAAA,SAAAA,CAAAA,CAAUQ;AANN,C;AAuFd,IAAM4B,SAAS,GAAG,SAAZA,SAAY,CAAA,IAAA,EAAA;EAAA,IAAA,UAAA,GAAA,IAAA,CAAEC,KAAF;IAAEA,KAAF,GAAA,UAAA,KAAA,KAAA,CAAA,GAAU,EAAV,GAAA,UAAA;IAAcR,YAAd,GAAA,IAAA,CAAcA,YAAd;IAA4BK,KAA5B,GAAA,IAAA,CAA4BA,KAA5B;IAAmCC,GAAnC,GAAA,IAAA,CAAmCA,GAAnC;EAAA,OAAA,aACvB,MAAA,CAAA,SAAA,CAAA,CAAA,aAAA,CAAA,GAAA,EAAA;IAAG,SAAS,EAAA,eAAA,CAAA,MAAA,CAAkBA,GAAG,IAAIzE,KAAK,GAAGC,GAAZ,CAArB,EAAA,GAAA;EAAZ,CAAA,EAAA,aACE,MAAA,CAAA,SAAA,CAAA,CAAA,aAAA,CAAA,MAAA,EAAA;IAAM,KAAK,EAAEC,MAAb;IAAqB,MAAM,EAAEF,KAA7B;IAAoC,KAAK,EAAE;MAAC4E,IAAI,EAAEJ;IAAP;EAA3C,CAAA,CADF,EAAA,aAEE,MAAA,CAAA,SAAA,CAAA,CAAA,aAAA,CAAA,MAAA,EAAA;IAAM,CAAC,EAAEtE,MAAM,GAAG,CAAlB;IAAqB,CAAC,EAAEF,KAAK,GAAG;EAAhC,CAAA,EACGmE,YAAY,GAAGQ,KAAK,CAACE,QAANF,EAAH,GAAsB,EADrC,CAFF,CADuB;AAAA,CAAlB","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport React, {Component} from 'react';\nimport PropTypes from 'prop-types';\nimport styled from 'styled-components';\nimport {createSelector} from 'reselect';\nimport {format} from 'd3-format';\nimport moment from 'moment';\nimport {SCALE_TYPES, SCALE_FUNC, ALL_FIELD_TYPES} from 'constants/default-settings';\nimport {getTimeWidgetHintFormatter} from 'utils/filter-utils';\nimport {isObject} from 'utils/utils';\n\nconst ROW_H = 10;\nconst GAP = 4;\nconst RECT_W = 20;\n\nconst StyledLegend = styled.div`\n  ${props => props.theme.sidePanelScrollBar};\n\n  max-height: 150px;\n  overflow-y: auto;\n\n  svg {\n    text {\n      font-size: 9px;\n      fill: ${props => props.theme.textColor};\n    }\n  }\n`;\n\nconst defaultFormat = d => d;\n\nconst getTimeLabelFormat = domain => {\n  const formatter = getTimeWidgetHintFormatter(domain);\n  return val => moment.utc(val).format(formatter);\n};\n\nconst getNumericLabelFormat = domain => {\n  const diff = domain[1] - domain[0];\n\n  if (diff < 10) {\n    return format('.2f');\n  }\n\n  return format('.1f');\n};\n\nconst getQuantLabelFormat = (domain, fieldType) => {\n  // quant scale can only be assigned to linear Fields: real, timestamp, integer\n  return fieldType === ALL_FIELD_TYPES.timestamp\n    ? getTimeLabelFormat(domain)\n    : !fieldType\n    ? defaultFormat\n    : getNumericLabelFormat(domain);\n};\n\nconst getOrdinalLegends = scale => {\n  const domain = scale.domain();\n  return {\n    data: domain.map(scale),\n    labels: domain\n  };\n};\n\nconst getQuantLegends = (scale, labelFormat) => {\n  if (typeof scale.invertExtent !== 'function') {\n    // only quantile, quantize, threshold scale has invertExtent method\n    return {\n      data: [],\n      labels: []\n    };\n  }\n\n  const labels = scale.range().map(d => {\n    const invert = scale.invertExtent(d);\n    return `${labelFormat(invert[0])} to ${labelFormat(invert[1])}`;\n  });\n\n  return {\n    data: scale.range(),\n    labels\n  };\n};\n\nexport default class ColorLegend extends Component {\n  static propTypes = {\n    width: PropTypes.number.isRequired,\n    scaleType: PropTypes.string,\n    domain: PropTypes.oneOfType([PropTypes.array, PropTypes.object]),\n    fieldType: PropTypes.string,\n    range: PropTypes.object,\n    labelFormat: PropTypes.func\n  };\n\n  domainSelector = props => props.domain;\n  rangeSelector = props => props.range;\n  labelFormatSelector = props => props.labelFormat;\n  scaleTypeSelector = props => props.scaleType;\n  fieldTypeSelector = props => props.fieldType;\n\n  legendsSelector = createSelector(\n    this.domainSelector,\n    this.rangeSelector,\n    this.scaleTypeSelector,\n    this.labelFormatSelector,\n    this.fieldTypeSelector,\n    (domain, range, scaleType, labelFormat, fieldType) => {\n      const empty = {\n        data: [],\n        labels: []\n      };\n      if (!range) {\n        return empty;\n      }\n      if (isObject(range.colorLegends)) {\n        return {\n          data: Object.keys(range.colorLegends),\n          labels: Object.values(range.colorLegends)\n        };\n      } else if (Array.isArray(range.colorMap)) {\n        return {\n          data: range.colorMap.map(cm => cm[1]),\n          labels: range.colorMap.map(cm => cm[0])\n        };\n      } else if (Array.isArray(range.colors)) {\n        if (!domain || !scaleType) {\n          return empty;\n        }\n\n        const scaleFunction = SCALE_FUNC[scaleType];\n        // color scale can only be quantize, quantile or ordinal\n        // @ts-ignore fix d3 scale\n        const scale = scaleFunction()\n          .domain(domain)\n          .range(range.colors);\n\n        if (scaleType === SCALE_TYPES.ordinal) {\n          return getOrdinalLegends(scale);\n        }\n\n        const formatLabel = labelFormat || getQuantLabelFormat(scale.domain(), fieldType);\n\n        return getQuantLegends(scale, formatLabel);\n      }\n      return empty;\n    }\n  );\n\n  render() {\n    const {width, displayLabel = true} = this.props;\n\n    const legends = this.legendsSelector(this.props);\n    const height = legends.data.length * (ROW_H + GAP);\n\n    return (\n      <StyledLegend>\n        <svg width={width} height={height}>\n          {legends.data.map((color, idx) => (\n            <LegendRow\n              key={idx}\n              label={legends.labels[idx]}\n              displayLabel={displayLabel}\n              color={color}\n              idx={idx}\n            />\n          ))}\n        </svg>\n      </StyledLegend>\n    );\n  }\n}\n\nexport const LegendRow = ({label = '', displayLabel, color, idx}) => (\n  <g transform={`translate(0, ${idx * (ROW_H + GAP)})`}>\n    <rect width={RECT_W} height={ROW_H} style={{fill: color}} />\n    <text x={RECT_W + 8} y={ROW_H - 1}>\n      {displayLabel ? label.toString() : ''}\n    </text>\n  </g>\n);\n"]},"metadata":{},"sourceType":"script"}