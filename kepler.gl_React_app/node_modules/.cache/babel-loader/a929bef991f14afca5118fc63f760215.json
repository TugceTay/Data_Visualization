{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Vector3, Matrix3, Matrix4, Quaternion } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { GL } from '@loaders.gl/math';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport { parse3DTileHeaderSync } from './helpers/parse-3d-tile-header';\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from './helpers/parse-3d-tile-tables';\nimport { parse3DTileGLTFViewSync, extractGLTF } from './helpers/parse-3d-tile-gltf-view';\nexport function parseInstancedModel3DTile(_x, _x2, _x3, _x4, _x5) {\n  return _parseInstancedModel3DTile.apply(this, arguments);\n}\nfunction _parseInstancedModel3DTile() {\n  _parseInstancedModel3DTile = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tile, arrayBuffer, byteOffset, options, context) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n            _context.next = 3;\n            return extractGLTF(tile, tile.gltfFormat, options, context);\n          case 3:\n            return _context.abrupt(\"return\", byteOffset);\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseInstancedModel3DTile.apply(this, arguments);\n}\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  if (tile.version !== 1) {\n    throw new Error(\"Instanced 3D Model version \".concat(tile.version, \" is not supported\"));\n  }\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  var view = new DataView(arrayBuffer);\n  tile.gltfFormat = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n  if (tile.featureTableJsonByteLength === 0) {\n    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n  }\n  var featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  var instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n  featureTable.featuresLength = instancesLength;\n  if (!Number.isFinite(instancesLength)) {\n    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n  }\n  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n  var batchTable = new Tile3DBatchTable(tile.batchTableJson, tile.batchTableBinary, instancesLength);\n  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n  return byteOffset;\n}\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n  var collectionOptions = {\n    instances: new Array(instancesLength),\n    batchTable: tile._batchTable,\n    cull: false,\n    url: undefined,\n    gltf: undefined,\n    basePath: undefined,\n    incrementallyLoadTextures: false,\n    forwardAxis: [1, 0, 0]\n  };\n  var instances = collectionOptions.instances;\n  var instancePosition = new Vector3();\n  var instanceNormalRight = new Vector3();\n  var instanceNormalUp = new Vector3();\n  var instanceNormalForward = new Vector3();\n  var instanceRotation = new Matrix3();\n  var instanceQuaternion = new Quaternion();\n  var instanceScale = new Vector3();\n  var instanceTranslationRotationScale = {};\n  var instanceTransform = new Matrix4();\n  var scratch1 = [];\n  var scratch2 = [];\n  var scratchVector1 = new Vector3();\n  var scratchVector2 = new Vector3();\n  for (var i = 0; i < instancesLength; i++) {\n    var position = void 0;\n    if (featureTable.hasProperty('POSITION')) {\n      position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, instancePosition);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      position = featureTable.getProperty('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3, i, instancePosition);\n      var quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3, scratchVector1);\n      if (!quantizedVolumeOffset) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n      var quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3, scratchVector2);\n      if (!quantizedVolumeScale) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n      var MAX_UNSIGNED_SHORT = 65535.0;\n      for (var j = 0; j < 3; j++) {\n        position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n    if (!position) {\n      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n    }\n    instancePosition.copy(position);\n    instanceTranslationRotationScale.translation = instancePosition;\n    tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n    var hasCustomOrientation = false;\n    if (tile.normalUp) {\n      if (!tile.normalRight) {\n        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n      }\n      tile.hasCustomOrientation = true;\n    } else {\n      tile.octNormalUp = featureTable.getProperty('NORMAL_UP_OCT32P', GL.UNSIGNED_SHORT, 2, scratch1);\n      tile.octNormalRight = featureTable.getProperty('NORMAL_RIGHT_OCT32P', GL.UNSIGNED_SHORT, 2, scratch2);\n      if (tile.octNormalUp) {\n        if (!tile.octNormalRight) {\n          throw new Error('i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P');\n        }\n        throw new Error('i3dm: oct-encoded orientation not implemented');\n      } else if (tile.eastNorthUp) {\n        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n        instanceTransform.getRotationMatrix3(instanceRotation);\n      } else {\n        instanceRotation.identity();\n      }\n    }\n    if (hasCustomOrientation) {\n      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();\n      instanceRotation.setColumn(0, instanceNormalRight);\n      instanceRotation.setColumn(1, instanceNormalUp);\n      instanceRotation.setColumn(2, instanceNormalForward);\n    }\n    instanceQuaternion.fromMatrix3(instanceRotation);\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n    instanceScale.set(1.0, 1.0, 1.0);\n    var scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i);\n    if (Number.isFinite(scale)) {\n      instanceScale.multiplyByScalar(scale);\n    }\n    var nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n    if (nonUniformScale) {\n      instanceScale.scale(nonUniformScale);\n    }\n    instanceTranslationRotationScale.scale = instanceScale;\n    var batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i);\n    if (batchId === undefined) {\n      batchId = i;\n    }\n    var rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n    instanceTransform.identity();\n    instanceTransform.translate(instanceTranslationRotationScale.translation);\n    instanceTransform.multiplyRight(rotationMatrix);\n    instanceTransform.scale(instanceTranslationRotationScale.scale);\n    var modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix: modelMatrix,\n      batchId: batchId\n    };\n  }\n  tile.instances = instances;\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-3d-tile-instanced-model.js"],"names":["Vector3","Matrix3","Matrix4","Quaternion","Ellipsoid","GL","Tile3DFeatureTable","Tile3DBatchTable","parse3DTileHeaderSync","parse3DTileTablesHeaderSync","parse3DTileTablesSync","parse3DTileGLTFViewSync","extractGLTF","parseInstancedModel3DTile","tile","arrayBuffer","byteOffset","options","context","parseInstancedModel","gltfFormat","version","Error","view","DataView","getUint32","featureTableJsonByteLength","featureTable","featureTableJson","featureTableBinary","instancesLength","getGlobalProperty","featuresLength","Number","isFinite","eastNorthUp","rtcCenter","FLOAT","batchTable","batchTableJson","batchTableBinary","extractInstancedAttributes","collectionOptions","instances","Array","_batchTable","cull","url","undefined","gltf","basePath","incrementallyLoadTextures","forwardAxis","instancePosition","instanceNormalRight","instanceNormalUp","instanceNormalForward","instanceRotation","instanceQuaternion","instanceScale","instanceTranslationRotationScale","instanceTransform","scratch1","scratch2","scratchVector1","scratchVector2","i","position","hasProperty","getProperty","UNSIGNED_SHORT","quantizedVolumeOffset","quantizedVolumeScale","MAX_UNSIGNED_SHORT","j","copy","translation","normalUp","normalRight","hasCustomOrientation","octNormalUp","octNormalRight","WGS84","eastNorthUpToFixedFrame","getRotationMatrix3","identity","cross","normalize","setColumn","fromMatrix3","rotation","set","scale","multiplyByScalar","nonUniformScale","batchId","rotationMatrix","fromQuaternion","translate","multiplyRight","modelMatrix","clone"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3, Matrix4, Quaternion} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {GL} from '@loaders.gl/math'; // 'math.gl/geometry';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\n\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {parse3DTileGLTFViewSync, extractGLTF} from './helpers/parse-3d-tile-gltf-view';\n\nexport async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n  await extractGLTF(tile, tile.gltfFormat, options, context);\n  return byteOffset;\n}\n\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  if (tile.version !== 1) {\n    throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);\n  }\n\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n\n  const view = new DataView(arrayBuffer);\n\n  tile.gltfFormat = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n\n  // PARSE FEATURE TABLE\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n\n  // TODO - Is the feature table sometimes optional or can check be moved into table header parser?\n  if (tile.featureTableJsonByteLength === 0) {\n    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n  }\n\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n  featureTable.featuresLength = instancesLength;\n\n  if (!Number.isFinite(instancesLength)) {\n    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n  }\n\n  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  const batchTable = new Tile3DBatchTable(\n    tile.batchTableJson,\n    tile.batchTableBinary,\n    instancesLength\n  );\n\n  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n\n  return byteOffset;\n}\n\n// eslint-disable-next-line max-statements, complexity\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n  // Create model instance collection\n  const collectionOptions = {\n    instances: new Array(instancesLength),\n    batchTable: tile._batchTable,\n    cull: false, // Already culled by 3D Tiles\n    url: undefined,\n    // requestType: RequestType.TILES3D,\n    gltf: undefined,\n    basePath: undefined,\n    incrementallyLoadTextures: false,\n    // TODO - tileset is not available at this stage, tile is parsed independently\n    // upAxis: (tileset && tileset._gltfUpAxis) || [0, 1, 0],\n    forwardAxis: [1, 0, 0]\n  };\n\n  const instances = collectionOptions.instances;\n  const instancePosition = new Vector3();\n  const instanceNormalRight = new Vector3();\n  const instanceNormalUp = new Vector3();\n  const instanceNormalForward = new Vector3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceScale = new Vector3();\n  const instanceTranslationRotationScale = {};\n  const instanceTransform = new Matrix4();\n  const scratch1 = [];\n  const scratch2 = [];\n  const scratchVector1 = new Vector3();\n  const scratchVector2 = new Vector3();\n\n  for (let i = 0; i < instancesLength; i++) {\n    let position;\n\n    // Get the instance position\n    if (featureTable.hasProperty('POSITION')) {\n      position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, instancePosition);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      position = featureTable.getProperty(\n        'POSITION_QUANTIZED',\n        GL.UNSIGNED_SHORT,\n        3,\n        i,\n        instancePosition\n      );\n\n      const quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3,\n        scratchVector1\n      );\n      if (!quantizedVolumeOffset) {\n        throw new Error(\n          'i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.'\n        );\n      }\n\n      const quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3,\n        scratchVector2\n      );\n      if (!quantizedVolumeScale) {\n        throw new Error(\n          'i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.'\n        );\n      }\n\n      const MAX_UNSIGNED_SHORT = 65535.0;\n      for (let j = 0; j < 3; j++) {\n        position[j] =\n          (position[j] / MAX_UNSIGNED_SHORT) * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n\n    if (!position) {\n      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n    }\n\n    instancePosition.copy(position);\n    instanceTranslationRotationScale.translation = instancePosition;\n\n    // Get the instance rotation\n    tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n\n    const hasCustomOrientation = false;\n    if (tile.normalUp) {\n      if (!tile.normalRight) {\n        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n      }\n      // Vector3.unpack(normalUp, 0, instanceNormalUp);\n      // Vector3.unpack(normalRight, 0, instanceNormalRight);\n      tile.hasCustomOrientation = true;\n    } else {\n      tile.octNormalUp = featureTable.getProperty(\n        'NORMAL_UP_OCT32P',\n        GL.UNSIGNED_SHORT,\n        2,\n        scratch1\n      );\n      tile.octNormalRight = featureTable.getProperty(\n        'NORMAL_RIGHT_OCT32P',\n        GL.UNSIGNED_SHORT,\n        2,\n        scratch2\n      );\n\n      if (tile.octNormalUp) {\n        if (!tile.octNormalRight) {\n          throw new Error(\n            'i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P'\n          );\n        }\n\n        throw new Error('i3dm: oct-encoded orientation not implemented');\n        /*\n        AttributeCompression.octDecodeInRange(octNormalUp[0], octNormalUp[1], 65535, instanceNormalUp);\n        AttributeCompression.octDecodeInRange(octNormalRight[0], octNormalRight[1], 65535, instanceNormalRight);\n        hasCustomOrientation = true;\n        */\n      } else if (tile.eastNorthUp) {\n        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n        instanceTransform.getRotationMatrix3(instanceRotation);\n      } else {\n        instanceRotation.identity();\n      }\n    }\n\n    if (hasCustomOrientation) {\n      instanceNormalForward\n        .copy(instanceNormalRight)\n        .cross(instanceNormalUp)\n        .normalize();\n      instanceRotation.setColumn(0, instanceNormalRight);\n      instanceRotation.setColumn(1, instanceNormalUp);\n      instanceRotation.setColumn(2, instanceNormalForward);\n    }\n\n    instanceQuaternion.fromMatrix3(instanceRotation);\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n\n    // Get the instance scale\n    instanceScale.set(1.0, 1.0, 1.0);\n    const scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i);\n    if (Number.isFinite(scale)) {\n      instanceScale.multiplyByScalar(scale);\n    }\n    const nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n    if (nonUniformScale) {\n      instanceScale.scale(nonUniformScale);\n    }\n\n    instanceTranslationRotationScale.scale = instanceScale;\n\n    // Get the batchId\n    let batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i);\n    if (batchId === undefined) {\n      // If BATCH_ID semantic is undefined, batchId is just the instance number\n      batchId = i;\n    }\n\n    const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n\n    // Create the model matrix and the instance\n    instanceTransform.identity();\n    instanceTransform.translate(instanceTranslationRotationScale.translation);\n    instanceTransform.multiplyRight(rotationMatrix);\n    instanceTransform.scale(instanceTranslationRotationScale.scale);\n\n    const modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix,\n      batchId\n    };\n  }\n\n  tile.instances = instances;\n}\n"]},"metadata":{},"sourceType":"module"}