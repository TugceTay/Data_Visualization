{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { MAGIC_ARRAY } from '../constants';\nimport { encode3DTileHeader, encode3DTileByteLength } from './helpers/encode-3d-tile-header';\nimport { padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView } from '@loaders.gl/loader-utils';\nvar DEFAULT_FEATURE_TABLE_JSON = {\n  POINTS_LENGTH: 1,\n  POSITIONS: {\n    byteOffset: 0\n  }\n};\nexport function encodePointCloud3DTile(tile, dataView, byteOffset, options) {\n  var _tile = tile,\n    _tile$featureTableJso = _tile.featureTableJson,\n    featureTableJson = _tile$featureTableJso === void 0 ? DEFAULT_FEATURE_TABLE_JSON : _tile$featureTableJso;\n  var featureTableJsonString = JSON.stringify(featureTableJson);\n  featureTableJsonString = padStringToByteAlignment(featureTableJsonString, 4);\n  var _tile2 = tile,\n    _tile2$featureTableJs = _tile2.featureTableJsonByteLength,\n    featureTableJsonByteLength = _tile2$featureTableJs === void 0 ? featureTableJsonString.length : _tile2$featureTableJs;\n  var featureTableBinary = new ArrayBuffer(12);\n  var featureTableBinaryByteLength = featureTableBinary.byteLength;\n  tile = _objectSpread({\n    magic: MAGIC_ARRAY.POINT_CLOUD\n  }, tile);\n  var byteOffsetStart = byteOffset;\n  byteOffset += encode3DTileHeader(tile, dataView, 0);\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, featureTableJsonByteLength, true);\n    dataView.setUint32(byteOffset + 4, featureTableBinaryByteLength, true);\n    dataView.setUint32(byteOffset + 8, 0, true);\n    dataView.setUint32(byteOffset + 12, 0, true);\n  }\n  byteOffset += 16;\n  byteOffset += copyStringToDataView(dataView, byteOffset, featureTableJsonString, featureTableJsonByteLength);\n  byteOffset += copyBinaryToDataView(dataView, byteOffset, featureTableBinary, featureTableBinaryByteLength);\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n  return byteOffset;\n}","map":{"version":3,"sources":["../../../../src/lib/encoders/encode-3d-tile-point-cloud.js"],"names":["MAGIC_ARRAY","encode3DTileHeader","encode3DTileByteLength","padStringToByteAlignment","copyStringToDataView","copyBinaryToDataView","DEFAULT_FEATURE_TABLE_JSON","POINTS_LENGTH","POSITIONS","byteOffset","encodePointCloud3DTile","tile","dataView","options","featureTableJson","featureTableJsonString","JSON","stringify","featureTableJsonByteLength","length","featureTableBinary","ArrayBuffer","featureTableBinaryByteLength","byteLength","magic","POINT_CLOUD","byteOffsetStart","setUint32"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,SAAQA,WAAR,QAA0B,cAA1B;AACA,SAAQC,kBAAR,EAA4BC,sBAA5B,QAAyD,iCAAzD;AACA,SACEC,wBADF,EAEEC,oBAFF,EAGEC,oBAHF,QAIO,0BAJP;AAMA,IAAMC,0BAA0B,GAAG;EACjCC,aAAa,EAAE,CADkB;EAEjCC,SAAS,EAAE;IACTC,UAAU,EAAE;EADH;AAFsB,CAAnC;AAOA,OAAO,SAASC,sBAAT,CAAgCC,IAAhC,EAAsCC,QAAtC,EAAgDH,UAAhD,EAA4DI,OAA5D,EAAqE;EAAA,IAAA,KAAA,GAClBF,IADkB;IAAA,qBAAA,GAAA,KAAA,CACnEG,gBADmE;IACnEA,gBADmE,GAAA,qBAAA,KAAA,KAAA,CAAA,GAChDR,0BADgD,GAAA,qBAAA;EAG1E,IAAIS,sBAAsB,GAAGC,IAAI,CAACC,SAALD,CAAeF,gBAAfE,CAA7B;EACAD,sBAAsB,GAAGZ,wBAAwB,CAACY,sBAAD,EAAyB,CAAzB,CAAjDA;EAJ0E,IAAA,MAAA,GAMLJ,IANK;IAAA,qBAAA,GAAA,MAAA,CAMnEO,0BANmE;IAMnEA,0BANmE,GAAA,qBAAA,KAAA,KAAA,CAAA,GAMtCH,sBAAsB,CAACI,MANe,GAAA,qBAAA;EAQ1E,IAAMC,kBAAkB,GAAG,IAAIC,WAAJ,CAAgB,EAAhB,CAA3B;EACA,IAAMC,4BAA4B,GAAGF,kBAAkB,CAACG,UAAxD;EAGAZ,IAAI,GAAA,aAAA,CAAA;IAAIa,KAAK,EAAExB,WAAW,CAACyB;EAAvB,CAAA,EAAuCd,IAAvC,CAAJA;EAEA,IAAMe,eAAe,GAAGjB,UAAxB;EAEAA,UAAU,IAAIR,kBAAkB,CAACU,IAAD,EAAOC,QAAP,EAAiB,CAAjB,CAAhCH;EAEA,IAAIG,QAAJ,EAAc;IACZA,QAAQ,CAACe,SAATf,CAAmBH,UAAU,GAAG,CAAhCG,EAAmCM,0BAAnCN,EAA+D,IAA/DA,CAAAA;IACAA,QAAQ,CAACe,SAATf,CAAmBH,UAAU,GAAG,CAAhCG,EAAmCU,4BAAnCV,EAAiE,IAAjEA,CAAAA;IACAA,QAAQ,CAACe,SAATf,CAAmBH,UAAU,GAAG,CAAhCG,EAAmC,CAAnCA,EAAsC,IAAtCA,CAAAA;IACAA,QAAQ,CAACe,SAATf,CAAmBH,UAAU,GAAG,EAAhCG,EAAoC,CAApCA,EAAuC,IAAvCA,CAAAA;EACD;EACDH,UAAU,IAAI,EAAdA;EAEAA,UAAU,IAAIL,oBAAoB,CAChCQ,QADgC,EAEhCH,UAFgC,EAGhCM,sBAHgC,EAIhCG,0BAJgC,CAAlCT;EAMAA,UAAU,IAAIJ,oBAAoB,CAChCO,QADgC,EAEhCH,UAFgC,EAGhCW,kBAHgC,EAIhCE,4BAJgC,CAAlCb;EAQAP,sBAAsB,CAACU,QAAD,EAAWc,eAAX,EAA4BjB,UAAU,GAAGiB,eAAzC,CAAtBxB;EAEA,OAAOO,UAAP;AACD","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {MAGIC_ARRAY} from '../constants';\nimport {encode3DTileHeader, encode3DTileByteLength} from './helpers/encode-3d-tile-header';\nimport {\n  padStringToByteAlignment,\n  copyStringToDataView,\n  copyBinaryToDataView\n} from '@loaders.gl/loader-utils';\n\nconst DEFAULT_FEATURE_TABLE_JSON = {\n  POINTS_LENGTH: 1,\n  POSITIONS: {\n    byteOffset: 0\n  }\n};\n\nexport function encodePointCloud3DTile(tile, dataView, byteOffset, options) {\n  const {featureTableJson = DEFAULT_FEATURE_TABLE_JSON} = tile;\n\n  let featureTableJsonString = JSON.stringify(featureTableJson);\n  featureTableJsonString = padStringToByteAlignment(featureTableJsonString, 4);\n\n  const {featureTableJsonByteLength = featureTableJsonString.length} = tile;\n\n  const featureTableBinary = new ArrayBuffer(12); // Enough space to hold 3 floats\n  const featureTableBinaryByteLength = featureTableBinary.byteLength;\n\n  // Add default magic for this tile type\n  tile = {magic: MAGIC_ARRAY.POINT_CLOUD, ...tile};\n\n  const byteOffsetStart = byteOffset;\n\n  byteOffset += encode3DTileHeader(tile, dataView, 0);\n\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, featureTableJsonByteLength, true); // featureTableJsonByteLength\n    dataView.setUint32(byteOffset + 4, featureTableBinaryByteLength, true); // featureTableBinaryByteLength\n    dataView.setUint32(byteOffset + 8, 0, true); // batchTableJsonByteLength\n    dataView.setUint32(byteOffset + 12, 0, true); // batchTableBinaryByteLength\n  }\n  byteOffset += 16;\n\n  byteOffset += copyStringToDataView(\n    dataView,\n    byteOffset,\n    featureTableJsonString,\n    featureTableJsonByteLength\n  );\n  byteOffset += copyBinaryToDataView(\n    dataView,\n    byteOffset,\n    featureTableBinary,\n    featureTableBinaryByteLength\n  );\n\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n\n  return byteOffset;\n}\n"]},"metadata":{},"sourceType":"module"}