{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/core';\nvar Tesselator = function () {\n  function Tesselator() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Tesselator);\n    var _opts$attributes = opts.attributes,\n      attributes = _opts$attributes === void 0 ? {} : _opts$attributes;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n    Object.seal(this);\n  }\n  _createClass(Tesselator, [{\n    key: \"updateGeometry\",\n    value: function updateGeometry(opts) {\n      Object.assign(this.opts, opts);\n      var _this$opts = this.opts,\n        data = _this$opts.data,\n        _this$opts$buffers = _this$opts.buffers,\n        buffers = _this$opts$buffers === void 0 ? {} : _this$opts$buffers,\n        getGeometry = _this$opts.getGeometry,\n        geometryBuffer = _this$opts.geometryBuffer,\n        positionFormat = _this$opts.positionFormat,\n        dataChanged = _this$opts.dataChanged,\n        _this$opts$normalize = _this$opts.normalize,\n        normalize = _this$opts$normalize === void 0 ? true : _this$opts$normalize;\n      this.data = data;\n      this.getGeometry = getGeometry;\n      this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n      this.buffers = buffers;\n      this.normalize = normalize;\n      if (geometryBuffer) {\n        assert(data.startIndices, 'binary data missing startIndices');\n        this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n        if (!normalize) {\n          buffers.positions = geometryBuffer;\n        }\n      }\n      this.geometryBuffer = buffers.positions;\n      if (Array.isArray(dataChanged)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n          for (var _iterator = dataChanged[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var dataRange = _step.value;\n            this._rebuildGeometry(dataRange);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        this._rebuildGeometry();\n      }\n    }\n  }, {\n    key: \"updatePartialGeometry\",\n    value: function updatePartialGeometry(_ref) {\n      var startRow = _ref.startRow,\n        endRow = _ref.endRow;\n      this._rebuildGeometry({\n        startRow: startRow,\n        endRow: endRow\n      });\n    }\n  }, {\n    key: \"normalizeGeometry\",\n    value: function normalizeGeometry(geometry) {\n      return geometry;\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(geometry, startIndex, size) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(geometry) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(geometryBuffer) {\n      var value = geometryBuffer.value || geometryBuffer;\n      assert(ArrayBuffer.isView(value), 'cannot read geometries');\n      return getAccessorFromBuffer(value, {\n        size: this.positionSize,\n        offset: geometryBuffer.offset,\n        stride: geometryBuffer.stride,\n        startIndices: this.data.startIndices\n      });\n    }\n  }, {\n    key: \"_allocate\",\n    value: function _allocate(instanceCount, copy) {\n      var attributes = this.attributes,\n        buffers = this.buffers,\n        _attributeDefs = this._attributeDefs,\n        typedArrayManager = this.typedArrayManager;\n      for (var name in _attributeDefs) {\n        if (name in buffers) {\n          typedArrayManager.release(attributes[name]);\n          attributes[name] = null;\n        } else {\n          var def = _attributeDefs[name];\n          def.copy = copy;\n          attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n        }\n      }\n    }\n  }, {\n    key: \"_forEachGeometry\",\n    value: function _forEachGeometry(visitor, startRow, endRow) {\n      var data = this.data,\n        getGeometry = this.getGeometry;\n      var _createIterable = createIterable(data, startRow, endRow),\n        iterable = _createIterable.iterable,\n        objectInfo = _createIterable.objectInfo;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n          objectInfo.index++;\n          var geometry = getGeometry(object, objectInfo);\n          visitor(geometry, objectInfo.index);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_rebuildGeometry\",\n    value: function _rebuildGeometry(dataRange) {\n      var _this = this;\n      if (!this.data || !this.getGeometry) {\n        return;\n      }\n      var indexStarts = this.indexStarts,\n        vertexStarts = this.vertexStarts,\n        instanceCount = this.instanceCount;\n      var data = this.data,\n        geometryBuffer = this.geometryBuffer;\n      var _ref2 = dataRange || {},\n        _ref2$startRow = _ref2.startRow,\n        startRow = _ref2$startRow === void 0 ? 0 : _ref2$startRow,\n        _ref2$endRow = _ref2.endRow,\n        endRow = _ref2$endRow === void 0 ? Infinity : _ref2$endRow;\n      var normalizedData = {};\n      if (!dataRange) {\n        indexStarts = [0];\n        vertexStarts = [0];\n      }\n      if (this.normalize || !geometryBuffer) {\n        this._forEachGeometry(function (geometry, dataIndex) {\n          geometry = _this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + _this.getGeometrySize(geometry);\n        }, startRow, endRow);\n        instanceCount = vertexStarts[vertexStarts.length - 1];\n      } else if (geometryBuffer.buffer instanceof Buffer) {\n        var byteStride = geometryBuffer.stride || this.positionSize * 4;\n        vertexStarts = data.startIndices;\n        instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n      } else {\n        var bufferValue = geometryBuffer.value || geometryBuffer;\n        var elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        vertexStarts = data.startIndices;\n        instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n      }\n      this._allocate(instanceCount, Boolean(dataRange));\n      this.indexStarts = indexStarts;\n      this.vertexStarts = vertexStarts;\n      this.instanceCount = instanceCount;\n      var context = {};\n      this._forEachGeometry(function (geometry, dataIndex) {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        var vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        _this.updateGeometryAttributes(geometry, context);\n      }, startRow, endRow);\n      this.vertexCount = indexStarts[indexStarts.length - 1];\n    }\n  }]);\n  return Tesselator;\n}();\nexport { Tesselator as default };","map":{"version":3,"sources":["../../../src/utils/tesselator.js"],"names":["createIterable","getAccessorFromBuffer","defaultTypedArrayManager","assert","Buffer","Tesselator","opts","attributes","typedArrayManager","indexStarts","vertexStarts","vertexCount","instanceCount","_attributeDefs","updateGeometry","Object","seal","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","startRow","endRow","geometry","startIndex","Error","value","ArrayBuffer","isView","offset","stride","copy","name","release","def","allocate","visitor","iterable","objectInfo","object","index","Infinity","normalizedData","_forEachGeometry","dataIndex","normalizeGeometry","getGeometrySize","length","buffer","byteStride","byteLength","bufferValue","elementStride","BYTES_PER_ELEMENT","_allocate","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/core';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices, 'binary data missing startIndices');\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n  normalizeGeometry(geometry) {\n    return geometry;\n  }\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value), 'cannot read geometries');\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          geometry = this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}