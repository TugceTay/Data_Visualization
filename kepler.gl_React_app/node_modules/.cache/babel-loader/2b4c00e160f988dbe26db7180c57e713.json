{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Matrix4 } from 'math.gl';\nimport { MVTLoader } from '@loaders.gl/mvt';\nimport { load } from '@loaders.gl/core';\nimport { COORDINATE_SYSTEM } from '@deck.gl/core';\nimport TileLayer from '../tile-layer/tile-layer';\nimport { getURLFromTemplate } from '../tile-layer/utils';\nimport ClipExtension from './clip-extension';\nvar WORLD_SIZE = 512;\nvar defaultProps = {\n  uniqueIdProperty: {\n    type: 'string',\n    value: ''\n  },\n  highlightedFeatureId: null\n};\nvar MVTLayer = function (_TileLayer) {\n  _inherits(MVTLayer, _TileLayer);\n  function MVTLayer() {\n    _classCallCheck(this, MVTLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(MVTLayer).apply(this, arguments));\n  }\n  _createClass(MVTLayer, [{\n    key: \"getTileData\",\n    value: function getTileData(tile) {\n      var url = getURLFromTemplate(this.props.data, tile);\n      if (!url) {\n        return Promise.reject('Invalid URL');\n      }\n      return load(url, MVTLoader, this.getLoadOptions());\n    }\n  }, {\n    key: \"renderSubLayers\",\n    value: function renderSubLayers(props) {\n      var tile = props.tile;\n      var worldScale = Math.pow(2, tile.z);\n      var xScale = WORLD_SIZE / worldScale;\n      var yScale = -xScale;\n      var xOffset = WORLD_SIZE * tile.x / worldScale;\n      var yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n      var modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n      props.autoHighlight = false;\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [].concat(_toConsumableArray(props.extensions || []), [new ClipExtension()]);\n      return _get(_getPrototypeOf(MVTLayer.prototype), \"renderSubLayers\", this).call(this, props);\n    }\n  }, {\n    key: \"onHover\",\n    value: function onHover(info, pickingEvent) {\n      var _this$props = this.props,\n        uniqueIdProperty = _this$props.uniqueIdProperty,\n        autoHighlight = _this$props.autoHighlight;\n      if (autoHighlight) {\n        var hoveredFeatureId = this.state.hoveredFeatureId;\n        var hoveredFeature = info.object;\n        var newHoveredFeatureId;\n        if (hoveredFeature) {\n          newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n        }\n        if (hoveredFeatureId !== newHoveredFeatureId) {\n          this.setState({\n            hoveredFeatureId: newHoveredFeatureId\n          });\n        }\n      }\n      return _get(_getPrototypeOf(MVTLayer.prototype), \"onHover\", this).call(this, info, pickingEvent);\n    }\n  }, {\n    key: \"getHighlightedObjectIndex\",\n    value: function getHighlightedObjectIndex(tile) {\n      var hoveredFeatureId = this.state.hoveredFeatureId;\n      var _this$props2 = this.props,\n        uniqueIdProperty = _this$props2.uniqueIdProperty,\n        highlightedFeatureId = _this$props2.highlightedFeatureId;\n      var data = tile.data;\n      var isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isFeatureIdDefined(highlightedFeatureId);\n      if (!isFeatureIdPresent || !Array.isArray(data)) {\n        return -1;\n      }\n      var featureIdToHighlight = isFeatureIdDefined(highlightedFeatureId) ? highlightedFeatureId : hoveredFeatureId;\n      return data.findIndex(function (feature) {\n        return getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n      });\n    }\n  }]);\n  return MVTLayer;\n}(TileLayer);\nexport { MVTLayer as default };\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n  if ('id' in feature) {\n    return feature.id;\n  }\n  return -1;\n}\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/mvt-layer/mvt-layer.js"],"names":["Matrix4","MVTLoader","load","COORDINATE_SYSTEM","TileLayer","getURLFromTemplate","ClipExtension","WORLD_SIZE","defaultProps","uniqueIdProperty","type","value","highlightedFeatureId","MVTLayer","tile","url","props","data","Promise","reject","getLoadOptions","worldScale","Math","pow","z","xScale","yScale","xOffset","x","yOffset","y","modelMatrix","scale","autoHighlight","coordinateOrigin","coordinateSystem","CARTESIAN","extensions","info","pickingEvent","hoveredFeatureId","state","hoveredFeature","object","newHoveredFeatureId","getFeatureUniqueId","setState","isFeatureIdPresent","isFeatureIdDefined","Array","isArray","featureIdToHighlight","findIndex","feature","properties","id","undefined","layerName"],"mappings":"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","sourcesContent":["import {Matrix4} from 'math.gl';\nimport {MVTLoader} from '@loaders.gl/mvt';\nimport {load} from '@loaders.gl/core';\nimport {COORDINATE_SYSTEM} from '@deck.gl/core';\n\nimport TileLayer from '../tile-layer/tile-layer';\nimport {getURLFromTemplate} from '../tile-layer/utils';\nimport ClipExtension from './clip-extension';\n\nconst WORLD_SIZE = 512;\n\nconst defaultProps = {\n  uniqueIdProperty: {type: 'string', value: ''},\n  highlightedFeatureId: null\n};\n\nexport default class MVTLayer extends TileLayer {\n  getTileData(tile) {\n    const url = getURLFromTemplate(this.props.data, tile);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n    return load(url, MVTLoader, this.getLoadOptions());\n  }\n\n  renderSubLayers(props) {\n    const {tile} = props;\n    const worldScale = Math.pow(2, tile.z);\n\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n\n    const xOffset = (WORLD_SIZE * tile.x) / worldScale;\n    const yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n\n    props.autoHighlight = false;\n    props.modelMatrix = modelMatrix;\n    props.coordinateOrigin = [xOffset, yOffset, 0];\n    props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n    props.extensions = [...(props.extensions || []), new ClipExtension()];\n\n    return super.renderSubLayers(props);\n  }\n\n  onHover(info, pickingEvent) {\n    const {uniqueIdProperty, autoHighlight} = this.props;\n\n    if (autoHighlight) {\n      const {hoveredFeatureId} = this.state;\n      const hoveredFeature = info.object;\n      let newHoveredFeatureId;\n\n      if (hoveredFeature) {\n        newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      }\n\n      if (hoveredFeatureId !== newHoveredFeatureId) {\n        this.setState({hoveredFeatureId: newHoveredFeatureId});\n      }\n    }\n\n    return super.onHover(info, pickingEvent);\n  }\n\n  getHighlightedObjectIndex(tile) {\n    const {hoveredFeatureId} = this.state;\n    const {uniqueIdProperty, highlightedFeatureId} = this.props;\n    const {data} = tile;\n\n    const isFeatureIdPresent =\n      isFeatureIdDefined(hoveredFeatureId) || isFeatureIdDefined(highlightedFeatureId);\n\n    if (!isFeatureIdPresent || !Array.isArray(data)) {\n      return -1;\n    }\n\n    const featureIdToHighlight = isFeatureIdDefined(highlightedFeatureId)\n      ? highlightedFeatureId\n      : hoveredFeatureId;\n\n    return data.findIndex(\n      feature => getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight\n    );\n  }\n}\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return -1;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}