{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nexport default function fetchProgress(_x, _x2) {\n  return _fetchProgress.apply(this, arguments);\n}\nfunction _fetchProgress() {\n  _fetchProgress = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(response, onProgress) {\n    var onDone,\n      onError,\n      body,\n      contentLength,\n      totalBytes,\n      progressStream,\n      _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            onDone = _args.length > 2 && _args[2] !== undefined ? _args[2] : function () {};\n            onError = _args.length > 3 && _args[3] !== undefined ? _args[3] : function () {};\n            _context.next = 4;\n            return response;\n          case 4:\n            response = _context.sent;\n            if (response.ok) {\n              _context.next = 7;\n              break;\n            }\n            return _context.abrupt(\"return\", response);\n          case 7:\n            body = response.body;\n            if (body) {\n              _context.next = 10;\n              break;\n            }\n            return _context.abrupt(\"return\", response);\n          case 10:\n            contentLength = response.headers.get('content-length');\n            totalBytes = contentLength && parseInt(contentLength, 10);\n            if (contentLength > 0) {\n              _context.next = 14;\n              break;\n            }\n            return _context.abrupt(\"return\", response);\n          case 14:\n            if (!(typeof ReadableStream === 'undefined' || !body.getReader)) {\n              _context.next = 16;\n              break;\n            }\n            return _context.abrupt(\"return\", response);\n          case 16:\n            progressStream = new ReadableStream({\n              start: function start(controller) {\n                var reader = body.getReader();\n                read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n              }\n            });\n            return _context.abrupt(\"return\", new Response(progressStream));\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _fetchProgress.apply(this, arguments);\n}\nfunction read(_x3, _x4, _x5, _x6, _x7, _x8, _x9) {\n  return _read.apply(this, arguments);\n}\nfunction _read() {\n  _read = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n    var _yield$reader$read, done, value, percent;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return reader.read();\n          case 3:\n            _yield$reader$read = _context2.sent;\n            done = _yield$reader$read.done;\n            value = _yield$reader$read.value;\n            if (!done) {\n              _context2.next = 10;\n              break;\n            }\n            onDone();\n            controller.close();\n            return _context2.abrupt(\"return\");\n          case 10:\n            loadedBytes += value.byteLength;\n            percent = Math.round(loadedBytes / totalBytes * 100);\n            onProgress(percent, {\n              loadedBytes: loadedBytes,\n              totalBytes: totalBytes\n            });\n            controller.enqueue(value);\n            _context2.next = 16;\n            return read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n          case 16:\n            _context2.next = 22;\n            break;\n          case 18:\n            _context2.prev = 18;\n            _context2.t0 = _context2[\"catch\"](0);\n            controller.error(_context2.t0);\n            onError(_context2.t0);\n          case 22:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 18]]);\n  }));\n  return _read.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/progress/fetch-progress.js"],"names":["fetchProgress","response","onProgress","onDone","onError","ok","body","contentLength","headers","get","totalBytes","parseInt","ReadableStream","getReader","progressStream","start","controller","reader","read","Response","loadedBytes","done","value","close","byteLength","percent","Math","round","enqueue","error"],"mappings":"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","sourcesContent":["// Forked from github AnthumChris/fetch-progress-indicators under MIT license\n/* global Response, ReadableStream */\n\n// Intercepts the Response stream and creates a new Response\nexport default async function fetchProgress(\n  response,\n  onProgress,\n  onDone = () => {},\n  onError = () => {}\n) {\n  response = await response;\n  if (!response.ok) {\n    // ERROR checking needs to be done separately\n    return response;\n  }\n  const body = response.body;\n  if (!body) {\n    // 'ReadableStream not yet supported in this browser.\n    return response;\n  }\n  const contentLength = response.headers.get('content-length');\n  const totalBytes = contentLength && parseInt(contentLength, 10);\n  if (!(contentLength > 0)) {\n    return response;\n  }\n  // Currently override only implemented in browser\n  if (typeof ReadableStream === 'undefined' || !body.getReader) {\n    return response;\n  }\n\n  // Create a new stream that invisbly wraps original stream\n  const progressStream = new ReadableStream({\n    start(controller) {\n      const reader = body.getReader();\n      read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n    }\n  });\n\n  return new Response(progressStream);\n}\n\n// Forward to original streams controller\n// TODO - this causes a crazy deep \"async stack\"... rewrite as async iterator?\n// eslint-disable-next-line max-params\nasync function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n  try {\n    const {done, value} = await reader.read();\n    if (done) {\n      onDone();\n      controller.close();\n      return;\n    }\n    loadedBytes += value.byteLength;\n    const percent = Math.round((loadedBytes / totalBytes) * 100);\n    onProgress(percent, {loadedBytes, totalBytes});\n    controller.enqueue(value);\n    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n  } catch (error) {\n    controller.error(error);\n    onError(error);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}