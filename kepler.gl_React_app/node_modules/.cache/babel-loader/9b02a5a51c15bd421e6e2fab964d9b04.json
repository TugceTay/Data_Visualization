{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _awaitAsyncGenerator from \"@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _asyncIterator from \"@babel/runtime/helpers/esm/asyncIterator\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { RowTableBatch } from '@loaders.gl/tables';\nimport { geojsonToBinary } from '@loaders.gl/gis';\nimport parseJSONSync from './lib/parse-json';\nimport parseJSONInBatches from './lib/parse-json-in-batches';\nvar VERSION = typeof \"2.3.13\" !== 'undefined' ? \"2.3.13\" : 'latest';\nvar GeoJSONLoaderOptions = {\n  geojson: {\n    TableBatch: RowTableBatch,\n    batchSize: 'auto',\n    workerUrl: \"https://unpkg.com/@loaders.gl/json@\".concat(VERSION, \"/dist/geojson-loader.worker.js\")\n  },\n  json: {\n    jsonpaths: ['$', '$.features']\n  },\n  gis: {\n    format: 'geojson'\n  }\n};\nexport var GeoJSONWorkerLoader = {\n  id: 'geojson',\n  name: 'GeoJSON',\n  version: VERSION,\n  extensions: ['geojson'],\n  mimeTypes: ['application/geo+json'],\n  category: 'geometry',\n  text: true,\n  options: GeoJSONLoaderOptions\n};\nexport var GeoJSONLoader = _objectSpread(_objectSpread({}, GeoJSONWorkerLoader), {}, {\n  parse: parse,\n  parseTextSync: parseTextSync,\n  parseInBatches: parseInBatches\n});\nfunction parse(_x2, _x3) {\n  return _parse.apply(this, arguments);\n}\nfunction _parse() {\n  _parse = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(arrayBuffer, options) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", parseTextSync(new TextDecoder().decode(arrayBuffer), options));\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _parse.apply(this, arguments);\n}\nfunction parseTextSync(text, options) {\n  options = _objectSpread(_objectSpread({}, GeoJSONLoaderOptions), options);\n  options.json = _objectSpread(_objectSpread({}, GeoJSONLoaderOptions.geojson), options.geojson);\n  options.gis = options.gis || {};\n  var json = parseJSONSync(text, options);\n  switch (options.gis.format) {\n    case 'binary':\n      return geojsonToBinary(json);\n    default:\n      return json;\n  }\n}\nfunction parseInBatches(_x4, _x5) {\n  return _parseInBatches.apply(this, arguments);\n}\nfunction _parseInBatches() {\n  _parseInBatches = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(asyncIterator, options) {\n    var geojsonIterator;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            options = _objectSpread(_objectSpread({}, GeoJSONLoaderOptions), options);\n            options.json = _objectSpread(_objectSpread({}, GeoJSONLoaderOptions.geojson), options.geojson);\n            geojsonIterator = parseJSONInBatches(asyncIterator, options);\n            _context3.t0 = options.gis.format;\n            _context3.next = _context3.t0 === 'binary' ? 6 : 7;\n            break;\n          case 6:\n            return _context3.abrupt(\"return\", makeBinaryGeometryIterator(geojsonIterator));\n          case 7:\n            return _context3.abrupt(\"return\", geojsonIterator);\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _parseInBatches.apply(this, arguments);\n}\nfunction makeBinaryGeometryIterator(_x) {\n  return _makeBinaryGeometryIterator.apply(this, arguments);\n}\nfunction _makeBinaryGeometryIterator() {\n  _makeBinaryGeometryIterator = _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee(geojsonIterator) {\n    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context.prev = 2;\n            _iterator = _asyncIterator(geojsonIterator);\n          case 4:\n            _context.next = 6;\n            return _awaitAsyncGenerator(_iterator.next());\n          case 6:\n            _step = _context.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context.next = 10;\n            return _awaitAsyncGenerator(_step.value);\n          case 10:\n            _value = _context.sent;\n            if (_iteratorNormalCompletion) {\n              _context.next = 19;\n              break;\n            }\n            batch = _value;\n            batch.data = geojsonToBinary(batch.data);\n            _context.next = 16;\n            return batch;\n          case 16:\n            _iteratorNormalCompletion = true;\n            _context.next = 4;\n            break;\n          case 19:\n            _context.next = 25;\n            break;\n          case 21:\n            _context.prev = 21;\n            _context.t0 = _context[\"catch\"](2);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n          case 25:\n            _context.prev = 25;\n            _context.prev = 26;\n            if (!(!_iteratorNormalCompletion && _iterator[\"return\"] != null)) {\n              _context.next = 30;\n              break;\n            }\n            _context.next = 30;\n            return _awaitAsyncGenerator(_iterator[\"return\"]());\n          case 30:\n            _context.prev = 30;\n            if (!_didIteratorError) {\n              _context.next = 33;\n              break;\n            }\n            throw _iteratorError;\n          case 33:\n            return _context.finish(30);\n          case 34:\n            return _context.finish(25);\n          case 35:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[2, 21, 25, 35], [26,, 30, 34]]);\n  }));\n  return _makeBinaryGeometryIterator.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/geojson-loader.js"],"names":["RowTableBatch","geojsonToBinary","parseJSONSync","parseJSONInBatches","VERSION","GeoJSONLoaderOptions","geojson","TableBatch","batchSize","workerUrl","json","jsonpaths","gis","format","GeoJSONWorkerLoader","id","name","version","extensions","mimeTypes","category","text","options","GeoJSONLoader","parse","parseTextSync","parseInBatches","arrayBuffer","TextDecoder","decode","asyncIterator","geojsonIterator","makeBinaryGeometryIterator","batch","data"],"mappings":"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","sourcesContent":["/* global TextDecoder */\n/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */\n/** @typedef {import('@loaders.gl/loader-utils').WorkerLoaderObject} WorkerLoaderObject */\nimport {RowTableBatch} from '@loaders.gl/tables';\nimport {geojsonToBinary} from '@loaders.gl/gis';\nimport parseJSONSync from './lib/parse-json';\nimport parseJSONInBatches from './lib/parse-json-in-batches';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nconst GeoJSONLoaderOptions = {\n  geojson: {\n    TableBatch: RowTableBatch,\n    batchSize: 'auto',\n    workerUrl: `https://unpkg.com/@loaders.gl/json@${VERSION}/dist/geojson-loader.worker.js`\n  },\n  json: {\n    jsonpaths: ['$', '$.features']\n  },\n  gis: {\n    format: 'geojson'\n  }\n};\n\n/** @type {WorkerLoaderObject} */\nexport const GeoJSONWorkerLoader = {\n  id: 'geojson',\n  name: 'GeoJSON',\n  version: VERSION,\n  extensions: ['geojson'],\n  mimeTypes: ['application/geo+json'],\n  // TODO - support various line based JSON formats\n  /*\n  extensions: {\n    json: null,\n    jsonl: {stream: true},\n    ndjson: {stream: true}\n  },\n  mimeTypes: {\n    'application/json': null,\n    'application/json-seq': {stream: true},\n    'application/x-ndjson': {stream: true}\n  },\n  */\n  category: 'geometry',\n  text: true,\n  options: GeoJSONLoaderOptions\n};\n\n/** @type {LoaderObject} */\nexport const GeoJSONLoader = {\n  ...GeoJSONWorkerLoader,\n  parse,\n  parseTextSync,\n  parseInBatches\n};\n\nasync function parse(arrayBuffer, options) {\n  return parseTextSync(new TextDecoder().decode(arrayBuffer), options);\n}\n\nfunction parseTextSync(text, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...GeoJSONLoaderOptions, ...options};\n  options.json = {...GeoJSONLoaderOptions.geojson, ...options.geojson};\n  options.gis = options.gis || {};\n  const json = parseJSONSync(text, options);\n  switch (options.gis.format) {\n    case 'binary':\n      return geojsonToBinary(json);\n    default:\n      return json;\n  }\n}\n\nasync function parseInBatches(asyncIterator, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...GeoJSONLoaderOptions, ...options};\n  options.json = {...GeoJSONLoaderOptions.geojson, ...options.geojson};\n\n  const geojsonIterator = parseJSONInBatches(asyncIterator, options);\n\n  switch (options.gis.format) {\n    case 'binary':\n      return makeBinaryGeometryIterator(geojsonIterator);\n    default:\n      return geojsonIterator;\n  }\n}\n\nasync function* makeBinaryGeometryIterator(geojsonIterator) {\n  for await (const batch of geojsonIterator) {\n    batch.data = geojsonToBinary(batch.data);\n    yield batch;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}