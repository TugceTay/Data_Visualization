{"ast":null,"code":"import { Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float32, Float64, Bool, Utf8, TimestampMillisecond, Null } from '../types/arrow-like/type';\nimport Schema from './schema';\nimport Field from './field';\nvar TYPED_ARRAY_TO_TYPE = {\n  Int8Array: new Int8(),\n  Int16Array: new Int16(),\n  Int32Array: new Int32(),\n  Uint8Array: new Uint8(),\n  Uint8ClampedArray: new Uint8(),\n  Uint16Array: new Uint16(),\n  Uint32Array: new Uint32(),\n  Float32Array: new Float32(),\n  Float64Array: new Float64()\n};\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n  TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n}\nfunction getTypeFromColumnArray(columnArray) {\n  var ArrayType = columnArray.constructor && columnArray.constructor.name;\n  var type = TYPED_ARRAY_TO_TYPE[ArrayType];\n  if (type) {\n    return {\n      type: type,\n      nullable: false,\n      metadata: null\n    };\n  }\n  var metadata = null;\n  if (columnArray.length > 0) {\n    var value = columnArray[0];\n    type = deduceTypeFromValue(value);\n    if (type) {\n      metadata = new Map([['type', type.toString()]]);\n    }\n  }\n  return {\n    type: new Null(),\n    nullable: true,\n    metadata: metadata\n  };\n}\nexport function deduceTableSchema(table) {\n  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var deducedSchema = Array.isArray(table) ? deduceSchemaForRowTable(table) : deduceSchemaForColumnarTable(table);\n  return Object.assign(deducedSchema, schema);\n}\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  var fields = [];\n  for (var columnName in columnarTable) {\n    var columnArray = columnarTable[columnName];\n    var _getTypeFromColumnArr = getTypeFromColumnArray(columnArray),\n      type = _getTypeFromColumnArr.type,\n      nullable = _getTypeFromColumnArr.nullable,\n      metadata = _getTypeFromColumnArr.metadata;\n    fields.push(new Field(columnName, type, nullable, metadata || new Map()));\n  }\n  return new Schema(fields);\n}\nfunction deduceSchemaForRowTable(rowTable) {\n  var fields = [];\n  if (rowTable.length) {\n    var row = rowTable[0];\n    if (Array.isArray(row)) {\n      for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n        var value = row[columnIndex];\n        var name = String(columnIndex);\n        var type = deduceTypeFromValue(value);\n        var nullable = true;\n        var metadata = new Map([['type', type.toString()]]);\n        fields.push(new Field(name, new Null(), nullable, metadata));\n      }\n    } else {\n      for (var columnName in row) {\n        var _value = row[columnName];\n        var _type = deduceTypeFromValue(_value);\n        var _nullable = true;\n        var _metadata = new Map([['type', _type.toString()]]);\n        fields.push(new Field(columnName, new Null(), _nullable, _metadata));\n      }\n    }\n  }\n  return new Schema(fields);\n}\nfunction deduceTypeFromValue(value) {\n  if (value === true || value === false) {\n    return new Bool();\n  }\n  if (value instanceof Date) {\n    return new TimestampMillisecond();\n  }\n  if (value instanceof Number) {\n    return new Float32();\n  }\n  if (typeof value === 'string') {\n    return new Utf8();\n  }\n  return new Null();\n}","map":{"version":3,"sources":["../../../../src/lib/schema/schema-utils.js"],"names":["Int8","Int16","Int32","Int64","Uint8","Uint16","Uint32","Uint64","Float32","Float64","Bool","Utf8","TimestampMillisecond","Null","Schema","Field","TYPED_ARRAY_TO_TYPE","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","getTypeFromColumnArray","columnArray","ArrayType","constructor","name","type","nullable","metadata","length","value","deduceTypeFromValue","Map","toString","deduceTableSchema","table","schema","deducedSchema","Array","isArray","deduceSchemaForRowTable","deduceSchemaForColumnarTable","Object","assign","columnarTable","fields","columnName","push","rowTable","row","columnIndex","String","Date","Number"],"mappings":"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","sourcesContent":["// SCHEMA SUPPORT - AUTODEDUCTION\nimport {\n  // Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  // Float,\n  // Float16,\n  Float32,\n  Float64,\n  Bool,\n  Utf8,\n  TimestampMillisecond,\n  Null\n} from '../types/arrow-like/type';\nimport Schema from './schema';\nimport Field from './field';\n\nconst TYPED_ARRAY_TO_TYPE = {\n  Int8Array: new Int8(),\n  Int16Array: new Int16(),\n  Int32Array: new Int32(),\n  Uint8Array: new Uint8(),\n  Uint8ClampedArray: new Uint8(),\n  Uint16Array: new Uint16(),\n  Uint32Array: new Uint32(),\n  Float32Array: new Float32(),\n  Float64Array: new Float64()\n};\n\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n  TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n}\n\n// Type deduction\n\n/**\n * Type deduction from columnar array\n *\n * Notes:\n * - If the column is a typed array we are able to make a fairly precise type deduction\n * - However we can't tell if it is intervals, dates, fixed size lists etc.\n * - Nullable typed arrays are only supported if backing table is Arrow\n *\n * @param {*} columnArray\n * @returns type, nullable, metadata - (Arrow-like) type information\n */\nfunction getTypeFromColumnArray(columnArray) {\n  const ArrayType = columnArray.constructor && columnArray.constructor.name;\n  let type = TYPED_ARRAY_TO_TYPE[ArrayType];\n  if (type) {\n    return {type, nullable: false, metadata: null};\n  }\n\n  let metadata = null;\n  if (columnArray.length > 0) {\n    const value = columnArray[0];\n    type = deduceTypeFromValue(value);\n    if (type) {\n      metadata = new Map([['type', type.toString()]]);\n    }\n  }\n\n  // We use fields of Arrow-Type Null to indicate that we represent additional, non binary columns\n  return {type: new Null(), nullable: true, metadata};\n}\n\nexport function deduceTableSchema(table, schema = null) {\n  const deducedSchema = Array.isArray(table)\n    ? deduceSchemaForRowTable(table)\n    : deduceSchemaForColumnarTable(table);\n  // Deduced schema will fill in missing info from partial options.schema, if provided\n  return Object.assign(deducedSchema, schema);\n}\n\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  const fields = [];\n  for (const columnName in columnarTable) {\n    const columnArray = columnarTable[columnName];\n    const {type, nullable, metadata} = getTypeFromColumnArray(columnArray);\n    fields.push(new Field(columnName, type, nullable, metadata || new Map()));\n  }\n  return new Schema(fields);\n}\n\nfunction deduceSchemaForRowTable(rowTable) {\n  const fields = [];\n  if (rowTable.length) {\n    const row = rowTable[0];\n    // Note - handle rows in both array and object format\n    if (Array.isArray(row)) {\n      // row: [value1, value2, ...]\n      for (let columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n        const value = row[columnIndex];\n        const name = String(columnIndex);\n        const type = deduceTypeFromValue(value);\n        const nullable = true;\n        const metadata = new Map([['type', type.toString()]]);\n        fields.push(new Field(name, new Null(), nullable, metadata));\n      }\n    } else {\n      for (const columnName in row) {\n        // row: {columnName1: value1, columnName2: value2, ...}\n        // TODO - Could look at additional rows if nulls in first row\n        const value = row[columnName];\n        const type = deduceTypeFromValue(value);\n        const nullable = true;\n        const metadata = new Map([['type', type.toString()]]);\n        fields.push(new Field(columnName, new Null(), nullable, metadata));\n      }\n    }\n  }\n  return new Schema(fields);\n}\n\nfunction deduceTypeFromValue(value) {\n  if (value === true || value === false) {\n    return new Bool();\n  }\n  if (value instanceof Date) {\n    return new TimestampMillisecond();\n  }\n  if (value instanceof Number) {\n    return new Float32();\n  }\n  if (typeof value === 'string') {\n    return new Utf8();\n  }\n  // TODO JS columns (arrays and object valued) are currently null\n  return new Null();\n}\n"]},"metadata":{},"sourceType":"module"}