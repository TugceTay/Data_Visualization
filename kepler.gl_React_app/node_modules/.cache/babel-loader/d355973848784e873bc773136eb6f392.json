{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getFloatTexture } from '../utils/resource-utils.js';\nvar defaultProps = Object.assign({}, ScreenGridCellLayer.defaultProps, {\n  getPosition: {\n    type: 'accessor',\n    value: function value(d) {\n      return d.position;\n    }\n  },\n  getWeight: {\n    type: 'accessor',\n    value: function value(d) {\n      return 1;\n    }\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n});\nvar POSITION_ATTRIBUTE_NAME = 'positions';\nvar DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nvar ScreenGridLayer = function (_GridAggregationLayer) {\n  _inherits(ScreenGridLayer, _GridAggregationLayer);\n  function ScreenGridLayer() {\n    _classCallCheck(this, ScreenGridLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScreenGridLayer).apply(this, arguments));\n  }\n  _createClass(ScreenGridLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _attributeManager$add;\n      var gl = this.context.gl;\n      if (!ScreenGridCellLayer.isSupported(gl)) {\n        this.setState({\n          supported: false\n        });\n        log.error(\"ScreenGridLayer: \".concat(this.id, \" is not supported on this browser\"))();\n        return;\n      }\n      _get(_getPrototypeOf(ScreenGridLayer.prototype), \"initializeState\", this).call(this, {\n        dimensions: DIMENSIONS,\n        getCellSize: function getCellSize(props) {\n          return props.cellSizePixels;\n        }\n      });\n      var weights = {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM,\n          needMax: true,\n          maxTexture: getFloatTexture(gl, {\n            id: \"\".concat(this.id, \"-max-texture\")\n          })\n        }\n      };\n      this.setState({\n        supported: true,\n        projectPoints: true,\n        weights: weights,\n        subLayerData: {\n          attributes: {}\n        },\n        maxTexture: weights.count.maxTexture,\n        positionAttributeName: 'positions',\n        posOffset: [0, 0],\n        translation: [1, -1]\n      });\n      var attributeManager = this.getAttributeManager();\n      attributeManager.add((_attributeManager$add = {}, _defineProperty(_attributeManager$add, POSITION_ATTRIBUTE_NAME, {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      }), _defineProperty(_attributeManager$add, \"count\", {\n        size: 3,\n        accessor: 'getWeight'\n      }), _attributeManager$add));\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return this.state.supported && changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      _get(_getPrototypeOf(ScreenGridLayer.prototype), \"updateState\", this).call(this, opts);\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      if (!this.state.supported) {\n        return [];\n      }\n      var _this$state = this.state,\n        maxTexture = _this$state.maxTexture,\n        numRow = _this$state.numRow,\n        numCol = _this$state.numCol,\n        weights = _this$state.weights;\n      var updateTriggers = this.props.updateTriggers;\n      var aggregationBuffer = weights.count.aggregationBuffer;\n      var CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n      return new CellLayerClass(this.props, this.getSubLayerProps({\n        id: 'cell-layer',\n        updateTriggers: updateTriggers\n      }), {\n        data: {\n          attributes: {\n            instanceCounts: aggregationBuffer\n          }\n        },\n        maxTexture: maxTexture,\n        numInstances: numRow * numCol\n      });\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      _get(_getPrototypeOf(ScreenGridLayer.prototype), \"finalizeState\", this).call(this);\n      var _this$state2 = this.state,\n        aggregationBuffer = _this$state2.aggregationBuffer,\n        maxBuffer = _this$state2.maxBuffer,\n        maxTexture = _this$state2.maxTexture;\n      if (aggregationBuffer) {\n        aggregationBuffer[\"delete\"]();\n      }\n      if (maxBuffer) {\n        maxBuffer[\"delete\"]();\n      }\n      if (maxTexture) {\n        maxTexture[\"delete\"]();\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2) {\n      var info = _ref2.info,\n        mode = _ref2.mode;\n      var index = info.index;\n      if (index >= 0) {\n        var gpuGridAggregator = this.state.gpuGridAggregator;\n        var aggregationResults = gpuGridAggregator.getData('count');\n        info.object = GPUGridAggregator.getAggregationData(Object.assign({\n          pixelIndex: index\n        }, aggregationResults));\n      }\n      return info;\n    }\n  }, {\n    key: \"updateResults\",\n    value: function updateResults(_ref3) {\n      var aggregationData = _ref3.aggregationData,\n        maxData = _ref3.maxData;\n      var count = this.state.weights.count;\n      count.aggregationData = aggregationData;\n      count.aggregationBuffer.setData({\n        data: aggregationData\n      });\n      count.maxData = maxData;\n      count.maxTexture.setImageData({\n        data: maxData\n      });\n    }\n  }, {\n    key: \"updateAggregationState\",\n    value: function updateAggregationState(opts) {\n      var cellSize = opts.props.cellSizePixels;\n      var cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n      var viewportChanged = opts.changeFlags.viewportChanged;\n      var gpuAggregation = opts.props.gpuAggregation;\n      if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n        if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n          log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n          gpuAggregation = false;\n        }\n      }\n      var gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n      this.setState({\n        gpuAggregation: gpuAggregation\n      });\n      var positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n      var dimensions = this.state.dimensions;\n      var data = dimensions.data,\n        weights = dimensions.weights;\n      var aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {\n        compareAll: gpuAggregation,\n        dimension: data\n      });\n      var aggregationWeightsDirty = this.isAggregationDirty(opts, {\n        dimension: weights\n      });\n      this.setState({\n        aggregationDataDirty: aggregationDataDirty,\n        aggregationWeightsDirty: aggregationWeightsDirty\n      });\n      var viewport = this.context.viewport;\n      if (viewportChanged || cellSizeChanged) {\n        var width = viewport.width,\n          height = viewport.height;\n        var numCol = Math.ceil(width / cellSize);\n        var numRow = Math.ceil(height / cellSize);\n        this.allocateResources(numRow, numCol);\n        this.setState({\n          scaling: [width / 2, -height / 2, 1],\n          gridOffset: {\n            xOffset: cellSize,\n            yOffset: cellSize\n          },\n          width: width,\n          height: height,\n          numCol: numCol,\n          numRow: numRow\n        });\n      }\n      if (aggregationWeightsDirty) {\n        this._updateAccessors(opts);\n      }\n      if (aggregationDataDirty || aggregationWeightsDirty) {\n        this._resetResults();\n      }\n    }\n  }, {\n    key: \"_updateAccessors\",\n    value: function _updateAccessors(opts) {\n      var _opts$props = opts.props,\n        getWeight = _opts$props.getWeight,\n        aggregation = _opts$props.aggregation;\n      var count = this.state.weights.count;\n      if (count) {\n        count.getWeight = getWeight;\n        count.operation = AGGREGATION_OPERATION[aggregation];\n      }\n      this.setState({\n        getValue: getValueFunc(aggregation, getWeight)\n      });\n    }\n  }, {\n    key: \"_resetResults\",\n    value: function _resetResults() {\n      var count = this.state.weights.count;\n      if (count) {\n        count.aggregationData = null;\n      }\n    }\n  }]);\n  return ScreenGridLayer;\n}(GridAggregationLayer);\nexport { ScreenGridLayer as default };\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/screen-grid-layer/screen-grid-layer.js"],"names":["log","GPUGridAggregator","AGGREGATION_OPERATION","getValueFunc","ScreenGridCellLayer","GridAggregationLayer","getFloatTexture","defaultProps","assign","getPosition","type","value","d","position","getWeight","gpuAggregation","aggregation","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ScreenGridLayer","gl","context","isSupported","setState","supported","error","id","dimensions","getCellSize","cellSizePixels","count","size","operation","SUM","needMax","maxTexture","projectPoints","subLayerData","attributes","positionAttributeName","posOffset","translation","attributeManager","getAttributeManager","add","accessor","fp64","use64bitPositions","changeFlags","state","somethingChanged","opts","numRow","numCol","updateTriggers","aggregationBuffer","CellLayerClass","getSubLayerClass","getSubLayerProps","instanceCounts","numInstances","maxBuffer","info","mode","index","gpuGridAggregator","aggregationResults","getData","object","getAggregationData","pixelIndex","aggregationData","maxData","setData","setImageData","cellSize","cellSizeChanged","oldProps","viewportChanged","warn","gpuAggregationChanged","positionsChanged","isAttributeChanged","aggregationDataDirty","isAggregationDirty","compareAll","dimension","aggregationWeightsDirty","viewport","width","height","Math","ceil","allocateResources","scaling","gridOffset","xOffset","yOffset","_updateAccessors","_resetResults","getValue","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {log} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport {getFloatTexture} from '../utils/resource-utils.js';\n\nconst defaultProps = Object.assign({}, ScreenGridCellLayer.defaultProps, {\n  getPosition: {type: 'accessor', value: d => d.position},\n  getWeight: {type: 'accessor', value: d => 1},\n\n  gpuAggregation: true,\n  aggregation: 'SUM'\n});\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {gl} = this.context;\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      // max aggregated value is sampled from a float texture\n      this.setState({supported: false});\n      log.error(`ScreenGridLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeState({\n      dimensions: DIMENSIONS,\n      getCellSize: props => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {id: `${this.id}-max-texture`})\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true, // aggregation in screen space\n      weights,\n      subLayerData: {attributes: {}},\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {maxTexture, numRow, numCol, weights} = this.state;\n    const {updateTriggers} = this.props;\n    const {aggregationBuffer} = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n\n    return new CellLayerClass(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell-layer',\n        updateTriggers\n      }),\n      {\n        data: {attributes: {instanceCounts: aggregationBuffer}},\n        maxTexture,\n        numInstances: numRow * numCol\n      }\n    );\n  }\n\n  finalizeState() {\n    super.finalizeState();\n\n    const {aggregationBuffer, maxBuffer, maxTexture} = this.state;\n\n    if (aggregationBuffer) {\n      aggregationBuffer.delete();\n    }\n    if (maxBuffer) {\n      maxBuffer.delete();\n    }\n    if (maxTexture) {\n      maxTexture.delete();\n    }\n  }\n\n  getPickingInfo({info, mode}) {\n    const {index} = info;\n    if (index >= 0) {\n      const {gpuGridAggregator} = this.state;\n      // Get count aggregation results\n      const aggregationResults = gpuGridAggregator.getData('count');\n\n      // Each instance (one cell) is aggregated into single pixel,\n      // Get current instance's aggregation details.\n      info.object = GPUGridAggregator.getAggregationData(\n        Object.assign({pixelIndex: index}, aggregationResults)\n      );\n    }\n\n    return info;\n  }\n\n  // Aggregation Overrides\n\n  updateResults({aggregationData, maxData}) {\n    const {count} = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({data: aggregationData});\n    count.maxData = maxData;\n    count.maxTexture.setImageData({data: maxData});\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {viewportChanged} = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n\n    const {dimensions} = this.state;\n    const {data, weights} = dimensions;\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      viewportChanged ||\n      this.isAggregationDirty(opts, {\n        compareAll: gpuAggregation, // check for all (including extentions props) when using gpu aggregation\n        dimension: data\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {dimension: weights});\n\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n\n    const {viewport} = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {width, height} = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        // transformation from clipspace to screen(pixel) space\n        scaling: [width / 2, -height / 2, 1],\n\n        gridOffset: {xOffset: cellSize, yOffset: cellSize},\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {getWeight, aggregation} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight)});\n  }\n\n  _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n}\n\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}