{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { CompositeLayer } from '@deck.gl/core';\nimport { SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport { WebMercatorViewport, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { load } from '@loaders.gl/core';\nimport { TerrainLoader } from '@loaders.gl/terrain';\nimport TileLayer from '../tile-layer/tile-layer';\nimport { urlType, getURLFromTemplate } from '../tile-layer/utils';\nvar DUMMY_DATA = [1];\nvar defaultProps = _objectSpread({}, TileLayer.defaultProps, {\n  elevationData: urlType,\n  texture: urlType,\n  meshMaxError: {\n    type: 'number',\n    value: 4.0\n  },\n  bounds: {\n    type: 'array',\n    value: null,\n    optional: true,\n    compare: true\n  },\n  color: {\n    type: 'color',\n    value: [255, 255, 255]\n  },\n  elevationDecoder: {\n    type: 'object',\n    value: {\n      rScaler: 1,\n      gScaler: 0,\n      bScaler: 0,\n      offset: 0\n    }\n  },\n  workerUrl: {\n    type: 'string',\n    value: null\n  },\n  wireframe: false,\n  material: true\n});\nfunction urlTemplateToUpdateTrigger(template) {\n  if (Array.isArray(template)) {\n    return template.join(';');\n  }\n  return template;\n}\nvar TerrainLayer = function (_CompositeLayer) {\n  _inherits(TerrainLayer, _CompositeLayer);\n  function TerrainLayer() {\n    _classCallCheck(this, TerrainLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(TerrainLayer).apply(this, arguments));\n  }\n  _createClass(TerrainLayer, [{\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n        oldProps = _ref.oldProps;\n      var elevationDataChanged = props.elevationData !== oldProps.elevationData;\n      if (elevationDataChanged) {\n        var elevationData = props.elevationData;\n        var isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes('{x}') && elevationData.includes('{y}'));\n        this.setState({\n          isTiled: isTiled\n        });\n      }\n      var shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;\n      if (!this.state.isTiled && shouldReload) {\n        var terrain = this.loadTerrain(props);\n        this.setState({\n          terrain: terrain\n        });\n      }\n    }\n  }, {\n    key: \"loadTerrain\",\n    value: function loadTerrain(_ref2) {\n      var elevationData = _ref2.elevationData,\n        bounds = _ref2.bounds,\n        elevationDecoder = _ref2.elevationDecoder,\n        meshMaxError = _ref2.meshMaxError,\n        workerUrl = _ref2.workerUrl;\n      if (!elevationData) {\n        return null;\n      }\n      var options = {\n        terrain: {\n          bounds: bounds,\n          meshMaxError: meshMaxError,\n          elevationDecoder: elevationDecoder\n        }\n      };\n      if (workerUrl !== null) {\n        options.terrain.workerUrl = workerUrl;\n      }\n      return load(elevationData, TerrainLoader, options);\n    }\n  }, {\n    key: \"getTiledTerrainData\",\n    value: function getTiledTerrainData(tile) {\n      var _this$props = this.props,\n        elevationData = _this$props.elevationData,\n        texture = _this$props.texture,\n        elevationDecoder = _this$props.elevationDecoder,\n        meshMaxError = _this$props.meshMaxError,\n        workerUrl = _this$props.workerUrl;\n      var dataUrl = getURLFromTemplate(elevationData, tile);\n      var textureUrl = getURLFromTemplate(texture, tile);\n      var bbox = tile.bbox,\n        z = tile.z;\n      var viewport = new WebMercatorViewport({\n        longitude: (bbox.west + bbox.east) / 2,\n        latitude: (bbox.north + bbox.south) / 2,\n        zoom: z\n      });\n      var bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);\n      var topRight = viewport.projectFlat([bbox.east, bbox.north]);\n      var bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];\n      var terrain = this.loadTerrain({\n        elevationData: dataUrl,\n        bounds: bounds,\n        elevationDecoder: elevationDecoder,\n        meshMaxError: meshMaxError,\n        workerUrl: workerUrl\n      });\n      var surface = textureUrl ? load(textureUrl)[\"catch\"](function (_) {\n        return null;\n      }) : Promise.resolve(null);\n      return Promise.all([terrain, surface]);\n    }\n  }, {\n    key: \"renderSubLayers\",\n    value: function renderSubLayers(props) {\n      var SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n      var data = props.data,\n        color = props.color;\n      if (!data) {\n        return null;\n      }\n      var _data = _slicedToArray(data, 2),\n        mesh = _data[0],\n        texture = _data[1];\n      return new SubLayerClass(props, {\n        data: DUMMY_DATA,\n        mesh: mesh,\n        texture: texture,\n        coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n        getPosition: function getPosition(d) {\n          return [0, 0, 0];\n        },\n        getColor: color\n      });\n    }\n  }, {\n    key: \"onViewportLoad\",\n    value: function onViewportLoad(data) {\n      if (!data || data.length === 0 || data.every(function (x) {\n        return !x;\n      })) {\n        return;\n      }\n      var zRange = this.state.zRange;\n      var ranges = data.filter(Boolean).map(function (arr) {\n        var bounds = arr[0].header.boundingBox;\n        return bounds.map(function (bound) {\n          return bound[2];\n        });\n      });\n      var minZ = Math.min.apply(Math, _toConsumableArray(ranges.map(function (x) {\n        return x[0];\n      })));\n      var maxZ = Math.max.apply(Math, _toConsumableArray(ranges.map(function (x) {\n        return x[1];\n      })));\n      if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {\n        this.setState({\n          zRange: [minZ, maxZ]\n        });\n      }\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$props2 = this.props,\n        color = _this$props2.color,\n        material = _this$props2.material,\n        elevationData = _this$props2.elevationData,\n        texture = _this$props2.texture,\n        wireframe = _this$props2.wireframe,\n        meshMaxError = _this$props2.meshMaxError,\n        elevationDecoder = _this$props2.elevationDecoder;\n      if (this.state.isTiled) {\n        return new TileLayer(this.getSubLayerProps({\n          id: 'tiles'\n        }), {\n          wireframe: wireframe,\n          color: color,\n          material: material,\n          getTileData: this.getTiledTerrainData.bind(this),\n          renderSubLayers: this.renderSubLayers.bind(this),\n          updateTriggers: {\n            getTileData: {\n              elevationData: urlTemplateToUpdateTrigger(elevationData),\n              texture: urlTemplateToUpdateTrigger(texture),\n              meshMaxError: meshMaxError,\n              elevationDecoder: elevationDecoder\n            }\n          },\n          onViewportLoad: this.onViewportLoad.bind(this),\n          zRange: this.state.zRange || null\n        });\n      }\n      var SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n      return new SubLayerClass(this.getSubLayerProps({\n        id: 'mesh'\n      }), {\n        data: DUMMY_DATA,\n        mesh: this.state.terrain,\n        texture: texture,\n        _instanced: false,\n        getPosition: function getPosition(d) {\n          return [0, 0, 0];\n        },\n        getColor: color,\n        material: material,\n        wireframe: wireframe\n      });\n    }\n  }]);\n  return TerrainLayer;\n}(CompositeLayer);\nexport { TerrainLayer as default };\nTerrainLayer.layerName = 'TerrainLayer';\nTerrainLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/terrain-layer/terrain-layer.js"],"names":["CompositeLayer","SimpleMeshLayer","WebMercatorViewport","COORDINATE_SYSTEM","load","TerrainLoader","TileLayer","urlType","getURLFromTemplate","DUMMY_DATA","defaultProps","elevationData","texture","meshMaxError","type","value","bounds","optional","compare","color","elevationDecoder","rScaler","gScaler","bScaler","offset","workerUrl","wireframe","material","urlTemplateToUpdateTrigger","template","Array","isArray","join","TerrainLayer","props","oldProps","elevationDataChanged","isTiled","includes","setState","shouldReload","state","terrain","loadTerrain","options","tile","dataUrl","textureUrl","bbox","z","viewport","longitude","west","east","latitude","north","south","zoom","bottomLeft","projectFlat","topRight","surface","Promise","resolve","all","SubLayerClass","getSubLayerClass","data","mesh","coordinateSystem","CARTESIAN","getPosition","getColor","length","every","x","zRange","ranges","filter","Boolean","map","arr","header","boundingBox","bound","minZ","Math","min","maxZ","max","getSubLayerProps","id","getTileData","getTiledTerrainData","bind","renderSubLayers","updateTriggers","onViewportLoad","_instanced","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer} from '@deck.gl/core';\nimport {SimpleMeshLayer} from '@deck.gl/mesh-layers';\nimport {WebMercatorViewport, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport {load} from '@loaders.gl/core';\nimport {TerrainLoader} from '@loaders.gl/terrain';\nimport TileLayer from '../tile-layer/tile-layer';\nimport {urlType, getURLFromTemplate} from '../tile-layer/utils';\n\nconst DUMMY_DATA = [1];\n\nconst defaultProps = {\n  ...TileLayer.defaultProps,\n  // Image url that encodes height data\n  elevationData: urlType,\n  // Image url to use as texture\n  texture: urlType,\n  // Martini error tolerance in meters, smaller number -> more detailed mesh\n  meshMaxError: {type: 'number', value: 4.0},\n  // Bounding box of the terrain image, [minX, minY, maxX, maxY] in world coordinates\n  bounds: {type: 'array', value: null, optional: true, compare: true},\n  // Color to use if texture is unavailable\n  color: {type: 'color', value: [255, 255, 255]},\n  // Object to decode height data, from (r, g, b) to height in meters\n  elevationDecoder: {\n    type: 'object',\n    value: {\n      rScaler: 1,\n      gScaler: 0,\n      bScaler: 0,\n      offset: 0\n    }\n  },\n  // Supply url to local terrain worker bundle. Only required if running offline and cannot access CDN.\n  workerUrl: {type: 'string', value: null},\n  // Same as SimpleMeshLayer wireframe\n  wireframe: false,\n  material: true\n};\n\n// Turns array of templates into a single string to work around shallow change\nfunction urlTemplateToUpdateTrigger(template) {\n  if (Array.isArray(template)) {\n    return template.join(';');\n  }\n  return template;\n}\n\n/**\n * state: {\n *   isTiled: True renders TileLayer of many SimpleMeshLayers, false renders one SimpleMeshLayer\n *   terrain: Mesh object. Only defined when isTiled is false.\n * }\n */\nexport default class TerrainLayer extends CompositeLayer {\n  updateState({props, oldProps}) {\n    const elevationDataChanged = props.elevationData !== oldProps.elevationData;\n    if (elevationDataChanged) {\n      const {elevationData} = props;\n      const isTiled =\n        elevationData &&\n        (Array.isArray(elevationData) ||\n          (elevationData.includes('{x}') && elevationData.includes('{y}')));\n      this.setState({isTiled});\n    }\n\n    // Reloading for single terrain mesh\n    const shouldReload =\n      elevationDataChanged ||\n      props.meshMaxError !== oldProps.meshMaxError ||\n      props.elevationDecoder !== oldProps.elevationDecoder ||\n      props.bounds !== oldProps.bounds;\n\n    if (!this.state.isTiled && shouldReload) {\n      const terrain = this.loadTerrain(props);\n      this.setState({terrain});\n    }\n  }\n\n  loadTerrain({elevationData, bounds, elevationDecoder, meshMaxError, workerUrl}) {\n    if (!elevationData) {\n      return null;\n    }\n    const options = {\n      terrain: {\n        bounds,\n        meshMaxError,\n        elevationDecoder\n      }\n    };\n    if (workerUrl !== null) {\n      options.terrain.workerUrl = workerUrl;\n    }\n    return load(elevationData, TerrainLoader, options);\n  }\n\n  getTiledTerrainData(tile) {\n    const {elevationData, texture, elevationDecoder, meshMaxError, workerUrl} = this.props;\n    const dataUrl = getURLFromTemplate(elevationData, tile);\n    const textureUrl = getURLFromTemplate(texture, tile);\n\n    const {bbox, z} = tile;\n    const viewport = new WebMercatorViewport({\n      longitude: (bbox.west + bbox.east) / 2,\n      latitude: (bbox.north + bbox.south) / 2,\n      zoom: z\n    });\n    const bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);\n    const topRight = viewport.projectFlat([bbox.east, bbox.north]);\n    const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];\n\n    const terrain = this.loadTerrain({\n      elevationData: dataUrl,\n      bounds,\n      elevationDecoder,\n      meshMaxError,\n      workerUrl\n    });\n    const surface = textureUrl\n      ? // If surface image fails to load, the tile should still be displayed\n        load(textureUrl).catch(_ => null)\n      : Promise.resolve(null);\n\n    return Promise.all([terrain, surface]);\n  }\n\n  renderSubLayers(props) {\n    const SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n    const {data, color} = props;\n\n    if (!data) {\n      return null;\n    }\n\n    const [mesh, texture] = data;\n\n    return new SubLayerClass(props, {\n      data: DUMMY_DATA,\n      mesh,\n      texture,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      getPosition: d => [0, 0, 0],\n      getColor: color\n    });\n  }\n\n  // Update zRange of viewport\n  onViewportLoad(data) {\n    if (!data || data.length === 0 || data.every(x => !x)) {\n      return;\n    }\n\n    const {zRange} = this.state;\n    const ranges = data.filter(Boolean).map(arr => {\n      const bounds = arr[0].header.boundingBox;\n      return bounds.map(bound => bound[2]);\n    });\n    const minZ = Math.min(...ranges.map(x => x[0]));\n    const maxZ = Math.max(...ranges.map(x => x[1]));\n\n    if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {\n      this.setState({zRange: [minZ, maxZ]});\n    }\n  }\n\n  renderLayers() {\n    const {\n      color,\n      material,\n      elevationData,\n      texture,\n      wireframe,\n      meshMaxError,\n      elevationDecoder\n    } = this.props;\n\n    if (this.state.isTiled) {\n      return new TileLayer(\n        this.getSubLayerProps({\n          id: 'tiles'\n        }),\n        {\n          wireframe,\n          color,\n          material,\n          getTileData: this.getTiledTerrainData.bind(this),\n          renderSubLayers: this.renderSubLayers.bind(this),\n          updateTriggers: {\n            getTileData: {\n              elevationData: urlTemplateToUpdateTrigger(elevationData),\n              texture: urlTemplateToUpdateTrigger(texture),\n              meshMaxError,\n              elevationDecoder\n            }\n          },\n          onViewportLoad: this.onViewportLoad.bind(this),\n          zRange: this.state.zRange || null\n        }\n      );\n    }\n\n    const SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n    return new SubLayerClass(\n      this.getSubLayerProps({\n        id: 'mesh'\n      }),\n      {\n        data: DUMMY_DATA,\n        mesh: this.state.terrain,\n        texture,\n        _instanced: false,\n        getPosition: d => [0, 0, 0],\n        getColor: color,\n        material,\n        wireframe\n      }\n    );\n  }\n}\n\nTerrainLayer.layerName = 'TerrainLayer';\nTerrainLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}