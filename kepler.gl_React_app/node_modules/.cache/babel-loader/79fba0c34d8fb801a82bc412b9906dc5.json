{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport VectorTile from './mapbox-vector-tile/vector-tile';\nimport { geojsonToBinary } from '@loaders.gl/gis';\nimport Protobuf from 'pbf';\nimport { transformCoordinates, transformToLocalCoordinates } from './transform-to-local-range';\nexport default function parseMVT(arrayBuffer, options) {\n  options = options || {};\n  options.mvt = options.mvt || {};\n  options.gis = options.gis || {};\n  var features = [];\n  if (arrayBuffer.byteLength > 0) {\n    var tile = new VectorTile(new Protobuf(arrayBuffer));\n    var loaderOptions = options.mvt;\n    var selectedLayers = Array.isArray(loaderOptions.layers) ? loaderOptions.layers : Object.keys(tile.layers);\n    selectedLayers.forEach(function (layerName) {\n      var vectorTileLayer = tile.layers[layerName];\n      var featureOptions = _objectSpread(_objectSpread({}, loaderOptions), {}, {\n        layerName: layerName\n      });\n      if (!vectorTileLayer) {\n        return;\n      }\n      for (var i = 0; i < vectorTileLayer.length; i++) {\n        var vectorTileFeature = vectorTileLayer.feature(i);\n        var decodedFeature = getDecodedFeature(vectorTileFeature, featureOptions);\n        features.push(decodedFeature);\n      }\n    });\n  }\n  if (options.gis.format === 'binary') {\n    var data = geojsonToBinary(features);\n    data.byteLength = arrayBuffer.byteLength;\n    return data;\n  }\n  return features;\n}\nfunction getDecodedFeature(feature) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var wgs84Coordinates = options.coordinates === 'wgs84';\n  var hasTileIndex = options.tileIndex && Number.isFinite(options.tileIndex.x) && Number.isFinite(options.tileIndex.y) && Number.isFinite(options.tileIndex.z);\n  if (wgs84Coordinates && !hasTileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property. Check documentation.');\n  }\n  var decodedFeature = wgs84Coordinates && hasTileIndex ? feature.toGeoJSON(options.tileIndex.x, options.tileIndex.y, options.tileIndex.z) : transformCoordinates(feature, transformToLocalCoordinates);\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n  return decodedFeature;\n}","map":{"version":3,"sources":["../../../src/lib/parse-mvt.js"],"names":["VectorTile","geojsonToBinary","Protobuf","transformCoordinates","transformToLocalCoordinates","parseMVT","arrayBuffer","options","mvt","gis","features","byteLength","tile","loaderOptions","selectedLayers","Array","isArray","layers","Object","keys","forEach","vectorTileLayer","layerName","featureOptions","i","length","vectorTileFeature","feature","decodedFeature","getDecodedFeature","push","format","data","wgs84Coordinates","coordinates","hasTileIndex","tileIndex","Number","isFinite","x","y","z","Error","toGeoJSON","layerProperty","properties"],"mappings":"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","sourcesContent":["// import {VectorTile} from '@mapbox/vector-tile';\nimport VectorTile from './mapbox-vector-tile/vector-tile';\n\nimport {geojsonToBinary} from '@loaders.gl/gis';\nimport Protobuf from 'pbf';\nimport {transformCoordinates, transformToLocalCoordinates} from './transform-to-local-range';\n\n/*\n  * Parse MVT arrayBuffer and return GeoJSON.\n  *\n  * @param {arrayBuffer} _ A MVT arrayBuffer\n  * @return {?Object} A GeoJSON geometry object\n  */\nexport default function parseMVT(arrayBuffer, options) {\n  options = options || {};\n  options.mvt = options.mvt || {};\n  options.gis = options.gis || {};\n\n  const features = [];\n\n  if (arrayBuffer.byteLength > 0) {\n    const tile = new VectorTile(new Protobuf(arrayBuffer));\n    const loaderOptions = options.mvt;\n\n    const selectedLayers = Array.isArray(loaderOptions.layers)\n      ? loaderOptions.layers\n      : Object.keys(tile.layers);\n\n    selectedLayers.forEach(layerName => {\n      const vectorTileLayer = tile.layers[layerName];\n      const featureOptions = {...loaderOptions, layerName};\n\n      if (!vectorTileLayer) {\n        return;\n      }\n\n      for (let i = 0; i < vectorTileLayer.length; i++) {\n        const vectorTileFeature = vectorTileLayer.feature(i);\n\n        const decodedFeature = getDecodedFeature(vectorTileFeature, featureOptions);\n        features.push(decodedFeature);\n      }\n    });\n  }\n\n  if (options.gis.format === 'binary') {\n    const data = geojsonToBinary(features);\n    // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n    // TODO decide where to store extra fields like byteLength (header etc) and document\n    // @ts-ignore\n    data.byteLength = arrayBuffer.byteLength;\n    return data;\n  }\n\n  return features;\n}\n\nfunction getDecodedFeature(feature, options = {}) {\n  const wgs84Coordinates = options.coordinates === 'wgs84';\n  const hasTileIndex =\n    options.tileIndex &&\n    Number.isFinite(options.tileIndex.x) &&\n    Number.isFinite(options.tileIndex.y) &&\n    Number.isFinite(options.tileIndex.z);\n\n  if (wgs84Coordinates && !hasTileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property. Check documentation.');\n  }\n\n  const decodedFeature =\n    wgs84Coordinates && hasTileIndex\n      ? feature.toGeoJSON(options.tileIndex.x, options.tileIndex.y, options.tileIndex.z)\n      : transformCoordinates(feature, transformToLocalCoordinates);\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n"]},"metadata":{},"sourceType":"module"}