{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport IconLayer from '../../icon-layer/icon-layer';\nimport fs from './multi-icon-layer-fragment.glsl';\nvar DEFAULT_GAMMA = 0.2;\nvar DEFAULT_BUFFER = 192.0 / 256;\nvar EMPTY_ARRAY = [];\nvar defaultProps = {\n  backgroundColor: {\n    type: 'color',\n    value: null,\n    optional: true\n  },\n  getIconOffsets: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.offsets;\n    }\n  }\n};\nvar MultiIconLayer = function (_IconLayer) {\n  _inherits(MultiIconLayer, _IconLayer);\n  function MultiIconLayer() {\n    _classCallCheck(this, MultiIconLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(MultiIconLayer).apply(this, arguments));\n  }\n  _createClass(MultiIconLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return Object.assign({}, _get(_getPrototypeOf(MultiIconLayer.prototype), \"getShaders\", this).call(this), {\n        inject: {\n          'vs:#decl': \"\\n  uniform float gamma;\\n  varying float vGamma;\\n\",\n          'vs:#main-end': \"\\n  vGamma = gamma / (sizeScale * iconSize.y);\\n\"\n        },\n        fs: fs\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n      _get(_getPrototypeOf(MultiIconLayer.prototype), \"initializeState\", this).call(this);\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instanceOffsets: {\n          size: 2,\n          accessor: 'getIconOffsets'\n        },\n        instancePickingColors: {\n          type: 5121,\n          size: 3,\n          accessor: function accessor(object, _ref) {\n            var index = _ref.index,\n              value = _ref.target;\n            return _this.encodePickingColor(index, value);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(updateParams) {\n      _get(_getPrototypeOf(MultiIconLayer.prototype), \"updateState\", this).call(this, updateParams);\n      var oldProps = updateParams.oldProps,\n        props = updateParams.props;\n      if (props.backgroundColor !== oldProps.backgroundColor) {\n        var backgroundColor = Array.isArray(props.backgroundColor) ? props.backgroundColor.map(function (c) {\n          return c / 255.0;\n        }).slice(0, 3) : null;\n        this.setState({\n          backgroundColor: backgroundColor\n        });\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var sdf = this.props.sdf;\n      var backgroundColor = this.state.backgroundColor;\n      var shouldDrawBackground = Array.isArray(backgroundColor);\n      _get(_getPrototypeOf(MultiIconLayer.prototype), \"draw\", this).call(this, {\n        uniforms: Object.assign({}, uniforms, {\n          buffer: DEFAULT_BUFFER,\n          gamma: DEFAULT_GAMMA,\n          sdf: Boolean(sdf),\n          backgroundColor: backgroundColor || [0, 0, 0],\n          shouldDrawBackground: shouldDrawBackground\n        })\n      });\n    }\n  }, {\n    key: \"getInstanceOffset\",\n    value: function getInstanceOffset(icons) {\n      var _this2 = this;\n      return icons ? Array.from(icons).map(function (icon) {\n        return _get(_getPrototypeOf(MultiIconLayer.prototype), \"getInstanceOffset\", _this2).call(_this2, icon);\n      }) : EMPTY_ARRAY;\n    }\n  }, {\n    key: \"getInstanceColorMode\",\n    value: function getInstanceColorMode(icons) {\n      return 1;\n    }\n  }, {\n    key: \"getInstanceIconFrame\",\n    value: function getInstanceIconFrame(icons) {\n      var _this3 = this;\n      return icons ? Array.from(icons).map(function (icon) {\n        return _get(_getPrototypeOf(MultiIconLayer.prototype), \"getInstanceIconFrame\", _this3).call(_this3, icon);\n      }) : EMPTY_ARRAY;\n    }\n  }]);\n  return MultiIconLayer;\n}(IconLayer);\nexport { MultiIconLayer as default };\nMultiIconLayer.layerName = 'MultiIconLayer';\nMultiIconLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../../src/text-layer/multi-icon-layer/multi-icon-layer.js"],"names":["IconLayer","fs","DEFAULT_GAMMA","DEFAULT_BUFFER","EMPTY_ARRAY","defaultProps","backgroundColor","type","value","optional","getIconOffsets","x","offsets","MultiIconLayer","assign","inject","attributeManager","getAttributeManager","addInstanced","instanceOffsets","size","accessor","instancePickingColors","object","index","target","encodePickingColor","updateParams","oldProps","props","isArray","map","c","slice","setState","uniforms","sdf","state","shouldDrawBackground","Array","buffer","gamma","Boolean","icons","from","icon","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport IconLayer from '../../icon-layer/icon-layer';\n\nimport fs from './multi-icon-layer-fragment.glsl';\n\n// TODO expose as layer properties\nconst DEFAULT_GAMMA = 0.2;\nconst DEFAULT_BUFFER = 192.0 / 256;\nconst EMPTY_ARRAY = [];\n\nconst defaultProps = {\n  backgroundColor: {type: 'color', value: null, optional: true},\n  getIconOffsets: {type: 'accessor', value: x => x.offsets}\n};\n\nexport default class MultiIconLayer extends IconLayer {\n  getShaders() {\n    return Object.assign({}, super.getShaders(), {\n      inject: {\n        'vs:#decl': `\n  uniform float gamma;\n  varying float vGamma;\n`,\n        'vs:#main-end': `\n  vGamma = gamma / (sizeScale * iconSize.y);\n`\n      },\n      fs\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIconOffsets'\n      },\n      instancePickingColors: {\n        type: GL.UNSIGNED_BYTE,\n        size: 3,\n        accessor: (object, {index, target: value}) => this.encodePickingColor(index, value)\n      }\n    });\n  }\n\n  updateState(updateParams) {\n    super.updateState(updateParams);\n    const {oldProps, props} = updateParams;\n\n    if (props.backgroundColor !== oldProps.backgroundColor) {\n      const backgroundColor = Array.isArray(props.backgroundColor)\n        ? props.backgroundColor.map(c => c / 255.0).slice(0, 3)\n        : null;\n      this.setState({backgroundColor});\n    }\n  }\n\n  draw({uniforms}) {\n    const {sdf} = this.props;\n    const {backgroundColor} = this.state;\n    const shouldDrawBackground = Array.isArray(backgroundColor);\n\n    super.draw({\n      uniforms: Object.assign({}, uniforms, {\n        // Refer the following doc about gamma and buffer\n        // https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817\n        buffer: DEFAULT_BUFFER,\n        gamma: DEFAULT_GAMMA,\n        sdf: Boolean(sdf),\n        backgroundColor: backgroundColor || [0, 0, 0],\n        shouldDrawBackground\n      })\n    });\n  }\n\n  getInstanceOffset(icons) {\n    return icons ? Array.from(icons).map(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;\n  }\n\n  getInstanceColorMode(icons) {\n    return 1; // mask\n  }\n\n  getInstanceIconFrame(icons) {\n    return icons ? Array.from(icons).map(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;\n  }\n}\n\nMultiIconLayer.layerName = 'MultiIconLayer';\nMultiIconLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}