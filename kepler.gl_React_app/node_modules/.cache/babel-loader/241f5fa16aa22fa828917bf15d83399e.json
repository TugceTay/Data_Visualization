{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport assert from '../env-utils/assert';\nimport * as node from '../node/buffer-utils.node';\nexport function toArrayBuffer(data) {\n  if (node.toArrayBuffer) {\n    data = node.toArrayBuffer(data);\n  }\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n  if (typeof data === 'string') {\n    var text = data;\n    var uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n  if (data && _typeof(data) === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n  return assert(false);\n}\nexport function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  var array1 = new Uint8Array(arrayBuffer1);\n  var array2 = new Uint8Array(arrayBuffer2);\n  for (var i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function concatenateArrayBuffers() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n  var sourceArrays = sources.map(function (source2) {\n    return source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;\n  });\n  var byteLength = sourceArrays.reduce(function (length, typedArray) {\n    return length + typedArray.byteLength;\n  }, 0);\n  var result = new Uint8Array(byteLength);\n  var offset = 0;\n  var _iterator = _createForOfIteratorHelper(sourceArrays),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var sourceArray = _step.value;\n      result.set(sourceArray, offset);\n      offset += sourceArray.byteLength;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result.buffer;\n}\nexport function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  var subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  var arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}","map":{"version":3,"sources":["../../../../src/lib/binary-utils/array-buffer-utils.js"],"names":["assert","node","toArrayBuffer","data","ArrayBuffer","isView","buffer","text","uint8Array","TextEncoder","encode","_toArrayBuffer","compareArrayBuffers","arrayBuffer1","arrayBuffer2","byteLength","array1","Uint8Array","array2","i","length","concatenateArrayBuffers","sources","sourceArrays","map","source2","reduce","typedArray","result","offset","sourceArray","set","sliceArrayBuffer","arrayBuffer","byteOffset","subArray","undefined","subarray","arrayCopy"],"mappings":"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","sourcesContent":["/** @typedef {import('./array-buffer-utils')} types */\n/* global TextEncoder */\nimport assert from '../env-utils/assert';\nimport * as node from '../node/buffer-utils.node';\n\n/** @type {types['toArrayBuffer']} */\nexport function toArrayBuffer(data) {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    data = node.toArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  return assert(false);\n}\n\n/** @type {types['compareArrayBuffers']} */\nexport function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Concatenate ArrayBuffers\n/** @type {types['concatenateArrayBuffers']} */\nexport function concatenateArrayBuffers(...sources) {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map(\n    source2 => (source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2)\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n// Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\nexport function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n"]},"metadata":{},"sourceType":"module"}