{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nimport { default as JSONParser } from './json-parser';\nimport JSONPath from '../jsonpath/jsonpath';\nvar StreamingJSONParser = function (_JSONParser) {\n  _inherits(StreamingJSONParser, _JSONParser);\n  var _super = _createSuper(StreamingJSONParser);\n  function StreamingJSONParser() {\n    var _this;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, StreamingJSONParser);\n    _this = _super.call(this);\n    var jsonpaths = options.jsonpaths || [];\n    _this.jsonPaths = jsonpaths.map(function (jsonpath) {\n      return new JSONPath(jsonpath);\n    });\n    _this.streamingJsonPath = null;\n    _this.streamingArray = null;\n    _this.topLevelObject = null;\n    _this._extendParser();\n    return _this;\n  }\n  _createClass(StreamingJSONParser, [{\n    key: \"write\",\n    value: function write(chunk) {\n      _get(_getPrototypeOf(StreamingJSONParser.prototype), \"write\", this).call(this, chunk);\n      var array = [];\n      if (this.streamingArray) {\n        array = _toConsumableArray(this.streamingArray);\n        this.streamingArray.length = 0;\n      }\n      return array;\n    }\n  }, {\n    key: \"getPartialResult\",\n    value: function getPartialResult() {\n      return this.topLevelObject;\n    }\n  }, {\n    key: \"getStreamingJsonPath\",\n    value: function getStreamingJsonPath() {\n      return this.streamingJsonPath;\n    }\n  }, {\n    key: \"getStreamingJsonPathAsString\",\n    value: function getStreamingJsonPathAsString() {\n      return this.streamingJsonPath && this.streamingJsonPath.toString();\n    }\n  }, {\n    key: \"getJsonPath\",\n    value: function getJsonPath() {\n      return this.jsonpath;\n    }\n  }, {\n    key: \"_matchJSONPath\",\n    value: function _matchJSONPath() {\n      var currentPath = this.getJsonPath();\n      if (this.jsonPaths.length === 0) {\n        return true;\n      }\n      var _iterator = _createForOfIteratorHelper(this.jsonPaths),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var jsonPath = _step.value;\n          if (jsonPath.equals(currentPath)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"_extendParser\",\n    value: function _extendParser() {\n      var _this2 = this;\n      this.parser.onopenarray = function () {\n        if (!_this2.streamingArray) {\n          if (_this2._matchJSONPath()) {\n            _this2.streamingJsonPath = _this2.getJsonPath().clone();\n            _this2.streamingArray = [];\n            _this2._openArray(_this2.streamingArray);\n            return;\n          }\n        }\n        _this2._openArray();\n      };\n      this.parser.onopenobject = function (name) {\n        if (!_this2.topLevelObject) {\n          _this2.topLevelObject = {};\n          _this2._openObject(_this2.topLevelObject);\n        } else {\n          _this2._openObject({});\n        }\n        if (typeof name !== 'undefined') {\n          _this2.parser.onkey(name);\n        }\n      };\n    }\n  }]);\n  return StreamingJSONParser;\n}(JSONParser);\nexport { StreamingJSONParser as default };","map":{"version":3,"sources":["../../../../src/lib/parser/streaming-json-parser.js"],"names":["default","JSONParser","JSONPath","StreamingJSONParser","options","jsonpaths","jsonPaths","map","jsonpath","streamingJsonPath","streamingArray","topLevelObject","_extendParser","chunk","array","length","toString","currentPath","getJsonPath","jsonPath","equals","parser","onopenarray","_matchJSONPath","clone","_openArray","onopenobject","_openObject","name","onkey"],"mappings":"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","sourcesContent":["import {default as JSONParser} from './json-parser';\nimport JSONPath from '../jsonpath/jsonpath';\n\n/**\n * The `StreamingJSONParser` looks for the first array in the JSON structure.\n * and emits an array of chunks\n */\nexport default class StreamingJSONParser extends JSONParser {\n  constructor(options = {}) {\n    super();\n    const jsonpaths = options.jsonpaths || [];\n    this.jsonPaths = jsonpaths.map(jsonpath => new JSONPath(jsonpath));\n    this.streamingJsonPath = null;\n    this.streamingArray = null;\n    this.topLevelObject = null;\n    this._extendParser();\n  }\n\n  /**\n   * write REDEFINITION\n   * - super.write() chunk to parser\n   * - get the contents (so far) of \"topmost-level\" array as batch of rows\n   * - clear top-level array\n   * - return the batch of rows\\\n   */\n  write(chunk) {\n    super.write(chunk);\n    let array = [];\n    if (this.streamingArray) {\n      array = [...this.streamingArray];\n      this.streamingArray.length = 0;\n    }\n    return array;\n  }\n\n  /**\n   * Returns a partially formed result object\n   * Useful for returning the \"wrapper\" object when array is not top level\n   * e.g. GeoJSON\n   */\n  getPartialResult() {\n    return this.topLevelObject;\n  }\n\n  getStreamingJsonPath() {\n    return this.streamingJsonPath;\n  }\n\n  getStreamingJsonPathAsString() {\n    return this.streamingJsonPath && this.streamingJsonPath.toString();\n  }\n\n  getJsonPath() {\n    return this.jsonpath;\n  }\n\n  // PRIVATE METHODS\n\n  /**\n   * Checks is this.getJsonPath matches the jsonpaths provided in options\n   */\n  _matchJSONPath() {\n    const currentPath = this.getJsonPath();\n    // console.debug(`Testing JSONPath`, currentPath);\n\n    // Backwards compatibility, match any array\n    // TODO implement using wildcard once that is supported\n    if (this.jsonPaths.length === 0) {\n      return true;\n    }\n\n    for (const jsonPath of this.jsonPaths) {\n      if (jsonPath.equals(currentPath)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _extendParser() {\n    // Redefine onopenarray to locate and inject value for top-level array\n    this.parser.onopenarray = () => {\n      if (!this.streamingArray) {\n        if (this._matchJSONPath()) {\n          // @ts-ignore\n          this.streamingJsonPath = this.getJsonPath().clone();\n          this.streamingArray = [];\n          this._openArray(this.streamingArray);\n          return;\n        }\n      }\n\n      this._openArray();\n    };\n\n    // Redefine onopenarray to inject value for top-level object\n    this.parser.onopenobject = name => {\n      if (!this.topLevelObject) {\n        this.topLevelObject = {};\n        this._openObject(this.topLevelObject);\n      } else {\n        this._openObject({});\n      }\n      if (typeof name !== 'undefined') {\n        this.parser.onkey(name);\n      }\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}