{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addNewLayersToSplitMap = addNewLayersToSplitMap;\nexports.removeLayerFromSplitMaps = removeLayerFromSplitMaps;\nexports.getInitialMapLayersForSplitMap = getInitialMapLayersForSplitMap;\nexports.computeSplitMapLayers = computeSplitMapLayers;\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.clonedeep\"));\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n/**\n * Add new layers to both existing maps\n * @param {Object} splitMaps\n * @param {Object|Array<Object>} layers\n * @returns {Array<Object>} new splitMaps\n */\nfunction addNewLayersToSplitMap(splitMaps, layers) {\n  var newLayers = Array.isArray(layers) ? layers : [layers];\n  if (!splitMaps.length || !newLayers.length) {\n    return splitMaps;\n  } // add new layer to both maps,\n  // don't override, if layer.id is already in splitMaps\n\n  return splitMaps.map(function (settings) {\n    return _objectSpread(_objectSpread({}, settings), {}, {\n      layers: _objectSpread(_objectSpread({}, settings.layers), newLayers.reduce(function (accu, newLayer) {\n        return (\n          // @ts-ignore\n          newLayer.id in settings.layers || !newLayer.config.isVisible ? accu : _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, newLayer.id, newLayer.config.isVisible))\n        );\n      }, {}))\n    });\n  });\n}\n/**\n * Remove an existing layer from split map settings\n * @param {Object} splitMaps\n * @param {Object} layer\n * @returns {Object} Maps of custom layer objects\n */\n\nfunction removeLayerFromSplitMaps(splitMaps, layer) {\n  if (!splitMaps.length) {\n    return splitMaps;\n  }\n  return splitMaps.map(function (settings) {\n    // eslint-disable-next-line no-unused-vars\n    var _settings$layers = settings.layers,\n      _layer$id = layer.id,\n      _ = _settings$layers[_layer$id],\n      newLayers = (0, _objectWithoutProperties2[\"default\"])(_settings$layers, [_layer$id].map(_toPropertyKey));\n    return _objectSpread(_objectSpread({}, settings), {}, {\n      layers: newLayers\n    });\n  });\n}\n/**\n * This method will compute the default maps layer settings\n * based on the current layers visibility\n * @param {Array<Object>} layers\n * @returns {Array<Object>} layer visibility for each panel\n */\n\nfunction getInitialMapLayersForSplitMap(layers) {\n  return layers.filter(function (layer) {\n    return layer.config.isVisible;\n  }).reduce(function (newLayers, currentLayer) {\n    return _objectSpread(_objectSpread({}, newLayers), {}, (0, _defineProperty2[\"default\"])({}, currentLayer.id, currentLayer.config.isVisible));\n  }, {});\n}\n/**\n * This method will get default splitMap settings based on existing layers\n * @param {Array<Object>} layers\n * @returns {Array<Object>} split map settings\n */\n\nfunction computeSplitMapLayers(layers) {\n  var mapLayers = getInitialMapLayersForSplitMap(layers);\n  return [{\n    layers: mapLayers\n  }, {\n    layers: (0, _lodash[\"default\"])(mapLayers)\n  }];\n}","map":{"version":3,"sources":["../../src/utils/split-map-utils.js"],"names":["addNewLayersToSplitMap","splitMaps","layers","newLayers","Array","isArray","length","map","settings","reduce","accu","newLayer","id","config","isVisible","removeLayerFromSplitMaps","layer","_","getInitialMapLayersForSplitMap","filter","currentLayer","computeSplitMapLayers","mapLayers"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport cloneDeep from 'lodash.clonedeep';\n\n/**\n * Add new layers to both existing maps\n * @param {Object} splitMaps\n * @param {Object|Array<Object>} layers\n * @returns {Array<Object>} new splitMaps\n */\nexport function addNewLayersToSplitMap(splitMaps, layers) {\n  const newLayers = Array.isArray(layers) ? layers : [layers];\n\n  if (!splitMaps.length || !newLayers.length) {\n    return splitMaps;\n  }\n\n  // add new layer to both maps,\n  // don't override, if layer.id is already in splitMaps\n  return splitMaps.map(settings => ({\n    ...settings,\n    layers: {\n      ...settings.layers,\n      ...newLayers.reduce(\n        (accu, newLayer) =>\n          // @ts-ignore\n          newLayer.id in settings.layers || !newLayer.config.isVisible\n            ? accu\n            : {\n                ...accu,\n                [newLayer.id]: newLayer.config.isVisible\n              },\n        {}\n      )\n    }\n  }));\n}\n\n/**\n * Remove an existing layer from split map settings\n * @param {Object} splitMaps\n * @param {Object} layer\n * @returns {Object} Maps of custom layer objects\n */\nexport function removeLayerFromSplitMaps(splitMaps, layer) {\n  if (!splitMaps.length) {\n    return splitMaps;\n  }\n  return splitMaps.map(settings => {\n    // eslint-disable-next-line no-unused-vars\n    const {[layer.id]: _, ...newLayers} = settings.layers;\n    return {\n      ...settings,\n      layers: newLayers\n    };\n  });\n}\n\n/**\n * This method will compute the default maps layer settings\n * based on the current layers visibility\n * @param {Array<Object>} layers\n * @returns {Array<Object>} layer visibility for each panel\n */\nexport function getInitialMapLayersForSplitMap(layers) {\n  return layers\n    .filter(layer => layer.config.isVisible)\n    .reduce(\n      (newLayers, currentLayer) => ({\n        ...newLayers,\n        [currentLayer.id]: currentLayer.config.isVisible\n      }),\n      {}\n    );\n}\n\n/**\n * This method will get default splitMap settings based on existing layers\n * @param {Array<Object>} layers\n * @returns {Array<Object>} split map settings\n */\nexport function computeSplitMapLayers(layers) {\n  const mapLayers = getInitialMapLayersForSplitMap(layers);\n\n  return [{layers: mapLayers}, {layers: cloneDeep(mapLayers)}];\n}\n"]},"metadata":{},"sourceType":"script"}