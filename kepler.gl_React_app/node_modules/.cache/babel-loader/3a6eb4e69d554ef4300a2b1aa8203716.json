{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { log } from '@deck.gl/core';\nimport { ColumnLayer } from '@deck.gl/layers';\nimport { defaultColorRange } from '../utils/color-utils';\nimport { pointToHexbin } from './hexagon-aggregator';\nimport CPUAggregator from '../utils/cpu-aggregator';\nimport AggregationLayer from '../aggregation-layer';\nfunction nop() {}\nvar defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {\n    type: 'accessor',\n    value: null\n  },\n  getColorWeight: {\n    type: 'accessor',\n    value: function value(x) {\n      return 1;\n    }\n  },\n  colorAggregation: 'SUM',\n  lowerPercentile: {\n    type: 'number',\n    value: 0,\n    min: 0,\n    max: 100\n  },\n  upperPercentile: {\n    type: 'number',\n    value: 100,\n    min: 0,\n    max: 100\n  },\n  colorScaleType: 'quantize',\n  onSetColorDomain: nop,\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {\n    type: 'accessor',\n    value: null\n  },\n  getElevationWeight: {\n    type: 'accessor',\n    value: function value(x) {\n      return 1;\n    }\n  },\n  elevationAggregation: 'SUM',\n  elevationLowerPercentile: {\n    type: 'number',\n    value: 0,\n    min: 0,\n    max: 100\n  },\n  elevationUpperPercentile: {\n    type: 'number',\n    value: 100,\n    min: 0,\n    max: 100\n  },\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  elevationScaleType: 'linear',\n  onSetElevationDomain: nop,\n  radius: {\n    type: 'number',\n    value: 1000,\n    min: 1\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  extruded: false,\n  hexagonAggregator: pointToHexbin,\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  material: true,\n  _filterData: {\n    type: 'function',\n    value: null,\n    optional: true\n  }\n};\nvar HexagonLayer = function (_AggregationLayer) {\n  _inherits(HexagonLayer, _AggregationLayer);\n  function HexagonLayer() {\n    _classCallCheck(this, HexagonLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(HexagonLayer).apply(this, arguments));\n  }\n  _createClass(HexagonLayer, [{\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var cpuAggregator = new CPUAggregator({\n        getAggregator: function getAggregator(props) {\n          return props.hexagonAggregator;\n        },\n        getCellSize: function getCellSize(props) {\n          return props.radius;\n        }\n      });\n      this.state = {\n        cpuAggregator: cpuAggregator,\n        aggregatorState: cpuAggregator.state,\n        hexagonVertices: null\n      };\n      var attributeManager = this.getAttributeManager();\n      attributeManager.add({\n        positions: {\n          size: 3,\n          accessor: 'getPosition'\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      _get(_getPrototypeOf(HexagonLayer.prototype), \"updateState\", this).call(this, opts);\n      var _this$state = this.state,\n        cpuAggregator = _this$state.cpuAggregator,\n        oldVertices = _this$state.hexagonVertices;\n      if (opts.changeFlags.propsOrDataChanged) {\n        this.setState({\n          aggregatorState: cpuAggregator.updateState(opts, {\n            viewport: this.context.viewport,\n            attributes: this.getAttributes()\n          })\n        });\n      }\n      var _ref2 = cpuAggregator.state.layerData || {},\n        hexagonVertices = _ref2.hexagonVertices;\n      if (hexagonVertices && oldVertices !== hexagonVertices) {\n        var vertices = this.convertLatLngToMeterOffset(hexagonVertices);\n        if (vertices) {\n          this.setState({\n            hexagonVertices: hexagonVertices,\n            vertices: vertices\n          });\n        }\n      } else {\n        this.updateRadiusAngle();\n      }\n    }\n  }, {\n    key: \"updateRadiusAngle\",\n    value: function updateRadiusAngle(vertices) {\n      var viewport = this.context.viewport;\n      var _viewport$getDistance = viewport.getDistanceScales(),\n        unitsPerMeter = _viewport$getDistance.unitsPerMeter;\n      var cpuAggregator = this.state.cpuAggregator;\n      if (cpuAggregator.state.layerData && cpuAggregator.state.layerData.radiusCommon) {\n        var radiusCommon = cpuAggregator.state.layerData.radiusCommon;\n        var radius = radiusCommon / unitsPerMeter[0];\n        this.setState({\n          angle: 90,\n          radius: radius\n        });\n      }\n    }\n  }, {\n    key: \"convertLatLngToMeterOffset\",\n    value: function convertLatLngToMeterOffset(hexagonVertices) {\n      var viewport = this.context.viewport;\n      if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {\n        var vertex0 = hexagonVertices[0];\n        var vertex3 = hexagonVertices[3];\n        var centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];\n        var centroidFlat = viewport.projectFlat(centroid);\n        var _viewport$getDistance2 = viewport.getDistanceScales(centroid),\n          metersPerUnit = _viewport$getDistance2.metersPerUnit;\n        var vertices = hexagonVertices.map(function (vt) {\n          var vtFlat = viewport.projectFlat(vt);\n          return [(vtFlat[0] - centroidFlat[0]) * metersPerUnit[0], (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]];\n        });\n        return vertices;\n      }\n      log.error('HexagonLayer: hexagonVertices needs to be an array of 6 points')();\n      return null;\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info;\n      return this.state.cpuAggregator.getPickingInfo({\n        info: info\n      });\n    }\n  }, {\n    key: \"_onGetSublayerColor\",\n    value: function _onGetSublayerColor(cell) {\n      return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n    }\n  }, {\n    key: \"_onGetSublayerElevation\",\n    value: function _onGetSublayerElevation(cell) {\n      return this.state.cpuAggregator.getAccessor('elevation')(cell);\n    }\n  }, {\n    key: \"_getSublayerUpdateTriggers\",\n    value: function _getSublayerUpdateTriggers() {\n      return this.state.cpuAggregator.getUpdateTriggers(this.props);\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$props = this.props,\n        elevationScale = _this$props.elevationScale,\n        extruded = _this$props.extruded,\n        coverage = _this$props.coverage,\n        material = _this$props.material,\n        transitions = _this$props.transitions;\n      var _this$state2 = this.state,\n        angle = _this$state2.angle,\n        radius = _this$state2.radius,\n        cpuAggregator = _this$state2.cpuAggregator,\n        vertices = _this$state2.vertices;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n      var updateTriggers = this._getSublayerUpdateTriggers();\n      var geometry = vertices && vertices.length ? {\n        vertices: vertices,\n        radius: 1\n      } : {\n        radius: radius,\n        angle: angle\n      };\n      return new SubLayerClass(_objectSpread({}, geometry, {\n        diskResolution: 6,\n        elevationScale: elevationScale,\n        extruded: extruded,\n        coverage: coverage,\n        material: material,\n        getFillColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        }\n      }), this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers: updateTriggers\n      }), {\n        data: cpuAggregator.state.layerData.data\n      });\n    }\n  }]);\n  return HexagonLayer;\n}(AggregationLayer);\nexport { HexagonLayer as default };\nHexagonLayer.layerName = 'HexagonLayer';\nHexagonLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/hexagon-layer/hexagon-layer.js"],"names":["log","ColumnLayer","defaultColorRange","pointToHexbin","CPUAggregator","AggregationLayer","nop","defaultProps","colorDomain","colorRange","getColorValue","type","value","getColorWeight","colorAggregation","lowerPercentile","min","max","upperPercentile","colorScaleType","onSetColorDomain","elevationDomain","elevationRange","getElevationValue","getElevationWeight","elevationAggregation","elevationLowerPercentile","elevationUpperPercentile","elevationScale","elevationScaleType","onSetElevationDomain","radius","coverage","extruded","hexagonAggregator","getPosition","x","position","material","_filterData","optional","HexagonLayer","changeFlags","somethingChanged","cpuAggregator","getAggregator","props","getCellSize","state","aggregatorState","hexagonVertices","attributeManager","getAttributeManager","add","positions","size","accessor","opts","oldVertices","propsOrDataChanged","setState","updateState","viewport","context","attributes","getAttributes","layerData","vertices","convertLatLngToMeterOffset","updateRadiusAngle","unitsPerMeter","getDistanceScales","radiusCommon","angle","Array","isArray","length","vertex0","vertex3","centroid","centroidFlat","projectFlat","metersPerUnit","map","vtFlat","vt","error","info","getPickingInfo","cell","getAccessor","getUpdateTriggers","transitions","SubLayerClass","getSubLayerClass","updateTriggers","_getSublayerUpdateTriggers","geometry","diskResolution","getFillColor","_onGetSublayerColor","bind","getElevation","_onGetSublayerElevation","getSubLayerProps","id","data","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {log} from '@deck.gl/core';\nimport {ColumnLayer} from '@deck.gl/layers';\n\nimport {defaultColorRange} from '../utils/color-utils';\n\nimport {pointToHexbin} from './hexagon-aggregator';\nimport CPUAggregator from '../utils/cpu-aggregator';\nimport AggregationLayer from '../aggregation-layer';\n\nfunction nop() {}\n\nconst defaultProps = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {type: 'accessor', value: null}, // default value is calcuated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {type: 'accessor', value: x => 1},\n  colorAggregation: 'SUM',\n  lowerPercentile: {type: 'number', value: 0, min: 0, max: 100},\n  upperPercentile: {type: 'number', value: 100, min: 0, max: 100},\n  colorScaleType: 'quantize',\n  onSetColorDomain: nop,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {type: 'accessor', value: null}, // default value is calcuated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {type: 'accessor', value: x => 1},\n  elevationAggregation: 'SUM',\n  elevationLowerPercentile: {type: 'number', value: 0, min: 0, max: 100},\n  elevationUpperPercentile: {type: 'number', value: 100, min: 0, max: 100},\n  elevationScale: {type: 'number', min: 0, value: 1},\n  elevationScaleType: 'linear',\n  onSetElevationDomain: nop,\n\n  radius: {type: 'number', value: 1000, min: 1},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  extruded: false,\n  hexagonAggregator: pointToHexbin,\n  getPosition: {type: 'accessor', value: x => x.position},\n  // Optional material for 'lighting' shader module\n  material: true,\n\n  // data filter\n  _filterData: {type: 'function', value: null, optional: true}\n};\n\nexport default class HexagonLayer extends AggregationLayer {\n  shouldUpdateState({changeFlags}) {\n    return changeFlags.somethingChanged;\n  }\n  initializeState() {\n    const cpuAggregator = new CPUAggregator({\n      getAggregator: props => props.hexagonAggregator,\n      getCellSize: props => props.radius\n    });\n\n    this.state = {\n      cpuAggregator,\n      aggregatorState: cpuAggregator.state,\n      hexagonVertices: null\n    };\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {size: 3, accessor: 'getPosition'}\n    });\n    // color and elevation attributes can't be added as attributes\n    // they are calculated using 'getValue' accessor that takes an array of pints.\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n    const {cpuAggregator, hexagonVertices: oldVertices} = this.state;\n\n    if (opts.changeFlags.propsOrDataChanged) {\n      this.setState({\n        // make a copy of the internal state of cpuAggregator for testing\n        aggregatorState: cpuAggregator.updateState(opts, {\n          viewport: this.context.viewport,\n          attributes: this.getAttributes()\n        })\n      });\n    }\n\n    // if user provided custom aggregator and returns hexagonVertices,\n    // Need to recalculate radius and angle based on vertices\n    const {hexagonVertices} = cpuAggregator.state.layerData || {};\n\n    if (hexagonVertices && oldVertices !== hexagonVertices) {\n      const vertices = this.convertLatLngToMeterOffset(hexagonVertices);\n      if (vertices) {\n        this.setState({\n          hexagonVertices,\n          vertices\n        });\n      }\n    } else {\n      // update radius angle by viewport\n      this.updateRadiusAngle();\n    }\n  }\n\n  updateRadiusAngle(vertices) {\n    const {viewport} = this.context;\n    const {unitsPerMeter} = viewport.getDistanceScales();\n    const {cpuAggregator} = this.state;\n\n    if (cpuAggregator.state.layerData && cpuAggregator.state.layerData.radiusCommon) {\n      const {radiusCommon} = cpuAggregator.state.layerData;\n      const radius = radiusCommon / unitsPerMeter[0];\n\n      // convert radius in common to meter\n      this.setState({angle: 90, radius});\n    }\n  }\n\n  convertLatLngToMeterOffset(hexagonVertices) {\n    const {viewport} = this.context;\n    if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {\n      // get centroid of hexagons\n      const vertex0 = hexagonVertices[0];\n      const vertex3 = hexagonVertices[3];\n\n      const centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];\n      const centroidFlat = viewport.projectFlat(centroid);\n\n      const {metersPerUnit} = viewport.getDistanceScales(centroid);\n\n      // offset all points by centroid to meter offset\n      const vertices = hexagonVertices.map(vt => {\n        const vtFlat = viewport.projectFlat(vt);\n\n        return [\n          (vtFlat[0] - centroidFlat[0]) * metersPerUnit[0],\n          (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]\n        ];\n      });\n\n      return vertices;\n    }\n\n    log.error('HexagonLayer: hexagonVertices needs to be an array of 6 points')();\n    return null;\n  }\n\n  getPickingInfo({info}) {\n    return this.state.cpuAggregator.getPickingInfo({info});\n  }\n\n  // create a method for testing\n  _onGetSublayerColor(cell) {\n    return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n  }\n\n  // create a method for testing\n  _onGetSublayerElevation(cell) {\n    return this.state.cpuAggregator.getAccessor('elevation')(cell);\n  }\n\n  _getSublayerUpdateTriggers() {\n    return this.state.cpuAggregator.getUpdateTriggers(this.props);\n  }\n\n  renderLayers() {\n    const {elevationScale, extruded, coverage, material, transitions} = this.props;\n    const {angle, radius, cpuAggregator, vertices} = this.state;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const updateTriggers = this._getSublayerUpdateTriggers();\n\n    const geometry = vertices && vertices.length ? {vertices, radius: 1} : {radius, angle};\n    return new SubLayerClass(\n      {\n        ...geometry,\n        diskResolution: 6,\n        elevationScale,\n        extruded,\n        coverage,\n        material,\n\n        getFillColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        }\n      },\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers\n      }),\n      {\n        data: cpuAggregator.state.layerData.data\n      }\n    );\n  }\n}\n\nHexagonLayer.layerName = 'HexagonLayer';\nHexagonLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}