{"ast":null,"code":"import { Vector2, Vector3, clamp, _MathUtils } from '@math.gl/core';\nimport assert from '../utils/assert';\nvar RIGHT_SHIFT = 1.0 / 256.0;\nvar LEFT_SHIFT = 256.0;\nvar scratchVector2 = new Vector2();\nvar scratchVector3 = new Vector3();\nvar scratchEncodeVector2 = new Vector2();\nvar octEncodeScratch = new Vector2();\nvar uint8ForceArray = new Uint8Array(1);\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\nfunction fromSNorm(value) {\n  var rangeMaximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 255;\n  return clamp(value, 0.0, rangeMaximum) / rangeMaximum * 2.0 - 1.0;\n}\nfunction toSNorm(value) {\n  var rangeMaximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 255;\n  return Math.round((clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum);\n}\nfunction signNotZero(value) {\n  return value < 0.0 ? -1.0 : 1.0;\n}\nexport function octEncodeInRange(vector, rangeMax, result) {\n  assert(vector);\n  assert(result);\n  var vector3 = scratchVector3.from(vector);\n  assert(Math.abs(vector3.magnitudeSquared() - 1.0) <= _MathUtils.EPSILON6);\n  result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  if (vector.z < 0) {\n    var x = result.x;\n    var y = result.y;\n    result.x = (1.0 - Math.abs(y)) * signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * signNotZero(y);\n  }\n  result.x = toSNorm(result.x, rangeMax);\n  result.y = toSNorm(result.y, rangeMax);\n  return result;\n}\nexport function octEncode(vector, result) {\n  return octEncodeInRange(vector, 255, result);\n}\nexport function octEncodeToVector4(vector, result) {\n  octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n}\nexport function octDecodeInRange(x, y, rangeMax, result) {\n  assert(result);\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new Error(\"x and y must be unsigned normalized integers between 0 and \".concat(rangeMax));\n  }\n  result.x = fromSNorm(x, rangeMax);\n  result.y = fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n  if (result.z < 0.0) {\n    var oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * signNotZero(result.y);\n  }\n  return result.normalize();\n}\nexport function octDecode(x, y, result) {\n  return octDecodeInRange(x, y, 255, result);\n}\nexport function octDecodeFromVector4(encoded, result) {\n  assert(encoded);\n  assert(result);\n  var x = encoded.x;\n  var y = encoded.y;\n  var z = encoded.z;\n  var w = encoded.w;\n  if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {\n    throw new Error('x, y, z, and w must be unsigned normalized integers between 0 and 255');\n  }\n  var xOct16 = x * LEFT_SHIFT + y;\n  var yOct16 = z * LEFT_SHIFT + w;\n  return octDecodeInRange(xOct16, yOct16, 65535, result);\n}\nexport function octPackFloat(encoded) {\n  var vector2 = scratchVector2.from(encoded);\n  return 256.0 * vector2.x + vector2.y;\n}\nexport function octEncodeFloat(vector) {\n  octEncode(vector, scratchEncodeVector2);\n  return octPackFloat(scratchEncodeVector2);\n}\nexport function octDecodeFloat(value, result) {\n  assert(Number.isFinite(value));\n  var temp = value / 256.0;\n  var x = Math.floor(temp);\n  var y = (temp - x) * 256.0;\n  return octDecode(x, y, result);\n}\nexport function octPack(v1, v2, v3, result) {\n  assert(v1);\n  assert(v2);\n  assert(v3);\n  assert(result);\n  var encoded1 = octEncodeFloat(v1);\n  var encoded2 = octEncodeFloat(v2);\n  var encoded3 = octEncode(v3, scratchEncodeVector2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n}\nexport function octUnpack(packed, v1, v2, v3) {\n  var temp = packed.x / 65536.0;\n  var x = Math.floor(temp);\n  var encodedFloat1 = (temp - x) * 65536.0;\n  temp = packed.y / 65536.0;\n  var y = Math.floor(temp);\n  var encodedFloat2 = (temp - y) * 65536.0;\n  octDecodeFloat(encodedFloat1, v1);\n  octDecodeFloat(encodedFloat2, v2);\n  octDecode(x, y, v3);\n}\nexport function compressTextureCoordinates(textureCoordinates) {\n  var x = textureCoordinates.x * 4095.0 | 0;\n  var y = textureCoordinates.y * 4095.0 | 0;\n  return 4096.0 * x + y;\n}\nexport function decompressTextureCoordinates(compressed, result) {\n  var temp = compressed / 4096.0;\n  var xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n}\nexport function zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer) {\n  assert(uBuffer);\n  assert(vBuffer);\n  assert(uBuffer.length === vBuffer.length);\n  if (heightBuffer) {\n    assert(uBuffer.length === heightBuffer.length);\n  }\n  function zigZagDecode(value) {\n    return value >> 1 ^ -(value & 1);\n  }\n  var u = 0;\n  var v = 0;\n  var height = 0;\n  for (var i = 0; i < uBuffer.length; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n    if (heightBuffer) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/geometry/compression/attribute-compression.js"],"names":["Vector2","Vector3","clamp","_MathUtils","assert","RIGHT_SHIFT","LEFT_SHIFT","scratchVector2","scratchVector3","scratchEncodeVector2","octEncodeScratch","uint8ForceArray","Uint8Array","forceUint8","value","fromSNorm","rangeMaximum","toSNorm","Math","round","signNotZero","octEncodeInRange","vector","rangeMax","result","vector3","from","abs","magnitudeSquared","EPSILON6","x","y","z","octEncode","octEncodeToVector4","w","octDecodeInRange","Error","oldVX","normalize","octDecode","octDecodeFromVector4","encoded","xOct16","yOct16","octPackFloat","vector2","octEncodeFloat","octDecodeFloat","Number","isFinite","temp","floor","octPack","v1","v2","v3","encoded1","encoded2","encoded3","octUnpack","packed","encodedFloat1","encodedFloat2","compressTextureCoordinates","textureCoordinates","decompressTextureCoordinates","compressed","xZeroTo4095","zigZagDeltaDecode","uBuffer","vBuffer","heightBuffer","length","zigZagDecode","u","v","height","i"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// Attribute compression and decompression functions.\n\n/** @typedef {import('@math.gl/core')} mathgl_core */\nimport {Vector2, Vector3, clamp, _MathUtils} from '@math.gl/core';\nimport assert from '../utils/assert';\n\nconst RIGHT_SHIFT = 1.0 / 256.0;\nconst LEFT_SHIFT = 256.0;\n\nconst scratchVector2 = new Vector2();\nconst scratchVector3 = new Vector3();\nconst scratchEncodeVector2 = new Vector2();\nconst octEncodeScratch = new Vector2();\n\nconst uint8ForceArray = new Uint8Array(1);\n\n// Force a value to Uint8\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n\n/**\n * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].\n * @param {Number} value SNORM value in the range [0, rangeMaximum]\n * @param {Number} [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.\n * @returns {Number} Scalar in the range [-1.0, 1.0].\n *\n * @see CesiumMath.toSNorm\n */\nfunction fromSNorm(value, rangeMaximum = 255) {\n  return (clamp(value, 0.0, rangeMaximum) / rangeMaximum) * 2.0 - 1.0;\n}\n\n/**\n * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]\n * @param {Number} value The scalar value in the range [-1.0, 1.0]\n * @param {Number} [rangeMaximum=255] The maximum value in the mapped range, 255 by default.\n * @returns {Number} A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.\n *\n * @see CesiumMath.fromSNorm\n */\nfunction toSNorm(value, rangeMaximum = 255) {\n  return Math.round((clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum);\n}\n\n/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n * This is similar to `Math.sign` except that returns 1.0 instead of\n * 0.0 when the input value is 0.0.\n * @param {Number} value The value to return the sign of.\n * @returns {Number} The sign of value.\n */\nfunction signNotZero(value) {\n  return value < 0.0 ? -1.0 : 1.0;\n}\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param {Vector3} vector The normalized vector to be compressed into 2 component 'oct' encoding.\n * @param {Vector2} result The 2 component oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns {Vector2} The 2 component oct-encoded unit length vector.\n *\n * @exception {Error} vector must be normalized.\n *\n * @see octDecodeInRange\n */\nexport function octEncodeInRange(vector, rangeMax, result) {\n  assert(vector);\n  assert(result);\n\n  const vector3 = scratchVector3.from(vector);\n\n  assert(Math.abs(vector3.magnitudeSquared() - 1.0) <= _MathUtils.EPSILON6);\n\n  result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n\n  if (vector.z < 0) {\n    const x = result.x;\n    const y = result.y;\n    result.x = (1.0 - Math.abs(y)) * signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * signNotZero(y);\n  }\n\n  result.x = toSNorm(result.x, rangeMax);\n  result.y = toSNorm(result.y, rangeMax);\n\n  return result;\n}\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n *\n * @param {Vector3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @param {Vector2} result The 2 byte oct-encoded unit length vector.\n * @returns {Vector2} The 2 byte oct-encoded unit length vector.\n *\n * @exception {Error} vector must be normalized.\n *\n * @see octEncodeInRange\n * @see octDecode\n */\nexport function octEncode(vector, result) {\n  return octEncodeInRange(vector, 255, result);\n}\n\n/**\n * @param {Vector3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.\n * @param {mathgl_core['Vector4']} result The 4 byte oct-encoded unit length vector.\n * @returns {mathgl_core['Vector4']} The 4 byte oct-encoded unit length vector.\n *\n * @exception {Error} vector must be normalized.\n *\n * @see octEncodeInRange\n * @see octDecodeFromVector4\n */\nexport function octEncodeToVector4(vector, result) {\n  octEncodeInRange(vector, 65535, octEncodeScratch);\n  // @ts-ignore\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  // @ts-ignore\n  result.y = forceUint8(octEncodeScratch.x);\n  // @ts-ignore\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  // @ts-ignore\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n}\n\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param {Vector3} result The decoded and normalized vector\n * @returns {Vector3} The decoded and normalized vector.\n *\n * @exception {Error} x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see octEncodeInRange\n */\nexport function octDecodeInRange(x, y, rangeMax, result) {\n  assert(result);\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new Error(`x and y must be unsigned normalized integers between 0 and ${rangeMax}`);\n  }\n\n  result.x = fromSNorm(x, rangeMax);\n  result.y = fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    const oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * signNotZero(result.y);\n  }\n\n  return result.normalize();\n}\n\n/**\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Vector3} result The decoded and normalized vector.\n * @returns {Vector3} The decoded and normalized vector.\n *\n * @exception {Error} x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see octDecodeInRange\n */\nexport function octDecode(x, y, result) {\n  return octDecodeInRange(x, y, 255, result);\n}\n\n/**\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {mathgl_core['Vector4']} encoded The oct-encoded unit length vector.\n * @param {Vector3} result The decoded and normalized vector.\n * @returns {Vector3} The decoded and normalized vector.\n *\n * @exception {Error} x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see octDecodeInRange\n * @see octEncodeToVector4\n */\nexport function octDecodeFromVector4(encoded, result) {\n  assert(encoded);\n  assert(result);\n  // @ts-ignore\n  const x = encoded.x;\n  // @ts-ignore\n  const y = encoded.y;\n  // @ts-ignore\n  const z = encoded.z;\n  // @ts-ignore\n  const w = encoded.w;\n  // @ts-ignore\n  if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {\n    throw new Error('x, y, z, and w must be unsigned normalized integers between 0 and 255');\n  }\n\n  const xOct16 = x * LEFT_SHIFT + y;\n  const yOct16 = z * LEFT_SHIFT + w;\n  return octDecodeInRange(xOct16, yOct16, 65535, result);\n}\n\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param {Vector2} encoded The oct encoded vector.\n * @returns {Number} The oct encoded vector packed into a single float.\n *\n */\nexport function octPackFloat(encoded) {\n  const vector2 = scratchVector2.from(encoded);\n  return 256.0 * vector2.x + vector2.y;\n}\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n * stores those values in a single float-point number.\n *\n * @param {Vector3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @returns {Number} The 2 byte oct-encoded unit length vector.\n *\n * @exception {Error} vector must be normalized.\n */\nexport function octEncodeFloat(vector) {\n  octEncode(vector, scratchEncodeVector2);\n  return octPackFloat(scratchEncodeVector2);\n}\n\n/**\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param {Number} value The oct-encoded unit length vector stored as a single floating-point number.\n * @param {Vector3} result The decoded and normalized vector\n * @returns {Vector3} The decoded and normalized vector.\n *\n */\nexport function octDecodeFloat(value, result) {\n  assert(Number.isFinite(value));\n\n  const temp = value / 256.0;\n  const x = Math.floor(temp);\n  const y = (temp - x) * 256.0;\n\n  return octDecode(x, y, result);\n}\n\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n * packs those into two floating-point numbers.\n *\n * @param {Vector3} v1 A normalized vector to be compressed.\n * @param {Vector3} v2 A normalized vector to be compressed.\n * @param {Vector3} v3 A normalized vector to be compressed.\n * @param {Vector2} result The 'oct' encoded vectors packed into two floating-point numbers.\n * @returns {Vector2} The 'oct' encoded vectors packed into two floating-point numbers.\n *\n */\nexport function octPack(v1, v2, v3, result) {\n  assert(v1);\n  assert(v2);\n  assert(v3);\n  assert(result);\n\n  const encoded1 = octEncodeFloat(v1);\n  const encoded2 = octEncodeFloat(v2);\n\n  const encoded3 = octEncode(v3, scratchEncodeVector2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n}\n\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param {Vector2} packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param {Vector3} v1 One decoded and normalized vector.\n * @param {Vector3} v2 One decoded and normalized vector.\n * @param {Vector3} v3 One decoded and normalized vector.\n */\nexport function octUnpack(packed, v1, v2, v3) {\n  let temp = packed.x / 65536.0;\n  const x = Math.floor(temp);\n  const encodedFloat1 = (temp - x) * 65536.0;\n\n  temp = packed.y / 65536.0;\n  const y = Math.floor(temp);\n  const encodedFloat2 = (temp - y) * 65536.0;\n\n  octDecodeFloat(encodedFloat1, v1);\n  octDecodeFloat(encodedFloat2, v2);\n  octDecode(x, y, v3);\n}\n\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param {Vector2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns {Number} The packed texture coordinates.\n *\n */\nexport function compressTextureCoordinates(textureCoordinates) {\n  // Move x and y to the range 0-4095;\n  const x = (textureCoordinates.x * 4095.0) | 0;\n  const y = (textureCoordinates.y * 4095.0) | 0;\n  return 4096.0 * x + y;\n}\n\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param {Number} compressed The compressed texture coordinates.\n * @param {Vector2} result The decompressed texture coordinates.\n * @returns {Vector2} The modified result parameter.\n *\n */\nexport function decompressTextureCoordinates(compressed, result) {\n  const temp = compressed / 4096.0;\n  const xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n}\n\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param {Uint16Array} uBuffer The buffer view of u values.\n * @param {Uint16Array} vBuffer The buffer view of v values.\n * @param {Uint16Array} [heightBuffer] The buffer view of height values.\n *\n * @see {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh|quantized-mesh-1.0 terrain format}\n */\nexport function zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer) {\n  assert(uBuffer);\n  assert(vBuffer);\n  assert(uBuffer.length === vBuffer.length);\n  if (heightBuffer) {\n    assert(uBuffer.length === heightBuffer.length);\n  }\n\n  function zigZagDecode(value) {\n    return (value >> 1) ^ -(value & 1);\n  }\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < uBuffer.length; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if (heightBuffer) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}