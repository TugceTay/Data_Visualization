{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport log from '../utils/log';\nimport { createMat4, extractCameraVectors, getFrustumPlanes as _getFrustumPlanes } from '../utils/math-utils';\nimport { Matrix4, Vector3, equals as _equals } from 'math.gl';\nimport * as mat4 from 'gl-matrix/mat4';\nimport { getDistanceScales as _getDistanceScales, getMeterZoom, lngLatToWorld, worldToLngLat, worldToPixels, pixelsToWorld } from '@math.gl/web-mercator';\nimport { PROJECTION_MODE } from '../lib/constants';\nvar DEGREES_TO_RADIANS = Math.PI / 180;\nvar IDENTITY = createMat4();\nvar ZERO_VECTOR = [0, 0, 0];\nvar DEFAULT_ZOOM = 0;\nvar DEFAULT_DISTANCE_SCALES = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\nvar Viewport = function () {\n  function Viewport() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Viewport);\n    var _opts$id = opts.id,\n      id = _opts$id === void 0 ? null : _opts$id,\n      _opts$x = opts.x,\n      x = _opts$x === void 0 ? 0 : _opts$x,\n      _opts$y = opts.y,\n      y = _opts$y === void 0 ? 0 : _opts$y,\n      _opts$width = opts.width,\n      width = _opts$width === void 0 ? 1 : _opts$width,\n      _opts$height = opts.height,\n      height = _opts$height === void 0 ? 1 : _opts$height;\n    this.id = id || this.constructor.displayName || 'viewport';\n    this.x = x;\n    this.y = y;\n    this.width = width || 1;\n    this.height = height || 1;\n    this._frustumPlanes = {};\n    this._initViewMatrix(opts);\n    this._initProjectionMatrix(opts);\n    this._initPixelMatrices();\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n  _createClass(Viewport, [{\n    key: \"equals\",\n    value: function equals(viewport) {\n      if (!(viewport instanceof Viewport)) {\n        return false;\n      }\n      if (this === viewport) {\n        return true;\n      }\n      return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && _equals(viewport.projectionMatrix, this.projectionMatrix) && _equals(viewport.viewMatrix, this.viewMatrix);\n    }\n  }, {\n    key: \"project\",\n    value: function project(xyz) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$topLeft = _ref.topLeft,\n        topLeft = _ref$topLeft === void 0 ? true : _ref$topLeft;\n      var worldPosition = this.projectPosition(xyz);\n      var coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n      var _coord = _slicedToArray(coord, 2),\n        x = _coord[0],\n        y = _coord[1];\n      var y2 = topLeft ? y : this.height - y;\n      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    }\n  }, {\n    key: \"unproject\",\n    value: function unproject(xyz) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref2$topLeft = _ref2.topLeft,\n        topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft,\n        targetZ = _ref2.targetZ;\n      var _xyz = _slicedToArray(xyz, 3),\n        x = _xyz[0],\n        y = _xyz[1],\n        z = _xyz[2];\n      var y2 = topLeft ? y : this.height - y;\n      var targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n      var coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n      var _this$unprojectPositi = this.unprojectPosition(coord),\n        _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3),\n        X = _this$unprojectPositi2[0],\n        Y = _this$unprojectPositi2[1],\n        Z = _this$unprojectPositi2[2];\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    }\n  }, {\n    key: \"projectPosition\",\n    value: function projectPosition(xyz) {\n      var _this$projectFlat = this.projectFlat(xyz),\n        _this$projectFlat2 = _slicedToArray(_this$projectFlat, 2),\n        X = _this$projectFlat2[0],\n        Y = _this$projectFlat2[1];\n      var Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n      return [X, Y, Z];\n    }\n  }, {\n    key: \"unprojectPosition\",\n    value: function unprojectPosition(xyz) {\n      var _this$unprojectFlat = this.unprojectFlat(xyz),\n        _this$unprojectFlat2 = _slicedToArray(_this$unprojectFlat, 2),\n        X = _this$unprojectFlat2[0],\n        Y = _this$unprojectFlat2[1];\n      var Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n      return [X, Y, Z];\n    }\n  }, {\n    key: \"projectFlat\",\n    value: function projectFlat(xyz) {\n      if (this.isGeospatial) {\n        return lngLatToWorld(xyz);\n      }\n      return xyz;\n    }\n  }, {\n    key: \"unprojectFlat\",\n    value: function unprojectFlat(xyz) {\n      if (this.isGeospatial) {\n        return worldToLngLat(xyz);\n      }\n      return xyz;\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var unprojectOption = {\n        targetZ: options.z || 0\n      };\n      var topLeft = this.unproject([0, 0], unprojectOption);\n      var topRight = this.unproject([this.width, 0], unprojectOption);\n      var bottomLeft = this.unproject([0, this.height], unprojectOption);\n      var bottomRight = this.unproject([this.width, this.height], unprojectOption);\n      return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];\n    }\n  }, {\n    key: \"getDistanceScales\",\n    value: function getDistanceScales() {\n      var coordinateOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (coordinateOrigin) {\n        return _getDistanceScales({\n          longitude: coordinateOrigin[0],\n          latitude: coordinateOrigin[1],\n          highPrecision: true\n        });\n      }\n      return this.distanceScales;\n    }\n  }, {\n    key: \"containsPixel\",\n    value: function containsPixel(_ref3) {\n      var x = _ref3.x,\n        y = _ref3.y,\n        _ref3$width = _ref3.width,\n        width = _ref3$width === void 0 ? 1 : _ref3$width,\n        _ref3$height = _ref3.height,\n        height = _ref3$height === void 0 ? 1 : _ref3$height;\n      return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;\n    }\n  }, {\n    key: \"getFrustumPlanes\",\n    value: function getFrustumPlanes() {\n      if (this._frustumPlanes.near) {\n        return this._frustumPlanes;\n      }\n      var _this$projectionProps = this.projectionProps,\n        near = _this$projectionProps.near,\n        far = _this$projectionProps.far,\n        fovyRadians = _this$projectionProps.fovyRadians,\n        aspect = _this$projectionProps.aspect;\n      Object.assign(this._frustumPlanes, _getFrustumPlanes({\n        aspect: aspect,\n        near: near,\n        far: far,\n        fovyRadians: fovyRadians,\n        position: this.cameraPosition,\n        direction: this.cameraDirection,\n        up: this.cameraUp,\n        right: this.cameraRight\n      }));\n      return this._frustumPlanes;\n    }\n  }, {\n    key: \"getCameraPosition\",\n    value: function getCameraPosition() {\n      return this.cameraPosition;\n    }\n  }, {\n    key: \"getCameraDirection\",\n    value: function getCameraDirection() {\n      return this.cameraDirection;\n    }\n  }, {\n    key: \"getCameraUp\",\n    value: function getCameraUp() {\n      return this.cameraUp;\n    }\n  }, {\n    key: \"_createProjectionMatrix\",\n    value: function _createProjectionMatrix(_ref4) {\n      var orthographic = _ref4.orthographic,\n        fovyRadians = _ref4.fovyRadians,\n        aspect = _ref4.aspect,\n        focalDistance = _ref4.focalDistance,\n        near = _ref4.near,\n        far = _ref4.far;\n      return orthographic ? new Matrix4().orthographic({\n        fovy: fovyRadians,\n        aspect: aspect,\n        focalDistance: focalDistance,\n        near: near,\n        far: far\n      }) : new Matrix4().perspective({\n        fovy: fovyRadians,\n        aspect: aspect,\n        near: near,\n        far: far\n      });\n    }\n  }, {\n    key: \"_initViewMatrix\",\n    value: function _initViewMatrix(opts) {\n      var _opts$viewMatrix = opts.viewMatrix,\n        viewMatrix = _opts$viewMatrix === void 0 ? IDENTITY : _opts$viewMatrix,\n        _opts$longitude = opts.longitude,\n        longitude = _opts$longitude === void 0 ? null : _opts$longitude,\n        _opts$latitude = opts.latitude,\n        latitude = _opts$latitude === void 0 ? null : _opts$latitude,\n        _opts$zoom = opts.zoom,\n        zoom = _opts$zoom === void 0 ? null : _opts$zoom,\n        _opts$position = opts.position,\n        position = _opts$position === void 0 ? null : _opts$position,\n        _opts$modelMatrix = opts.modelMatrix,\n        modelMatrix = _opts$modelMatrix === void 0 ? null : _opts$modelMatrix,\n        _opts$focalDistance = opts.focalDistance,\n        focalDistance = _opts$focalDistance === void 0 ? 1 : _opts$focalDistance,\n        _opts$distanceScales = opts.distanceScales,\n        distanceScales = _opts$distanceScales === void 0 ? null : _opts$distanceScales;\n      this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n      this.zoom = zoom;\n      if (!Number.isFinite(this.zoom)) {\n        this.zoom = this.isGeospatial ? getMeterZoom({\n          latitude: latitude\n        }) + Math.log2(focalDistance) : DEFAULT_ZOOM;\n      }\n      var scale = Math.pow(2, this.zoom);\n      this.scale = scale;\n      this.distanceScales = this.isGeospatial ? _getDistanceScales({\n        latitude: latitude,\n        longitude: longitude\n      }) : distanceScales || DEFAULT_DISTANCE_SCALES;\n      this.focalDistance = focalDistance;\n      this.distanceScales.metersPerUnit = new Vector3(this.distanceScales.metersPerUnit);\n      this.distanceScales.unitsPerMeter = new Vector3(this.distanceScales.unitsPerMeter);\n      this.position = ZERO_VECTOR;\n      this.meterOffset = ZERO_VECTOR;\n      if (position) {\n        this.position = position;\n        this.modelMatrix = modelMatrix;\n        this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;\n      }\n      if (this.isGeospatial) {\n        this.longitude = longitude;\n        this.latitude = latitude;\n        this.center = this._getCenterInWorld({\n          longitude: longitude,\n          latitude: latitude\n        });\n      } else {\n        this.center = position ? this.projectPosition(position) : [0, 0, 0];\n      }\n      this.viewMatrixUncentered = viewMatrix;\n      this.viewMatrix = new Matrix4().multiplyRight(this.viewMatrixUncentered).translate(new Vector3(this.center || ZERO_VECTOR).negate());\n    }\n  }, {\n    key: \"_getCenterInWorld\",\n    value: function _getCenterInWorld(_ref5) {\n      var longitude = _ref5.longitude,\n        latitude = _ref5.latitude;\n      var meterOffset = this.meterOffset,\n        distanceScales = this.distanceScales;\n      var center = new Vector3(this.projectPosition([longitude, latitude, 0]));\n      if (meterOffset) {\n        var commonPosition = new Vector3(meterOffset).scale(distanceScales.unitsPerMeter);\n        center.add(commonPosition);\n      }\n      return center;\n    }\n  }, {\n    key: \"_initProjectionMatrix\",\n    value: function _initProjectionMatrix(opts) {\n      var _opts$projectionMatri = opts.projectionMatrix,\n        projectionMatrix = _opts$projectionMatri === void 0 ? null : _opts$projectionMatri,\n        _opts$orthographic = opts.orthographic,\n        orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic,\n        fovyRadians = opts.fovyRadians,\n        _opts$fovy = opts.fovy,\n        fovy = _opts$fovy === void 0 ? 75 : _opts$fovy,\n        _opts$near = opts.near,\n        near = _opts$near === void 0 ? 0.1 : _opts$near,\n        _opts$far = opts.far,\n        far = _opts$far === void 0 ? 1000 : _opts$far,\n        _opts$focalDistance2 = opts.focalDistance,\n        focalDistance = _opts$focalDistance2 === void 0 ? 1 : _opts$focalDistance2;\n      this.projectionProps = {\n        orthographic: orthographic,\n        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n        aspect: this.width / this.height,\n        focalDistance: focalDistance,\n        near: near,\n        far: far\n      };\n      this.projectionMatrix = projectionMatrix || this._createProjectionMatrix(this.projectionProps);\n    }\n  }, {\n    key: \"_initPixelMatrices\",\n    value: function _initPixelMatrices() {\n      var vpm = createMat4();\n      mat4.multiply(vpm, vpm, this.projectionMatrix);\n      mat4.multiply(vpm, vpm, this.viewMatrix);\n      this.viewProjectionMatrix = vpm;\n      this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n      var _extractCameraVectors = extractCameraVectors({\n          viewMatrix: this.viewMatrix,\n          viewMatrixInverse: this.viewMatrixInverse\n        }),\n        eye = _extractCameraVectors.eye,\n        direction = _extractCameraVectors.direction,\n        up = _extractCameraVectors.up,\n        right = _extractCameraVectors.right;\n      this.cameraPosition = eye;\n      this.cameraDirection = direction;\n      this.cameraUp = up;\n      this.cameraRight = right;\n      var viewportMatrix = createMat4();\n      var pixelProjectionMatrix = createMat4();\n      mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n      mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n      mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n      this.pixelProjectionMatrix = pixelProjectionMatrix;\n      this.viewportMatrix = viewportMatrix;\n      this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n      if (!this.pixelUnprojectionMatrix) {\n        log.warn('Pixel project matrix not invertible')();\n      }\n    }\n  }, {\n    key: \"metersPerPixel\",\n    get: function get() {\n      return this.distanceScales.metersPerUnit[2] / this.scale;\n    }\n  }, {\n    key: \"projectionMode\",\n    get: function get() {\n      if (this.isGeospatial) {\n        return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n      }\n      return PROJECTION_MODE.IDENTITY;\n    }\n  }]);\n  return Viewport;\n}();\nexport { Viewport as default };\nViewport.displayName = 'Viewport';","map":{"version":3,"sources":["../../../src/viewports/viewport.js"],"names":["log","createMat4","extractCameraVectors","getFrustumPlanes","Matrix4","Vector3","equals","mat4","getDistanceScales","getMeterZoom","lngLatToWorld","worldToLngLat","worldToPixels","pixelsToWorld","PROJECTION_MODE","DEGREES_TO_RADIANS","Math","PI","IDENTITY","ZERO_VECTOR","DEFAULT_ZOOM","DEFAULT_DISTANCE_SCALES","unitsPerMeter","metersPerUnit","Viewport","opts","id","x","y","width","height","constructor","displayName","_frustumPlanes","_initViewMatrix","_initProjectionMatrix","_initPixelMatrices","bind","project","unproject","projectPosition","unprojectPosition","projectFlat","unprojectFlat","distanceScales","scale","isGeospatial","zoom","WEB_MERCATOR","WEB_MERCATOR_AUTO_OFFSET","viewport","projectionMatrix","viewMatrix","xyz","topLeft","worldPosition","coord","pixelProjectionMatrix","y2","length","targetZ","z","targetZWorld","pixelUnprojectionMatrix","X","Y","Z","Number","isFinite","options","unprojectOption","topRight","bottomLeft","bottomRight","min","max","coordinateOrigin","longitude","latitude","highPrecision","near","far","fovyRadians","aspect","projectionProps","Object","assign","position","cameraPosition","direction","cameraDirection","up","cameraUp","right","cameraRight","orthographic","focalDistance","fovy","perspective","modelMatrix","log2","pow","meterOffset","transformVector","center","_getCenterInWorld","viewMatrixUncentered","multiplyRight","translate","negate","commonPosition","add","_createProjectionMatrix","vpm","multiply","viewProjectionMatrix","viewMatrixInverse","invert","eye","viewportMatrix","warn"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../utils/log';\nimport {createMat4, extractCameraVectors, getFrustumPlanes} from '../utils/math-utils';\n\nimport {Matrix4, Vector3, equals} from 'math.gl';\nimport * as mat4 from 'gl-matrix/mat4';\n\nimport {\n  getDistanceScales,\n  getMeterZoom,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  pixelsToWorld\n} from '@math.gl/web-mercator';\n\nimport {PROJECTION_MODE} from '../lib/constants';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nconst IDENTITY = createMat4();\n\nconst ZERO_VECTOR = [0, 0, 0];\n\nconst DEFAULT_ZOOM = 0;\n\nconst DEFAULT_DISTANCE_SCALES = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\n\nexport default class Viewport {\n  /**\n   * @classdesc\n   * Manages coordinate system transformations for deck.gl.\n   *\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   */\n  constructor(opts = {}) {\n    const {\n      id = null,\n      // Window width/height in pixels (for pixel projection)\n      x = 0,\n      y = 0,\n      width = 1,\n      height = 1\n    } = opts;\n\n    this.id = id || this.constructor.displayName || 'viewport';\n\n    this.x = x;\n    this.y = y;\n    // Silently allow apps to send in w,h = 0,0\n    this.width = width || 1;\n    this.height = height || 1;\n    this._frustumPlanes = {};\n\n    this._initViewMatrix(opts);\n    this._initProjectionMatrix(opts);\n    this._initPixelMatrices();\n\n    // Bind methods for easy access\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n\n  get metersPerPixel() {\n    return this.distanceScales.metersPerUnit[2] / this.scale;\n  }\n\n  get projectionMode() {\n    if (this.isGeospatial) {\n      return this.zoom < 12\n        ? PROJECTION_MODE.WEB_MERCATOR\n        : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n    }\n    return PROJECTION_MODE.IDENTITY;\n  }\n\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport) {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n    if (this === viewport) {\n      return true;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      viewport.scale === this.scale &&\n      equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      equals(viewport.viewMatrix, this.viewMatrix)\n    );\n    // TODO - check distance scales?\n  }\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether projected coords are top left\n   * @return {Array} - [x, y] or [x, y, z] in top left coords\n   */\n  project(xyz, {topLeft = true} = {}) {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates,\n   * (possibly [lon, lat]) on map.\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   * @param {Array} xyz -\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether origin is top left\n   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject(xyz, {topLeft = true, targetZ} = {}) {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition(xyz) {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz) {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n  projectFlat(xyz) {\n    if (this.isGeospatial) {\n      return lngLatToWorld(xyz);\n    }\n    return xyz;\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   * @param {object|Vector} xy - object with {x,y} members\n   *  representing point on projected map plane\n   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xyz) {\n    if (this.isGeospatial) {\n      return worldToLngLat(xyz);\n    }\n    return xyz;\n  }\n\n  getBounds(options = {}) {\n    const unprojectOption = {targetZ: options.z || 0};\n\n    const topLeft = this.unproject([0, 0], unprojectOption);\n    const topRight = this.unproject([this.width, 0], unprojectOption);\n    const bottomLeft = this.unproject([0, this.height], unprojectOption);\n    const bottomRight = this.unproject([this.width, this.height], unprojectOption);\n\n    return [\n      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),\n      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])\n    ];\n  }\n\n  getDistanceScales(coordinateOrigin = null) {\n    if (coordinateOrigin) {\n      return getDistanceScales({\n        longitude: coordinateOrigin[0],\n        latitude: coordinateOrigin[1],\n        highPrecision: true\n      });\n    }\n    return this.distanceScales;\n  }\n\n  containsPixel({x, y, width = 1, height = 1}) {\n    return (\n      x < this.x + this.width &&\n      this.x < x + width &&\n      y < this.y + this.height &&\n      this.y < y + height\n    );\n  }\n\n  // Extract frustum planes in common space\n  getFrustumPlanes() {\n    if (this._frustumPlanes.near) {\n      return this._frustumPlanes;\n    }\n\n    const {near, far, fovyRadians, aspect} = this.projectionProps;\n\n    Object.assign(\n      this._frustumPlanes,\n      getFrustumPlanes({\n        aspect,\n        near,\n        far,\n        fovyRadians,\n        position: this.cameraPosition,\n        direction: this.cameraDirection,\n        up: this.cameraUp,\n        right: this.cameraRight\n      })\n    );\n\n    return this._frustumPlanes;\n  }\n\n  // EXPERIMENTAL METHODS\n\n  getCameraPosition() {\n    return this.cameraPosition;\n  }\n\n  getCameraDirection() {\n    return this.cameraDirection;\n  }\n\n  getCameraUp() {\n    return this.cameraUp;\n  }\n\n  // INTERNAL METHODS\n\n  _createProjectionMatrix({orthographic, fovyRadians, aspect, focalDistance, near, far}) {\n    return orthographic\n      ? new Matrix4().orthographic({fovy: fovyRadians, aspect, focalDistance, near, far})\n      : new Matrix4().perspective({fovy: fovyRadians, aspect, near, far});\n  }\n\n  /* eslint-disable complexity, max-statements */\n  _initViewMatrix(opts) {\n    const {\n      // view matrix\n      viewMatrix = IDENTITY,\n\n      longitude = null, // Anchor: lng lat zoom makes viewport work w/ geospatial coordinate systems\n      latitude = null,\n      zoom = null,\n\n      position = null, // Anchor position offset (in meters for geospatial viewports)\n      modelMatrix = null, // A model matrix to be applied to position, to match the layer props API\n      focalDistance = 1, // Only needed for orthographic views\n\n      distanceScales = null\n    } = opts;\n\n    // Check if we have a geospatial anchor\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n\n    this.zoom = zoom;\n    if (!Number.isFinite(this.zoom)) {\n      this.zoom = this.isGeospatial\n        ? getMeterZoom({latitude}) + Math.log2(focalDistance)\n        : DEFAULT_ZOOM;\n    }\n    const scale = Math.pow(2, this.zoom);\n    this.scale = scale;\n\n    // Calculate distance scales if lng/lat/zoom are provided\n    this.distanceScales = this.isGeospatial\n      ? getDistanceScales({latitude, longitude})\n      : distanceScales || DEFAULT_DISTANCE_SCALES;\n\n    this.focalDistance = focalDistance;\n\n    this.distanceScales.metersPerUnit = new Vector3(this.distanceScales.metersPerUnit);\n    this.distanceScales.unitsPerMeter = new Vector3(this.distanceScales.unitsPerMeter);\n\n    this.position = ZERO_VECTOR;\n    this.meterOffset = ZERO_VECTOR;\n    if (position) {\n      // Apply model matrix if supplied\n      this.position = position;\n      this.modelMatrix = modelMatrix;\n      this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;\n    }\n\n    if (this.isGeospatial) {\n      // Determine camera center\n      this.longitude = longitude;\n      this.latitude = latitude;\n      this.center = this._getCenterInWorld({longitude, latitude});\n    } else {\n      this.center = position ? this.projectPosition(position) : [0, 0, 0];\n    }\n    this.viewMatrixUncentered = viewMatrix;\n    // Make a centered version of the matrix for projection modes without an offset\n    this.viewMatrix = new Matrix4()\n      // Apply the uncentered view matrix\n      .multiplyRight(this.viewMatrixUncentered)\n      // And center it\n      .translate(new Vector3(this.center || ZERO_VECTOR).negate());\n  }\n  /* eslint-enable complexity, max-statements */\n\n  _getCenterInWorld({longitude, latitude}) {\n    const {meterOffset, distanceScales} = this;\n\n    // Make a centered version of the matrix for projection modes without an offset\n    const center = new Vector3(this.projectPosition([longitude, latitude, 0]));\n\n    if (meterOffset) {\n      const commonPosition = new Vector3(meterOffset)\n        // Convert to pixels in current zoom\n        .scale(distanceScales.unitsPerMeter);\n      center.add(commonPosition);\n    }\n\n    return center;\n  }\n\n  _initProjectionMatrix(opts) {\n    const {\n      // Projection matrix\n      projectionMatrix = null,\n\n      // Projection matrix parameters, used if projectionMatrix not supplied\n      orthographic = false,\n      fovyRadians,\n      fovy = 75,\n      near = 0.1, // Distance of near clipping plane\n      far = 1000, // Distance of far clipping plane\n      focalDistance = 1\n    } = opts;\n\n    this.projectionProps = {\n      orthographic,\n      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n      aspect: this.width / this.height,\n      focalDistance,\n      near,\n      far\n    };\n\n    this.projectionMatrix = projectionMatrix || this._createProjectionMatrix(this.projectionProps);\n  }\n\n  _initPixelMatrices() {\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);\n\n    // Calculate inverse view matrix\n    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n\n    // Decompose camera directions\n    const {eye, direction, up, right} = extractCameraVectors({\n      viewMatrix: this.viewMatrix,\n      viewMatrixInverse: this.viewMatrixInverse\n    });\n    this.cameraPosition = eye;\n    this.cameraDirection = direction;\n    this.cameraUp = up;\n    this.cameraRight = right;\n\n    // console.log(this.cameraPosition, this.cameraDirection, this.cameraUp);\n\n    /*\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n\n    // matrix for conversion from world location to screen (pixel) coordinates\n    const viewportMatrix = createMat4(); // matrix from NDC to viewport.\n    const pixelProjectionMatrix = createMat4(); // matrix from world space to viewport.\n    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n    this.pixelProjectionMatrix = pixelProjectionMatrix;\n    this.viewportMatrix = viewportMatrix;\n\n    this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n    if (!this.pixelUnprojectionMatrix) {\n      log.warn('Pixel project matrix not invertible')();\n      // throw new Error('Pixel project matrix not invertible');\n    }\n  }\n}\n\nViewport.displayName = 'Viewport';\n"]},"metadata":{},"sourceType":"module"}