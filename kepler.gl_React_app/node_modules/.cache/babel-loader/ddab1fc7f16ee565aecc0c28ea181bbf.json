{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.featureResolver = exports.featureAccessor = exports.geoJsonRequiredColumns = exports.tripVisConfigs = exports.defaultLineWidth = exports.defaultThickness = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.memoize\"));\nvar _lodash2 = _interopRequireDefault(require(\"lodash.uniq\"));\nvar _baseLayer = _interopRequireDefault(require(\"../base-layer\"));\nvar _geoLayers = require(\"@deck.gl/geo-layers\");\nvar _defaultSettings = require(\"../../constants/default-settings\");\nvar _tripLayerIcon = _interopRequireDefault(require(\"./trip-layer-icon\"));\nvar _geojsonUtils = require(\"../geojson-layer/geojson-utils\");\nvar _tripUtils = require(\"./trip-utils\");\nvar _tripInfoModal = _interopRequireDefault(require(\"./trip-info-modal\"));\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar zoomFactorValue = 8;\nvar defaultThickness = 0.5;\nexports.defaultThickness = defaultThickness;\nvar defaultLineWidth = 1;\nexports.defaultLineWidth = defaultLineWidth;\nvar tripVisConfigs = {\n  opacity: 'opacity',\n  thickness: {\n    type: 'number',\n    defaultValue: defaultThickness,\n    label: 'Stroke Width',\n    isRanged: false,\n    range: [0, 100],\n    step: 0.1,\n    group: 'stroke',\n    property: 'thickness'\n  },\n  colorRange: 'colorRange',\n  trailLength: 'trailLength',\n  sizeRange: 'strokeWidthRange'\n};\nexports.tripVisConfigs = tripVisConfigs;\nvar geoJsonRequiredColumns = ['geojson'];\nexports.geoJsonRequiredColumns = geoJsonRequiredColumns;\nvar featureAccessor = function featureAccessor(_ref) {\n  var geojson = _ref.geojson;\n  return function (dc) {\n    return function (d) {\n      return dc.valueAt(d.index, geojson.fieldIdx);\n    };\n  };\n};\nexports.featureAccessor = featureAccessor;\nvar featureResolver = function featureResolver(_ref2) {\n  var geojson = _ref2.geojson;\n  return geojson.fieldIdx;\n};\nexports.featureResolver = featureResolver;\nvar TripLayer = /*#__PURE__*/function (_Layer) {\n  (0, _inherits2[\"default\"])(TripLayer, _Layer);\n  var _super = _createSuper(TripLayer);\n  function TripLayer(props) {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, TripLayer);\n    _this = _super.call(this, props);\n    _this.dataToFeature = [];\n    _this.dataToTimeStamp = [];\n    _this.registerVisConfig(tripVisConfigs);\n    _this.getFeature = (0, _lodash[\"default\"])(featureAccessor, featureResolver);\n    _this._layerInfoModal = (0, _tripInfoModal[\"default\"])();\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(TripLayer, [{\n    key: \"type\",\n    get: function get() {\n      return 'trip';\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Trip';\n    }\n  }, {\n    key: \"layerIcon\",\n    get: function get() {\n      return _tripLayerIcon[\"default\"];\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return geoJsonRequiredColumns;\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      var visualChannels = (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(TripLayer.prototype), \"visualChannels\", this);\n      return _objectSpread(_objectSpread({}, visualChannels), {}, {\n        color: _objectSpread(_objectSpread({}, visualChannels.color), {}, {\n          accessor: 'getColor',\n          nullValue: visualChannels.color.nullValue,\n          getAttributeValue: function getAttributeValue(config) {\n            return function (d) {\n              return d.properties.lineColor || config.color;\n            };\n          },\n          // used this to get updateTriggers\n          defaultValue: function defaultValue(config) {\n            return config.color;\n          }\n        }),\n        size: _objectSpread(_objectSpread({}, visualChannels.size), {}, {\n          property: 'stroke',\n          accessor: 'getWidth',\n          condition: function condition(config) {\n            return config.visConfig.stroked;\n          },\n          nullValue: 0,\n          getAttributeValue: function getAttributeValue() {\n            return function (d) {\n              return d.properties.lineWidth || defaultLineWidth;\n            };\n          }\n        })\n      });\n    }\n  }, {\n    key: \"animationDomain\",\n    get: function get() {\n      return this.config.animation.domain;\n    }\n  }, {\n    key: \"layerInfoModal\",\n    get: function get() {\n      return {\n        id: 'iconInfo',\n        template: this._layerInfoModal,\n        modalProps: {\n          title: 'modal.tripInfo.title'\n        }\n      };\n    }\n  }, {\n    key: \"getPositionAccessor\",\n    value: function getPositionAccessor(dataContainer) {\n      return this.getFeature(this.config.columns)(dataContainer);\n    }\n  }, {\n    key: \"getDefaultLayerConfig\",\n    value: function getDefaultLayerConfig(props) {\n      return _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(TripLayer.prototype), \"getDefaultLayerConfig\", this).call(this, props)), {}, {\n        animation: {\n          enabled: true,\n          domain: null\n        }\n      });\n    }\n  }, {\n    key: \"getHoverData\",\n    value: function getHoverData(object, dataContainer) {\n      // index for dataContainer is saved to feature.properties\n      return dataContainer.row(object.properties.index);\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(_ref3, getPosition) {\n      var _this2 = this;\n      var dataContainer = _ref3.dataContainer,\n        filteredIndex = _ref3.filteredIndex;\n      return filteredIndex.map(function (i) {\n        return _this2.dataToFeature[i];\n      }).filter(function (d) {\n        return d && d.geometry.type === 'LineString';\n      });\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, oldLayerData) {\n      var _this3 = this;\n\n      // to-do: parse segment from dataContainer\n      var _datasets$this$config = datasets[this.config.dataId],\n        dataContainer = _datasets$this$config.dataContainer,\n        gpuFilter = _datasets$this$config.gpuFilter;\n      var _this$updateData = this.updateData(datasets, oldLayerData),\n        data = _this$updateData.data;\n      var customFilterValueAccessor = function customFilterValueAccessor(dc, f, fieldIndex) {\n        return dc.valueAt(f.properties.index, fieldIndex);\n      };\n      var indexAccessor = function indexAccessor(f) {\n        return f.properties.index;\n      };\n      var dataAccessor = function dataAccessor(dc) {\n        return function (d) {\n          return {\n            index: d.properties.index\n          };\n        };\n      };\n      var accessors = this.getAttributeAccessors({\n        dataAccessor: dataAccessor,\n        dataContainer: dataContainer\n      });\n      return _objectSpread({\n        data: data,\n        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(indexAccessor, customFilterValueAccessor),\n        getPath: function getPath(d) {\n          return d.geometry.coordinates;\n        },\n        getTimestamps: function getTimestamps(d) {\n          return _this3.dataToTimeStamp[d.properties.index];\n        }\n      }, accessors);\n    }\n  }, {\n    key: \"updateAnimationDomain\",\n    value: function updateAnimationDomain(domain) {\n      this.updateLayerConfig({\n        animation: _objectSpread(_objectSpread({}, this.config.animation), {}, {\n          domain: domain\n        })\n      });\n    }\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer) {\n      var getFeature = this.getPositionAccessor(dataContainer);\n      if (getFeature === this.meta.getFeature) {\n        // TODO: revisit this after gpu filtering\n        return;\n      }\n      this.dataToFeature = (0, _geojsonUtils.getGeojsonDataMaps)(dataContainer, getFeature);\n      var _parseTripGeoJsonTime = (0, _tripUtils.parseTripGeoJsonTimestamp)(this.dataToFeature),\n        dataToTimeStamp = _parseTripGeoJsonTime.dataToTimeStamp,\n        animationDomain = _parseTripGeoJsonTime.animationDomain;\n      this.dataToTimeStamp = dataToTimeStamp;\n      this.updateAnimationDomain(animationDomain); // get bounds from features\n\n      var bounds = (0, _geojsonUtils.getGeojsonBounds)(this.dataToFeature); // keep a record of what type of geometry the collection has\n\n      var featureTypes = (0, _geojsonUtils.getGeojsonFeatureTypes)(this.dataToFeature);\n      this.updateMeta({\n        bounds: bounds,\n        featureTypes: featureTypes,\n        getFeature: getFeature\n      });\n    }\n  }, {\n    key: \"setInitialLayerConfig\",\n    value: function setInitialLayerConfig(_ref4) {\n      var dataContainer = _ref4.dataContainer;\n      this.updateLayerMeta(dataContainer);\n      return this;\n    }\n  }, {\n    key: \"renderLayer\",\n    value: function renderLayer(opts) {\n      var _animationConfig$doma;\n      var data = opts.data,\n        gpuFilter = opts.gpuFilter,\n        mapState = opts.mapState,\n        animationConfig = opts.animationConfig;\n      var visConfig = this.config.visConfig;\n      var zoomFactor = this.getZoomFactor(mapState);\n      var isValidTime = animationConfig && Array.isArray(animationConfig.domain) && animationConfig.domain.every(Number.isFinite) && Number.isFinite(animationConfig.currentTime);\n      if (!isValidTime) {\n        return [];\n      }\n      var domain0 = (_animationConfig$doma = animationConfig.domain) === null || _animationConfig$doma === void 0 ? void 0 : _animationConfig$doma[0];\n      var updateTriggers = _objectSpread(_objectSpread({}, this.getVisualChannelUpdateTriggers()), {}, {\n        getTimestamps: {\n          columns: this.config.columns,\n          domain0: domain0\n        },\n        getFilterValue: gpuFilter.filterValueUpdateTriggers\n      });\n      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n      return [new _geoLayers.TripsLayer(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), data), {}, {\n        getTimestamps: function getTimestamps(d) {\n          return data.getTimestamps(d).map(function (ts) {\n            return ts - domain0;\n          });\n        },\n        widthScale: this.config.visConfig.thickness * zoomFactor * zoomFactorValue,\n        rounded: true,\n        wrapLongitude: false,\n        parameters: {\n          depthTest: mapState.dragRotate,\n          depthMask: false\n        },\n        trailLength: visConfig.trailLength * 1000,\n        currentTime: animationConfig.currentTime - domain0,\n        updateTriggers: updateTriggers\n      }))];\n    }\n  }], [{\n    key: \"findDefaultLayerProps\",\n    value: function findDefaultLayerProps(_ref5, foundLayers) {\n      var _this4 = this;\n      var label = _ref5.label,\n        _ref5$fields = _ref5.fields,\n        fields = _ref5$fields === void 0 ? [] : _ref5$fields,\n        dataContainer = _ref5.dataContainer,\n        id = _ref5.id;\n      var geojsonColumns = fields.filter(function (f) {\n        return f.type === 'geojson';\n      }).map(function (f) {\n        return f.name;\n      });\n      var defaultColumns = {\n        geojson: (0, _lodash2[\"default\"])([].concat((0, _toConsumableArray2[\"default\"])(_defaultSettings.GEOJSON_FIELDS.geojson), (0, _toConsumableArray2[\"default\"])(geojsonColumns)))\n      };\n      var geoJsonColumns = this.findDefaultColumnField(defaultColumns, fields);\n      var tripColumns = (geoJsonColumns || []).filter(function (col) {\n        return (0, _tripUtils.isTripGeoJsonField)(dataContainer, fields[col.geojson.fieldIdx]);\n      });\n      if (!tripColumns.length) {\n        return {\n          props: []\n        };\n      }\n      return {\n        props: tripColumns.map(function (columns) {\n          return {\n            label: typeof label === 'string' && label.replace(/\\.[^/.]+$/, '') || _this4.type,\n            columns: columns,\n            isVisible: true\n          };\n        }),\n        // if a geojson layer is created from this column, delete it\n        foundLayers: foundLayers.filter(function (prop) {\n          return prop.type !== 'geojson' || prop.dataId !== id || !tripColumns.find(function (c) {\n            return prop.columns.geojson.name === c.geojson.name;\n          });\n        })\n      };\n    }\n  }]);\n  return TripLayer;\n}(_baseLayer[\"default\"]);\nexports[\"default\"] = TripLayer;","map":{"version":3,"sources":["../../../src/layers/trip-layer/trip-layer.js"],"names":["zoomFactorValue","defaultThickness","defaultLineWidth","tripVisConfigs","opacity","thickness","type","defaultValue","label","isRanged","range","step","group","property","colorRange","trailLength","sizeRange","geoJsonRequiredColumns","featureAccessor","geojson","dc","valueAt","d","index","fieldIdx","featureResolver","TripLayer","Layer","props","dataToFeature","dataToTimeStamp","registerVisConfig","getFeature","_layerInfoModal","TripLayerIcon","visualChannels","color","accessor","nullValue","getAttributeValue","properties","lineColor","config","size","condition","visConfig","stroked","lineWidth","animation","domain","id","template","modalProps","title","dataContainer","columns","fields","foundLayers","geojsonColumns","filter","f","map","name","defaultColumns","GEOJSON_FIELDS","geoJsonColumns","findDefaultColumnField","tripColumns","col","length","replace","isVisible","prop","dataId","find","c","enabled","object","row","filteredIndex","getPosition","i","geometry","datasets","oldLayerData","gpuFilter","data","updateData","customFilterValueAccessor","fieldIndex","indexAccessor","dataAccessor","accessors","getAttributeAccessors","getFilterValue","filterValueAccessor","getPath","coordinates","getTimestamps","updateLayerConfig","getPositionAccessor","meta","animationDomain","updateAnimationDomain","bounds","featureTypes","updateMeta","updateLayerMeta","opts","mapState","animationConfig","zoomFactor","getZoomFactor","isValidTime","Array","isArray","every","Number","isFinite","currentTime","domain0","updateTriggers","getVisualChannelUpdateTriggers","filterValueUpdateTriggers","defaultLayerProps","getDefaultDeckLayerProps","DeckGLTripsLayer","ts","widthScale","rounded","wrapLongitude","parameters","depthTest","dragRotate","depthMask"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport memoize from 'lodash.memoize';\nimport uniq from 'lodash.uniq';\nimport Layer from '../base-layer';\nimport {TripsLayer as DeckGLTripsLayer} from '@deck.gl/geo-layers';\n\nimport {GEOJSON_FIELDS} from 'constants/default-settings';\nimport TripLayerIcon from './trip-layer-icon';\n\nimport {\n  getGeojsonDataMaps,\n  getGeojsonBounds,\n  getGeojsonFeatureTypes\n} from 'layers/geojson-layer/geojson-utils';\n\nimport {isTripGeoJsonField, parseTripGeoJsonTimestamp} from './trip-utils';\nimport TripInfoModalFactory from './trip-info-modal';\n\nconst zoomFactorValue = 8;\n\nexport const defaultThickness = 0.5;\nexport const defaultLineWidth = 1;\n\nexport const tripVisConfigs = {\n  opacity: 'opacity',\n  thickness: {\n    type: 'number',\n    defaultValue: defaultThickness,\n    label: 'Stroke Width',\n    isRanged: false,\n    range: [0, 100],\n    step: 0.1,\n    group: 'stroke',\n    property: 'thickness'\n  },\n  colorRange: 'colorRange',\n  trailLength: 'trailLength',\n  sizeRange: 'strokeWidthRange'\n};\n\nexport const geoJsonRequiredColumns = ['geojson'];\nexport const featureAccessor = ({geojson}) => dc => d => dc.valueAt(d.index, geojson.fieldIdx);\nexport const featureResolver = ({geojson}) => geojson.fieldIdx;\n\nexport default class TripLayer extends Layer {\n  constructor(props) {\n    super(props);\n\n    this.dataToFeature = [];\n    this.dataToTimeStamp = [];\n    this.registerVisConfig(tripVisConfigs);\n    this.getFeature = memoize(featureAccessor, featureResolver);\n    this._layerInfoModal = TripInfoModalFactory();\n  }\n\n  get type() {\n    return 'trip';\n  }\n\n  get name() {\n    return 'Trip';\n  }\n\n  get layerIcon() {\n    return TripLayerIcon;\n  }\n\n  get requiredLayerColumns() {\n    return geoJsonRequiredColumns;\n  }\n\n  get visualChannels() {\n    const visualChannels = super.visualChannels;\n\n    return {\n      ...visualChannels,\n      color: {\n        ...visualChannels.color,\n        accessor: 'getColor',\n        nullValue: visualChannels.color.nullValue,\n        getAttributeValue: config => d => d.properties.lineColor || config.color,\n        // used this to get updateTriggers\n        defaultValue: config => config.color\n      },\n      size: {\n        ...visualChannels.size,\n        property: 'stroke',\n        accessor: 'getWidth',\n        condition: config => config.visConfig.stroked,\n        nullValue: 0,\n        getAttributeValue: () => d => d.properties.lineWidth || defaultLineWidth\n      }\n    };\n  }\n\n  get animationDomain() {\n    return this.config.animation.domain;\n  }\n\n  get layerInfoModal() {\n    return {\n      id: 'iconInfo',\n      template: this._layerInfoModal,\n      modalProps: {\n        title: 'modal.tripInfo.title'\n      }\n    };\n  }\n\n  getPositionAccessor(dataContainer) {\n    return this.getFeature(this.config.columns)(dataContainer);\n  }\n\n  static findDefaultLayerProps({label, fields = [], dataContainer, id}, foundLayers) {\n    const geojsonColumns = fields.filter(f => f.type === 'geojson').map(f => f.name);\n\n    const defaultColumns = {\n      geojson: uniq([...GEOJSON_FIELDS.geojson, ...geojsonColumns])\n    };\n\n    const geoJsonColumns = this.findDefaultColumnField(defaultColumns, fields);\n\n    const tripColumns = (geoJsonColumns || []).filter(col =>\n      isTripGeoJsonField(dataContainer, fields[col.geojson.fieldIdx])\n    );\n\n    if (!tripColumns.length) {\n      return {props: []};\n    }\n\n    return {\n      props: tripColumns.map(columns => ({\n        label: (typeof label === 'string' && label.replace(/\\.[^/.]+$/, '')) || this.type,\n        columns,\n        isVisible: true\n      })),\n\n      // if a geojson layer is created from this column, delete it\n      foundLayers: foundLayers.filter(\n        prop =>\n          prop.type !== 'geojson' ||\n          prop.dataId !== id ||\n          !tripColumns.find(c => prop.columns.geojson.name === c.geojson.name)\n      )\n    };\n  }\n\n  getDefaultLayerConfig(props) {\n    return {\n      ...super.getDefaultLayerConfig(props),\n      animation: {\n        enabled: true,\n        domain: null\n      }\n    };\n  }\n\n  getHoverData(object, dataContainer) {\n    // index for dataContainer is saved to feature.properties\n    return dataContainer.row(object.properties.index);\n  }\n\n  calculateDataAttribute({dataContainer, filteredIndex}, getPosition) {\n    return filteredIndex\n      .map(i => this.dataToFeature[i])\n      .filter(d => d && d.geometry.type === 'LineString');\n  }\n\n  formatLayerData(datasets, oldLayerData) {\n    // to-do: parse segment from dataContainer\n    const {dataContainer, gpuFilter} = datasets[this.config.dataId];\n    const {data} = this.updateData(datasets, oldLayerData);\n\n    const customFilterValueAccessor = (dc, f, fieldIndex) => {\n      return dc.valueAt(f.properties.index, fieldIndex);\n    };\n    const indexAccessor = f => f.properties.index;\n\n    const dataAccessor = dc => d => ({index: d.properties.index});\n    const accessors = this.getAttributeAccessors({dataAccessor, dataContainer});\n\n    return {\n      data,\n      getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(\n        indexAccessor,\n        customFilterValueAccessor\n      ),\n      getPath: d => d.geometry.coordinates,\n      getTimestamps: d => this.dataToTimeStamp[d.properties.index],\n      ...accessors\n    };\n  }\n\n  updateAnimationDomain(domain) {\n    this.updateLayerConfig({\n      animation: {\n        ...this.config.animation,\n        domain\n      }\n    });\n  }\n\n  updateLayerMeta(dataContainer) {\n    const getFeature = this.getPositionAccessor(dataContainer);\n    if (getFeature === this.meta.getFeature) {\n      // TODO: revisit this after gpu filtering\n      return;\n    }\n\n    this.dataToFeature = getGeojsonDataMaps(dataContainer, getFeature);\n\n    const {dataToTimeStamp, animationDomain} = parseTripGeoJsonTimestamp(this.dataToFeature);\n\n    this.dataToTimeStamp = dataToTimeStamp;\n    this.updateAnimationDomain(animationDomain);\n\n    // get bounds from features\n    const bounds = getGeojsonBounds(this.dataToFeature);\n\n    // keep a record of what type of geometry the collection has\n    const featureTypes = getGeojsonFeatureTypes(this.dataToFeature);\n\n    this.updateMeta({bounds, featureTypes, getFeature});\n  }\n\n  setInitialLayerConfig({dataContainer}) {\n    this.updateLayerMeta(dataContainer);\n    return this;\n  }\n\n  renderLayer(opts) {\n    const {data, gpuFilter, mapState, animationConfig} = opts;\n    const {visConfig} = this.config;\n    const zoomFactor = this.getZoomFactor(mapState);\n    const isValidTime =\n      animationConfig &&\n      Array.isArray(animationConfig.domain) &&\n      animationConfig.domain.every(Number.isFinite) &&\n      Number.isFinite(animationConfig.currentTime);\n\n    if (!isValidTime) {\n      return [];\n    }\n\n    const domain0 = animationConfig.domain?.[0];\n\n    const updateTriggers = {\n      ...this.getVisualChannelUpdateTriggers(),\n      getTimestamps: {\n        columns: this.config.columns,\n        domain0\n      },\n      getFilterValue: gpuFilter.filterValueUpdateTriggers\n    };\n    const defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n\n    return [\n      new DeckGLTripsLayer({\n        ...defaultLayerProps,\n        ...data,\n        getTimestamps: d => data.getTimestamps(d).map(ts => ts - domain0),\n        widthScale: this.config.visConfig.thickness * zoomFactor * zoomFactorValue,\n        rounded: true,\n        wrapLongitude: false,\n        parameters: {\n          depthTest: mapState.dragRotate,\n          depthMask: false\n        },\n        trailLength: visConfig.trailLength * 1000,\n        currentTime: animationConfig.currentTime - domain0,\n        updateTriggers\n      })\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}