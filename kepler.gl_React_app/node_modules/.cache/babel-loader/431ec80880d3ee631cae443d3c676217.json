{"ast":null,"code":"import { isWebGL2, assertWebGL2Context, withParameters, log } from '@luma.gl/gltools';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport { TEXTURE_FORMATS, DATA_FORMAT_CHANNELS, TYPE_SIZES, isFormatSupported, isLinearFilteringSupported } from './texture-formats';\nimport { assert } from '../utils/assert';\nimport { uid, isPowerOfTwo } from '../utils/utils';\nconst NPOT_MIN_FILTERS = [9729, 9728];\nconst WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer() {};\nexport default class Texture extends Resource {\n  get [Symbol.toStringTag]() {\n    return 'Texture';\n  }\n  static isSupported(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      format,\n      linearFiltering\n    } = opts;\n    let supported = true;\n    if (format) {\n      supported = supported && isFormatSupported(gl, format);\n      supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));\n    }\n    return supported;\n  }\n  constructor(gl, props) {\n    const {\n      id = uid('texture'),\n      handle,\n      target\n    } = props;\n    super(gl, {\n      id,\n      handle\n    });\n    this.target = target;\n    this.textureUnit = undefined;\n    this.loaded = false;\n    this.width = undefined;\n    this.height = undefined;\n    this.depth = undefined;\n    this.format = undefined;\n    this.type = undefined;\n    this.dataFormat = undefined;\n    this.border = undefined;\n    this.textureUnit = undefined;\n    this.mipmaps = undefined;\n  }\n  toString() {\n    return \"Texture(\".concat(this.id, \",\").concat(this.width, \"x\").concat(this.height, \")\");\n  }\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let data = props.data;\n    if (data instanceof Promise) {\n      data.then(resolvedImageData => this.initialize(Object.assign({}, props, {\n        pixels: resolvedImageData,\n        data: resolvedImageData\n      })));\n      return this;\n    }\n    const isVideo = typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement;\n    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {\n      this._video = null;\n      data.addEventListener('loadeddata', () => this.initialize(props));\n      return this;\n    }\n    const {\n      pixels = null,\n      format = 6408,\n      border = 0,\n      recreate = false,\n      parameters = {},\n      pixelStore = {},\n      textureUnit = undefined\n    } = props;\n    if (!data) {\n      data = pixels;\n    }\n    let {\n      width,\n      height,\n      dataFormat,\n      type,\n      compressed = false,\n      mipmaps = true\n    } = props;\n    const {\n      depth = 0\n    } = props;\n    ({\n      width,\n      height,\n      compressed,\n      dataFormat,\n      type\n    } = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.format = format;\n    this.type = type;\n    this.dataFormat = dataFormat;\n    this.border = border;\n    this.textureUnit = textureUnit;\n    if (Number.isFinite(this.textureUnit)) {\n      this.gl.activeTexture(33984 + this.textureUnit);\n      this.gl.bindTexture(this.target, this.handle);\n    }\n    if (mipmaps && this._isNPOT()) {\n      log.warn(\"texture: \".concat(this, \" is Non-Power-Of-Two, disabling mipmaping\"))();\n      mipmaps = false;\n      this._updateForNPOT(parameters);\n    }\n    this.mipmaps = mipmaps;\n    this.setImageData({\n      data,\n      width,\n      height,\n      depth,\n      format,\n      type,\n      dataFormat,\n      border,\n      mipmaps,\n      parameters: pixelStore,\n      compressed\n    });\n    if (mipmaps) {\n      this.generateMipmap();\n    }\n    this.setParameters(parameters);\n    if (recreate) {\n      this.data = data;\n    }\n    if (isVideo) {\n      this._video = {\n        video: data,\n        parameters,\n        lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1\n      };\n    }\n    return this;\n  }\n  update() {\n    if (this._video) {\n      const {\n        video,\n        parameters,\n        lastTime\n      } = this._video;\n      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {\n        return;\n      }\n      this.setSubImageData({\n        data: video,\n        parameters\n      });\n      if (this.mipmaps) {\n        this.generateMipmap();\n      }\n      this._video.lastTime = video.currentTime;\n    }\n  }\n  resize(_ref) {\n    let {\n      height,\n      width,\n      mipmaps = false\n    } = _ref;\n    if (width !== this.width || height !== this.height) {\n      return this.initialize({\n        width,\n        height,\n        format: this.format,\n        type: this.type,\n        dataFormat: this.dataFormat,\n        border: this.border,\n        mipmaps\n      });\n    }\n    return this;\n  }\n  generateMipmap() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this._isNPOT()) {\n      log.warn(\"texture: \".concat(this, \" is Non-Power-Of-Two, disabling mipmaping\"))();\n      return this;\n    }\n    this.mipmaps = true;\n    this.gl.bindTexture(this.target, this.handle);\n    withParameters(this.gl, params, () => {\n      this.gl.generateMipmap(this.target);\n    });\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n  setImageData(options) {\n    this._trackDeallocatedMemory('Texture');\n    const {\n      target = this.target,\n      pixels = null,\n      level = 0,\n      format = this.format,\n      border = this.border,\n      offset = 0,\n      parameters = {}\n    } = options;\n    let {\n      data = null,\n      type = this.type,\n      width = this.width,\n      height = this.height,\n      dataFormat = this.dataFormat,\n      compressed = false\n    } = options;\n    if (!data) {\n      data = pixels;\n    }\n    ({\n      type,\n      dataFormat,\n      compressed,\n      width,\n      height\n    } = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n    const {\n      gl\n    } = this;\n    gl.bindTexture(this.target, this.handle);\n    let dataType = null;\n    ({\n      data,\n      dataType\n    } = this._getDataType({\n      data,\n      compressed\n    }));\n    let gl2;\n    let compressedTextureSize = 0;\n    withParameters(this.gl, parameters, () => {\n      switch (dataType) {\n        case 'null':\n          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          break;\n        case 'typed-array':\n          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);\n          break;\n        case 'buffer':\n          gl2 = assertWebGL2Context(gl);\n          gl2.bindBuffer(35052, data.handle || data);\n          gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);\n          gl2.bindBuffer(35052, null);\n          break;\n        case 'browser-object':\n          if (isWebGL2(gl)) {\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          } else {\n            gl.texImage2D(target, level, format, dataFormat, type, data);\n          }\n          break;\n        case 'compressed':\n          for (const [levelIndex, levelData] of data.entries()) {\n            gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);\n            compressedTextureSize += levelData.levelSize;\n          }\n          break;\n        default:\n          assert(false, 'Unknown image data type');\n      }\n    });\n    if (dataType === 'compressed') {\n      this._trackAllocatedMemory(compressedTextureSize, 'Texture');\n    } else if (data && data.byteLength) {\n      this._trackAllocatedMemory(data.byteLength, 'Texture');\n    } else {\n      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n      const channelSize = TYPE_SIZES[this.type] || 1;\n      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');\n    }\n    this.loaded = true;\n    return this;\n  }\n  setSubImageData(_ref2) {\n    let {\n      target = this.target,\n      pixels = null,\n      data = null,\n      x = 0,\n      y = 0,\n      width = this.width,\n      height = this.height,\n      level = 0,\n      format = this.format,\n      type = this.type,\n      dataFormat = this.dataFormat,\n      compressed = false,\n      offset = 0,\n      border = this.border,\n      parameters = {}\n    } = _ref2;\n    ({\n      type,\n      dataFormat,\n      compressed,\n      width,\n      height\n    } = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n    assert(this.depth === 0, 'texSubImage not supported for 3D textures');\n    if (!data) {\n      data = pixels;\n    }\n    if (data && data.data) {\n      const ndarray = data;\n      data = ndarray.data;\n      width = ndarray.shape[0];\n      height = ndarray.shape[1];\n    }\n    if (data instanceof Buffer) {\n      data = data.handle;\n    }\n    this.gl.bindTexture(this.target, this.handle);\n    withParameters(this.gl, parameters, () => {\n      if (compressed) {\n        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);\n      } else if (data === null) {\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);\n      } else if (ArrayBuffer.isView(data)) {\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);\n      } else if (data instanceof WebGLBuffer) {\n        const gl2 = assertWebGL2Context(this.gl);\n        gl2.bindBuffer(35052, data);\n        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);\n        gl2.bindBuffer(35052, null);\n      } else if (isWebGL2(this.gl)) {\n        const gl2 = assertWebGL2Context(this.gl);\n        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);\n      } else {\n        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);\n      }\n    });\n    this.gl.bindTexture(this.target, null);\n  }\n  copyFramebuffer() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.error('Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})')();\n    return null;\n  }\n  getActiveUnit() {\n    return this.gl.getParameter(34016) - 33984;\n  }\n  bind() {\n    let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;\n    const {\n      gl\n    } = this;\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(33984 + textureUnit);\n    }\n    gl.bindTexture(this.target, this.handle);\n    return textureUnit;\n  }\n  unbind() {\n    let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;\n    const {\n      gl\n    } = this;\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(33984 + textureUnit);\n    }\n    gl.bindTexture(this.target, null);\n    return textureUnit;\n  }\n  _getDataType(_ref3) {\n    let {\n      data,\n      compressed = false\n    } = _ref3;\n    if (compressed) {\n      return {\n        data,\n        dataType: 'compressed'\n      };\n    }\n    if (data === null) {\n      return {\n        data,\n        dataType: 'null'\n      };\n    }\n    if (ArrayBuffer.isView(data)) {\n      return {\n        data,\n        dataType: 'typed-array'\n      };\n    }\n    if (data instanceof Buffer) {\n      return {\n        data: data.handle,\n        dataType: 'buffer'\n      };\n    }\n    if (data instanceof WebGLBuffer) {\n      return {\n        data,\n        dataType: 'buffer'\n      };\n    }\n    return {\n      data,\n      dataType: 'browser-object'\n    };\n  }\n  _deduceParameters(opts) {\n    const {\n      format,\n      data\n    } = opts;\n    let {\n      width,\n      height,\n      dataFormat,\n      type,\n      compressed\n    } = opts;\n    const textureFormat = TEXTURE_FORMATS[format];\n    dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;\n    type = type || textureFormat && textureFormat.types[0];\n    compressed = compressed || textureFormat && textureFormat.compressed;\n    ({\n      width,\n      height\n    } = this._deduceImageSize(data, width, height));\n    return {\n      dataFormat,\n      type,\n      compressed,\n      width,\n      height,\n      format,\n      data\n    };\n  }\n  _deduceImageSize(data, width, height) {\n    let size;\n    if (typeof ImageData !== 'undefined' && data instanceof ImageData) {\n      size = {\n        width: data.width,\n        height: data.height\n      };\n    } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n      size = {\n        width: data.naturalWidth,\n        height: data.naturalHeight\n      };\n    } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {\n      size = {\n        width: data.width,\n        height: data.height\n      };\n    } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {\n      size = {\n        width: data.width,\n        height: data.height\n      };\n    } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n      size = {\n        width: data.videoWidth,\n        height: data.videoHeight\n      };\n    } else if (!data) {\n      size = {\n        width: width >= 0 ? width : 1,\n        height: height >= 0 ? height : 1\n      };\n    } else {\n      size = {\n        width,\n        height\n      };\n    }\n    assert(size, 'Could not deduced texture size');\n    assert(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');\n    assert(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');\n    return size;\n  }\n  _createHandle() {\n    return this.gl.createTexture();\n  }\n  _deleteHandle() {\n    this.gl.deleteTexture(this.handle);\n    this._trackDeallocatedMemory('Texture');\n  }\n  _getParameter(pname) {\n    switch (pname) {\n      case 4096:\n        return this.width;\n      case 4097:\n        return this.height;\n      default:\n        this.gl.bindTexture(this.target, this.handle);\n        const value = this.gl.getTexParameter(this.target, pname);\n        this.gl.bindTexture(this.target, null);\n        return value;\n    }\n  }\n  _setParameter(pname, param) {\n    this.gl.bindTexture(this.target, this.handle);\n    param = this._getNPOTParam(pname, param);\n    switch (pname) {\n      case 33082:\n      case 33083:\n        this.gl.texParameterf(this.handle, pname, param);\n        break;\n      case 4096:\n      case 4097:\n        assert(false);\n        break;\n      default:\n        this.gl.texParameteri(this.target, pname, param);\n        break;\n    }\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n  _isNPOT() {\n    if (isWebGL2(this.gl)) {\n      return false;\n    }\n    if (!this.width || !this.height) {\n      return false;\n    }\n    return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);\n  }\n  _updateForNPOT(parameters) {\n    if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {\n      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;\n    }\n    if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {\n      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;\n    }\n    if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {\n      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;\n    }\n  }\n  _getNPOTParam(pname, param) {\n    if (this._isNPOT()) {\n      switch (pname) {\n        case 10241:\n          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {\n            param = 9729;\n          }\n          break;\n        case 10242:\n        case 10243:\n          if (param !== 33071) {\n            param = 33071;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    return param;\n  }\n}","map":{"version":3,"sources":["../../../src/classes/texture.js"],"names":["isWebGL2","assertWebGL2Context","withParameters","log","Resource","Buffer","TEXTURE_FORMATS","DATA_FORMAT_CHANNELS","TYPE_SIZES","isFormatSupported","isLinearFilteringSupported","assert","uid","isPowerOfTwo","NPOT_MIN_FILTERS","WebGLBuffer","globalThis","Texture","Symbol","toStringTag","isSupported","gl","opts","format","linearFiltering","supported","constructor","props","id","handle","target","textureUnit","undefined","loaded","width","height","depth","type","dataFormat","border","mipmaps","toString","initialize","data","Promise","then","resolvedImageData","assign","pixels","isVideo","HTMLVideoElement","readyState","HAVE_METADATA","_video","addEventListener","recreate","parameters","pixelStore","compressed","_deduceParameters","Number","isFinite","activeTexture","bindTexture","_isNPOT","warn","_updateForNPOT","setImageData","generateMipmap","setParameters","video","lastTime","HAVE_CURRENT_DATA","currentTime","update","setSubImageData","resize","params","options","_trackDeallocatedMemory","level","offset","dataType","_getDataType","gl2","compressedTextureSize","texImage2D","bindBuffer","levelIndex","levelData","entries","compressedTexImage2D","levelSize","_trackAllocatedMemory","byteLength","channels","channelSize","x","y","ndarray","shape","compressedTexSubImage2D","texSubImage2D","ArrayBuffer","isView","copyFramebuffer","error","getActiveUnit","getParameter","bind","unbind","textureFormat","types","_deduceImageSize","size","ImageData","HTMLImageElement","naturalWidth","naturalHeight","HTMLCanvasElement","ImageBitmap","videoWidth","videoHeight","_createHandle","createTexture","_deleteHandle","deleteTexture","_getParameter","pname","value","getTexParameter","_setParameter","param","_getNPOTParam","texParameterf","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","indexOf"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {isWebGL2, assertWebGL2Context, withParameters, log} from '@luma.gl/gltools';\n\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport {\n  TEXTURE_FORMATS,\n  DATA_FORMAT_CHANNELS,\n  TYPE_SIZES,\n  isFormatSupported,\n  isLinearFilteringSupported\n} from './texture-formats';\nimport {assert} from '../utils/assert';\nimport {uid, isPowerOfTwo} from '../utils/utils';\n\n// Supported min filters for NPOT texture.\nconst NPOT_MIN_FILTERS = [GL.LINEAR, GL.NEAREST];\n\n// Polyfill\n// Note (Tarek): Do we really need to support this API?\nconst WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer() {};\n\nexport default class Texture extends Resource {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'Texture';\n  }\n  static isSupported(gl, opts = {}) {\n    const {format, linearFiltering} = opts;\n    let supported = true;\n    if (format) {\n      supported = supported && isFormatSupported(gl, format);\n      supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));\n    }\n    return supported;\n  }\n\n  // target cannot be modified by bind:\n  // textures are special because when you first bind them to a target,\n  // they get special information. When you first bind a texture as a\n  // GL_TEXTURE_2D, you are actually setting special state in the texture.\n  // You are saying that this texture is a 2D texture.\n  // And it will always be a 2D texture; this state cannot be changed ever.\n  // If you have a texture that was first bound as a GL_TEXTURE_2D,\n  // you must always bind it as a GL_TEXTURE_2D;\n  // attempting to bind it as GL_TEXTURE_1D will give rise to an error\n  // (while run-time).\n  constructor(gl, props) {\n    const {\n      id = uid('texture'),\n      handle,\n      target\n      // , magFilter, minFilter, wrapS, wrapT\n    } = props;\n\n    super(gl, {id, handle});\n\n    this.target = target;\n    this.textureUnit = undefined;\n\n    // Program.draw() checks the loaded flag of all textures to avoid\n    // Textures that are still loading from promises\n    // Set to true as soon as texture has been initialized with valid data\n    this.loaded = false;\n\n    this.width = undefined;\n    this.height = undefined;\n    this.depth = undefined;\n    this.format = undefined;\n    this.type = undefined;\n    this.dataFormat = undefined;\n    this.border = undefined;\n    this.textureUnit = undefined;\n    this.mipmaps = undefined;\n  }\n\n  toString() {\n    return `Texture(${this.id},${this.width}x${this.height})`;\n  }\n\n  /* eslint-disable max-len, max-statements */\n  initialize(props = {}) {\n    let data = props.data;\n\n    if (data instanceof Promise) {\n      data.then(resolvedImageData =>\n        this.initialize(\n          Object.assign({}, props, {\n            pixels: resolvedImageData,\n            data: resolvedImageData\n          })\n        )\n      );\n      return this;\n    }\n    const isVideo = typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement;\n    // @ts-ignore\n    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {\n      this._video = null; // Declare member before the object is sealed\n      data.addEventListener('loadeddata', () => this.initialize(props));\n      return this;\n    }\n\n    const {\n      pixels = null,\n      format = GL.RGBA,\n      border = 0,\n      recreate = false,\n      parameters = {},\n      pixelStore = {},\n      textureUnit = undefined\n    } = props;\n\n    // pixels variable is for API compatibility purpose\n    if (!data) {\n      // TODO - This looks backwards? Commenting out for now until we decide\n      // which prop to use\n      // log.deprecated('data', 'pixels')();\n      data = pixels;\n    }\n\n    let {width, height, dataFormat, type, compressed = false, mipmaps = true} = props;\n    const {depth = 0} = props;\n\n    // Deduce width and height\n    ({width, height, compressed, dataFormat, type} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n\n    // Store opts for accessors\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.format = format;\n    this.type = type;\n    this.dataFormat = dataFormat;\n    this.border = border;\n    this.textureUnit = textureUnit;\n\n    if (Number.isFinite(this.textureUnit)) {\n      this.gl.activeTexture(GL.TEXTURE0 + this.textureUnit);\n      this.gl.bindTexture(this.target, this.handle);\n    }\n\n    if (mipmaps && this._isNPOT()) {\n      log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();\n      mipmaps = false;\n\n      this._updateForNPOT(parameters);\n    }\n\n    this.mipmaps = mipmaps;\n\n    this.setImageData({\n      data,\n      width,\n      height,\n      depth,\n      format,\n      type,\n      dataFormat,\n      border,\n      mipmaps,\n      parameters: pixelStore,\n      compressed\n    });\n\n    if (mipmaps) {\n      this.generateMipmap();\n    }\n\n    // Set texture sampler parameters\n    this.setParameters(parameters);\n\n    // TODO - Store data to enable auto recreate on context loss\n    if (recreate) {\n      this.data = data;\n    }\n    if (isVideo) {\n      this._video = {\n        video: data,\n        parameters,\n        // @ts-ignore\n        lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1\n      };\n    }\n\n    return this;\n  }\n\n  update() {\n    if (this._video) {\n      const {video, parameters, lastTime} = this._video;\n      // @ts-ignore\n      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {\n        return;\n      }\n      this.setSubImageData({\n        data: video,\n        parameters\n      });\n      if (this.mipmaps) {\n        this.generateMipmap();\n      }\n      this._video.lastTime = video.currentTime;\n    }\n  }\n\n  // If size has changed, reinitializes with current format\n  // note clears image and mipmaps\n  resize({height, width, mipmaps = false}) {\n    if (width !== this.width || height !== this.height) {\n      return this.initialize({\n        width,\n        height,\n        format: this.format,\n        type: this.type,\n        dataFormat: this.dataFormat,\n        border: this.border,\n        mipmaps\n      });\n    }\n    return this;\n  }\n\n  // Call to regenerate mipmaps after modifying texture(s)\n  generateMipmap(params = {}) {\n    if (this._isNPOT()) {\n      log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();\n      return this;\n    }\n\n    this.mipmaps = true;\n\n    this.gl.bindTexture(this.target, this.handle);\n    withParameters(this.gl, params, () => {\n      this.gl.generateMipmap(this.target);\n    });\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n\n  /*\n   * Allocates storage\n   * @param {*} pixels -\n   *  null - create empty texture of specified format\n   *  Typed array - init from image data in typed array\n   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer\n   *  HTMLImageElement|Image - Inits with content of image. Auto width/height\n   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height\n   *  HTMLVideoElement - Creates video texture. Auto width/height\n   *\n   * @param {GLint} width -\n   * @param {GLint} height -\n   * @param {GLint} mipMapLevel -\n   * @param {GLenum} format - format of image data.\n   * @param {GLenum} type\n   *  - format of array (autodetect from type) or\n   *  - (WEBGL2) format of buffer\n   * @param {Number} offset - (WEBGL2) offset from start of buffer\n   * @param {GLint} border - must be 0.\n   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.\n   */\n  /* eslint-disable max-len, max-statements, complexity */\n  setImageData(options) {\n    this._trackDeallocatedMemory('Texture');\n\n    const {\n      target = this.target,\n      pixels = null,\n      level = 0,\n      format = this.format,\n      border = this.border,\n      offset = 0,\n      parameters = {}\n    } = options;\n\n    let {\n      data = null,\n      type = this.type,\n      width = this.width,\n      height = this.height,\n      dataFormat = this.dataFormat,\n      compressed = false\n    } = options;\n\n    // pixels variable is  for API compatibility purpose\n    if (!data) {\n      data = pixels;\n    }\n\n    ({type, dataFormat, compressed, width, height} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n\n    const {gl} = this;\n    gl.bindTexture(this.target, this.handle);\n\n    let dataType = null;\n    ({data, dataType} = this._getDataType({data, compressed}));\n\n    let gl2;\n\n    let compressedTextureSize = 0;\n\n    withParameters(this.gl, parameters, () => {\n      switch (dataType) {\n        case 'null':\n          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          break;\n        case 'typed-array':\n          // Looks like this assert is not necessary, as offset is ignored under WebGL1\n          // assert((offset === 0 || isWebGL2(gl)), 'offset supported in WebGL2 only');\n          // @ts-ignore\n          gl.texImage2D(\n            target,\n            level,\n            format,\n            width,\n            height,\n            border,\n            dataFormat,\n            type,\n            data,\n            // @ts-ignore\n            offset\n          );\n          break;\n        case 'buffer':\n          // WebGL2 enables creating textures directly from a WebGL buffer\n          gl2 = assertWebGL2Context(gl);\n          gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data.handle || data);\n          gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);\n          gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, null);\n          break;\n        case 'browser-object':\n          if (isWebGL2(gl)) {\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          } else {\n            gl.texImage2D(target, level, format, dataFormat, type, data);\n          }\n          break;\n        case 'compressed':\n          for (const [levelIndex, levelData] of data.entries()) {\n            gl.compressedTexImage2D(\n              target,\n              levelIndex,\n              levelData.format,\n              levelData.width,\n              levelData.height,\n              border,\n              levelData.data\n            );\n            compressedTextureSize += levelData.levelSize;\n          }\n          break;\n        default:\n          assert(false, 'Unknown image data type');\n      }\n    });\n\n    if (dataType === 'compressed') {\n      this._trackAllocatedMemory(compressedTextureSize, 'Texture');\n    } else if (data && data.byteLength) {\n      this._trackAllocatedMemory(data.byteLength, 'Texture');\n    } else {\n      // NOTE(Tarek): Default to RGBA bytes\n      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n      const channelSize = TYPE_SIZES[this.type] || 1;\n\n      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');\n    }\n\n    this.loaded = true;\n\n    return this;\n  }\n  /* eslint-enable max-len, max-statements, complexity */\n\n  /**\n   * Redefines an area of an existing texture\n   * Note: does not allocate storage\n   */\n  /*\n   * Redefines an area of an existing texture\n   * @param {*} pixels, data -\n   *  null - create empty texture of specified format\n   *  Typed array - init from image data in typed array\n   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer\n   *  HTMLImageElement|Image - Inits with content of image. Auto width/height\n   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height\n   *  HTMLVideoElement - Creates video texture. Auto width/height\n   *\n   * @param {GLint} x - xOffset from where texture to be updated\n   * @param {GLint} y - yOffset from where texture to be updated\n   * @param {GLint} width - width of the sub image to be updated\n   * @param {GLint} height - height of the sub image to be updated\n   * @param {GLint} level - mip level to be updated\n   * @param {GLenum} format - internal format of image data.\n   * @param {GLenum} type\n   *  - format of array (autodetect from type) or\n   *  - (WEBGL2) format of buffer or ArrayBufferView\n   * @param {GLenum} dataFormat - format of image data.\n   * @param {Number} offset - (WEBGL2) offset from start of buffer\n   * @param {GLint} border - must be 0.\n   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.\n   */\n  setSubImageData({\n    target = this.target,\n    pixels = null,\n    data = null,\n    x = 0,\n    y = 0,\n    width = this.width,\n    height = this.height,\n    level = 0,\n    format = this.format,\n    type = this.type,\n    dataFormat = this.dataFormat,\n    compressed = false,\n    offset = 0,\n    border = this.border,\n    parameters = {}\n  }) {\n    ({type, dataFormat, compressed, width, height} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n\n    assert(this.depth === 0, 'texSubImage not supported for 3D textures');\n\n    // pixels variable is  for API compatibility purpose\n    if (!data) {\n      data = pixels;\n    }\n\n    // Support ndarrays\n    if (data && data.data) {\n      const ndarray = data;\n      data = ndarray.data;\n      width = ndarray.shape[0];\n      height = ndarray.shape[1];\n    }\n\n    // Support buffers\n    if (data instanceof Buffer) {\n      data = data.handle;\n    }\n\n    this.gl.bindTexture(this.target, this.handle);\n\n    withParameters(this.gl, parameters, () => {\n      // TODO - x,y parameters\n      if (compressed) {\n        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);\n      } else if (data === null) {\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);\n      } else if (ArrayBuffer.isView(data)) {\n        // const gl2 = assertWebGL2Context(this.gl);\n        // @ts-ignore last offset parameter is ignored under WebGL1\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);\n      } else if (data instanceof WebGLBuffer) {\n        // WebGL2 allows us to create texture directly from a WebGL buffer\n        const gl2 = assertWebGL2Context(this.gl);\n        // This texImage2D signature uses currently bound GL.PIXEL_UNPACK_BUFFER\n        gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data);\n        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);\n        gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, null);\n      } else if (isWebGL2(this.gl)) {\n        // Assume data is a browser supported object (ImageData, Canvas, ...)\n        const gl2 = assertWebGL2Context(this.gl);\n        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);\n      } else {\n        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);\n      }\n    });\n\n    this.gl.bindTexture(this.target, null);\n  }\n  /* eslint-enable max-len, max-statements, complexity */\n\n  /**\n   * Defines a two-dimensional texture image or cube-map texture image with\n   * pixels from the current framebuffer (rather than from client memory).\n   * (gl.copyTexImage2D wrapper)\n   *\n   * Note that binding a texture into a Framebuffer's color buffer and\n   * rendering can be faster.\n   */\n  copyFramebuffer(opts = {}) {\n    log.error(\n      'Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})'\n    )();\n    return null;\n  }\n\n  getActiveUnit() {\n    return this.gl.getParameter(GL.ACTIVE_TEXTURE) - GL.TEXTURE0;\n  }\n\n  // target cannot be modified by bind:\n  // textures are special because when you first bind them to a target,\n  // they get special information. When you first bind a texture as a\n  // GL_TEXTURE_2D, you are actually setting special state in the texture.\n  // You are saying that this texture is a 2D texture.\n  // And it will always be a 2D texture; this state cannot be changed ever.\n  // If you have a texture that was first bound as a GL_TEXTURE_2D,\n  // you must always bind it as a GL_TEXTURE_2D;\n  // attempting to bind it as GL_TEXTURE_1D will give rise to an error\n  // (while run-time).\n\n  bind(textureUnit = this.textureUnit) {\n    const {gl} = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(gl.TEXTURE0 + textureUnit);\n    }\n\n    gl.bindTexture(this.target, this.handle);\n    return textureUnit;\n  }\n\n  unbind(textureUnit = this.textureUnit) {\n    const {gl} = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(gl.TEXTURE0 + textureUnit);\n    }\n\n    gl.bindTexture(this.target, null);\n    return textureUnit;\n  }\n\n  // PRIVATE METHODS\n\n  _getDataType({data, compressed = false}) {\n    if (compressed) {\n      return {data, dataType: 'compressed'};\n    }\n    if (data === null) {\n      return {data, dataType: 'null'};\n    }\n    if (ArrayBuffer.isView(data)) {\n      return {data, dataType: 'typed-array'};\n    }\n    if (data instanceof Buffer) {\n      return {data: data.handle, dataType: 'buffer'};\n    }\n    if (data instanceof WebGLBuffer) {\n      return {data, dataType: 'buffer'};\n    }\n    // Assume data is a browser supported object (ImageData, Canvas, ...)\n    return {data, dataType: 'browser-object'};\n  }\n\n  /* Copied from texture-2d.js\n  // WebGL2\n  setPixels(opts = {}) {\n    const {\n      buffer,\n      width = null,\n      height = null,\n      mipmapLevel = 0,\n      format = GL.RGBA,\n      type = GL.UNSIGNED_BYTE,\n      border = 0\n    } = opts;\n\n    const {gl} = this;\n\n    // This signature of texImage2D uses currently bound GL.PIXEL_UNPACK_BUFFER\n    gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, buffer.target);\n    // And as always, we must also bind the texture itself\n    this.bind();\n\n    gl.texImage2D(gl.TEXTURE_2D,\n      mipmapLevel, format, width, height, border, format, type, buffer.target);\n\n    this.unbind();\n    gl.bindBuffer(GL.GL.PIXEL_UNPACK_BUFFER, null);\n    return this;\n  }\n\n  setImageDataFromCompressedBuffer(opts) {\n    const {\n      buffer,\n      // offset = 0,\n      width = null,\n      height = null,\n      mipmapLevel = 0,\n      internalFormat = GL.RGBA,\n      // format = GL.RGBA,\n      // type = GL.UNSIGNED_BYTE,\n      border = 0\n    } = opts;\n\n    const {gl} = this;\n    gl.compressedTexImage2D(this.target,\n      mipmapLevel, internalFormat, width, height, border, buffer);\n    // gl.compressedTexSubImage2D(target,\n    //   level, xoffset, yoffset, width, height, format, ArrayBufferView? pixels);\n    return this;\n  }\n\n  copySubImage(opts) {\n    const {\n      // pixels,\n      // offset = 0,\n      // x,\n      // y,\n      // width,\n      // height,\n      // mipmapLevel = 0,\n      // internalFormat = GL.RGBA,\n      // type = GL.UNSIGNED_BYTE,\n      // border = 0\n    } = opts;\n\n    // if (pixels instanceof ArrayBufferView) {\n    //   gl.texSubImage2D(target, level, x, y, width, height, format, type, pixels);\n    // }\n    // gl.texSubImage2D(target, level, x, y, format, type, ? pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLImageElement pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLCanvasElement pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLVideoElement pixels);\n    // // Additional signature in a WebGL 2 context:\n    // gl.texSubImage2D(target, level, x, y, format, type, GLintptr offset);\n  }\n  */\n\n  // HELPER METHODS\n\n  _deduceParameters(opts) {\n    const {format, data} = opts;\n    let {width, height, dataFormat, type, compressed} = opts;\n\n    // Deduce format and type from format\n    const textureFormat = TEXTURE_FORMATS[format];\n    dataFormat = dataFormat || (textureFormat && textureFormat.dataFormat);\n    type = type || (textureFormat && textureFormat.types[0]);\n\n    // Deduce compression from format\n    compressed = compressed || (textureFormat && textureFormat.compressed);\n\n    ({width, height} = this._deduceImageSize(data, width, height));\n\n    return {dataFormat, type, compressed, width, height, format, data};\n  }\n\n  // eslint-disable-next-line complexity\n  _deduceImageSize(data, width, height) {\n    let size;\n\n    if (typeof ImageData !== 'undefined' && data instanceof ImageData) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n      size = {width: data.naturalWidth, height: data.naturalHeight};\n    } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n      size = {width: data.videoWidth, height: data.videoHeight};\n    } else if (!data) {\n      size = {width: width >= 0 ? width : 1, height: height >= 0 ? height : 1};\n    } else {\n      size = {width, height};\n    }\n\n    assert(size, 'Could not deduced texture size');\n    assert(\n      width === undefined || size.width === width,\n      'Deduced texture width does not match supplied width'\n    );\n    assert(\n      height === undefined || size.height === height,\n      'Deduced texture height does not match supplied height'\n    );\n\n    return size;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createTexture();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTexture(this.handle);\n    this._trackDeallocatedMemory('Texture');\n  }\n\n  _getParameter(pname) {\n    switch (pname) {\n      case GL.TEXTURE_WIDTH:\n        return this.width;\n      case GL.TEXTURE_HEIGHT:\n        return this.height;\n      default:\n        this.gl.bindTexture(this.target, this.handle);\n        const value = this.gl.getTexParameter(this.target, pname);\n        this.gl.bindTexture(this.target, null);\n        return value;\n    }\n  }\n\n  _setParameter(pname, param) {\n    this.gl.bindTexture(this.target, this.handle);\n\n    // NOTE: Apply NPOT workaround\n    param = this._getNPOTParam(pname, param);\n\n    // Apparently there are some integer/float conversion rules that made\n    // the WebGL committe expose two parameter setting functions in JavaScript.\n    // For now, pick the float version for parameters specified as GLfloat.\n    switch (pname) {\n      case GL.TEXTURE_MIN_LOD:\n      case GL.TEXTURE_MAX_LOD:\n        this.gl.texParameterf(this.handle, pname, param);\n        break;\n\n      case GL.TEXTURE_WIDTH:\n      case GL.TEXTURE_HEIGHT:\n        assert(false);\n        break;\n\n      default:\n        this.gl.texParameteri(this.target, pname, param);\n        break;\n    }\n\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n\n  _isNPOT() {\n    if (isWebGL2(this.gl)) {\n      // NPOT restriction is only for WebGL1\n      return false;\n    }\n    // Width and height not available, consider it is not NPOT texture\n    if (!this.width || !this.height) {\n      return false;\n    }\n    return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);\n  }\n\n  // Update default settings which are not supported by NPOT textures.\n  _updateForNPOT(parameters) {\n    if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR`)();\n      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;\n    }\n    if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_WRAP_S to CLAMP_TO_EDGE`)();\n      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;\n    }\n    if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_WRAP_T to CLAMP_TO_EDGE`)();\n      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;\n    }\n  }\n\n  _getNPOTParam(pname, param) {\n    if (this._isNPOT()) {\n      switch (pname) {\n        case GL.TEXTURE_MIN_FILTER:\n          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {\n            // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR`)();\n            param = GL.LINEAR;\n          }\n          break;\n        case GL.TEXTURE_WRAP_S:\n        case GL.TEXTURE_WRAP_T:\n          if (param !== GL.CLAMP_TO_EDGE) {\n            // log.warn(`texture: ${this} is Non-Power-Of-Two, ${getKey(this.gl, pname)} to CLAMP_TO_EDGE`)();\n            param = GL.CLAMP_TO_EDGE;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    return param;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}