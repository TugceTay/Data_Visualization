{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { GLTFLoader } from '@loaders.gl/gltf';\nimport { getZeroOffsetArrayBuffer } from '@loaders.gl/loader-utils';\nexport var GLTF_FORMAT = {\n  URI: 0,\n  EMBEDDED: 1\n};\nexport function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {\n  tile.rotateYtoZ = true;\n  var gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;\n  if (gltfByteLength === 0) {\n    throw new Error('glTF byte length must be greater than 0.');\n  }\n  tile.gltfUpAxis = options['3d-tiles'] && options['3d-tiles'].assetGltfUpAxis ? options['3d-tiles'].assetGltfUpAxis : 'Y';\n  tile.gltfArrayBuffer = getZeroOffsetArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);\n  tile.gltfByteOffset = 0;\n  tile.gltfByteLength = gltfByteLength;\n  if (byteOffset % 4 === 0) {} else {\n    console.warn(\"\".concat(tile.type, \": embedded glb is not aligned to a 4-byte boundary.\"));\n  }\n  return tile.byteOffset + tile.byteLength;\n}\nexport function extractGLTF(_x, _x2, _x3, _x4) {\n  return _extractGLTF.apply(this, arguments);\n}\nfunction _extractGLTF() {\n  _extractGLTF = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tile, gltfFormat, options, context) {\n    var tile3DOptions, parse, fetch;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            tile3DOptions = options['3d-tiles'] || {};\n            extractGLTFBufferOrURL(tile, gltfFormat, options);\n            if (!tile3DOptions.loadGLTF) {\n              _context.next = 16;\n              break;\n            }\n            parse = context.parse, fetch = context.fetch;\n            if (!tile.gltfUrl) {\n              _context.next = 9;\n              break;\n            }\n            _context.next = 7;\n            return fetch(tile.gltfUrl, options);\n          case 7:\n            tile.gltfArrayBuffer = _context.sent;\n            tile.gltfByteOffset = 0;\n          case 9:\n            if (!tile.gltfArrayBuffer) {\n              _context.next = 16;\n              break;\n            }\n            _context.next = 12;\n            return parse(tile.gltfArrayBuffer, GLTFLoader, options, context);\n          case 12:\n            tile.gltf = _context.sent;\n            delete tile.gltfArrayBuffer;\n            delete tile.gltfByteOffset;\n            delete tile.gltfByteLength;\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _extractGLTF.apply(this, arguments);\n}\nfunction extractGLTFBufferOrURL(tile, gltfFormat, options) {\n  switch (gltfFormat) {\n    case GLTF_FORMAT.URI:\n      var gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);\n      var textDecoder = new TextDecoder();\n      var gltfUrl = textDecoder.decode(gltfUrlBytes);\n      tile.gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, '');\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n      break;\n    case GLTF_FORMAT.EMBEDDED:\n      break;\n    default:\n      throw new Error(\"b3dm: Illegal glTF format field\");\n  }\n}","map":{"version":3,"sources":["../../../../../src/lib/parsers/helpers/parse-3d-tile-gltf-view.js"],"names":["GLTFLoader","getZeroOffsetArrayBuffer","GLTF_FORMAT","URI","EMBEDDED","parse3DTileGLTFViewSync","tile","arrayBuffer","byteOffset","options","rotateYtoZ","gltfByteLength","byteLength","Error","gltfUpAxis","assetGltfUpAxis","gltfArrayBuffer","gltfByteOffset","console","warn","type","extractGLTF","gltfFormat","context","tile3DOptions","extractGLTFBufferOrURL","loadGLTF","parse","fetch","gltfUrl","gltf","gltfUrlBytes","Uint8Array","textDecoder","TextDecoder","decode","replace"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* global TextDecoder */\n\n// TODO - should we automatically parse the embedded glTF or leave it to the app?\n// - I.e. some apps might work directly on a GLB, in that case no need for us to decode...\n// - And if we decode, do we still keep the GLB in case it is needed?\n// - Do we add an option to control this?\n// - Also, should we have hard dependency on gltf module or use injection or auto-discovery for gltf parser?\n\nimport {GLTFLoader} from '@loaders.gl/gltf';\nimport {getZeroOffsetArrayBuffer} from '@loaders.gl/loader-utils';\n\nexport const GLTF_FORMAT = {\n  URI: 0,\n  EMBEDDED: 1\n};\n\nexport function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {\n  // Set flags\n  // glTF models need to be rotated from Y to Z up\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n  tile.rotateYtoZ = true;\n\n  // Assume glTF consumes rest of tile\n  const gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;\n  if (gltfByteLength === 0) {\n    throw new Error('glTF byte length must be greater than 0.');\n  }\n\n  // Save gltf up axis\n  tile.gltfUpAxis =\n    options['3d-tiles'] && options['3d-tiles'].assetGltfUpAxis\n      ? options['3d-tiles'].assetGltfUpAxis\n      : 'Y';\n\n  // TODO - We can avoid copy if already 4-byte aligned...\n  // However the rest of the code may not be able to accept byteOffsets, so copy anyway\n  tile.gltfArrayBuffer = getZeroOffsetArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);\n  tile.gltfByteOffset = 0;\n  tile.gltfByteLength = gltfByteLength;\n\n  if (byteOffset % 4 === 0) {\n    // tile.gltfArrayBuffer = arrayBuffer;\n    // tile.gltfByteOffset = byteOffset;\n    // tile.gltfByteLength = gltfByteLength;\n  } else {\n    // Create a copy of the glb so that it is 4-byte aligned\n    // eslint-disable-next-line\n    console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);\n  }\n\n  // Entire tile is consumed\n  return tile.byteOffset + tile.byteLength;\n}\n\nexport async function extractGLTF(tile, gltfFormat, options, context) {\n  const tile3DOptions = options['3d-tiles'] || {};\n\n  extractGLTFBufferOrURL(tile, gltfFormat, options);\n\n  if (tile3DOptions.loadGLTF) {\n    const {parse, fetch} = context;\n    if (tile.gltfUrl) {\n      tile.gltfArrayBuffer = await fetch(tile.gltfUrl, options);\n      tile.gltfByteOffset = 0;\n    }\n    if (tile.gltfArrayBuffer) {\n      // TODO - Should handle byteOffset... However, not used now...\n      tile.gltf = await parse(tile.gltfArrayBuffer, GLTFLoader, options, context);\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n    }\n  }\n}\n\nfunction extractGLTFBufferOrURL(tile, gltfFormat, options) {\n  switch (gltfFormat) {\n    case GLTF_FORMAT.URI:\n      // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n      // This removes all white space and null characters from the end of the string.\n      const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);\n      const textDecoder = new TextDecoder();\n      const gltfUrl = textDecoder.decode(gltfUrlBytes);\n      tile.gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, '');\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n      break;\n    case GLTF_FORMAT.EMBEDDED:\n      break;\n    default:\n      throw new Error(`b3dm: Illegal glTF format field`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}