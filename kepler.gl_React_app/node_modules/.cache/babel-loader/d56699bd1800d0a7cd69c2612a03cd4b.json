{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { global } from '../utils/globals';\nimport { getImageSize } from '../category-api/parsed-image-api';\nvar _encodeImageNode = global._encodeImageNode;\nexport function encodeImage(_x, _x2) {\n  return _encodeImage.apply(this, arguments);\n}\nfunction _encodeImage() {\n  _encodeImage = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(image, options) {\n    return _regeneratorRuntime.wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = options || {};\n            options.image = options.image || {};\n            return _context2.abrupt(\"return\", _encodeImageNode ? _encodeImageNode(image, {\n              type: options.image.mimeType\n            }) : encodeImageInBrowser(image, options));\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _encodeImage.apply(this, arguments);\n}\nvar qualityParamSupported = true;\nfunction encodeImageInBrowser(_x3, _x4) {\n  return _encodeImageInBrowser.apply(this, arguments);\n}\nfunction _encodeImageInBrowser() {\n  _encodeImageInBrowser = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(image, options) {\n    var _options$image, mimeType, jpegQuality, _getImageSize, width, height, canvas, blob;\n    return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _options$image = options.image, mimeType = _options$image.mimeType, jpegQuality = _options$image.jpegQuality;\n            _getImageSize = getImageSize(image), width = _getImageSize.width, height = _getImageSize.height;\n            canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n            drawImageToCanvas(image, canvas);\n            _context3.next = 8;\n            return new Promise(function (resolve, reject) {\n              if (jpegQuality && qualityParamSupported) {\n                try {\n                  canvas.toBlob(resolve, mimeType, jpegQuality);\n                  return;\n                } catch (error) {\n                  qualityParamSupported = false;\n                }\n              }\n              canvas.toBlob(resolve, mimeType);\n            });\n          case 8:\n            blob = _context3.sent;\n            _context3.next = 11;\n            return blob.arrayBuffer();\n          case 11:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _encodeImageInBrowser.apply(this, arguments);\n}\nfunction drawImageToCanvas(image, canvas) {\n  var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    var _context = canvas.getContext('bitmaprenderer');\n    if (_context) {\n      _context.transferFromImageBitmap(image);\n      return canvas;\n    }\n  }\n  var context = canvas.getContext('2d');\n  if (image.data) {\n    var clampedArray = new Uint8ClampedArray(image.data);\n    var imageData = new ImageData(clampedArray, image.width, image.height);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n  context.drawImage(image, 0, 0);\n  return canvas;\n}","map":{"version":3,"sources":["../../../../src/lib/encoders/encode-image.js"],"names":["global","getImageSize","_encodeImageNode","encodeImage","image","options","type","mimeType","encodeImageInBrowser","qualityParamSupported","jpegQuality","width","height","canvas","document","createElement","drawImageToCanvas","blob","Promise","resolve","reject","toBlob","error","arrayBuffer","x","y","ImageBitmap","context","getContext","transferFromImageBitmap","data","clampedArray","Uint8ClampedArray","imageData","ImageData","putImageData","drawImage"],"mappings":"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","sourcesContent":["// Image loading/saving for browser and Node.js\n/* global document, ImageBitmap, ImageData */\nimport {global} from '../utils/globals';\nimport {getImageSize} from '../category-api/parsed-image-api';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_encodeImageNode} = global;\n\nexport async function encodeImage(image, options) {\n  options = options || {};\n  options.image = options.image || {};\n\n  return _encodeImageNode\n    ? _encodeImageNode(image, {type: options.image.mimeType})\n    : encodeImageInBrowser(image, options);\n}\n\n// In case we get exceptions from canvas.toBlob(resolve, type, quality)\nlet qualityParamSupported = true;\n\n/**\n *\n * @param image\n * @param options\n * @note Based on canvas.toBlob\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n */\nasync function encodeImageInBrowser(image, options) {\n  const {mimeType, jpegQuality} = options.image;\n\n  const {width, height} = getImageSize(image);\n\n  // create a canvas and resize it to the size of our image\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n\n  drawImageToCanvas(image, canvas);\n\n  // The actual encoding is done asynchronously with `canvas.toBlob()`\n  const blob = await new Promise((resolve, reject) => {\n    // get it back as a Blob\n    if (jpegQuality && qualityParamSupported) {\n      try {\n        canvas.toBlob(resolve, mimeType, jpegQuality);\n        return;\n      } catch (error) {\n        qualityParamSupported = false;\n      }\n    }\n    canvas.toBlob(resolve, mimeType);\n  });\n\n  return await blob.arrayBuffer();\n}\n\nfunction drawImageToCanvas(image, canvas, x = 0, y = 0) {\n  // Try optimized path for ImageBitmaps via bitmaprenderer context\n  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const context = canvas.getContext('bitmaprenderer');\n    if (context) {\n      // transfer the ImageBitmap to it\n      context.transferFromImageBitmap(image);\n      return canvas;\n    }\n  }\n\n  // Available on most platforms, except IE11 and Andriod WebViews...\n  const context = canvas.getContext('2d');\n  if (image.data) {\n    // ImageData constructor expects clamped array even though getImageData does not return a clamped array...\n    const clampedArray = new Uint8ClampedArray(image.data);\n    const imageData = new ImageData(clampedArray, image.width, image.height);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  // Fall back to generic image/image bitmap rendering path\n  context.drawImage(image, 0, 0);\n  return canvas;\n}\n"]},"metadata":{},"sourceType":"module"}