{"ast":null,"code":"import { project } from '@deck.gl/core';\nvar vs = \"\\n  uniform bool brushing_enabled;\\n  uniform int brushing_target;\\n  uniform vec2 brushing_mousePos;\\n  uniform float brushing_radius;\\n\\n  #ifdef NON_INSTANCED_MODEL\\n  attribute vec2 brushingTargets;\\n  #else\\n  attribute vec2 instanceBrushingTargets;\\n  #endif\\n\\n  varying float brushing_isVisible;\\n\\n  bool brushing_isPointInRange(vec2 position) {\\n    if (!brushing_enabled) {\\n      return true;\\n    }\\n    vec2 source_commonspace = project_position(position);\\n    vec2 target_commonspace = project_position(brushing_mousePos);\\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\\n\\n    return distance <= brushing_radius;\\n  }\\n\\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\\n  }\\n\\n  void brushing_setVisible(bool visible) {\\n    brushing_isVisible = float(visible);\\n  }\\n\";\nvar fs = \"\\n  uniform bool brushing_enabled;\\n  varying float brushing_isVisible;\\n\";\nvar TARGET = {\n  source: 0,\n  target: 1,\n  custom: 2,\n  source_target: 3\n};\nvar inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': \"\\n    vec2 brushingTarget;\\n    vec2 brushingSource;\\n    if (brushing_target == 3) {\\n      brushingTarget = geometry.worldPositionAlt.xy;\\n      brushingSource = geometry.worldPosition.xy;\\n    } else if (brushing_target == 0) {\\n      brushingTarget = geometry.worldPosition.xy;\\n    } else if (brushing_target == 1) {\\n      brushingTarget = geometry.worldPositionAlt.xy;\\n    } else {\\n      #ifdef NON_INSTANCED_MODEL\\n      brushingTarget = brushingTargets;\\n      #else\\n      brushingTarget = instanceBrushingTargets;\\n      #endif\\n    }\\n    bool visible;\\n    if (brushing_target == 3) {\\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\\n    } else {\\n      visible = brushing_isPointInRange(brushingTarget);\\n    }\\n    brushing_setVisible(visible);\\n  \",\n  'fs:DECKGL_FILTER_COLOR': \"\\n    if (brushing_enabled && brushing_isVisible < 0.5) {\\n      discard;\\n    }\\n  \"\n};\nexport default {\n  name: 'brushing',\n  dependencies: [project],\n  vs: vs,\n  fs: fs,\n  inject: inject,\n  getUniforms: function getUniforms(opts) {\n    if (!opts || !opts.viewport) {\n      return {};\n    }\n    var _opts$brushingEnabled = opts.brushingEnabled,\n      brushingEnabled = _opts$brushingEnabled === void 0 ? true : _opts$brushingEnabled,\n      _opts$brushingRadius = opts.brushingRadius,\n      brushingRadius = _opts$brushingRadius === void 0 ? 10000 : _opts$brushingRadius,\n      _opts$brushingTarget = opts.brushingTarget,\n      brushingTarget = _opts$brushingTarget === void 0 ? 'source' : _opts$brushingTarget,\n      mousePosition = opts.mousePosition,\n      viewport = opts.viewport;\n    return {\n      brushing_enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),\n      brushing_radius: brushingRadius,\n      brushing_target: TARGET[brushingTarget] || 0,\n      brushing_mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]\n    };\n  }\n};","map":{"version":3,"sources":["../../../src/brushing/shader-module.js"],"names":["project","vs","fs","TARGET","source","target","custom","source_target","inject","name","dependencies","getUniforms","opts","viewport","brushingEnabled","brushingRadius","brushingTarget","mousePosition","brushing_enabled","Boolean","containsPixel","brushing_radius","brushing_target","brushing_mousePos","unproject","x","y"],"mappings":"AAmBA,SAAQA,OAAR,QAAsB,eAAtB;AAEA,IAAMC,EAAE,GAAA,u7BAAR;AAkCA,IAAMC,EAAE,GAAA,2EAAR;AAKA,IAAMC,MAAM,GAAG;EACbC,MAAM,EAAE,CADK;EAEbC,MAAM,EAAE,CAFK;EAGbC,MAAM,EAAE,CAHK;EAIbC,aAAa,EAAE;AAJF,CAAf;AAOA,IAAMC,MAAM,GAAG;EACb,8BAAA,EAAA,2xBADa;EA2Bb,wBAAA,EAAA;AA3Ba,CAAf;AAkCA,eAAe;EACbC,IAAI,EAAE,UADO;EAEbC,YAAY,EAAE,CAACV,OAAD,CAFD;EAGbC,EAAE,EAAFA,EAHa;EAIbC,EAAE,EAAFA,EAJa;EAKbM,MAAM,EAANA,MALa;EAMbG,WAAW,EAAE,SAAA,WAAA,CAAA,IAAI,EAAI;IACnB,IAAI,CAACC,IAAD,IAAS,CAACA,IAAI,CAACC,QAAnB,EAA6B;MAC3B,OAAO,CAAA,CAAP;IACD;IAHkB,IAAA,qBAAA,GAUfD,IAVe,CAKjBE,eALiB;MAKjBA,eALiB,GAAA,qBAAA,KAAA,KAAA,CAAA,GAKC,IALD,GAAA,qBAAA;MAAA,oBAAA,GAUfF,IAVe,CAMjBG,cANiB;MAMjBA,cANiB,GAAA,oBAAA,KAAA,KAAA,CAAA,GAMA,KANA,GAAA,oBAAA;MAAA,oBAAA,GAUfH,IAVe,CAOjBI,cAPiB;MAOjBA,cAPiB,GAAA,oBAAA,KAAA,KAAA,CAAA,GAOA,QAPA,GAAA,oBAAA;MAQjBC,aARiB,GAUfL,IAVe,CAQjBK,aARiB;MASjBJ,QATiB,GAUfD,IAVe,CASjBC,QATiB;IAWnB,OAAO;MACLK,gBAAgB,EAAEC,OAAO,CACvBL,eAAe,IAAIG,aAAnBH,IAAoCD,QAAQ,CAACO,aAATP,CAAuBI,aAAvBJ,CADb,CADpB;MAILQ,eAAe,EAAEN,cAJZ;MAKLO,eAAe,EAAEnB,MAAM,CAACa,cAAD,CAANb,IAA0B,CALtC;MAMLoB,iBAAiB,EAAEN,aAAa,GAC5BJ,QAAQ,CAACW,SAATX,CAAmB,CAACI,aAAa,CAACQ,CAAdR,GAAkBJ,QAAQ,CAACY,CAA5B,EAA+BR,aAAa,CAACS,CAAdT,GAAkBJ,QAAQ,CAACa,CAA1D,CAAnBb,CAD4B,GAE5B,CAAC,CAAD,EAAI,CAAJ;IARC,CAAP;EAUD;AA3BY,CAAf","sourcesContent":["// Copyright (c) 2015-2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {project} from '@deck.gl/core';\n\nconst vs = `\n  uniform bool brushing_enabled;\n  uniform int brushing_target;\n  uniform vec2 brushing_mousePos;\n  uniform float brushing_radius;\n\n  #ifdef NON_INSTANCED_MODEL\n  attribute vec2 brushingTargets;\n  #else\n  attribute vec2 instanceBrushingTargets;\n  #endif\n\n  varying float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing_enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing_mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\n\n    return distance <= brushing_radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n`;\n\nconst fs = `\n  uniform bool brushing_enabled;\n  varying float brushing_isVisible;\n`;\n\nconst TARGET = {\n  source: 0,\n  target: 1,\n  custom: 2,\n  source_target: 3\n};\n\nconst inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': `\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing_target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing_target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing_target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      #ifdef NON_INSTANCED_MODEL\n      brushingTarget = brushingTargets;\n      #else\n      brushingTarget = instanceBrushingTargets;\n      #endif\n    }\n    bool visible;\n    if (brushing_target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': `\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  `\n};\n\nexport default {\n  name: 'brushing',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: opts => {\n    if (!opts || !opts.viewport) {\n      return {};\n    }\n    const {\n      brushingEnabled = true,\n      brushingRadius = 10000,\n      brushingTarget = 'source',\n      mousePosition,\n      viewport\n    } = opts;\n    return {\n      brushing_enabled: Boolean(\n        brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)\n      ),\n      brushing_radius: brushingRadius,\n      brushing_target: TARGET[brushingTarget] || 0,\n      brushing_mousePos: mousePosition\n        ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y])\n        : [0, 0]\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}