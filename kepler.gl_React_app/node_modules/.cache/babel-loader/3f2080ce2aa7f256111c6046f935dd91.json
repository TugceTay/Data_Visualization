{"ast":null,"code":"var geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];\nexport function transformToLocalCoordinates(line, feature) {\n  for (var i = 0; i < line.length; i++) {\n    var point = line[i];\n    line[i] = [point.x / feature.extent, point.y / feature.extent];\n  }\n}\nexport function transformCoordinates(feature) {\n  var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (coordinates, feature_) {\n    return coordinates;\n  };\n  var type = geometryTypes[feature.type];\n  var coordinates = feature.loadGeometry();\n  switch (feature.type) {\n    case 1:\n      var points = [];\n      for (var i = 0; i < coordinates.length; i++) {\n        points[i] = coordinates[i][0];\n      }\n      coordinates = points;\n      transform(coordinates, feature);\n      break;\n    case 2:\n      for (var _i = 0; _i < coordinates.length; _i++) {\n        transform(coordinates[_i], feature);\n      }\n      break;\n    case 3:\n      coordinates = classifyRings(coordinates);\n      for (var _i2 = 0; _i2 < coordinates.length; _i2++) {\n        for (var j = 0; j < coordinates[_i2].length; j++) {\n          transform(coordinates[_i2][j], feature);\n        }\n      }\n      break;\n    default:\n      break;\n  }\n  return generateJSON(type, feature, coordinates);\n}\nfunction generateJSON(type, feature, coordinates) {\n  var geometryType = type;\n  if (coordinates.length === 1) {\n    coordinates = coordinates[0];\n  } else {\n    geometryType = \"Multi\".concat(type);\n  }\n  var jsonResult = {\n    type: 'Feature',\n    geometry: {\n      type: geometryType,\n      coordinates: coordinates\n    },\n    properties: feature.properties || {}\n  };\n  if ('id' in feature) {\n    jsonResult.id = feature.id;\n  }\n  return jsonResult;\n}\nfunction classifyRings(rings) {\n  var len = rings.length;\n  if (len <= 1) return [rings];\n  var polygons = [];\n  var polygon;\n  var ccw;\n  for (var i = 0; i < len; i++) {\n    var area = signedArea(rings[i]);\n    if (area === 0) {\n      continue;\n    }\n    if (ccw === undefined) ccw = area < 0;\n    if (ccw === area < 0) {\n      if (polygon) {\n        polygons.push(polygon);\n      }\n      polygon = [rings[i]];\n    } else if (polygon) {\n      polygon.push(rings[i]);\n    }\n  }\n  if (polygon) polygons.push(polygon);\n  return polygons;\n}\nfunction signedArea(ring) {\n  var length = ring.length;\n  var sum = 0;\n  var p1;\n  var p2;\n  for (var i = 0, j = length - 1; i < length; j = i++) {\n    p1 = ring[i];\n    p2 = ring[j];\n    sum += (p2.x - p1.x) * (p1.y + p2.y);\n  }\n  return sum;\n}","map":{"version":3,"sources":["../../../src/lib/transform-to-local-range.js"],"names":["geometryTypes","transformToLocalCoordinates","line","feature","i","length","point","x","extent","y","transformCoordinates","transform","coordinates","feature_","type","loadGeometry","points","classifyRings","j","generateJSON","geometryType","jsonResult","geometry","properties","id","rings","len","polygons","polygon","ccw","area","signedArea","undefined","push","ring","sum","p1","p2"],"mappings":"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","sourcesContent":["const geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\nexport function transformToLocalCoordinates(line, feature) {\n  // This function transforms local coordinates in a\n  // [0 - bufferSize, this.extent + bufferSize] range to a\n  // [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n  // The resulting extent would be 1.\n\n  for (let i = 0; i < line.length; i++) {\n    const point = line[i];\n\n    line[i] = [point.x / feature.extent, point.y / feature.extent];\n  }\n}\n\nexport function transformCoordinates(feature, transform = (coordinates, feature_) => coordinates) {\n  const type = geometryTypes[feature.type];\n  let coordinates = feature.loadGeometry();\n\n  switch (feature.type) {\n    // Point\n    case 1:\n      const points = [];\n      for (let i = 0; i < coordinates.length; i++) {\n        points[i] = coordinates[i][0];\n      }\n      coordinates = points;\n      transform(coordinates, feature);\n      break;\n\n    // LineString\n    case 2:\n      for (let i = 0; i < coordinates.length; i++) {\n        transform(coordinates[i], feature);\n      }\n      break;\n\n    // Polygon\n    case 3:\n      coordinates = classifyRings(coordinates);\n      for (let i = 0; i < coordinates.length; i++) {\n        for (let j = 0; j < coordinates[i].length; j++) {\n          transform(coordinates[i][j], feature);\n        }\n      }\n      break;\n\n    default:\n      break;\n  }\n\n  return generateJSON(type, feature, coordinates);\n}\n\nfunction generateJSON(type, feature, coordinates) {\n  let geometryType = type;\n\n  if (coordinates.length === 1) {\n    coordinates = coordinates[0];\n  } else {\n    geometryType = `Multi${type}`;\n  }\n\n  const jsonResult = {\n    type: 'Feature',\n    geometry: {\n      type: geometryType,\n      coordinates\n    },\n    properties: feature.properties || {}\n  };\n\n  if ('id' in feature) {\n    jsonResult.id = feature.id;\n  }\n\n  return jsonResult;\n}\n\n/*\n* Methods below are extracted and modified from @mapbox/vector-tile\n* https://github.com/mapbox/vector-tile-js/blob/58df1e9344ee64f26deee84a9f54cee11fb95ef6/lib/vectortilefeature.js#L197-L233\n*/\n\n// classifies an array of rings into polygons with outer rings and holes\nfunction classifyRings(rings) {\n  const len = rings.length;\n\n  if (len <= 1) return [rings];\n\n  const polygons = [];\n  let polygon;\n  let ccw;\n\n  for (let i = 0; i < len; i++) {\n    const area = signedArea(rings[i]);\n\n    if (area === 0) {\n      /* eslint-disable-next-line no-continue */\n      continue;\n    }\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon) {\n        polygons.push(polygon);\n      }\n\n      polygon = [rings[i]];\n    } else if (polygon) {\n      polygon.push(rings[i]);\n    }\n  }\n\n  if (polygon) polygons.push(polygon);\n\n  return polygons;\n}\n\nfunction signedArea(ring) {\n  const length = ring.length;\n  let sum = 0;\n  let p1;\n  let p2;\n\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    p1 = ring[i];\n    p2 = ring[j];\n    sum += (p2.x - p1.x) * (p1.y + p2.y);\n  }\n\n  return sum;\n}\n"]},"metadata":{},"sourceType":"module"}