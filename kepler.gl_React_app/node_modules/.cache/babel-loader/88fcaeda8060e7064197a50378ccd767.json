{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.clusterVisConfigs = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _aggregationLayer = _interopRequireDefault(require(\"../aggregation-layer\"));\nvar _layers = require(\"@deck.gl/layers\");\nvar _clusterLayer = _interopRequireDefault(require(\"../../deckgl-layers/cluster-layer/cluster-layer\"));\nvar _defaultSettings = require(\"../../constants/default-settings\");\nvar _clusterLayerIcon = _interopRequireDefault(require(\"./cluster-layer-icon\"));\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar clusterVisConfigs = {\n  opacity: 'opacity',\n  clusterRadius: 'clusterRadius',\n  colorRange: 'colorRange',\n  radiusRange: 'clusterRadiusRange',\n  colorAggregation: 'aggregation'\n};\nexports.clusterVisConfigs = clusterVisConfigs;\nvar ClusterLayer = /*#__PURE__*/function (_AggregationLayer) {\n  (0, _inherits2[\"default\"])(ClusterLayer, _AggregationLayer);\n  var _super = _createSuper(ClusterLayer);\n  function ClusterLayer(props) {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, ClusterLayer);\n    _this = _super.call(this, props);\n    _this.registerVisConfig(clusterVisConfigs);\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(ClusterLayer, [{\n    key: \"type\",\n    get: function get() {\n      return 'cluster';\n    }\n  }, {\n    key: \"layerIcon\",\n    get: function get() {\n      return _clusterLayerIcon[\"default\"];\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      return {\n        color: {\n          aggregation: 'colorAggregation',\n          channelScaleType: _defaultSettings.CHANNEL_SCALES.colorAggr,\n          defaultMeasure: 'property.pointCount',\n          domain: 'colorDomain',\n          field: 'colorField',\n          key: 'color',\n          property: 'color',\n          range: 'colorRange',\n          scale: 'colorScale'\n        }\n      };\n    }\n  }, {\n    key: \"renderLayer\",\n    value: function renderLayer(opts) {\n      var visConfig = this.config.visConfig;\n      var data = opts.data,\n        gpuFilter = opts.gpuFilter,\n        objectHovered = opts.objectHovered,\n        mapState = opts.mapState,\n        layerCallbacks = opts.layerCallbacks;\n      var updateTriggers = {\n        getColorValue: {\n          colorField: this.config.colorField,\n          colorAggregation: this.config.visConfig.colorAggregation\n        },\n        filterData: _objectSpread({\n          filterRange: gpuFilter.filterRange\n        }, gpuFilter.filterValueUpdateTriggers)\n      };\n      var filterData = data._filterData,\n        clusterData = (0, _objectWithoutProperties2[\"default\"])(data, [\"_filterData\"]);\n      var hoveredObject = this.hasHoveredObject(objectHovered);\n      return [new _clusterLayer[\"default\"](_objectSpread(_objectSpread(_objectSpread({}, this.getDefaultDeckLayerProps(opts)), clusterData), {}, {\n        filterData: filterData,\n        // radius\n        radiusScale: 1,\n        radiusRange: visConfig.radiusRange,\n        clusterRadius: visConfig.clusterRadius,\n        // color\n        colorRange: this.getColorRange(visConfig.colorRange),\n        colorScaleType: this.config.colorScale,\n        colorAggregation: visConfig.colorAggregation,\n        zoom: Math.round(mapState.zoom),\n        width: mapState.width,\n        height: mapState.height,\n        // updateTriggers\n        updateTriggers: updateTriggers,\n        // call back from layer after calculate clusters\n        onSetColorDomain: layerCallbacks.onSetLayerDomain\n      }))].concat((0, _toConsumableArray2[\"default\"])(hoveredObject ? [new _layers.ScatterplotLayer({\n        id: \"\".concat(this.id, \"-hovered\"),\n        data: [hoveredObject],\n        getFillColor: this.config.highlightColor,\n        getRadius: function getRadius(d) {\n          return d.radius;\n        },\n        radiusScale: 1,\n        pickable: false\n      })] : []));\n    }\n  }]);\n  return ClusterLayer;\n}(_aggregationLayer[\"default\"]);\nexports[\"default\"] = ClusterLayer;","map":{"version":3,"sources":["../../../src/layers/cluster-layer/cluster-layer.js"],"names":["clusterVisConfigs","opacity","clusterRadius","colorRange","radiusRange","colorAggregation","ClusterLayer","AggregationLayer","props","registerVisConfig","ClusterLayerIcon","color","aggregation","channelScaleType","CHANNEL_SCALES","colorAggr","defaultMeasure","domain","field","key","property","range","scale","opts","visConfig","config","data","gpuFilter","objectHovered","mapState","layerCallbacks","updateTriggers","getColorValue","colorField","filterData","filterRange","filterValueUpdateTriggers","_filterData","clusterData","hoveredObject","hasHoveredObject","DeckGLClusterLayer","getDefaultDeckLayerProps","radiusScale","getColorRange","colorScaleType","colorScale","zoom","Math","round","width","height","onSetColorDomain","onSetLayerDomain","ScatterplotLayer","id","getFillColor","highlightColor","getRadius","d","radius","pickable"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport AggregationLayer from '../aggregation-layer';\nimport {ScatterplotLayer} from '@deck.gl/layers';\n\nimport DeckGLClusterLayer from 'deckgl-layers/cluster-layer/cluster-layer';\nimport {CHANNEL_SCALES} from 'constants/default-settings';\nimport ClusterLayerIcon from './cluster-layer-icon';\n\nexport const clusterVisConfigs = {\n  opacity: 'opacity',\n  clusterRadius: 'clusterRadius',\n  colorRange: 'colorRange',\n  radiusRange: 'clusterRadiusRange',\n  colorAggregation: 'aggregation'\n};\n\nexport default class ClusterLayer extends AggregationLayer {\n  constructor(props) {\n    super(props);\n    this.registerVisConfig(clusterVisConfigs);\n  }\n\n  get type() {\n    return 'cluster';\n  }\n\n  get layerIcon() {\n    return ClusterLayerIcon;\n  }\n\n  get visualChannels() {\n    return {\n      color: {\n        aggregation: 'colorAggregation',\n        channelScaleType: CHANNEL_SCALES.colorAggr,\n        defaultMeasure: 'property.pointCount',\n        domain: 'colorDomain',\n        field: 'colorField',\n        key: 'color',\n        property: 'color',\n        range: 'colorRange',\n        scale: 'colorScale'\n      }\n    };\n  }\n\n  renderLayer(opts) {\n    const {visConfig} = this.config;\n    const {data, gpuFilter, objectHovered, mapState, layerCallbacks} = opts;\n\n    const updateTriggers = {\n      getColorValue: {\n        colorField: this.config.colorField,\n        colorAggregation: this.config.visConfig.colorAggregation\n      },\n      filterData: {\n        filterRange: gpuFilter.filterRange,\n        ...gpuFilter.filterValueUpdateTriggers\n      }\n    };\n    const {_filterData: filterData, ...clusterData} = data;\n    const hoveredObject = this.hasHoveredObject(objectHovered);\n\n    return [\n      new DeckGLClusterLayer({\n        ...this.getDefaultDeckLayerProps(opts),\n        ...clusterData,\n        filterData,\n\n        // radius\n        radiusScale: 1,\n        radiusRange: visConfig.radiusRange,\n        clusterRadius: visConfig.clusterRadius,\n\n        // color\n        colorRange: this.getColorRange(visConfig.colorRange),\n        colorScaleType: this.config.colorScale,\n        colorAggregation: visConfig.colorAggregation,\n\n        zoom: Math.round(mapState.zoom),\n        width: mapState.width,\n        height: mapState.height,\n\n        // updateTriggers\n        updateTriggers,\n\n        // call back from layer after calculate clusters\n        onSetColorDomain: layerCallbacks.onSetLayerDomain\n      }),\n      // hover layer\n      ...(hoveredObject\n        ? [\n            new ScatterplotLayer({\n              id: `${this.id}-hovered`,\n              data: [hoveredObject],\n              getFillColor: this.config.highlightColor,\n              getRadius: d => d.radius,\n              radiusScale: 1,\n              pickable: false\n            })\n          ]\n        : [])\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}