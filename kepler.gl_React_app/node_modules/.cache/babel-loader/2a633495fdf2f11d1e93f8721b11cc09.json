{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coordHasLength4 = coordHasLength4;\nexports.containValidTime = containValidTime;\nexports.isTripGeoJsonField = isTripGeoJsonField;\nexports.parseTripGeoJsonTimestamp = parseTripGeoJsonTimestamp;\nexports.getAnimationDomainFromTimestamps = getAnimationDomainFromTimestamps;\nvar _typeAnalyzer = require(\"type-analyzer\");\nvar _dataUtils = require(\"../../utils/data-utils\");\nvar _dataContainerUtils = require(\"../../utils/table-utils/data-container-utils\");\nvar _geojsonUtils = require(\"../geojson-layer/geojson-utils\");\n\n// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * Parse geojson from string\n * @param {array} samples feature object values\n * @returns {boolean} whether the geometry coordinates has length of 4\n */\nfunction coordHasLength4(samples) {\n  var hasLength4 = true;\n  for (var i = 0; i < samples.length; i += 1) {\n    hasLength4 = !samples[i].geometry.coordinates.find(function (c) {\n      return c.length < 4;\n    });\n    if (!hasLength4) {\n      break;\n    }\n  }\n  return hasLength4;\n}\n/**\n * Check whether geojson linestring's 4th coordinate is 1) not timestamp 2) unix time stamp 3) real date time\n * @param {array} timestamps array to be tested if its elements are timestamp\n * @returns {object | boolean} the type of timestamp: unix/datetime/invalid(not timestamp)\n */\n\nfunction containValidTime(timestamps) {\n  var formattedTimeStamps = timestamps.map(function (ts) {\n    return {\n      ts: ts\n    };\n  });\n  var ignoredDataTypes = Object.keys(_typeAnalyzer.DATA_TYPES).filter(function (type) {\n    return ![_typeAnalyzer.DATA_TYPES.TIME, _typeAnalyzer.DATA_TYPES.DATETIME].includes(type);\n  }); // ignore all types but TIME to improve performance\n\n  var analyzedType = _typeAnalyzer.Analyzer.computeColMeta(formattedTimeStamps, [], {\n    ignoredDataTypes: ignoredDataTypes\n  })[0];\n  if (!analyzedType || analyzedType.category !== 'TIME') {\n    return false;\n  }\n  return analyzedType;\n}\n/**\n * Check if geojson features are trip layer animatable by meeting 3 conditions\n * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} dataContainer geojson feature objects container\n * @param {object} field array of geojson feature objects\n * @returns {boolean} whether it is trip layer animatable\n */\n\nfunction isTripGeoJsonField(dataContainer, field) {\n  if (dataContainer.numRows() < 1) {\n    return false;\n  }\n  var maxCount = 10000;\n  var sampleRawFeatures = dataContainer.numRows() > maxCount ? (0, _dataContainerUtils.getSampleData)(dataContainer, maxCount) : dataContainer;\n  var features = sampleRawFeatures.mapIndex(field.valueAccessor).map(_geojsonUtils.parseGeoJsonRawFeature).filter(function (f) {\n    return f;\n  });\n  var featureTypes = (0, _geojsonUtils.getGeojsonFeatureTypes)(features); // condition 1: contain line string\n\n  if (!featureTypes.line) {\n    return false;\n  } // condition 2:sample line strings contain 4 coordinates\n\n  if (!coordHasLength4(features)) {\n    return false;\n  } // condition 3:the 4th coordinate of the first feature line strings is valid time\n\n  var tsHolder = features[0].geometry.coordinates.map(function (coord) {\n    return coord[3];\n  });\n  return Boolean(containValidTime(tsHolder));\n}\n/**\n * Get unix timestamp from animatable geojson for deck.gl trip layer\n * @param {Array<Object>} dataToFeature array of geojson feature objects, can be null\n * @returns {{dataToTimeStamp: Array[Number], animationDomain: null | Array<Number>}} {dataToTimeStamp: [], animationDomain: null}\n */\n\nfunction parseTripGeoJsonTimestamp(dataToFeature) {\n  // Analyze type based on coordinates of the 1st lineString\n  // select a sample trip to analyze time format\n  var empty = {\n    dataToTimeStamp: [],\n    animationDomain: null\n  };\n  var sampleTrip = dataToFeature.find(function (f) {\n    return f && f.geometry && f.geometry.coordinates && f.geometry.coordinates.length >= 3;\n  }); // if no valid geometry\n\n  if (!sampleTrip) {\n    return empty;\n  }\n  var analyzedType = containValidTime(sampleTrip.geometry.coordinates.map(function (coord) {\n    return coord[3];\n  }));\n  if (!analyzedType) {\n    return empty;\n  }\n  var format = analyzedType.format;\n  var getTimeValue = function getTimeValue(coord) {\n    return coord && (0, _dataUtils.notNullorUndefined)(coord[3]) ? (0, _dataUtils.timeToUnixMilli)(coord[3], format) : null;\n  };\n  var dataToTimeStamp = dataToFeature.map(function (f) {\n    return f && f.geometry && Array.isArray(f.geometry.coordinates) ? f.geometry.coordinates.map(getTimeValue) : null;\n  });\n  var animationDomain = getAnimationDomainFromTimestamps(dataToTimeStamp);\n  return {\n    dataToTimeStamp: dataToTimeStamp,\n    animationDomain: animationDomain\n  };\n}\nfunction findMinFromSorted() {\n  var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return list.find(function (d) {\n    return (0, _dataUtils.notNullorUndefined)(d) && Number.isFinite(d);\n  }) || null;\n}\nfunction findMaxFromSorted() {\n  var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var i = list.length - 1;\n  while (i > 0) {\n    if ((0, _dataUtils.notNullorUndefined)(list[i]) && Number.isFinite(list[i])) {\n      return list[i];\n    }\n    i--;\n  }\n  return null;\n}\nfunction getAnimationDomainFromTimestamps() {\n  var dataToTimeStamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return dataToTimeStamp.reduce(function (accu, tss) {\n    var tsMin = findMinFromSorted(tss);\n    var tsMax = findMaxFromSorted(tss);\n    if (Number.isFinite(tsMin) && Number.isFinite(tsMax)) {\n      accu[0] = Math.min(accu[0], tsMin);\n      accu[1] = Math.max(accu[1], tsMax);\n    }\n    return accu;\n  }, [Infinity, -Infinity]);\n}","map":{"version":3,"sources":["../../../src/layers/trip-layer/trip-utils.js"],"names":["coordHasLength4","samples","hasLength4","i","length","geometry","coordinates","find","c","containValidTime","timestamps","formattedTimeStamps","map","ts","ignoredDataTypes","keys","DATA_TYPES","filter","TIME","DATETIME","includes","type","analyzedType","computeColMeta","category","isTripGeoJsonField","dataContainer","field","numRows","maxCount","sampleRawFeatures","features","mapIndex","valueAccessor","parseGeoJsonRawFeature","f","featureTypes","line","tsHolder","coord","Boolean","parseTripGeoJsonTimestamp","dataToFeature","empty","dataToTimeStamp","animationDomain","sampleTrip","format","getTimeValue","Array","isArray","getAnimationDomainFromTimestamps","findMinFromSorted","list","d","Number","isFinite","findMaxFromSorted","reduce","accu","tss","tsMin","tsMax","Math","min","max","Infinity"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Analyzer, DATA_TYPES} from 'type-analyzer';\n\nimport {timeToUnixMilli, notNullorUndefined} from 'utils/data-utils';\nimport {getSampleData} from 'utils/table-utils/data-container-utils';\n\nimport {parseGeoJsonRawFeature, getGeojsonFeatureTypes} from 'layers/geojson-layer/geojson-utils';\n\n/**\n * Parse geojson from string\n * @param {array} samples feature object values\n * @returns {boolean} whether the geometry coordinates has length of 4\n */\nexport function coordHasLength4(samples) {\n  let hasLength4 = true;\n  for (let i = 0; i < samples.length; i += 1) {\n    hasLength4 = !samples[i].geometry.coordinates.find(c => c.length < 4);\n    if (!hasLength4) {\n      break;\n    }\n  }\n  return hasLength4;\n}\n\n/**\n * Check whether geojson linestring's 4th coordinate is 1) not timestamp 2) unix time stamp 3) real date time\n * @param {array} timestamps array to be tested if its elements are timestamp\n * @returns {object | boolean} the type of timestamp: unix/datetime/invalid(not timestamp)\n */\n\nexport function containValidTime(timestamps) {\n  const formattedTimeStamps = timestamps.map(ts => ({ts}));\n  const ignoredDataTypes = Object.keys(DATA_TYPES).filter(\n    type => ![DATA_TYPES.TIME, DATA_TYPES.DATETIME].includes(type)\n  );\n\n  // ignore all types but TIME to improve performance\n  const analyzedType = Analyzer.computeColMeta(formattedTimeStamps, [], {ignoredDataTypes})[0];\n\n  if (!analyzedType || analyzedType.category !== 'TIME') {\n    return false;\n  }\n  return analyzedType;\n}\n\n/**\n * Check if geojson features are trip layer animatable by meeting 3 conditions\n * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} dataContainer geojson feature objects container\n * @param {object} field array of geojson feature objects\n * @returns {boolean} whether it is trip layer animatable\n */\nexport function isTripGeoJsonField(dataContainer, field) {\n  if (dataContainer.numRows() < 1) {\n    return false;\n  }\n\n  const maxCount = 10000;\n  const sampleRawFeatures =\n    dataContainer.numRows() > maxCount ? getSampleData(dataContainer, maxCount) : dataContainer;\n\n  const features = sampleRawFeatures\n    .mapIndex(field.valueAccessor)\n    .map(parseGeoJsonRawFeature)\n    .filter(f => f);\n  const featureTypes = getGeojsonFeatureTypes(features);\n\n  // condition 1: contain line string\n  if (!featureTypes.line) {\n    return false;\n  }\n\n  // condition 2:sample line strings contain 4 coordinates\n  if (!coordHasLength4(features)) {\n    return false;\n  }\n\n  // condition 3:the 4th coordinate of the first feature line strings is valid time\n  const tsHolder = features[0].geometry.coordinates.map(coord => coord[3]);\n\n  return Boolean(containValidTime(tsHolder));\n}\n\n/**\n * Get unix timestamp from animatable geojson for deck.gl trip layer\n * @param {Array<Object>} dataToFeature array of geojson feature objects, can be null\n * @returns {{dataToTimeStamp: Array[Number], animationDomain: null | Array<Number>}} {dataToTimeStamp: [], animationDomain: null}\n */\nexport function parseTripGeoJsonTimestamp(dataToFeature) {\n  // Analyze type based on coordinates of the 1st lineString\n  // select a sample trip to analyze time format\n  const empty = {dataToTimeStamp: [], animationDomain: null};\n  const sampleTrip = dataToFeature.find(\n    f => f && f.geometry && f.geometry.coordinates && f.geometry.coordinates.length >= 3\n  );\n\n  // if no valid geometry\n  if (!sampleTrip) {\n    return empty;\n  }\n\n  const analyzedType = containValidTime(sampleTrip.geometry.coordinates.map(coord => coord[3]));\n\n  if (!analyzedType) {\n    return empty;\n  }\n\n  const {format} = analyzedType;\n  const getTimeValue = coord =>\n    coord && notNullorUndefined(coord[3]) ? timeToUnixMilli(coord[3], format) : null;\n\n  const dataToTimeStamp = dataToFeature.map(f =>\n    f && f.geometry && Array.isArray(f.geometry.coordinates)\n      ? f.geometry.coordinates.map(getTimeValue)\n      : null\n  );\n\n  const animationDomain = getAnimationDomainFromTimestamps(dataToTimeStamp);\n\n  return {dataToTimeStamp, animationDomain};\n}\n\nfunction findMinFromSorted(list = []) {\n  return list.find(d => notNullorUndefined(d) && Number.isFinite(d)) || null;\n}\n\nfunction findMaxFromSorted(list = []) {\n  let i = list.length - 1;\n  while (i > 0) {\n    if (notNullorUndefined(list[i]) && Number.isFinite(list[i])) {\n      return list[i];\n    }\n    i--;\n  }\n  return null;\n}\n\nexport function getAnimationDomainFromTimestamps(dataToTimeStamp = []) {\n  return dataToTimeStamp.reduce(\n    (accu, tss) => {\n      const tsMin = findMinFromSorted(tss);\n      const tsMax = findMaxFromSorted(tss);\n      if (Number.isFinite(tsMin) && Number.isFinite(tsMax)) {\n        accu[0] = Math.min(accu[0], tsMin);\n        accu[1] = Math.max(accu[1], tsMax);\n      }\n      return accu;\n    },\n    [Infinity, -Infinity]\n  );\n}\n"]},"metadata":{},"sourceType":"script"}