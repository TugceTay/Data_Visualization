{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar DEFAULT_OPTIONS = {\n  batchSize: 'auto',\n  convertToObject: true,\n  optimizeMemoryUsage: false\n};\nvar RowTableBatch = function () {\n  function RowTableBatch(schema) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, RowTableBatch);\n    options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n    this.schema = schema;\n    this.batchSize = options.batchSize;\n    this.convertToObject = options.convertToObject;\n    this.optimizeMemoryUsage = options.optimizeMemoryUsage;\n    this.rows = null;\n    this.length = 0;\n    this.isChunkComplete = false;\n    this.cursor = 0;\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (var key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n  _createClass(RowTableBatch, [{\n    key: \"addRow\",\n    value: function addRow(row) {\n      var cursor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (!this.rows) {\n        this.rows = new Array(this.batchSize);\n        this.length = 0;\n      }\n      if (Number.isFinite(cursor)) {\n        this.cursor = cursor;\n      }\n      var convertToObject = this.convertToObject && this.schema;\n      this.rows[this.length] = convertToObject ? convertRowToObject(row, this._headers) : row;\n      if (this.optimizeMemoryUsage) {\n        this.rows[this.length] = JSON.parse(JSON.stringify(this.rows[this.length]));\n      }\n      this.length++;\n    }\n  }, {\n    key: \"chunkComplete\",\n    value: function chunkComplete() {\n      this.isChunkComplete = true;\n    }\n  }, {\n    key: \"isFull\",\n    value: function isFull() {\n      if (this.batchSize === 'auto') {\n        return this.isChunkComplete && this.length > 0;\n      }\n      return this.rows && this.length >= this.batchSize;\n    }\n  }, {\n    key: \"getBatch\",\n    value: function getBatch() {\n      if (this.rows) {\n        var rows = this.rows.slice(0, this.length);\n        this.rows = null;\n        this.isChunkComplete = false;\n        return {\n          data: rows,\n          schema: this.schema,\n          length: rows.length,\n          cursor: this.cursor\n        };\n      }\n      return null;\n    }\n  }]);\n  return RowTableBatch;\n}();\nexport { RowTableBatch as default };\nfunction convertRowToObject(row, headers) {\n  if (!row) {\n    throw new Error('null row');\n  }\n  if (!Array.isArray(row)) {\n    return row;\n  }\n  if (!headers) {\n    return row;\n  }\n  var result = {};\n  for (var i = 0; i < headers.length; i++) {\n    result[headers[i]] = row[i];\n  }\n  return result;\n}","map":{"version":3,"sources":["../../../../src/lib/table/row-table-batch.js"],"names":["DEFAULT_OPTIONS","batchSize","convertToObject","optimizeMemoryUsage","RowTableBatch","schema","options","rows","length","isChunkComplete","cursor","Array","isArray","_headers","key","index","name","row","Number","isFinite","convertRowToObject","JSON","parse","stringify","slice","data","headers","Error","result","i"],"mappings":"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","sourcesContent":["const DEFAULT_OPTIONS = {\n  batchSize: 'auto',\n  convertToObject: true,\n  // optimizes memory usage but increases parsing time.\n  optimizeMemoryUsage: false\n};\n\nexport default class RowTableBatch {\n  constructor(schema, options = {}) {\n    options = {...DEFAULT_OPTIONS, ...options};\n\n    this.schema = schema;\n    this.batchSize = options.batchSize;\n    this.convertToObject = options.convertToObject;\n    this.optimizeMemoryUsage = options.optimizeMemoryUsage;\n\n    this.rows = null;\n    this.length = 0;\n    this.isChunkComplete = false;\n    this.cursor = 0;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  addRow(row, cursor = null) {\n    if (!this.rows) {\n      this.rows = new Array(this.batchSize);\n      this.length = 0;\n    }\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor;\n    }\n\n    // We can only convert if we were given a schema\n    const convertToObject = this.convertToObject && this.schema;\n    this.rows[this.length] = convertToObject ? convertRowToObject(row, this._headers) : row;\n\n    if (this.optimizeMemoryUsage) {\n      // A workaround to allocate new strings and don't retain pointers to original strings.\n      // https://bugs.chromium.org/p/v8/issues/detail?id=2869\n      this.rows[this.length] = JSON.parse(JSON.stringify(this.rows[this.length]));\n    }\n\n    this.length++;\n  }\n\n  chunkComplete() {\n    this.isChunkComplete = true;\n  }\n\n  isFull() {\n    if (this.batchSize === 'auto') {\n      return this.isChunkComplete && this.length > 0;\n    }\n    return this.rows && this.length >= this.batchSize;\n  }\n\n  getBatch() {\n    if (this.rows) {\n      const rows = this.rows.slice(0, this.length);\n      this.rows = null;\n      this.isChunkComplete = false;\n      return {data: rows, schema: this.schema, length: rows.length, cursor: this.cursor};\n    }\n    return null;\n  }\n}\n\nfunction convertRowToObject(row, headers) {\n  if (!row) {\n    throw new Error('null row');\n  }\n  if (!Array.isArray(row)) {\n    return row;\n  }\n\n  if (!headers) {\n    return row;\n  }\n  const result = {};\n  for (let i = 0; i < headers.length; i++) {\n    result[headers[i]] = row[i];\n  }\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}