{"ast":null,"code":"import { assert } from '@loaders.gl/loader-utils';\nexport function encode3DTileHeader(tile, dataView, byteOffset) {\n  var HEADER_SIZE = 12;\n  if (!dataView) {\n    return byteOffset + HEADER_SIZE;\n  }\n  var magic = tile.magic,\n    _tile$version = tile.version,\n    version = _tile$version === void 0 ? 1 : _tile$version,\n    _tile$byteLength = tile.byteLength,\n    byteLength = _tile$byteLength === void 0 ? 12 : _tile$byteLength;\n  assert(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));\n  dataView.setUint8(byteOffset + 0, magic[0]);\n  dataView.setUint8(byteOffset + 1, magic[1]);\n  dataView.setUint8(byteOffset + 2, magic[2]);\n  dataView.setUint8(byteOffset + 3, magic[3]);\n  dataView.setUint32(byteOffset + 4, version, true);\n  dataView.setUint32(byteOffset + 8, byteLength, true);\n  byteOffset += HEADER_SIZE;\n  return byteOffset;\n}\nexport function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {\n  if (!dataView) {\n    return;\n  }\n  dataView.setUint32(byteOffsetTileStart + 8, byteLength, true);\n}","map":{"version":3,"sources":["../../../../../src/lib/encoders/helpers/encode-3d-tile-header.js"],"names":["assert","encode3DTileHeader","tile","dataView","byteOffset","HEADER_SIZE","magic","version","byteLength","Array","isArray","Number","isFinite","setUint8","setUint32","encode3DTileByteLength","byteOffsetTileStart"],"mappings":"AACA,SAAQA,MAAR,QAAqB,0BAArB;AAEA,OAAO,SAASC,kBAAT,CAA4BC,IAA5B,EAAkCC,QAAlC,EAA4CC,UAA5C,EAAwD;EAC7D,IAAMC,WAAW,GAAG,EAApB;EAEA,IAAI,CAACF,QAAL,EAAe;IACb,OAAOC,UAAU,GAAGC,WAApB;EACD;EAL4D,IAOtDC,KAPsD,GAOfJ,IAPe,CAOtDI,KAPsD;IAAA,aAAA,GAOfJ,IAPe,CAO/CK,OAP+C;IAO/CA,OAP+C,GAAA,aAAA,KAAA,KAAA,CAAA,GAOrC,CAPqC,GAAA,aAAA;IAAA,gBAAA,GAOfL,IAPe,CAOlCM,UAPkC;IAOlCA,UAPkC,GAAA,gBAAA,KAAA,KAAA,CAAA,GAOrB,EAPqB,GAAA,gBAAA;EAS7DR,MAAM,CAACS,KAAK,CAACC,OAAND,CAAcH,KAAdG,CAAAA,IAAwBE,MAAM,CAACC,QAAPD,CAAgBJ,OAAhBI,CAAxBF,IAAoDE,MAAM,CAACC,QAAPD,CAAgBH,UAAhBG,CAArD,CAANX;EAEAG,QAAQ,CAACU,QAATV,CAAkBC,UAAU,GAAG,CAA/BD,EAAkCG,KAAK,CAAC,CAAD,CAAvCH,CAAAA;EACAA,QAAQ,CAACU,QAATV,CAAkBC,UAAU,GAAG,CAA/BD,EAAkCG,KAAK,CAAC,CAAD,CAAvCH,CAAAA;EACAA,QAAQ,CAACU,QAATV,CAAkBC,UAAU,GAAG,CAA/BD,EAAkCG,KAAK,CAAC,CAAD,CAAvCH,CAAAA;EACAA,QAAQ,CAACU,QAATV,CAAkBC,UAAU,GAAG,CAA/BD,EAAkCG,KAAK,CAAC,CAAD,CAAvCH,CAAAA;EACAA,QAAQ,CAACW,SAATX,CAAmBC,UAAU,GAAG,CAAhCD,EAAmCI,OAAnCJ,EAA4C,IAA5CA,CAAAA;EACAA,QAAQ,CAACW,SAATX,CAAmBC,UAAU,GAAG,CAAhCD,EAAmCK,UAAnCL,EAA+C,IAA/CA,CAAAA;EAEAC,UAAU,IAAIC,WAAdD;EAEA,OAAOA,UAAP;AACD;AAGD,OAAO,SAASW,sBAAT,CAAgCZ,QAAhC,EAA0Ca,mBAA1C,EAA+DR,UAA/D,EAA2E;EAChF,IAAI,CAACL,QAAL,EAAe;IACb;EACD;EAEDA,QAAQ,CAACW,SAATX,CAAmBa,mBAAmB,GAAG,CAAzCb,EAA4CK,UAA5CL,EAAwD,IAAxDA,CAAAA;AACD","sourcesContent":["// HELPER ENCODERS\nimport {assert} from '@loaders.gl/loader-utils';\n\nexport function encode3DTileHeader(tile, dataView, byteOffset) {\n  const HEADER_SIZE = 12;\n\n  if (!dataView) {\n    return byteOffset + HEADER_SIZE;\n  }\n\n  const {magic, version = 1, byteLength = 12} = tile;\n\n  assert(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));\n\n  dataView.setUint8(byteOffset + 0, magic[0]);\n  dataView.setUint8(byteOffset + 1, magic[1]);\n  dataView.setUint8(byteOffset + 2, magic[2]);\n  dataView.setUint8(byteOffset + 3, magic[3]);\n  dataView.setUint32(byteOffset + 4, version, true); // version\n  dataView.setUint32(byteOffset + 8, byteLength, true); // byteLength\n\n  byteOffset += HEADER_SIZE;\n\n  return byteOffset;\n}\n\n// Bytelength is sometimes only known at the end of writing a tile\nexport function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {\n  if (!dataView) {\n    return;\n  }\n\n  dataView.setUint32(byteOffsetTileStart + 8, byteLength, true); // byteLength\n}\n"]},"metadata":{},"sourceType":"module"}