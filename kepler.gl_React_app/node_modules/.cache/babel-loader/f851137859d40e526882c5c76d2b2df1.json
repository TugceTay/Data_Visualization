{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { equals } from 'math.gl';\nimport assert from '../utils/assert';\nvar TransitionInterpolator = function () {\n  function TransitionInterpolator() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, TransitionInterpolator);\n    if (Array.isArray(opts)) {\n      opts = {\n        compare: opts,\n        extract: opts,\n        required: opts\n      };\n    }\n    var _opts = opts,\n      compare = _opts.compare,\n      extract = _opts.extract,\n      required = _opts.required;\n    this._propsToCompare = compare;\n    this._propsToExtract = extract;\n    this._requiredProps = required;\n  }\n  _createClass(TransitionInterpolator, [{\n    key: \"arePropsEqual\",\n    value: function arePropsEqual(currentProps, nextProps) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = (this._propsToCompare || Object.keys(nextProps))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"initializeProps\",\n    value: function initializeProps(startProps, endProps) {\n      var result;\n      if (this._propsToExtract) {\n        var startViewStateProps = {};\n        var endViewStateProps = {};\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n        try {\n          for (var _iterator2 = this._propsToExtract[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var key = _step2.value;\n            startViewStateProps[key] = startProps[key];\n            endViewStateProps[key] = endProps[key];\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n        result = {\n          start: startViewStateProps,\n          end: endViewStateProps\n        };\n      } else {\n        result = {\n          start: startProps,\n          end: endProps\n        };\n      }\n      this._checkRequiredProps(result.start);\n      this._checkRequiredProps(result.end);\n      return result;\n    }\n  }, {\n    key: \"interpolateProps\",\n    value: function interpolateProps(startProps, endProps, t) {\n      return endProps;\n    }\n  }, {\n    key: \"getDuration\",\n    value: function getDuration(startProps, endProps) {\n      return endProps.transitionDuration;\n    }\n  }, {\n    key: \"_checkRequiredProps\",\n    value: function _checkRequiredProps(props) {\n      if (!this._requiredProps) {\n        return;\n      }\n      this._requiredProps.forEach(function (propName) {\n        var value = props[propName];\n        assert(Number.isFinite(value) || Array.isArray(value), \"\".concat(propName, \" is required for transition\"));\n      });\n    }\n  }]);\n  return TransitionInterpolator;\n}();\nexport { TransitionInterpolator as default };","map":{"version":3,"sources":["../../../src/transitions/transition-interpolator.js"],"names":["equals","assert","TransitionInterpolator","opts","Array","isArray","compare","extract","required","_propsToCompare","_propsToExtract","_requiredProps","currentProps","nextProps","key","Object","keys","startProps","endProps","result","startViewStateProps","endViewStateProps","start","end","_checkRequiredProps","t","transitionDuration","props","forEach","value","propName","Number","isFinite"],"mappings":"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","sourcesContent":["import {equals} from 'math.gl';\nimport assert from '../utils/assert';\n\nexport default class TransitionInterpolator {\n  /**\n   * @param opts {array|object}\n   * @param opts.compare {array} - prop names used in equality check\n   * @param opts.extract {array} - prop names needed for interpolation\n   * @param opts.required {array} - prop names that must be supplied\n   * alternatively, supply one list of prop names as `opts` if all of the above are the same.\n   */\n  constructor(opts = {}) {\n    if (Array.isArray(opts)) {\n      opts = {\n        compare: opts,\n        extract: opts,\n        required: opts\n      };\n    }\n    const {compare, extract, required} = opts;\n\n    this._propsToCompare = compare;\n    this._propsToExtract = extract;\n    this._requiredProps = required;\n  }\n\n  /**\n   * Checks if two sets of props need transition in between\n   * @param currentProps {object} - a list of viewport props\n   * @param nextProps {object} - a list of viewport props\n   * @returns {bool} - true if two props are equivalent\n   */\n  arePropsEqual(currentProps, nextProps) {\n    for (const key of this._propsToCompare || Object.keys(nextProps)) {\n      if (\n        !(key in currentProps) ||\n        !(key in nextProps) ||\n        !equals(currentProps[key], nextProps[key])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Called before transition starts to validate/pre-process start and end props\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @returns {Object} {start, end} - start and end props to be passed\n   *   to `interpolateProps`\n   */\n  initializeProps(startProps, endProps) {\n    let result;\n\n    if (this._propsToExtract) {\n      const startViewStateProps = {};\n      const endViewStateProps = {};\n\n      for (const key of this._propsToExtract) {\n        startViewStateProps[key] = startProps[key];\n        endViewStateProps[key] = endProps[key];\n      }\n      result = {start: startViewStateProps, end: endViewStateProps};\n    } else {\n      result = {start: startProps, end: endProps};\n    }\n\n    this._checkRequiredProps(result.start);\n    this._checkRequiredProps(result.end);\n\n    return result;\n  }\n\n  /**\n   * Returns viewport props in transition\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @param t {number} - a time factor between [0, 1]\n   * @returns {object} - a list of interpolated viewport props\n   */\n  interpolateProps(startProps, endProps, t) {\n    return endProps;\n  }\n\n  /**\n   * Returns transition duration\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @returns {Number} - transition duration in milliseconds\n   */\n  getDuration(startProps, endProps) {\n    return endProps.transitionDuration;\n  }\n\n  _checkRequiredProps(props) {\n    if (!this._requiredProps) {\n      return;\n    }\n\n    this._requiredProps.forEach(propName => {\n      const value = props[propName];\n      assert(\n        Number.isFinite(value) || Array.isArray(value),\n        `${propName} is required for transition`\n      );\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}