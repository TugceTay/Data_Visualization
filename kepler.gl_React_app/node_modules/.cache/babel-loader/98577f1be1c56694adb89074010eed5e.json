{"ast":null,"code":"import { getPassthroughFS } from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { assert, isObjectEmpty, getShaderVersion } from '@luma.gl/webgl';\nimport Model from '../lib/model';\nexport default class Transform {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n    this._initialize(props);\n    Object.seal(this);\n  }\n  delete() {\n    const {\n      model,\n      bufferTransform,\n      textureTransform\n    } = this;\n    if (model) {\n      model.delete();\n    }\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n  run() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      clearRenderTarget = true\n    } = opts;\n    const updatedOpts = this._updateDrawOptions(opts);\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({\n        color: true\n      });\n    }\n    this.model.transform(updatedOpts);\n  }\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n    assert(swapped, 'Nothing to swap');\n  }\n  getBuffer() {\n    let varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n  getData() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      const data = resourceTransform.getData(opts);\n      if (data) {\n        return data;\n      }\n    }\n    return null;\n  }\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n  update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if ('elementCount' in opts) {\n      this.model.setVertexCount(opts.elementCount);\n    }\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n  _initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      gl\n    } = this;\n    this._buildResourceTransforms(gl, props);\n    props = this._updateModelProps(props);\n    this.model = new Model(gl, Object.assign({}, props, {\n      fs: props.fs || getPassthroughFS({\n        version: getShaderVersion(props.vs)\n      }),\n      id: props.id || 'transform-model',\n      drawMode: props.drawMode || 0,\n      vertexCount: props.elementCount\n    }));\n    this.bufferTransform && this.bufferTransform.setupResources({\n      model: this.model\n    });\n  }\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n    return updatedProps;\n  }\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n    assert(this.bufferTransform || this.textureTransform, 'must provide source/feedback buffers or source/target textures');\n  }\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n    return updatedOpts;\n  }\n}\nfunction canCreateBufferTransform(props) {\n  if (!isObjectEmpty(props.feedbackBuffers) || !isObjectEmpty(props.feedbackMap) || props.varyings && props.varyings.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction canCreateTextureTransform(props) {\n  if (!isObjectEmpty(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {\n    return true;\n  }\n  return false;\n}","map":{"version":3,"sources":["../../../src/transform/transform.js"],"names":["getPassthroughFS","BufferTransform","TextureTransform","isWebGL2","assert","isObjectEmpty","getShaderVersion","Model","Transform","isSupported","gl","constructor","props","model","elementCount","bufferTransform","textureTransform","elementIDBuffer","_initialize","Object","seal","delete","run","opts","clearRenderTarget","updatedOpts","_updateDrawOptions","framebuffer","clear","color","transform","swap","swapped","resourceTransforms","filter","Boolean","resourceTransform","getBuffer","varyingName","getData","data","getFramebuffer","update","setVertexCount","_buildResourceTransforms","_updateModelProps","assign","fs","version","vs","id","drawMode","vertexCount","setupResources","updatedProps","updateModelProps","canCreateBufferTransform","canCreateTextureTransform","getDrawOptions","feedbackBuffers","feedbackMap","varyings","length","_sourceTextures","_targetTexture","_targetTextureVarying"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\n\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {assert, isObjectEmpty, getShaderVersion} from '@luma.gl/webgl';\nimport Model from '../lib/model';\n\n// takes source and target buffers/textures and setsup the pipeline\nexport default class Transform {\n  static isSupported(gl) {\n    // TODO : differentiate writting to buffer vs not\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {model, bufferTransform, textureTransform} = this;\n    if (model) {\n      model.delete();\n    }\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  // Run one transform loop.\n  run(opts = {}) {\n    const {clearRenderTarget = true} = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({color: true});\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  // swap resources if a map is provided\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n    assert(swapped, 'Nothing to swap');\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  // Return data either from Buffer or from Texture\n  getData(opts = {}) {\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      // @ts-ignore\n      const data = resourceTransform.getData(opts);\n      if (data) {\n        return data;\n      }\n    }\n    return null;\n  }\n\n  // Return framebuffer object if rendering to textures\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  // Update some or all buffer/texture bindings.\n  update(opts = {}) {\n    if ('elementCount' in opts) {\n      // @ts-ignore TODO\n      this.model.setVertexCount(opts.elementCount);\n    }\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {gl} = this;\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new Model(\n      gl,\n      Object.assign({}, props, {\n        fs: props.fs || getPassthroughFS({version: getShaderVersion(props.vs)}),\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || GL.POINTS,\n        vertexCount: props.elementCount\n      })\n    );\n\n    /* eslint-disable no-unused-expressions */\n    this.bufferTransform && this.bufferTransform.setupResources({model: this.model});\n    /* eslint-enable no-unused-expressions */\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n    assert(\n      this.bufferTransform || this.textureTransform,\n      'must provide source/feedback buffers or source/target textures'\n    );\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n    return updatedOpts;\n  }\n}\n\n// Helper Methods\n\nfunction canCreateBufferTransform(props) {\n  if (\n    !isObjectEmpty(props.feedbackBuffers) ||\n    !isObjectEmpty(props.feedbackMap) ||\n    (props.varyings && props.varyings.length > 0)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (\n    !isObjectEmpty(props._sourceTextures) ||\n    props._targetTexture ||\n    props._targetTextureVarying\n  ) {\n    return true;\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}