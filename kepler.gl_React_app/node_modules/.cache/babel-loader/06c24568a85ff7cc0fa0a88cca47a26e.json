{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nvar BrowserFileSystem = function () {\n  function BrowserFileSystem(files) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, BrowserFileSystem);\n    this._fetch = options.fetch || fetch;\n    this.files = {};\n    for (var i = 0; i < files.length; ++i) {\n      var file = files[i];\n      this.files[file.name] = file;\n    }\n    this.fetch = this.fetch.bind(this);\n  }\n  _createClass(BrowserFileSystem, [{\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(path) {\n        var options,\n          fallbackFetch,\n          file,\n          response,\n          _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                if (!path.includes('://')) {\n                  _context.next = 4;\n                  break;\n                }\n                fallbackFetch = options.fetch || this._fetch;\n                return _context.abrupt(\"return\", fallbackFetch(path, options));\n              case 4:\n                file = this.files[path];\n                if (!file) {\n                  _context.next = 9;\n                  break;\n                }\n                response = new Response(this.files[path]);\n                Object.defineProperty(response, 'url', {\n                  value: path\n                });\n                return _context.abrupt(\"return\", response);\n              case 9:\n                return _context.abrupt(\"return\", new Response(path, {\n                  status: 400,\n                  statusText: 'NOT FOUND'\n                }));\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function fetch(_x) {\n        return _fetch.apply(this, arguments);\n      }\n      return fetch;\n    }()\n  }, {\n    key: \"readdir\",\n    value: function () {\n      var _readdir = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2() {\n        var files, path;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                files = [];\n                for (path in this.files) {\n                  files.push(path);\n                }\n                return _context2.abrupt(\"return\", files);\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function readdir() {\n        return _readdir.apply(this, arguments);\n      }\n      return readdir;\n    }()\n  }, {\n    key: \"stat\",\n    value: function () {\n      var _stat = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(path, options) {\n        var file;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                file = this.files[path];\n                if (file) {\n                  _context3.next = 3;\n                  break;\n                }\n                throw new Error(\"No such file: \".concat(path));\n              case 3:\n                return _context3.abrupt(\"return\", {\n                  size: file.size\n                });\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function stat(_x2, _x3) {\n        return _stat.apply(this, arguments);\n      }\n      return stat;\n    }()\n  }, {\n    key: \"unlink\",\n    value: function () {\n      var _unlink = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4(pathname) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                delete this.files[pathname];\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function unlink(_x4) {\n        return _unlink.apply(this, arguments);\n      }\n      return unlink;\n    }()\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator(_regeneratorRuntime.mark(function _callee5(pathname) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.files[pathname]);\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function open(_x5) {\n        return _open.apply(this, arguments);\n      }\n      return open;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator(_regeneratorRuntime.mark(function _callee6(fd, _ref) {\n        var _ref$buffer, buffer, _ref$offset, offset, _ref$length, length, _ref$position, position, file, arrayBuffer;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _ref$buffer = _ref.buffer, buffer = _ref$buffer === void 0 ? null : _ref$buffer, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? 0 : _ref$offset, _ref$length = _ref.length, length = _ref$length === void 0 ? buffer.byteLength : _ref$length, _ref$position = _ref.position, position = _ref$position === void 0 ? null : _ref$position;\n                file = fd;\n                _context6.next = 4;\n                return readFileSlice(file, position, position + length);\n              case 4:\n                arrayBuffer = _context6.sent;\n                return _context6.abrupt(\"return\", arrayBuffer);\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n      function read(_x6, _x7) {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator(_regeneratorRuntime.mark(function _callee7(fd) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n      function close(_x8) {\n        return _close.apply(this, arguments);\n      }\n      return close;\n    }()\n  }]);\n  return BrowserFileSystem;\n}();\nexport { BrowserFileSystem as default };\nfunction readFileSlice(_x9, _x10, _x11) {\n  return _readFileSlice.apply(this, arguments);\n}\nfunction _readFileSlice() {\n  _readFileSlice = _asyncToGenerator(_regeneratorRuntime.mark(function _callee8(file, start, end) {\n    var slice;\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            slice = file.slice(start, end);\n            _context8.next = 3;\n            return new Promise(function (resolve, reject) {\n              var fileReader = new FileReader();\n              fileReader.onload = function (event) {\n                return resolve(event.target && event.target.result);\n              };\n              fileReader.onerror = function (error) {\n                return reject(error);\n              };\n              fileReader.readAsArrayBuffer(slice);\n            });\n          case 3:\n            return _context8.abrupt(\"return\", _context8.sent);\n          case 4:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _readFileSlice.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/filesystems/browser-filesystem.js"],"names":["BrowserFileSystem","files","options","_fetch","fetch","i","length","file","name","bind","path","includes","fallbackFetch","response","Response","Object","defineProperty","value","status","statusText","push","Error","size","pathname","fd","buffer","offset","byteLength","position","arrayBuffer","readFileSlice","start","end","slice","Promise","resolve","reject","fileReader","FileReader","onload","event","target","result","onerror","error","readAsArrayBuffer"],"mappings":"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","sourcesContent":["/* global Response, fetch, FileReader */\n// import {fetchFile} from \"../fetch/fetch-file\"\n/** @typedef {import('@loaders.gl/loader-utils').IFileSystem} IFileSystem */\n\n/** @implements {IFileSystem} */\nexport default class BrowserFileSystem {\n  constructor(files, options = {}) {\n    this._fetch = options.fetch || fetch;\n    this.files = {};\n\n    for (let i = 0; i < files.length; ++i) {\n      const file = files[i];\n      this.files[file.name] = file;\n    }\n\n    this.fetch = this.fetch.bind(this);\n  }\n\n  // FETCH\n\n  async fetch(path, options = {}) {\n    if (path.includes('://')) {\n      // Falls back to handle https:/http:/data: etc fetches\n      const fallbackFetch = options.fetch || this._fetch;\n      return fallbackFetch(path, options);\n    }\n\n    // local fetches are served from the list of files\n    const file = this.files[path];\n    if (file) {\n      // return makeResponse()\n      const response = new Response(this.files[path]);\n      Object.defineProperty(response, 'url', {value: path});\n      return response;\n    }\n    return new Response(path, {status: 400, statusText: 'NOT FOUND'});\n  }\n\n  // FS\n\n  async readdir() {\n    const files = [];\n    for (const path in this.files) {\n      files.push(path);\n    }\n    return files;\n  }\n\n  async stat(path, options) {\n    const file = this.files[path];\n    if (!file) {\n      throw new Error(`No such file: ${path}`);\n    }\n    return {size: file.size};\n  }\n\n  // Just removes the file from the list\n  async unlink(pathname) {\n    delete this.files[pathname];\n  }\n\n  // RANDOM ACCESS\n  async open(pathname) {\n    return this.files[pathname];\n  }\n\n  // buffer is the buffer that the data (read from the fd) will be written to.\n  // offset is the offset in the buffer to start writing at.\n  // length is an integer specifying the number of bytes to read.\n  // position is an argument specifying where to begin reading from in the file. If position is null, data will be read from the current file position, and the file position will be updated. If position is an integer, the file position will remain unchanged.\n  async read(fd, {buffer = null, offset = 0, length = buffer.byteLength, position = null}) {\n    const file = fd;\n    const arrayBuffer = await readFileSlice(file, position, position + length);\n    return arrayBuffer;\n  }\n\n  async close(fd) {\n    // NO OP\n  }\n}\n\n// The trick when reading File objects is to read successive \"slices\" of the File\n// Per spec https://w3c.github.io/FileAPI/, slicing a File should only update the start and end fields\n// Actually reading from file should happen in `readAsArrayBuffer` (and as far we can tell it does)\nasync function readFileSlice(file, start, end) {\n  const slice = file.slice(start, end);\n  return await new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = event => resolve(event.target && event.target.result);\n    fileReader.onerror = error => reject(error);\n    fileReader.readAsArrayBuffer(slice);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}