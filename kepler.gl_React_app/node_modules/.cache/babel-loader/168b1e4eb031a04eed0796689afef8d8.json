{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.clusterAggregation = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _layers = require(\"@deck.gl/layers\");\nvar _aggregationLayers = require(\"@deck.gl/aggregation-layers\");\nvar _geoViewport = _interopRequireDefault(require(\"@mapbox/geo-viewport\"));\nvar _cpuAggregator = _interopRequireWildcard(require(\"../layer-utils/cpu-aggregator\"));\nvar _viewportMercatorProject = require(\"viewport-mercator-project\");\nvar _d3Array = require(\"d3-array\");\nvar _layerFactory = require(\"../../layers/layer-factory\");\nvar _defaultSettings = require(\"../../constants/default-settings\");\nvar _colorRanges = require(\"../../constants/color-ranges\");\nvar _clusterUtils = _interopRequireWildcard(require(\"../layer-utils/cluster-utils\"));\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar defaultRadius = _layerFactory.LAYER_VIS_CONFIGS.clusterRadius.defaultValue;\nvar defaultRadiusRange = _layerFactory.LAYER_VIS_CONFIGS.clusterRadiusRange.defaultValue;\nvar defaultGetColorValue = function defaultGetColorValue(points) {\n  return points.length;\n};\nvar defaultGetRadiusValue = function defaultGetRadiusValue(cell) {\n  return cell.filteredPoints ? cell.filteredPoints.length : cell.points.length;\n};\nfunction processGeoJSON(step, props, aggregation, _ref) {\n  var viewport = _ref.viewport;\n  var data = props.data,\n    getPosition = props.getPosition,\n    filterData = props.filterData;\n  var geoJSON = (0, _clusterUtils.getGeoJSON)(data, getPosition, filterData);\n  var clusterBuilder = new _clusterUtils[\"default\"]();\n  this.setState({\n    geoJSON: geoJSON,\n    clusterBuilder: clusterBuilder\n  });\n}\nfunction getClusters(step, props, aggregation, _ref2) {\n  var viewport = _ref2.viewport;\n  var _this$state = this.state,\n    geoJSON = _this$state.geoJSON,\n    clusterBuilder = _this$state.clusterBuilder;\n  var clusterRadius = props.clusterRadius,\n    zoom = props.zoom,\n    width = props.width,\n    height = props.height;\n  var longitude = viewport.longitude,\n    latitude = viewport.latitude; // zoom needs to be an integer for the different map utils. Also helps with cache key.\n\n  var bbox = _geoViewport[\"default\"].bounds([longitude, latitude], zoom, [width, height]);\n  var clusters = clusterBuilder.clustersAtZoom({\n    bbox: bbox,\n    clusterRadius: clusterRadius,\n    geoJSON: geoJSON,\n    zoom: zoom\n  });\n  this.setState({\n    layerData: {\n      data: clusters\n    }\n  });\n}\nfunction getSubLayerRadius(dimensionState, dimension, layerProps) {\n  return function (cell) {\n    var getRadiusValue = layerProps.getRadiusValue;\n    var scaleFunc = dimensionState.scaleFunc;\n    return scaleFunc(getRadiusValue(cell));\n  };\n}\nvar clusterAggregation = {\n  key: 'position',\n  updateSteps: [{\n    key: 'geojson',\n    triggers: {\n      position: {\n        prop: 'getPosition',\n        updateTrigger: 'getPosition'\n      },\n      filterData: {\n        prop: 'filterData',\n        updateTrigger: 'filterData'\n      }\n    },\n    updater: processGeoJSON\n  }, {\n    key: 'clustering',\n    triggers: {\n      clusterRadius: {\n        prop: 'clusterRadius'\n      },\n      zoom: {\n        prop: 'zoom'\n      },\n      width: {\n        prop: 'width'\n      },\n      height: {\n        prop: 'height'\n      }\n    },\n    updater: getClusters\n  }]\n};\nexports.clusterAggregation = clusterAggregation;\nfunction getRadiusValueDomain(step, props, dimensionUpdater) {\n  var key = dimensionUpdater.key;\n  var getRadiusValue = props.getRadiusValue;\n  var layerData = this.state.layerData;\n  var valueDomain = [0, (0, _d3Array.max)(layerData.data, getRadiusValue)];\n  this._setDimensionState(key, {\n    valueDomain: valueDomain\n  });\n}\nvar clusterLayerDimensions = [_cpuAggregator.defaultColorDimension, {\n  key: 'radius',\n  accessor: 'getRadius',\n  nullValue: 0,\n  updateSteps: [{\n    key: 'getDomain',\n    triggers: {\n      value: {\n        prop: 'getRadiusValue',\n        updateTrigger: 'getRadiusValue'\n      }\n    },\n    updater: getRadiusValueDomain\n  }, {\n    key: 'getScaleFunc',\n    triggers: {\n      domain: {\n        prop: 'radiusDomain'\n      },\n      range: {\n        prop: 'radiusRange'\n      },\n      scaleType: {\n        prop: 'radiusScaleType'\n      }\n    },\n    updater: _cpuAggregator.getDimensionScale\n  }],\n  getSubLayerAccessor: getSubLayerRadius,\n  getPickingInfo: function getPickingInfo(dimensionState, cell, layerProps) {\n    var radiusValue = layerProps.getRadiusValue(cell);\n    return {\n      radiusValue: radiusValue\n    };\n  }\n}];\nvar defaultProps = {\n  clusterRadius: defaultRadius,\n  colorDomain: null,\n  colorRange: _colorRanges.DEFAULT_COLOR_RANGE,\n  colorScaleType: _defaultSettings.SCALE_TYPES.quantize,\n  radiusScaleType: _defaultSettings.SCALE_TYPES.sqrt,\n  radiusRange: defaultRadiusRange,\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getColorValue: {\n    type: 'accessor',\n    value: defaultGetColorValue\n  },\n  getRadiusValue: {\n    type: 'accessor',\n    value: defaultGetRadiusValue\n  }\n};\nvar ClusterLayer = /*#__PURE__*/function (_AggregationLayer) {\n  (0, _inherits2[\"default\"])(ClusterLayer, _AggregationLayer);\n  var _super = _createSuper(ClusterLayer);\n  function ClusterLayer() {\n    (0, _classCallCheck2[\"default\"])(this, ClusterLayer);\n    return _super.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(ClusterLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var cpuAggregator = new _cpuAggregator[\"default\"]({\n        aggregation: clusterAggregation,\n        dimensions: clusterLayerDimensions\n      });\n      this.state = {\n        cpuAggregator: cpuAggregator,\n        aggregatorState: cpuAggregator.state\n      };\n      var attributeManager = this.getAttributeManager();\n      attributeManager.add({\n        positions: {\n          size: 3,\n          accessor: 'getPosition'\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref3) {\n      var oldProps = _ref3.oldProps,\n        props = _ref3.props,\n        changeFlags = _ref3.changeFlags;\n      this.setState({\n        // make a copy of the internal state of cpuAggregator for testing\n        aggregatorState: this.state.cpuAggregator.updateState({\n          oldProps: oldProps,\n          props: props,\n          changeFlags: changeFlags\n        }, {\n          viewport: this.context.viewport,\n          attributes: this.getAttributes(),\n          numInstances: this.getNumInstances(props)\n        })\n      });\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref4) {\n      var info = _ref4.info;\n      return this.state.cpuAggregator.getPickingInfo({\n        info: info\n      }, this.props);\n    }\n  }, {\n    key: \"_getSublayerUpdateTriggers\",\n    value: function _getSublayerUpdateTriggers() {\n      return this.state.cpuAggregator.getUpdateTriggers(this.props);\n    }\n  }, {\n    key: \"_getSubLayerAccessors\",\n    value: function _getSubLayerAccessors() {\n      return {\n        getRadius: this.state.cpuAggregator.getAccessor('radius', this.props),\n        getFillColor: this.state.cpuAggregator.getAccessor('fillColor', this.props)\n      };\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      // for subclassing, override this method to return\n      // customized sub layer props\n      var _this$props = this.props,\n        id = _this$props.id,\n        radiusScale = _this$props.radiusScale;\n      var cpuAggregator = this.state.cpuAggregator; // base layer props\n\n      var _this$props2 = this.props,\n        visible = _this$props2.visible,\n        opacity = _this$props2.opacity,\n        pickable = _this$props2.pickable,\n        autoHighlight = _this$props2.autoHighlight,\n        highlightColor = _this$props2.highlightColor;\n      var updateTriggers = this._getSublayerUpdateTriggers();\n      var accessors = this._getSubLayerAccessors();\n      var distanceScale = (0, _viewportMercatorProject.getDistanceScales)(this.context.viewport);\n      var metersPerPixel = distanceScale.metersPerPixel[0]; // return props to the sublayer constructor\n\n      return new _layers.ScatterplotLayer(_objectSpread({\n        id: \"\".concat(id, \"-cluster\"),\n        data: cpuAggregator.state.layerData.data,\n        radiusScale: metersPerPixel * radiusScale,\n        visible: visible,\n        opacity: opacity,\n        pickable: pickable,\n        autoHighlight: autoHighlight,\n        highlightColor: highlightColor,\n        updateTriggers: updateTriggers\n      }, accessors));\n    }\n  }]);\n  return ClusterLayer;\n}(_aggregationLayers._AggregationLayer);\nexports[\"default\"] = ClusterLayer;\nClusterLayer.layerName = 'ClusterLayer';\nClusterLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/deckgl-layers/cluster-layer/cluster-layer.js"],"names":["defaultRadius","LAYER_VIS_CONFIGS","clusterRadius","defaultValue","defaultRadiusRange","clusterRadiusRange","defaultGetColorValue","points","length","defaultGetRadiusValue","cell","filteredPoints","processGeoJSON","step","props","aggregation","viewport","data","getPosition","filterData","geoJSON","clusterBuilder","ClusterBuilder","setState","getClusters","state","zoom","width","height","longitude","latitude","bbox","geoViewport","bounds","clusters","clustersAtZoom","layerData","getSubLayerRadius","dimensionState","dimension","layerProps","getRadiusValue","scaleFunc","clusterAggregation","key","updateSteps","triggers","position","prop","updateTrigger","updater","getRadiusValueDomain","dimensionUpdater","valueDomain","_setDimensionState","clusterLayerDimensions","defaultColorDimension","accessor","nullValue","value","domain","range","scaleType","getDimensionScale","getSubLayerAccessor","getPickingInfo","radiusValue","defaultProps","colorDomain","colorRange","DEFAULT_COLOR_RANGE","colorScaleType","SCALE_TYPES","quantize","radiusScaleType","sqrt","radiusRange","type","x","getColorValue","ClusterLayer","AggregationLayer","cpuAggregator","CPUAggregator","dimensions","aggregatorState","attributeManager","getAttributeManager","add","positions","size","oldProps","changeFlags","updateState","context","attributes","getAttributes","numInstances","getNumInstances","info","getUpdateTriggers","getRadius","getAccessor","getFillColor","id","radiusScale","visible","opacity","pickable","autoHighlight","highlightColor","updateTriggers","_getSublayerUpdateTriggers","accessors","_getSubLayerAccessors","distanceScale","metersPerPixel","ScatterplotLayer","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {ScatterplotLayer} from '@deck.gl/layers';\nimport {_AggregationLayer as AggregationLayer} from '@deck.gl/aggregation-layers';\n\nimport geoViewport from '@mapbox/geo-viewport';\nimport CPUAggregator, {\n  defaultColorDimension,\n  getDimensionScale\n} from '../layer-utils/cpu-aggregator';\nimport {getDistanceScales} from 'viewport-mercator-project';\nimport {max} from 'd3-array';\n\nimport {LAYER_VIS_CONFIGS} from 'layers/layer-factory';\nimport {SCALE_TYPES} from 'constants/default-settings';\nimport {DEFAULT_COLOR_RANGE} from 'constants/color-ranges';\nimport ClusterBuilder, {getGeoJSON} from '../layer-utils/cluster-utils';\n\nconst defaultRadius = LAYER_VIS_CONFIGS.clusterRadius.defaultValue;\nconst defaultRadiusRange = LAYER_VIS_CONFIGS.clusterRadiusRange.defaultValue;\n\nconst defaultGetColorValue = points => points.length;\nconst defaultGetRadiusValue = cell =>\n  cell.filteredPoints ? cell.filteredPoints.length : cell.points.length;\n\nfunction processGeoJSON(step, props, aggregation, {viewport}) {\n  const {data, getPosition, filterData} = props;\n  const geoJSON = getGeoJSON(data, getPosition, filterData);\n  const clusterBuilder = new ClusterBuilder();\n\n  this.setState({geoJSON, clusterBuilder});\n}\n\nfunction getClusters(step, props, aggregation, {viewport}) {\n  const {geoJSON, clusterBuilder} = this.state;\n  const {clusterRadius, zoom, width, height} = props;\n  const {longitude, latitude} = viewport;\n\n  // zoom needs to be an integer for the different map utils. Also helps with cache key.\n  const bbox = geoViewport.bounds([longitude, latitude], zoom, [width, height]);\n  const clusters = clusterBuilder.clustersAtZoom({bbox, clusterRadius, geoJSON, zoom});\n\n  this.setState({\n    layerData: {data: clusters}\n  });\n}\n\nfunction getSubLayerRadius(dimensionState, dimension, layerProps) {\n  return cell => {\n    const {getRadiusValue} = layerProps;\n    const {scaleFunc} = dimensionState;\n    return scaleFunc(getRadiusValue(cell));\n  };\n}\n\nexport const clusterAggregation = {\n  key: 'position',\n  updateSteps: [\n    {\n      key: 'geojson',\n      triggers: {\n        position: {\n          prop: 'getPosition',\n          updateTrigger: 'getPosition'\n        },\n        filterData: {\n          prop: 'filterData',\n          updateTrigger: 'filterData'\n        }\n      },\n      updater: processGeoJSON\n    },\n    {\n      key: 'clustering',\n      triggers: {\n        clusterRadius: {\n          prop: 'clusterRadius'\n        },\n        zoom: {\n          prop: 'zoom'\n        },\n        width: {\n          prop: 'width'\n        },\n        height: {\n          prop: 'height'\n        }\n      },\n      updater: getClusters\n    }\n  ]\n};\n\nfunction getRadiusValueDomain(step, props, dimensionUpdater) {\n  const {key} = dimensionUpdater;\n  const {getRadiusValue} = props;\n  const {layerData} = this.state;\n\n  const valueDomain = [0, max(layerData.data, getRadiusValue)];\n  this._setDimensionState(key, {valueDomain});\n}\n\nconst clusterLayerDimensions = [\n  defaultColorDimension,\n  {\n    key: 'radius',\n    accessor: 'getRadius',\n    nullValue: 0,\n    updateSteps: [\n      {\n        key: 'getDomain',\n        triggers: {\n          value: {\n            prop: 'getRadiusValue',\n            updateTrigger: 'getRadiusValue'\n          }\n        },\n        updater: getRadiusValueDomain\n      },\n      {\n        key: 'getScaleFunc',\n        triggers: {\n          domain: {prop: 'radiusDomain'},\n          range: {prop: 'radiusRange'},\n          scaleType: {prop: 'radiusScaleType'}\n        },\n        updater: getDimensionScale\n      }\n    ],\n    getSubLayerAccessor: getSubLayerRadius,\n    getPickingInfo: (dimensionState, cell, layerProps) => {\n      const radiusValue = layerProps.getRadiusValue(cell);\n      return {radiusValue};\n    }\n  }\n];\n\nconst defaultProps = {\n  clusterRadius: defaultRadius,\n  colorDomain: null,\n  colorRange: DEFAULT_COLOR_RANGE,\n  colorScaleType: SCALE_TYPES.quantize,\n  radiusScaleType: SCALE_TYPES.sqrt,\n  radiusRange: defaultRadiusRange,\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColorValue: {type: 'accessor', value: defaultGetColorValue},\n  getRadiusValue: {type: 'accessor', value: defaultGetRadiusValue}\n};\n\nexport default class ClusterLayer extends AggregationLayer {\n  initializeState() {\n    const cpuAggregator = new CPUAggregator({\n      aggregation: clusterAggregation,\n      dimensions: clusterLayerDimensions\n    });\n\n    this.state = {\n      cpuAggregator,\n      aggregatorState: cpuAggregator.state\n    };\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {size: 3, accessor: 'getPosition'}\n    });\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    this.setState({\n      // make a copy of the internal state of cpuAggregator for testing\n      aggregatorState: this.state.cpuAggregator.updateState(\n        {oldProps, props, changeFlags},\n        {\n          viewport: this.context.viewport,\n          attributes: this.getAttributes(),\n          numInstances: this.getNumInstances(props)\n        }\n      )\n    });\n  }\n\n  getPickingInfo({info}) {\n    return this.state.cpuAggregator.getPickingInfo({info}, this.props);\n  }\n\n  _getSublayerUpdateTriggers() {\n    return this.state.cpuAggregator.getUpdateTriggers(this.props);\n  }\n\n  _getSubLayerAccessors() {\n    return {\n      getRadius: this.state.cpuAggregator.getAccessor('radius', this.props),\n      getFillColor: this.state.cpuAggregator.getAccessor('fillColor', this.props)\n    };\n  }\n\n  renderLayers() {\n    // for subclassing, override this method to return\n    // customized sub layer props\n    const {id, radiusScale} = this.props;\n    const {cpuAggregator} = this.state;\n\n    // base layer props\n    const {visible, opacity, pickable, autoHighlight, highlightColor} = this.props;\n    const updateTriggers = this._getSublayerUpdateTriggers();\n    const accessors = this._getSubLayerAccessors();\n\n    const distanceScale = getDistanceScales(this.context.viewport);\n    const metersPerPixel = distanceScale.metersPerPixel[0];\n\n    // return props to the sublayer constructor\n    return new ScatterplotLayer({\n      id: `${id}-cluster`,\n      data: cpuAggregator.state.layerData.data,\n      radiusScale: metersPerPixel * radiusScale,\n      visible,\n      opacity,\n      pickable,\n      autoHighlight,\n      highlightColor,\n      updateTriggers,\n      ...accessors\n    });\n  }\n}\n\nClusterLayer.layerName = 'ClusterLayer';\nClusterLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"script"}