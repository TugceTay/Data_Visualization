{"ast":null,"code":"import { VERTEX_SHADER, FRAGMENT_SHADER } from './constants';\nimport { resolveModules } from './resolve-modules';\nimport { getPlatformShaderDefines, getVersionDefines } from './platform-defines';\nimport injectShader, { DECLARATION_INJECT_MARKER } from './inject-shader';\nimport transpileShader from './transpile-shader';\nimport { assert } from '../utils';\nconst INJECT_SHADER_DECLARATIONS = \"\\n\\n\".concat(DECLARATION_INJECT_MARKER, \"\\n\\n\");\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\nconst FRAGMENT_SHADER_PROLOGUE = \"precision highp float;\\n\\n\";\nexport function assembleShaders(gl, opts) {\n  const {\n    vs,\n    fs\n  } = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {\n      source: vs,\n      type: VERTEX_SHADER,\n      modules\n    })),\n    fs: assembleShader(gl, Object.assign({}, opts, {\n      source: fs,\n      type: FRAGMENT_SHADER,\n      modules\n    })),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\nfunction assembleShader(gl, _ref) {\n  let {\n    id,\n    source,\n    type,\n    modules,\n    defines = {},\n    hookFunctions = [],\n    inject = {},\n    transpileToGLSL100 = false,\n    prologue = true,\n    log\n  } = _ref;\n  assert(typeof source === 'string', 'shader source must be a string');\n  const isVertex = type === VERTEX_SHADER;\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300;\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = \"#version \".concat(glslVersion);\n  }\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n  let assembledSource = prologue ? \"\".concat(versionLine, \"\\n\").concat(getShaderName({\n    id,\n    source,\n    type\n  }), \"\\n\").concat(getShaderType({\n    type\n  }), \"\\n\").concat(getPlatformShaderDefines(gl), \"\\n\").concat(getVersionDefines(gl, glslVersion, !isVertex), \"\\n\").concat(getApplicationDefines(allDefines), \"\\n\").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, \"\\n\") : \"\".concat(versionLine, \"\\n\");\n  const hookFunctionMap = normalizeHookFunctions(hookFunctions);\n  const hookInjections = {};\n  const declInjections = {};\n  const mainInjections = {};\n  for (const key in inject) {\n    const injection = typeof inject[key] === 'string' ? {\n      injection: inject[key],\n      order: 0\n    } : inject[key];\n    const match = key.match(/^(v|f)s:(#)?([\\w-]+)$/);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      mainInjections[key] = [injection];\n    }\n  }\n  for (const module of modules) {\n    if (log) {\n      module.checkDeprecations(coreSource, log);\n    }\n    const moduleSource = module.getModuleSource(type, glslVersion);\n    assembledSource += moduleSource;\n    const injections = module.injections[type];\n    for (const key in injections) {\n      const match = key.match(/^(v|f)s:#([\\w-]+)$/);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n  assembledSource = injectShader(assembledSource, type, declInjections);\n  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);\n  assembledSource += coreSource;\n  assembledSource = injectShader(assembledSource, type, mainInjections);\n  assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);\n  return assembledSource;\n}\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\nfunction getShaderType(_ref2) {\n  let {\n    type\n  } = _ref2;\n  return \"\\n#define SHADER_TYPE_\".concat(SHADER_TYPE[type].toUpperCase(), \"\\n\");\n}\nfunction getShaderName(_ref3) {\n  let {\n    id,\n    source,\n    type\n  } = _ref3;\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? \"\\n#define SHADER_NAME \".concat(id, \"_\").concat(SHADER_TYPE[type], \"\\n\\n\") : '';\n}\nfunction getApplicationDefines() {\n  let defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += \"#define \".concat(define.toUpperCase(), \" \").concat(defines[define], \"\\n\");\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += \"void \".concat(hookFunction.signature, \" {\\n\");\n    if (hookFunction.header) {\n      result += \"  \".concat(hookFunction.header);\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += \"  \".concat(injection.injection, \"\\n\");\n      }\n    }\n    if (hookFunction.footer) {\n      result += \"  \".concat(hookFunction.footer);\n    }\n    result += '}\\n';\n  }\n  return result;\n}\nfunction normalizeHookFunctions(hookFunctions) {\n  const result = {\n    vs: {},\n    fs: {}\n  };\n  hookFunctions.forEach(hook => {\n    let opts;\n    if (typeof hook !== 'string') {\n      opts = hook;\n      hook = opts.hook;\n    } else {\n      opts = {};\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    result[stage][name] = Object.assign(opts, {\n      signature\n    });\n  });\n  return result;\n}","map":{"version":3,"sources":["../../../src/lib/assemble-shaders.js"],"names":["VERTEX_SHADER","FRAGMENT_SHADER","resolveModules","getPlatformShaderDefines","getVersionDefines","injectShader","DECLARATION_INJECT_MARKER","transpileShader","assert","INJECT_SHADER_DECLARATIONS","SHADER_TYPE","FRAGMENT_SHADER_PROLOGUE","assembleShaders","gl","opts","vs","fs","modules","assembleShader","assign","source","type","getUniforms","assembleGetUniforms","id","defines","hookFunctions","inject","transpileToGLSL100","prologue","log","isVertex","sourceLines","split","glslVersion","versionLine","coreSource","indexOf","slice","join","allDefines","forEach","module","Object","getDefines","assembledSource","getShaderName","getShaderType","getApplicationDefines","hookFunctionMap","normalizeHookFunctions","hookInjections","declInjections","mainInjections","key","injection","order","match","hash","name","checkDeprecations","moduleSource","getModuleSource","injections","injectionType","push","getHookFunctions","uniforms","moduleUniforms","toUpperCase","injectShaderName","count","sourceText","define","value","Number","isFinite","result","hookName","hookFunction","signature","header","sort","a","b","footer","hook","trim","stage","replace"],"mappings":"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","sourcesContent":["import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader, {DECLARATION_INJECT_MARKER} from './inject-shader';\nimport transpileShader from './transpile-shader';\nimport {assert} from '../utils';\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n\\n`;\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {\n    id,\n    source,\n    type,\n    modules,\n    defines = {},\n    hookFunctions = [],\n    inject = {},\n    transpileToGLSL100 = false,\n    prologue = true,\n    log\n  }\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches actual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = `#version ${glslVersion}`;\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  const hookFunctionMap = normalizeHookFunctions(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections = {};\n  const declInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    const match = key.match(/^(v|f)s:(#)?([\\w-]+)$/);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    if (log) {\n      module.checkDeprecations(coreSource, log);\n    }\n    const moduleSource = module.getModuleSource(type, glslVersion);\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.injections[type];\n    for (const key in injections) {\n      const match = key.match(/^(v|f)s:#([\\w-]+)$/);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource = injectShader(assembledSource, type, declInjections);\n\n  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, mainInjections);\n\n  assembledSource = transpileShader(\n    assembledSource,\n    transpileToGLSL100 ? 100 : glslVersion,\n    isVertex\n  );\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\nfunction normalizeHookFunctions(hookFunctions) {\n  const result = {\n    vs: {},\n    fs: {}\n  };\n\n  hookFunctions.forEach(hook => {\n    let opts;\n    if (typeof hook !== 'string') {\n      opts = hook;\n      hook = opts.hook;\n    } else {\n      opts = {};\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    result[stage][name] = Object.assign(opts, {signature});\n  });\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}