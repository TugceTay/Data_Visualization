{"ast":null,"code":"import { toHilbertQuadkey, FromHilbertQuadKey, IJToST, STToUV, FaceUVToXYZ, XYZToLngLat } from './s2-geometry';\nimport Long from 'long';\nfunction getIdFromToken(token) {\n  var paddedToken = token.padEnd(16, '0');\n  return Long.fromString(paddedToken, 16);\n}\nvar MAX_RESOLUTION = 100;\nfunction getGeoBounds(_ref) {\n  var face = _ref.face,\n    ij = _ref.ij,\n    level = _ref.level;\n  var offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n  var resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));\n  var result = new Float64Array(4 * resolution * 2 + 2);\n  var ptIndex = 0;\n  for (var i = 0; i < 4; i++) {\n    var offset = offsets[i].slice(0);\n    var nextOffset = offsets[i + 1];\n    var stepI = (nextOffset[0] - offset[0]) / resolution;\n    var stepJ = (nextOffset[1] - offset[1]) / resolution;\n    for (var j = 0; j < resolution; j++) {\n      offset[0] += stepI;\n      offset[1] += stepJ;\n      var st = IJToST(ij, level, offset);\n      var uv = STToUV(st);\n      var xyz = FaceUVToXYZ(face, uv);\n      var lngLat = XYZToLngLat(xyz);\n      result[ptIndex++] = lngLat[0];\n      result[ptIndex++] = lngLat[1];\n    }\n  }\n  result[ptIndex++] = result[0];\n  result[ptIndex++] = result[1];\n  return result;\n}\nexport function getS2QuadKey(token) {\n  if (typeof token === 'string') {\n    if (token.indexOf('/') > 0) {\n      return token;\n    }\n    token = getIdFromToken(token);\n  }\n  return toHilbertQuadkey(token.toString());\n}\nexport function getS2Polygon(token) {\n  var key = getS2QuadKey(token);\n  var s2cell = FromHilbertQuadKey(key);\n  return getGeoBounds(s2cell);\n}","map":{"version":3,"sources":["../../../src/s2-layer/s2-utils.js"],"names":["toHilbertQuadkey","FromHilbertQuadKey","IJToST","STToUV","FaceUVToXYZ","XYZToLngLat","Long","getIdFromToken","token","paddedToken","padEnd","fromString","MAX_RESOLUTION","getGeoBounds","face","ij","level","offsets","resolution","Math","max","ceil","pow","result","Float64Array","ptIndex","i","offset","slice","nextOffset","stepI","stepJ","j","st","uv","xyz","lngLat","getS2QuadKey","indexOf","toString","getS2Polygon","key","s2cell"],"mappings":"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","sourcesContent":["// s2-geometry is a pure JavaScript port of Google/Niantic's S2 Geometry library\n// which is perfect since it works in the browser.\nimport {\n  toHilbertQuadkey,\n  FromHilbertQuadKey,\n  IJToST,\n  STToUV,\n  FaceUVToXYZ,\n  XYZToLngLat\n} from './s2-geometry';\nimport Long from 'long';\n\n/**\n * Given an S2 token this function convert the token to 64 bit id\n   https://github.com/google/s2-geometry-library-java/blob/c04b68bf3197a9c34082327eeb3aec7ab7c85da1/src/com/google/common/geometry/S2CellId.java#L439\n * */\nfunction getIdFromToken(token) {\n  // pad token with zeros to make the length 16\n  const paddedToken = token.padEnd(16, '0');\n  return Long.fromString(paddedToken, 16);\n}\n\nconst MAX_RESOLUTION = 100;\n\n/* Adapted from s2-geometry's S2Cell.getCornerLatLngs */\nfunction getGeoBounds({face, ij, level}) {\n  const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n\n  // The S2 cell edge is curved: http://s2geometry.io/\n  // This is more prominent at lower levels\n  // resolution is the number of segments to generate per edge.\n  // We exponentially reduce resolution as level increases so it doesn't affect perf\n  // when there are a large number of cells\n  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));\n  const result = new Float64Array(4 * resolution * 2 + 2);\n  let ptIndex = 0;\n\n  for (let i = 0; i < 4; i++) {\n    const offset = offsets[i].slice(0);\n    const nextOffset = offsets[i + 1];\n    const stepI = (nextOffset[0] - offset[0]) / resolution;\n    const stepJ = (nextOffset[1] - offset[1]) / resolution;\n\n    for (let j = 0; j < resolution; j++) {\n      offset[0] += stepI;\n      offset[1] += stepJ;\n      // Cell can be represented by coordinates IJ, ST, UV, XYZ\n      // http://s2geometry.io/devguide/s2cell_hierarchy#coordinate-systems\n      const st = IJToST(ij, level, offset);\n      const uv = STToUV(st);\n      const xyz = FaceUVToXYZ(face, uv);\n      const lngLat = XYZToLngLat(xyz);\n\n      result[ptIndex++] = lngLat[0];\n      result[ptIndex++] = lngLat[1];\n    }\n  }\n  // close the loop\n  result[ptIndex++] = result[0];\n  result[ptIndex++] = result[1];\n  return result;\n}\n\nexport function getS2QuadKey(token) {\n  if (typeof token === 'string') {\n    if (token.indexOf('/') > 0) {\n      // is Hilbert quad key\n      return token;\n    }\n    // is S2 token\n    token = getIdFromToken(token);\n  }\n  // is Long id\n  return toHilbertQuadkey(token.toString());\n}\n\n/**\n * Get a polygon with corner coordinates for an s2 cell\n * @param {*} cell - This can be an S2 key or token\n * @return {Array} - a simple polygon in array format: [[lng, lat], ...]\n *   - each coordinate is an array [lng, lat]\n *   - the polygon is closed, i.e. last coordinate is a copy of the first coordinate\n */\nexport function getS2Polygon(token) {\n  const key = getS2QuadKey(token);\n  const s2cell = FromHilbertQuadKey(key);\n\n  return getGeoBounds(s2cell);\n}\n"]},"metadata":{},"sourceType":"module"}