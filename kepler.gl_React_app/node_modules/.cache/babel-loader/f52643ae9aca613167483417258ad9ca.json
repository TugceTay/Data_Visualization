{"ast":null,"code":"import { Texture2D, hasFeature, FEATURES, log } from '@luma.gl/webgl';\nexport default class GLTFMaterialParser {\n  constructor(gl, _ref) {\n    let {\n      attributes,\n      material,\n      pbrDebug,\n      imageBasedLightingEnvironment,\n      lights,\n      useTangents\n    } = _ref;\n    this.gl = gl;\n    this.defines = {\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n    if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n    this.uniforms = {\n      u_Camera: [0, 0, 0],\n      u_MetallicRoughnessValues: [1, 1]\n    };\n    this.parameters = {};\n    this.generatedTextures = [];\n    if (imageBasedLightingEnvironment) {\n      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.u_ScaleIBLAmbient = [1, 1];\n    }\n    if (pbrDebug) {\n      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];\n    }\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n  defineIfPresent(value, name) {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n  parseTexture(gltfTexture, name) {\n    let define = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const parameters = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [this.gl.TEXTURE_MIN_FILTER]: image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR\n      };\n    } else {\n      textureOptions = {\n        data: image\n      };\n    }\n    const texture = new Texture2D(this.gl, {\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [this.gl.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.uniforms[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.parseTexture(pbrMetallicRoughness.baseColorTexture, 'u_BaseColorSampler', 'HAS_BASECOLORMAP');\n    }\n    this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, 'u_MetallicRoughnessSampler', 'HAS_METALROUGHNESSMAP');\n    }\n    const {\n      metallicFactor = 1,\n      roughnessFactor = 1\n    } = pbrMetallicRoughness;\n    this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n  parseMaterial(material) {\n    this.uniforms.pbr_uUnlit = Boolean(material.unlit);\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');\n      const {\n        scale = 1\n      } = material.normalTexture;\n      this.uniforms.u_NormalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');\n      const {\n        strength = 1\n      } = material.occlusionTexture;\n      this.uniforms.u_OcclusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {\n        alphaCutoff = 0.5\n      } = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.u_AlphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: this.gl.FUNC_ADD,\n        blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]\n      });\n    }\n  }\n  delete() {\n    this.generatedTextures.forEach(texture => texture.delete());\n  }\n}","map":{"version":3,"sources":["../../../src/gltf/gltf-material-parser.js"],"names":["Texture2D","hasFeature","FEATURES","log","GLTFMaterialParser","constructor","gl","attributes","material","pbrDebug","imageBasedLightingEnvironment","lights","useTangents","defines","MANUAL_SRGB","SRGB_FAST_APPROXIMATION","GLSL_TEXTURE_LOD","USE_TEX_LOD","uniforms","u_Camera","u_MetallicRoughnessValues","parameters","generatedTextures","u_DiffuseEnvSampler","getDiffuseEnvSampler","u_SpecularEnvSampler","getSpecularEnvSampler","u_brdfLUT","getBrdfTexture","u_ScaleIBLAmbient","u_ScaleDiffBaseMR","u_ScaleFGDSpec","defineIfPresent","NORMAL","TANGENT","TEXCOORD_0","parseMaterial","value","name","parseTexture","gltfTexture","define","texture","sampler","image","source","textureOptions","specialTextureParameters","compressed","TEXTURE_MIN_FILTER","data","length","LINEAR_MIPMAP_NEAREST","LINEAR","id","pixelStore","UNPACK_FLIP_Y_WEBGL","push","parsePbrMetallicRoughness","pbrMetallicRoughness","baseColorTexture","u_BaseColorFactor","baseColorFactor","metallicRoughnessTexture","metallicFactor","roughnessFactor","pbr_uUnlit","Boolean","unlit","normalTexture","scale","u_NormalScale","occlusionTexture","strength","u_OcclusionStrength","emissiveTexture","u_EmissiveFactor","emissiveFactor","alphaMode","alphaCutoff","ALPHA_CUTOFF","u_AlphaCutoff","warn","Object","assign","blend","blendEquation","FUNC_ADD","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","delete","forEach"],"mappings":"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","sourcesContent":["import {Texture2D, hasFeature, FEATURES, log} from '@luma.gl/webgl';\n\nexport default class GLTFMaterialParser {\n  constructor(\n    gl,\n    {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents}\n  ) {\n    this.gl = gl;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      u_Camera: [0, 0, 0], // Model should override\n\n      u_MetallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.u_ScaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  defineIfPresent(value, name) {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  parseTexture(gltfTexture, name, define = null) {\n    const parameters =\n      (gltfTexture.texture &&\n        gltfTexture.texture.sampler &&\n        gltfTexture.texture.sampler.parameters) ||\n      {};\n\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [this.gl.TEXTURE_MIN_FILTER]:\n          image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR\n      };\n    } else {\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      textureOptions = {data: image};\n    }\n\n    const texture = new Texture2D(this.gl, {\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [this.gl.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.uniforms[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.parseTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'u_BaseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.parseTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'u_MetallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  parseMaterial(material) {\n    this.uniforms.pbr_uUnlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.u_NormalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.u_OcclusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.u_AlphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: this.gl.FUNC_ADD,\n        blendFunc: [\n          this.gl.SRC_ALPHA,\n          this.gl.ONE_MINUS_SRC_ALPHA,\n          this.gl.ONE,\n          this.gl.ONE_MINUS_SRC_ALPHA\n        ]\n      });\n    }\n  }\n\n  /**\n   * Destroy all generated resources to release memory.\n   */\n  delete() {\n    this.generatedTextures.forEach(texture => texture.delete());\n  }\n}\n"]},"metadata":{},"sourceType":"module"}