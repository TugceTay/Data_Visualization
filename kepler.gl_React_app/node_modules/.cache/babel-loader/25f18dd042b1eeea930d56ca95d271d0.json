{"ast":null,"code":"import { COORDINATE_SYSTEM, createIterable } from '@deck.gl/core';\nvar RADIAN_PER_DEGREE = Math.PI / 180;\nvar modelMatrix = new Float32Array(16);\nvar valueArray = new Float32Array(12);\nfunction calculateTransformMatrix(targetMatrix, orientation, scale) {\n  var pitch = orientation[0] * RADIAN_PER_DEGREE;\n  var yaw = orientation[1] * RADIAN_PER_DEGREE;\n  var roll = orientation[2] * RADIAN_PER_DEGREE;\n  var sr = Math.sin(roll);\n  var sp = Math.sin(pitch);\n  var sw = Math.sin(yaw);\n  var cr = Math.cos(roll);\n  var cp = Math.cos(pitch);\n  var cw = Math.cos(yaw);\n  var scx = scale[0];\n  var scy = scale[1];\n  var scz = scale[2];\n  targetMatrix[0] = scx * cw * cp;\n  targetMatrix[1] = scx * sw * cp;\n  targetMatrix[2] = scx * -sp;\n  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);\n  targetMatrix[4] = scy * (cw * cr + sw * sp * sr);\n  targetMatrix[5] = scy * cp * sr;\n  targetMatrix[6] = scz * (sw * sr + cw * sp * cr);\n  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);\n  targetMatrix[8] = scz * cp * cr;\n}\nfunction getExtendedMat3FromMat4(mat4) {\n  mat4[0] = mat4[0];\n  mat4[1] = mat4[1];\n  mat4[2] = mat4[2];\n  mat4[3] = mat4[4];\n  mat4[4] = mat4[5];\n  mat4[5] = mat4[6];\n  mat4[6] = mat4[8];\n  mat4[7] = mat4[9];\n  mat4[8] = mat4[10];\n  mat4[9] = mat4[12];\n  mat4[10] = mat4[13];\n  mat4[11] = mat4[14];\n  return mat4.subarray(0, 12);\n}\nexport var MATRIX_ATTRIBUTES = {\n  size: 12,\n  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],\n  shaderAttributes: {\n    instanceModelMatrix__LOCATION_0: {\n      size: 3,\n      elementOffset: 0\n    },\n    instanceModelMatrix__LOCATION_1: {\n      size: 3,\n      elementOffset: 3\n    },\n    instanceModelMatrix__LOCATION_2: {\n      size: 3,\n      elementOffset: 6\n    },\n    instanceTranslation: {\n      size: 3,\n      elementOffset: 9\n    }\n  },\n  update: function update(attribute, _ref) {\n    var startRow = _ref.startRow,\n      endRow = _ref.endRow;\n    var _this$props = this.props,\n      data = _this$props.data,\n      getOrientation = _this$props.getOrientation,\n      getScale = _this$props.getScale,\n      getTranslation = _this$props.getTranslation,\n      getTransformMatrix = _this$props.getTransformMatrix;\n    var arrayMatrix = Array.isArray(getTransformMatrix);\n    var constantMatrix = arrayMatrix && getTransformMatrix.length === 16;\n    var constantScale = Array.isArray(getScale);\n    var constantOrientation = Array.isArray(getOrientation);\n    var constantTranslation = Array.isArray(getTranslation);\n    var hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));\n    if (hasMatrix) {\n      attribute.constant = constantMatrix;\n    } else {\n      attribute.constant = constantOrientation && constantScale && constantTranslation;\n    }\n    var instanceModelMatrixData = attribute.value;\n    if (attribute.constant) {\n      var matrix;\n      if (hasMatrix) {\n        modelMatrix.set(getTransformMatrix);\n        matrix = getExtendedMat3FromMat4(modelMatrix);\n      } else {\n        matrix = valueArray;\n        var orientation = getOrientation;\n        var scale = getScale;\n        calculateTransformMatrix(matrix, orientation, scale);\n        matrix.set(getTranslation, 9);\n      }\n      attribute.value = new Float32Array(matrix);\n    } else {\n      var i = startRow * attribute.size;\n      var _createIterable = createIterable(data, startRow, endRow),\n        iterable = _createIterable.iterable,\n        objectInfo = _createIterable.objectInfo;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n          objectInfo.index++;\n          var _matrix = void 0;\n          if (hasMatrix) {\n            modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));\n            _matrix = getExtendedMat3FromMat4(modelMatrix);\n          } else {\n            _matrix = valueArray;\n            var _orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);\n            var _scale = constantScale ? getScale : getScale(object, objectInfo);\n            calculateTransformMatrix(_matrix, _orientation, _scale);\n            _matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);\n          }\n          instanceModelMatrixData[i++] = _matrix[0];\n          instanceModelMatrixData[i++] = _matrix[1];\n          instanceModelMatrixData[i++] = _matrix[2];\n          instanceModelMatrixData[i++] = _matrix[3];\n          instanceModelMatrixData[i++] = _matrix[4];\n          instanceModelMatrixData[i++] = _matrix[5];\n          instanceModelMatrixData[i++] = _matrix[6];\n          instanceModelMatrixData[i++] = _matrix[7];\n          instanceModelMatrixData[i++] = _matrix[8];\n          instanceModelMatrixData[i++] = _matrix[9];\n          instanceModelMatrixData[i++] = _matrix[10];\n          instanceModelMatrixData[i++] = _matrix[11];\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }\n};\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;\n}","map":{"version":3,"sources":["../../../src/utils/matrix.js"],"names":["COORDINATE_SYSTEM","createIterable","RADIAN_PER_DEGREE","Math","PI","modelMatrix","Float32Array","valueArray","calculateTransformMatrix","targetMatrix","orientation","scale","pitch","yaw","roll","sr","sin","sp","sw","cr","cos","cp","cw","scx","scy","scz","getExtendedMat3FromMat4","mat4","subarray","MATRIX_ATTRIBUTES","size","accessor","shaderAttributes","instanceModelMatrix__LOCATION_0","elementOffset","instanceModelMatrix__LOCATION_1","instanceModelMatrix__LOCATION_2","instanceTranslation","update","attribute","startRow","endRow","data","getOrientation","getScale","getTranslation","getTransformMatrix","props","arrayMatrix","Array","isArray","constantMatrix","length","constantScale","constantOrientation","constantTranslation","hasMatrix","Boolean","constant","instanceModelMatrixData","value","matrix","set","i","iterable","objectInfo","object","index","shouldComposeModelMatrix","viewport","coordinateSystem","CARTESIAN","METER_OFFSETS","DEFAULT","isGeospatial"],"mappings":"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","sourcesContent":["import {COORDINATE_SYSTEM, createIterable} from '@deck.gl/core';\n\n/* eslint-disable max-statements, complexity */\nconst RADIAN_PER_DEGREE = Math.PI / 180;\nconst modelMatrix = new Float32Array(16);\nconst valueArray = new Float32Array(12);\n\nfunction calculateTransformMatrix(targetMatrix, orientation, scale) {\n  const pitch = orientation[0] * RADIAN_PER_DEGREE;\n  const yaw = orientation[1] * RADIAN_PER_DEGREE;\n  const roll = orientation[2] * RADIAN_PER_DEGREE;\n\n  const sr = Math.sin(roll);\n  const sp = Math.sin(pitch);\n  const sw = Math.sin(yaw);\n\n  const cr = Math.cos(roll);\n  const cp = Math.cos(pitch);\n  const cw = Math.cos(yaw);\n\n  const scx = scale[0];\n  const scy = scale[1];\n  const scz = scale[2];\n\n  targetMatrix[0] = scx * cw * cp; // 0,0\n  targetMatrix[1] = scx * sw * cp; // 1,0\n  targetMatrix[2] = scx * -sp; // 2,0\n  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr); // 0,1\n  targetMatrix[4] = scy * (cw * cr + sw * sp * sr); // 1,1\n  targetMatrix[5] = scy * cp * sr; // 2,1\n  targetMatrix[6] = scz * (sw * sr + cw * sp * cr); // 0,2\n  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr); // 1,2\n  targetMatrix[8] = scz * cp * cr; // 2,2\n}\n\nfunction getExtendedMat3FromMat4(mat4) {\n  mat4[0] = mat4[0];\n  mat4[1] = mat4[1];\n  mat4[2] = mat4[2];\n  mat4[3] = mat4[4];\n  mat4[4] = mat4[5];\n  mat4[5] = mat4[6];\n  mat4[6] = mat4[8];\n  mat4[7] = mat4[9];\n  mat4[8] = mat4[10];\n  mat4[9] = mat4[12];\n  mat4[10] = mat4[13];\n  mat4[11] = mat4[14];\n\n  return mat4.subarray(0, 12);\n}\n\nexport const MATRIX_ATTRIBUTES = {\n  size: 12,\n  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],\n  shaderAttributes: {\n    instanceModelMatrix__LOCATION_0: {\n      size: 3,\n      elementOffset: 0\n    },\n    instanceModelMatrix__LOCATION_1: {\n      size: 3,\n      elementOffset: 3\n    },\n    instanceModelMatrix__LOCATION_2: {\n      size: 3,\n      elementOffset: 6\n    },\n    instanceTranslation: {\n      size: 3,\n      elementOffset: 9\n    }\n  },\n\n  update(attribute, {startRow, endRow}) {\n    // NOTE(Tarek): \"this\" will be bound to a layer!\n    const {data, getOrientation, getScale, getTranslation, getTransformMatrix} = this.props;\n\n    const arrayMatrix = Array.isArray(getTransformMatrix);\n    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;\n    const constantScale = Array.isArray(getScale);\n    const constantOrientation = Array.isArray(getOrientation);\n    const constantTranslation = Array.isArray(getTranslation);\n\n    const hasMatrix = constantMatrix || (!arrayMatrix && Boolean(getTransformMatrix(data[0])));\n\n    if (hasMatrix) {\n      attribute.constant = constantMatrix;\n    } else {\n      attribute.constant = constantOrientation && constantScale && constantTranslation;\n    }\n\n    const instanceModelMatrixData = attribute.value;\n\n    if (attribute.constant) {\n      let matrix;\n\n      if (hasMatrix) {\n        modelMatrix.set(getTransformMatrix);\n        matrix = getExtendedMat3FromMat4(modelMatrix);\n      } else {\n        matrix = valueArray;\n\n        const orientation = getOrientation;\n        const scale = getScale;\n\n        calculateTransformMatrix(matrix, orientation, scale);\n        matrix.set(getTranslation, 9);\n      }\n\n      attribute.value = new Float32Array(matrix);\n    } else {\n      let i = startRow * attribute.size;\n      const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n      for (const object of iterable) {\n        objectInfo.index++;\n        let matrix;\n\n        if (hasMatrix) {\n          modelMatrix.set(\n            constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo)\n          );\n          matrix = getExtendedMat3FromMat4(modelMatrix);\n        } else {\n          matrix = valueArray;\n\n          const orientation = constantOrientation\n            ? getOrientation\n            : getOrientation(object, objectInfo);\n          const scale = constantScale ? getScale : getScale(object, objectInfo);\n\n          calculateTransformMatrix(matrix, orientation, scale);\n          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);\n        }\n\n        instanceModelMatrixData[i++] = matrix[0];\n        instanceModelMatrixData[i++] = matrix[1];\n        instanceModelMatrixData[i++] = matrix[2];\n        instanceModelMatrixData[i++] = matrix[3];\n        instanceModelMatrixData[i++] = matrix[4];\n        instanceModelMatrixData[i++] = matrix[5];\n        instanceModelMatrixData[i++] = matrix[6];\n        instanceModelMatrixData[i++] = matrix[7];\n        instanceModelMatrixData[i++] = matrix[8];\n        instanceModelMatrixData[i++] = matrix[9];\n        instanceModelMatrixData[i++] = matrix[10];\n        instanceModelMatrixData[i++] = matrix[11];\n      }\n    }\n  }\n};\n\n// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system\n// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations\n// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled\n// when in LNGLAT and LNGLAT_OFFSET coordinates.\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return (\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS ||\n    (coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial)\n  );\n}\n"]},"metadata":{},"sourceType":"module"}