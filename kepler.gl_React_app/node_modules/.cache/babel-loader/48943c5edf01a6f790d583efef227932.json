{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport * as React from 'react';\nimport { useRef, useEffect, useState, useCallback, useMemo } from 'react';\nimport * as PropTypes from 'prop-types';\nimport { document } from '../utils/globals';\nimport mapboxgl from '../utils/mapboxgl';\nimport MapState from '../utils/map-state';\nimport { LINEAR_TRANSITION_PROPS } from '../utils/map-controller';\nimport { isGeolocationSupported } from '../utils/geolocate-utils';\nimport useMapControl, { mapControlDefaultProps, mapControlPropTypes } from './use-map-control';\nvar noop = function noop() {};\nvar propTypes = Object.assign({}, mapControlPropTypes, {\n  className: PropTypes.string,\n  style: PropTypes.object,\n  label: PropTypes.string,\n  disabledLabel: PropTypes.string,\n  auto: PropTypes.bool,\n  positionOptions: PropTypes.object,\n  fitBoundsOptions: PropTypes.object,\n  trackUserLocation: PropTypes.bool,\n  showUserLocation: PropTypes.bool,\n  showAccuracyCircle: PropTypes.bool,\n  showUserHeading: PropTypes.bool,\n  onViewStateChange: PropTypes.func,\n  onViewportChange: PropTypes.func,\n  onGeolocate: PropTypes.func\n});\nvar defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  label: 'Find My Location',\n  disabledLabel: 'Location Not Available',\n  auto: false,\n  positionOptions: {\n    enableHighAccuracy: false,\n    timeout: 6000\n  },\n  fitBoundsOptions: {\n    maxZoom: 15\n  },\n  trackUserLocation: false,\n  showUserLocation: true,\n  showUserHeading: false,\n  showAccuracyCircle: true,\n  onGeolocate: function onGeolocate() {}\n});\nfunction getBounds(position) {\n  var center = new mapboxgl.LngLat(position.coords.longitude, position.coords.latitude);\n  var radius = position.coords.accuracy;\n  var bounds = center.toBounds(radius);\n  return [[bounds._ne.lng, bounds._ne.lat], [bounds._sw.lng, bounds._sw.lat]];\n}\nfunction setupMapboxGeolocateControl(context, props, geolocateButton) {\n  var control = new mapboxgl.GeolocateControl(props);\n  control._container = document.createElement('div');\n  control._map = {\n    on: function on() {},\n    _getUIString: function _getUIString() {\n      return '';\n    }\n  };\n  control._setupUI(true);\n  control._map = context.map;\n  control._geolocateButton = geolocateButton;\n  var eventManager = context.eventManager;\n  if (control.options.trackUserLocation && eventManager) {\n    eventManager.on('panstart', function () {\n      if (control._watchState === 'ACTIVE_LOCK') {\n        control._watchState = 'BACKGROUND';\n        geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');\n        geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');\n      }\n    });\n  }\n  control.on('geolocate', props.onGeolocate);\n  return control;\n}\nfunction updateCamera(position, _ref) {\n  var context = _ref.context,\n    props = _ref.props;\n  var bounds = getBounds(position);\n  var _context$viewport$fit = context.viewport.fitBounds(bounds, props.fitBoundsOptions),\n    longitude = _context$viewport$fit.longitude,\n    latitude = _context$viewport$fit.latitude,\n    zoom = _context$viewport$fit.zoom;\n  var newViewState = Object.assign({}, context.viewport, {\n    longitude: longitude,\n    latitude: latitude,\n    zoom: zoom\n  });\n  var mapState = new MapState(newViewState);\n  var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n  var onViewportChange = props.onViewportChange || context.onViewportChange || noop;\n  var onViewStateChange = props.onViewStateChange || context.onViewStateChange || noop;\n  onViewStateChange({\n    viewState: viewState\n  });\n  onViewportChange(viewState);\n}\nfunction GeolocateControl(props) {\n  var thisRef = useMapControl(props);\n  var context = thisRef.context,\n    containerRef = thisRef.containerRef;\n  var geolocateButtonRef = useRef(null);\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    mapboxGeolocateControl = _useState2[0],\n    createMapboxGeolocateControl = _useState2[1];\n  var _useState3 = useState(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    supportsGeolocation = _useState4[0],\n    setSupportsGeolocation = _useState4[1];\n  useEffect(function () {\n    var control;\n    if (context.map) {\n      isGeolocationSupported().then(function (result) {\n        setSupportsGeolocation(result);\n        if (geolocateButtonRef.current) {\n          control = setupMapboxGeolocateControl(context, props, geolocateButtonRef.current);\n          control._updateCamera = function (position) {\n            return updateCamera(position, thisRef);\n          };\n          createMapboxGeolocateControl(control);\n        }\n      });\n    }\n    return function () {\n      if (control) {\n        control._clearWatch();\n      }\n    };\n  }, [context.map]);\n  var triggerGeolocate = useCallback(function () {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl.options = thisRef.props;\n      mapboxGeolocateControl.trigger();\n    }\n  }, [mapboxGeolocateControl]);\n  useEffect(function () {\n    if (props.auto) {\n      triggerGeolocate();\n    }\n  }, [mapboxGeolocateControl, props.auto]);\n  useEffect(function () {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl._onZoom();\n    }\n  }, [context.viewport.zoom]);\n  var className = props.className,\n    label = props.label,\n    disabledLabel = props.disabledLabel,\n    trackUserLocation = props.trackUserLocation;\n  var style = useMemo(function () {\n    return _objectSpread({\n      position: 'absolute'\n    }, props.style);\n  }, [props.style]);\n  return React.createElement(\"div\", {\n    style: style,\n    className: className\n  }, React.createElement(\"div\", {\n    key: \"geolocate-control\",\n    className: \"mapboxgl-ctrl mapboxgl-ctrl-group\",\n    ref: containerRef\n  }, React.createElement(\"button\", {\n    key: \"geolocate\",\n    className: \"mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate\",\n    ref: geolocateButtonRef,\n    disabled: !supportsGeolocation,\n    \"aria-pressed\": !trackUserLocation,\n    type: \"button\",\n    title: supportsGeolocation ? label : disabledLabel,\n    \"aria-label\": supportsGeolocation ? label : disabledLabel,\n    onClick: triggerGeolocate\n  }, React.createElement(\"span\", {\n    className: \"mapboxgl-ctrl-icon\",\n    \"aria-hidden\": \"true\"\n  }))));\n}\nGeolocateControl.propTypes = propTypes;\nGeolocateControl.defaultProps = defaultProps;\nexport default React.memo(GeolocateControl);","map":{"version":3,"sources":["../../../src/components/geolocate-control.js"],"names":["React","useRef","useEffect","useState","useCallback","useMemo","PropTypes","document","mapboxgl","MapState","LINEAR_TRANSITION_PROPS","isGeolocationSupported","useMapControl","mapControlDefaultProps","mapControlPropTypes","noop","propTypes","assign","className","string","style","object","label","disabledLabel","auto","bool","positionOptions","fitBoundsOptions","trackUserLocation","showUserLocation","showAccuracyCircle","showUserHeading","onViewStateChange","func","onViewportChange","onGeolocate","defaultProps","enableHighAccuracy","timeout","maxZoom","getBounds","position","center","LngLat","coords","longitude","latitude","radius","accuracy","bounds","toBounds","_ne","lng","lat","_sw","setupMapboxGeolocateControl","context","props","geolocateButton","control","GeolocateControl","_container","createElement","_map","on","_getUIString","_setupUI","map","_geolocateButton","eventManager","options","_watchState","classList","add","remove","updateCamera","zoom","viewport","fitBounds","newViewState","mapState","viewState","Object","getViewportProps","thisRef","containerRef","geolocateButtonRef","mapboxGeolocateControl","createMapboxGeolocateControl","supportsGeolocation","setSupportsGeolocation","then","result","current","_updateCamera","_clearWatch","triggerGeolocate","trigger","_onZoom","memo"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {useRef, useEffect, useState, useCallback, useMemo} from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport {document} from '../utils/globals';\nimport mapboxgl from '../utils/mapboxgl';\n\nimport MapState from '../utils/map-state';\nimport {LINEAR_TRANSITION_PROPS} from '../utils/map-controller';\nimport {isGeolocationSupported} from '../utils/geolocate-utils';\n\nimport useMapControl, {mapControlDefaultProps, mapControlPropTypes} from './use-map-control';\n\nconst noop = () => {};\n\nconst propTypes = Object.assign({}, mapControlPropTypes, {\n  // Custom className\n  className: PropTypes.string,\n  style: PropTypes.object,\n  // Custom label assigned to the control\n  label: PropTypes.string,\n  disabledLabel: PropTypes.string,\n  // Auto trigger instead of waiting for click\n  auto: PropTypes.bool,\n\n  // mapbox geolocate options\n  // https://docs.mapbox.com/mapbox-gl-js/api/#geolocatecontrol\n  positionOptions: PropTypes.object,\n  fitBoundsOptions: PropTypes.object,\n  trackUserLocation: PropTypes.bool,\n  showUserLocation: PropTypes.bool,\n  showAccuracyCircle: PropTypes.bool,\n  showUserHeading: PropTypes.bool,\n\n  // Callbacks fired when the user interacted with the map. The object passed to the callbacks\n  // contains viewport properties such as `longitude`, `latitude`, `zoom` etc.\n  onViewStateChange: PropTypes.func,\n  onViewportChange: PropTypes.func,\n\n  onGeolocate: PropTypes.func\n});\n\nconst defaultProps = Object.assign({}, mapControlDefaultProps, {\n  className: '',\n  label: 'Find My Location',\n  disabledLabel: 'Location Not Available',\n  auto: false,\n\n  // mapbox geolocate options\n  positionOptions: {enableHighAccuracy: false, timeout: 6000},\n  fitBoundsOptions: {maxZoom: 15},\n  trackUserLocation: false,\n  showUserLocation: true,\n  showUserHeading: false,\n  showAccuracyCircle: true,\n\n  onGeolocate: () => {}\n});\n\nfunction getBounds(position) {\n  const center = new mapboxgl.LngLat(position.coords.longitude, position.coords.latitude);\n  const radius = position.coords.accuracy;\n  const bounds = center.toBounds(radius);\n\n  return [\n    [bounds._ne.lng, bounds._ne.lat],\n    [bounds._sw.lng, bounds._sw.lat]\n  ];\n}\n\nfunction setupMapboxGeolocateControl(context, props, geolocateButton) {\n  const control = new mapboxgl.GeolocateControl(props);\n\n  // Dummy placeholders so that _setupUI does not crash\n  control._container = document.createElement('div');\n  control._map = {\n    on: () => {},\n    _getUIString: () => ''\n  };\n  control._setupUI(true);\n  control._map = context.map;\n\n  // replace mapbox internal UI elements with ours\n  control._geolocateButton = geolocateButton;\n\n  // From _setupUI\n  // when the camera is changed (and it's not as a result of the Geolocation Control) change\n  // the watch mode to background watch, so that the marker is updated but not the camera.\n  const {eventManager} = context;\n  if (control.options.trackUserLocation && eventManager) {\n    eventManager.on('panstart', () => {\n      if (control._watchState === 'ACTIVE_LOCK') {\n        control._watchState = 'BACKGROUND';\n        geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');\n        geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active');\n      }\n    });\n  }\n\n  control.on('geolocate', props.onGeolocate);\n  return control;\n}\n\nfunction updateCamera(position, {context, props}) {\n  const bounds = getBounds(position);\n  const {longitude, latitude, zoom} = context.viewport.fitBounds(bounds, props.fitBoundsOptions);\n\n  const newViewState = Object.assign({}, context.viewport, {\n    longitude,\n    latitude,\n    zoom\n  });\n  const mapState = new MapState(newViewState);\n  const viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);\n\n  const onViewportChange = props.onViewportChange || context.onViewportChange || noop;\n  const onViewStateChange = props.onViewStateChange || context.onViewStateChange || noop;\n\n  // Call new style callback\n  onViewStateChange({viewState});\n\n  // Call old style callback\n  onViewportChange(viewState);\n}\n\nfunction GeolocateControl(props) {\n  const thisRef = useMapControl(props);\n  const {context, containerRef} = thisRef;\n  const geolocateButtonRef = useRef(null);\n  const [mapboxGeolocateControl, createMapboxGeolocateControl] = useState(null);\n  const [supportsGeolocation, setSupportsGeolocation] = useState(false);\n\n  useEffect(() => {\n    let control;\n\n    if (context.map) {\n      isGeolocationSupported().then(result => {\n        setSupportsGeolocation(result);\n\n        if (geolocateButtonRef.current) {\n          control = setupMapboxGeolocateControl(context, props, geolocateButtonRef.current);\n          // Overwrite Mapbox's GeolocateControl internal method\n          control._updateCamera = position => updateCamera(position, thisRef);\n          createMapboxGeolocateControl(control);\n        }\n      });\n    }\n\n    return () => {\n      if (control) {\n        control._clearWatch();\n      }\n    };\n  }, [context.map]);\n\n  const triggerGeolocate = useCallback(() => {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl.options = thisRef.props;\n      mapboxGeolocateControl.trigger();\n    }\n  }, [mapboxGeolocateControl]);\n\n  useEffect(() => {\n    if (props.auto) {\n      triggerGeolocate();\n    }\n  }, [mapboxGeolocateControl, props.auto]);\n\n  useEffect(() => {\n    if (mapboxGeolocateControl) {\n      mapboxGeolocateControl._onZoom();\n    }\n  }, [context.viewport.zoom]);\n\n  const {className, label, disabledLabel, trackUserLocation} = props;\n\n  const style = useMemo(() => ({position: 'absolute', ...props.style}), [props.style]);\n\n  return (\n    <div style={style} className={className}>\n      <div key=\"geolocate-control\" className=\"mapboxgl-ctrl mapboxgl-ctrl-group\" ref={containerRef}>\n        <button\n          key=\"geolocate\"\n          className={`mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate`}\n          ref={geolocateButtonRef}\n          disabled={!supportsGeolocation}\n          aria-pressed={!trackUserLocation}\n          type=\"button\"\n          title={supportsGeolocation ? label : disabledLabel}\n          aria-label={supportsGeolocation ? label : disabledLabel}\n          onClick={triggerGeolocate}\n        >\n          <span className=\"mapboxgl-ctrl-icon\" aria-hidden=\"true\" />\n        </button>\n      </div>\n    </div>\n  );\n}\n\nGeolocateControl.propTypes = propTypes;\nGeolocateControl.defaultProps = defaultProps;\n\nexport default React.memo(GeolocateControl);\n"]},"metadata":{},"sourceType":"module"}