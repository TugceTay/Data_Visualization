{"ast":null,"code":"function systemIsLittleEndian() {\n  var a = new Uint32Array([0x12345678]);\n  var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\nvar LITTLE_ENDIAN_OS = systemIsLittleEndian();\nvar DTYPES = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\nexport function parseNPY(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n  var view = new DataView(arrayBuffer);\n  var _parseHeader = parseHeader(view),\n    header = _parseHeader.header,\n    headerEndOffset = _parseHeader.headerEndOffset;\n  var numpyType = header.descr;\n  var ArrayType = DTYPES[numpyType.slice(1, 3)];\n  if (!ArrayType) {\n    console.warn(\"Decoding of npy dtype not implemented: \".concat(numpyType));\n    return null;\n  }\n  var nArrayElements = header.shape.reduce(function (a, b) {\n    return a * b;\n  });\n  var arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n  var data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n  if (numpyType[0] === '>' && LITTLE_ENDIAN_OS || numpyType[0] === '<' && !LITTLE_ENDIAN_OS) {\n    console.warn('Data is wrong endianness, byte swapping not yet implemented.');\n  }\n  return {\n    data: data,\n    header: header\n  };\n}\nfunction parseHeader(view) {\n  var majorVersion = view.getUint8(6);\n  var offset = 8;\n  var headerLength;\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(8, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(8, true);\n    offset += 2;\n  }\n  var encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  var decoder = new TextDecoder(encoding);\n  var headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  var headerText = decoder.decode(headerArray);\n  offset += headerLength;\n  var header = JSON.parse(headerText.replace(/'/g, '\"').replace('False', 'false').replace('(', '[').replace(/,*\\),*/g, ']'));\n  return {\n    header: header,\n    headerEndOffset: offset\n  };\n}","map":{"version":3,"sources":["../../../src/lib/parse-npy.js"],"names":["systemIsLittleEndian","a","Uint32Array","b","Uint8Array","buffer","byteOffset","byteLength","LITTLE_ENDIAN_OS","DTYPES","u1","i1","Int8Array","u2","Uint16Array","i2","Int16Array","u4","i4","Int32Array","f4","Float32Array","f8","Float64Array","parseNPY","arrayBuffer","options","view","DataView","header","headerEndOffset","parseHeader","numpyType","descr","ArrayType","slice","console","warn","nArrayElements","shape","reduce","arrayByteLength","BYTES_PER_ELEMENT","data","majorVersion","getUint8","offset","headerLength","getUint32","getUint16","encoding","decoder","TextDecoder","headerArray","headerText","decode","JSON","parse","replace"],"mappings":"AAEA,SAASA,oBAAT,GAAgC;EAC9B,IAAMC,CAAC,GAAG,IAAIC,WAAJ,CAAgB,CAAC,UAAD,CAAhB,CAAV;EACA,IAAMC,CAAC,GAAG,IAAIC,UAAJ,CAAeH,CAAC,CAACI,MAAjB,EAAyBJ,CAAC,CAACK,UAA3B,EAAuCL,CAAC,CAACM,UAAzC,CAAV;EACA,OAAO,EAAEJ,CAAC,CAAC,CAAD,CAADA,KAAS,IAAX,CAAP;AACD;AAED,IAAMK,gBAAgB,GAAGR,oBAAoB,EAA7C;AAUA,IAAMS,MAAM,GAAG;EACbC,EAAE,EAAEN,UADS;EAEbO,EAAE,EAAEC,SAFS;EAGbC,EAAE,EAAEC,WAHS;EAIbC,EAAE,EAAEC,UAJS;EAKbC,EAAE,EAAEf,WALS;EAMbgB,EAAE,EAAEC,UANS;EAObC,EAAE,EAAEC,YAPS;EAQbC,EAAE,EAAEC;AARS,CAAf;AAWA,OAAO,SAASC,QAAT,CAAkBC,WAAlB,EAA+BC,OAA/B,EAAwC;EAC7C,IAAI,CAACD,WAAL,EAAkB;IAChB,OAAO,IAAP;EACD;EAED,IAAME,IAAI,GAAG,IAAIC,QAAJ,CAAaH,WAAb,CAAb;EAL6C,IAAA,YAAA,GAMXM,WAAW,CAACJ,IAAD,CANA;IAMtCE,MANsC,GAAA,YAAA,CAMtCA,MANsC;IAM9BC,eAN8B,GAAA,YAAA,CAM9BA,eAN8B;EAQ7C,IAAME,SAAS,GAAGH,MAAM,CAACI,KAAzB;EACA,IAAMC,SAAS,GAAGzB,MAAM,CAACuB,SAAS,CAACG,KAAVH,CAAgB,CAAhBA,EAAmB,CAAnBA,CAAD,CAAxB;EACA,IAAI,CAACE,SAAL,EAAgB;IAEdE,OAAO,CAACC,IAARD,CAAAA,yCAAAA,CAAAA,MAAAA,CAAuDJ,SAAvDI,CAAAA,CAAAA;IACA,OAAO,IAAP;EACD;EAED,IAAME,cAAc,GAAG,MAAM,CAACC,KAAP,CAAaC,MAAb,CAAoB,UAACvC,CAAD,EAAIE,CAAJ,EAAA;IAAA,OAAUF,CAAC,GAAGE,CAAd;EAAA,CAApB,CAAvB;EACA,IAAMsC,eAAe,GAAGH,cAAc,GAAGJ,SAAS,CAACQ,iBAAnD;EAEA,IAAMC,IAAI,GAAG,IAAIT,SAAJ,CAAcT,WAAW,CAACU,KAAZV,CAAkBK,eAAlBL,EAAmCK,eAAe,GAAGW,eAArDhB,CAAd,CAAb;EAGA,IAAKO,SAAS,CAAC,CAAD,CAATA,KAAiB,GAAjBA,IAAwBxB,gBAAzB,IAA+CwB,SAAS,CAAC,CAAD,CAATA,KAAiB,GAAjBA,IAAwB,CAACxB,gBAA5E,EAA+F;IAE7F4B,OAAO,CAACC,IAARD,CAAa,8DAAbA,CAAAA;EACD;EAED,OAAO;IACLO,IAAI,EAAJA,IADK;IAELd,MAAM,EAANA;EAFK,CAAP;AAID;AAQD,SAASE,WAAT,CAAqBJ,IAArB,EAA2B;EACzB,IAAMiB,YAAY,GAAGjB,IAAI,CAACkB,QAALlB,CAAc,CAAdA,CAArB;EAGA,IAAImB,MAAM,GAAG,CAAb;EACA,IAAIC,YAAJ;EACA,IAAIH,YAAY,IAAI,CAApB,EAAuB;IACrBG,YAAY,GAAGpB,IAAI,CAACqB,SAALrB,CAAe,CAAfA,EAAkB,IAAlBA,CAAfoB;IACAD,MAAM,IAAI,CAAVA;EACD,CAHD,MAGO;IACLC,YAAY,GAAGpB,IAAI,CAACsB,SAALtB,CAAe,CAAfA,EAAkB,IAAlBA,CAAfoB;IACAD,MAAM,IAAI,CAAVA;EACD;EAED,IAAMI,QAAQ,GAAGN,YAAY,IAAI,CAAhBA,GAAoB,QAApBA,GAA+B,OAAhD;EACA,IAAMO,OAAO,GAAG,IAAIC,WAAJ,CAAgBF,QAAhB,CAAhB;EACA,IAAMG,WAAW,GAAG,IAAIjD,UAAJ,CAAeuB,IAAI,CAACtB,MAApB,EAA4ByC,MAA5B,EAAoCC,YAApC,CAApB;EACA,IAAMO,UAAU,GAAGH,OAAO,CAACI,MAARJ,CAAeE,WAAfF,CAAnB;EACAL,MAAM,IAAIC,YAAVD;EAEA,IAAMjB,MAAM,GAAG2B,IAAI,CAACC,KAALD,CACbF,UAAU,CACPI,OADHJ,CACW,IADXA,EACiB,GADjBA,CAAAA,CAEGI,OAFHJ,CAEW,OAFXA,EAEoB,OAFpBA,CAAAA,CAGGI,OAHHJ,CAGW,GAHXA,EAGgB,GAHhBA,CAAAA,CAIGI,OAJHJ,CAIW,SAJXA,EAIsB,GAJtBA,CADaE,CAAf;EAQA,OAAO;IAAC3B,MAAM,EAANA,MAAD;IAASC,eAAe,EAAEgB;EAA1B,CAAP;AACD","sourcesContent":["/* globals TextDecoder */\n\nfunction systemIsLittleEndian() {\n  const a = new Uint32Array([0x12345678]);\n  const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\n\nconst LITTLE_ENDIAN_OS = systemIsLittleEndian();\n\n// The basic string format consists of 3 characters:\n// 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n// 2. a character code giving the basic type of the array\n// 3. an integer providing the number of bytes the type uses.\n// https://numpy.org/doc/stable/reference/arrays.interface.html\n//\n// Here I only include the second and third characters, and check endianness\n// separately\nconst DTYPES = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\n\nexport function parseNPY(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  const view = new DataView(arrayBuffer);\n  const {header, headerEndOffset} = parseHeader(view);\n\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n  if (!ArrayType) {\n    // eslint-disable-next-line no-console, no-undef\n    console.warn(`Decoding of npy dtype not implemented: ${numpyType}`);\n    return null;\n  }\n\n  const nArrayElements = header.shape.reduce((a, b) => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n\n  // Swap endianness if needed\n  if ((numpyType[0] === '>' && LITTLE_ENDIAN_OS) || (numpyType[0] === '<' && !LITTLE_ENDIAN_OS)) {\n    // eslint-disable-next-line no-console, no-undef\n    console.warn('Data is wrong endianness, byte swapping not yet implemented.');\n  }\n\n  return {\n    data,\n    header\n  };\n}\n\n/**\n * Parse NPY header\n *\n * @param  {DataView} view\n * @return {Object}\n */\nfunction parseHeader(view) {\n  const majorVersion = view.getUint8(6);\n  // const minorVersion = view.getUint8(7);\n\n  let offset = 8;\n  let headerLength;\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(8, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(8, true);\n    offset += 2;\n  }\n\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n\n  const header = JSON.parse(\n    headerText\n      .replace(/'/g, '\"')\n      .replace('False', 'false')\n      .replace('(', '[')\n      .replace(/,*\\),*/g, ']')\n  );\n\n  return {header, headerEndOffset: offset};\n}\n"]},"metadata":{},"sourceType":"module"}