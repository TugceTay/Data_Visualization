{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _awaitAsyncGenerator from \"@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nvar DEFAULT_CHUNK_SIZE = 1024 * 1024;\nexport function makeBlobIterator(_x) {\n  return _makeBlobIterator.apply(this, arguments);\n}\nfunction _makeBlobIterator() {\n  _makeBlobIterator = _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee(file) {\n    var options,\n      chunkSize,\n      offset,\n      end,\n      chunk,\n      _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            chunkSize = options.chunkSize || DEFAULT_CHUNK_SIZE;\n            offset = 0;\n          case 3:\n            if (!(offset < file.size)) {\n              _context.next = 13;\n              break;\n            }\n            end = offset + chunkSize;\n            _context.next = 7;\n            return _awaitAsyncGenerator(readFileSlice(file, offset, end));\n          case 7:\n            chunk = _context.sent;\n            offset = end;\n            _context.next = 11;\n            return chunk;\n          case 11:\n            _context.next = 3;\n            break;\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _makeBlobIterator.apply(this, arguments);\n}\nexport function readFileSlice(_x2, _x3, _x4) {\n  return _readFileSlice.apply(this, arguments);\n}\nfunction _readFileSlice() {\n  _readFileSlice = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(file, offset, end) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return new Promise(function (resolve, reject) {\n              var slice = file.slice(offset, end);\n              var fileReader = new FileReader();\n              fileReader.onload = function (event) {\n                return resolve(event.target && event.target.result);\n              };\n              fileReader.onerror = function (error) {\n                return reject(error);\n              };\n              fileReader.readAsArrayBuffer(slice);\n            });\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent);\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _readFileSlice.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/iterator-utils/make-iterator/blob-iterator.js"],"names":["DEFAULT_CHUNK_SIZE","makeBlobIterator","file","options","chunkSize","offset","size","end","chunk","readFileSlice","Promise","resolve","reject","slice","fileReader","FileReader","onload","event","target","result","onerror","error","readAsArrayBuffer"],"mappings":"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","sourcesContent":["/* global FileReader */\n\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024; // 1MB â€” biggest value that keeps UI responsive\n\nexport async function* makeBlobIterator(file, options = {}) {\n  const chunkSize = options.chunkSize || DEFAULT_CHUNK_SIZE;\n\n  let offset = 0;\n  while (offset < file.size) {\n    const end = offset + chunkSize;\n\n    const chunk = await readFileSlice(file, offset, end);\n\n    offset = end;\n    yield chunk;\n  }\n}\n\nexport async function readFileSlice(file, offset, end) {\n  return await new Promise((resolve, reject) => {\n    // The trick when reading File objects is to read successive \"slices\" of the File\n    // Per spec https://w3c.github.io/FileAPI/, slicing a File should only update the start and end fields\n    // Actually reading from file should happen in `readAsArrayBuffer` (and as far we can tell it does)\n    const slice = file.slice(offset, end);\n\n    const fileReader = new FileReader();\n    fileReader.onload = event => resolve(event.target && event.target.result);\n    fileReader.onerror = error => reject(error);\n    fileReader.readAsArrayBuffer(slice);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}