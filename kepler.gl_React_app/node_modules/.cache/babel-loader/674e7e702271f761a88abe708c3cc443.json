{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport LinearInterpolator from '../transitions/linear-interpolator';\nimport Transition from '../transitions/transition';\nvar noop = function noop() {};\nexport var TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\nvar DEFAULT_PROPS = {\n  transitionDuration: 0,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: noop,\n  onTransitionInterrupt: noop,\n  onTransitionEnd: noop\n};\nvar TransitionManager = function () {\n  function TransitionManager(ControllerState) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, TransitionManager);\n    this.ControllerState = ControllerState;\n    this.props = Object.assign({}, DEFAULT_PROPS, props);\n    this.propsInTransition = null;\n    this.transition = new Transition(props.timeline);\n    this.onViewStateChange = props.onViewStateChange;\n    this._onTransitionUpdate = this._onTransitionUpdate.bind(this);\n  }\n  _createClass(TransitionManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      this.transition.cancel();\n    }\n  }, {\n    key: \"getViewportInTransition\",\n    value: function getViewportInTransition() {\n      return this.propsInTransition;\n    }\n  }, {\n    key: \"processViewStateChange\",\n    value: function processViewStateChange(nextProps) {\n      var transitionTriggered = false;\n      var currentProps = this.props;\n      nextProps = Object.assign({}, DEFAULT_PROPS, nextProps);\n      this.props = nextProps;\n      if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n        return transitionTriggered;\n      }\n      if (this._isTransitionEnabled(nextProps)) {\n        var _this$transition$sett = this.transition.settings,\n          interruption = _this$transition$sett.interruption,\n          endProps = _this$transition$sett.endProps;\n        var startProps = Object.assign({}, currentProps, interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps);\n        this._triggerTransition(startProps, nextProps);\n        transitionTriggered = true;\n      } else {\n        this.transition.cancel();\n      }\n      return transitionTriggered;\n    }\n  }, {\n    key: \"updateTransition\",\n    value: function updateTransition() {\n      this.transition.update();\n    }\n  }, {\n    key: \"_isTransitionEnabled\",\n    value: function _isTransitionEnabled(props) {\n      var transitionDuration = props.transitionDuration,\n        transitionInterpolator = props.transitionInterpolator;\n      return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);\n    }\n  }, {\n    key: \"_isUpdateDueToCurrentTransition\",\n    value: function _isUpdateDueToCurrentTransition(props) {\n      if (this.transition.inProgress) {\n        return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);\n      }\n      return false;\n    }\n  }, {\n    key: \"_shouldIgnoreViewportChange\",\n    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {\n      if (this.transition.inProgress) {\n        return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);\n      } else if (this._isTransitionEnabled(nextProps)) {\n        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n      }\n      return true;\n    }\n  }, {\n    key: \"_triggerTransition\",\n    value: function _triggerTransition(startProps, endProps) {\n      var startViewstate = new this.ControllerState(startProps);\n      var endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);\n      var transitionInterpolator = endProps.transitionInterpolator;\n      var duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;\n      if (duration === 0) {\n        return;\n      }\n      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endViewStateProps);\n      this.propsInTransition = {};\n      this.duration = duration;\n      this.transition.start({\n        duration: duration,\n        easing: endProps.transitionEasing,\n        interpolator: endProps.transitionInterpolator,\n        interruption: endProps.transitionInterruption,\n        startProps: initialProps.start,\n        endProps: initialProps.end,\n        onStart: endProps.onTransitionStart,\n        onUpdate: this._onTransitionUpdate,\n        onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n        onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n      });\n      this.updateTransition();\n    }\n  }, {\n    key: \"_onTransitionEnd\",\n    value: function _onTransitionEnd(callback) {\n      var _this = this;\n      return function (transition) {\n        _this.propsInTransition = null;\n        callback(transition);\n      };\n    }\n  }, {\n    key: \"_onTransitionUpdate\",\n    value: function _onTransitionUpdate(transition) {\n      var time = transition.time,\n        _transition$settings = transition.settings,\n        interpolator = _transition$settings.interpolator,\n        startProps = _transition$settings.startProps,\n        endProps = _transition$settings.endProps,\n        duration = _transition$settings.duration,\n        easing = _transition$settings.easing;\n      var t = easing(time / duration);\n      var viewport = interpolator.interpolateProps(startProps, endProps, t);\n      this.propsInTransition = new this.ControllerState(Object.assign({}, this.props, viewport)).getViewportProps();\n      if (this.onViewStateChange) {\n        this.onViewStateChange({\n          viewState: this.propsInTransition,\n          interactionState: {\n            inTransition: true\n          },\n          oldViewState: this.props\n        });\n      }\n    }\n  }]);\n  return TransitionManager;\n}();\nexport { TransitionManager as default };\nTransitionManager.defaultProps = DEFAULT_PROPS;","map":{"version":3,"sources":["../../../src/controllers/transition-manager.js"],"names":["LinearInterpolator","Transition","noop","TRANSITION_EVENTS","BREAK","SNAP_TO_END","IGNORE","DEFAULT_PROPS","transitionDuration","transitionEasing","t","transitionInterpolator","transitionInterruption","onTransitionStart","onTransitionInterrupt","onTransitionEnd","TransitionManager","ControllerState","props","Object","assign","propsInTransition","transition","timeline","onViewStateChange","_onTransitionUpdate","bind","cancel","nextProps","transitionTriggered","currentProps","_shouldIgnoreViewportChange","_isTransitionEnabled","interruption","endProps","settings","startProps","_triggerTransition","update","Boolean","inProgress","interpolator","arePropsEqual","_isUpdateDueToCurrentTransition","startViewstate","endViewStateProps","shortestPathFrom","duration","getDuration","initialProps","initializeProps","start","easing","end","onStart","onUpdate","onInterrupt","_onTransitionEnd","onEnd","updateTransition","callback","time","viewport","interpolateProps","getViewportProps","viewState","interactionState","inTransition","oldViewState","defaultProps"],"mappings":"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","sourcesContent":["import LinearInterpolator from '../transitions/linear-interpolator';\nimport Transition from '../transitions/transition';\n\nconst noop = () => {};\n\nexport const TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\n\nconst DEFAULT_PROPS = {\n  transitionDuration: 0,\n  transitionEasing: t => t,\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: noop,\n  onTransitionInterrupt: noop,\n  onTransitionEnd: noop\n};\n\nexport default class TransitionManager {\n  constructor(ControllerState, props = {}) {\n    this.ControllerState = ControllerState;\n    this.props = Object.assign({}, DEFAULT_PROPS, props);\n    this.propsInTransition = null;\n    this.transition = new Transition(props.timeline);\n\n    this.onViewStateChange = props.onViewStateChange;\n\n    this._onTransitionUpdate = this._onTransitionUpdate.bind(this);\n  }\n\n  finalize() {\n    this.transition.cancel();\n  }\n\n  // Returns current transitioned viewport.\n  getViewportInTransition() {\n    return this.propsInTransition;\n  }\n\n  // Process the vewiport change, either ignore or trigger a new transition.\n  // Return true if a new transition is triggered, false otherwise.\n  processViewStateChange(nextProps) {\n    let transitionTriggered = false;\n    const currentProps = this.props;\n    // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n    nextProps = Object.assign({}, DEFAULT_PROPS, nextProps);\n    this.props = nextProps;\n\n    // NOTE: Be cautious re-ordering statements in this function.\n    if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n      return transitionTriggered;\n    }\n\n    if (this._isTransitionEnabled(nextProps)) {\n      const {interruption, endProps} = this.transition.settings;\n      const startProps = Object.assign(\n        {},\n        currentProps,\n        interruption === TRANSITION_EVENTS.SNAP_TO_END\n          ? endProps\n          : this.propsInTransition || currentProps\n      );\n\n      this._triggerTransition(startProps, nextProps);\n\n      transitionTriggered = true;\n    } else {\n      this.transition.cancel();\n    }\n\n    return transitionTriggered;\n  }\n\n  updateTransition() {\n    this.transition.update();\n  }\n\n  // Helper methods\n\n  _isTransitionEnabled(props) {\n    const {transitionDuration, transitionInterpolator} = props;\n    return (\n      (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator)\n    );\n  }\n\n  _isUpdateDueToCurrentTransition(props) {\n    if (this.transition.inProgress) {\n      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);\n    }\n    return false;\n  }\n\n  _shouldIgnoreViewportChange(currentProps, nextProps) {\n    if (this.transition.inProgress) {\n      // Ignore update if it is requested to be ignored\n      return (\n        this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE ||\n        // Ignore update if it is due to current active transition.\n        this._isUpdateDueToCurrentTransition(nextProps)\n      );\n    } else if (this._isTransitionEnabled(nextProps)) {\n      // Ignore if none of the viewport props changed.\n      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n    }\n    return true;\n  }\n\n  _triggerTransition(startProps, endProps) {\n    const startViewstate = new this.ControllerState(startProps);\n    const endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);\n\n    // update transitionDuration for 'auto' mode\n    const {transitionInterpolator} = endProps;\n    const duration = transitionInterpolator.getDuration\n      ? transitionInterpolator.getDuration(startProps, endProps)\n      : endProps.transitionDuration;\n\n    if (duration === 0) {\n      return;\n    }\n\n    const initialProps = endProps.transitionInterpolator.initializeProps(\n      startProps,\n      endViewStateProps\n    );\n\n    this.propsInTransition = {};\n    this.duration = duration;\n    this.transition.start({\n      duration,\n      easing: endProps.transitionEasing,\n      interpolator: endProps.transitionInterpolator,\n      interruption: endProps.transitionInterruption,\n\n      startProps: initialProps.start,\n      endProps: initialProps.end,\n\n      onStart: endProps.onTransitionStart,\n      onUpdate: this._onTransitionUpdate,\n      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n    });\n    this.updateTransition();\n  }\n\n  _onTransitionEnd(callback) {\n    return transition => {\n      this.propsInTransition = null;\n      callback(transition);\n    };\n  }\n\n  _onTransitionUpdate(transition) {\n    // NOTE: Be cautious re-ordering statements in this function.\n    const {\n      time,\n      settings: {interpolator, startProps, endProps, duration, easing}\n    } = transition;\n    const t = easing(time / duration);\n    const viewport = interpolator.interpolateProps(startProps, endProps, t);\n\n    // This gurantees all props (e.g. bearing, longitude) are normalized\n    // So when viewports are compared they are in same range.\n    this.propsInTransition = new this.ControllerState(\n      Object.assign({}, this.props, viewport)\n    ).getViewportProps();\n\n    if (this.onViewStateChange) {\n      this.onViewStateChange({\n        viewState: this.propsInTransition,\n        interactionState: {inTransition: true},\n        oldViewState: this.props\n      });\n    }\n  }\n}\n\nTransitionManager.defaultProps = DEFAULT_PROPS;\n"]},"metadata":{},"sourceType":"module"}