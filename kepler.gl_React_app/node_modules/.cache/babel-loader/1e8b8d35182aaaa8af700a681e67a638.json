{"ast":null,"code":"import { assert } from '../utils';\nimport { parsePropTypes } from './filters/prop-types';\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\nexport default class ShaderModule {\n  constructor(_ref) {\n    let {\n      name,\n      vs,\n      fs,\n      dependencies = [],\n      uniforms,\n      getUniforms,\n      deprecations = [],\n      defines = {},\n      inject = {},\n      vertexShader,\n      fragmentShader\n    } = _ref;\n    assert(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n    this.injections = normalizeInjections(inject);\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n  getModuleSource(type) {\n    let moduleSource;\n    switch (type) {\n      case VERTEX_SHADER:\n        moduleSource = this.vs || '';\n        break;\n      case FRAGMENT_SHADER:\n        moduleSource = this.fs || '';\n        break;\n      default:\n        assert(false);\n    }\n    return \"#define MODULE_\".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, '_'), \"\\n\").concat(moduleSource, \"// END MODULE_\").concat(this.name, \"\\n\\n\");\n  }\n  getUniforms(opts, uniforms) {\n    if (this.getModuleUniforms) {\n      return this.getModuleUniforms(opts, uniforms);\n    }\n    if (this.uniforms) {\n      return this._defaultGetUniforms(opts);\n    }\n    return {};\n  }\n  getDefines() {\n    return this.defines;\n  }\n  checkDeprecations(shaderSource, log) {\n    this.deprecations.forEach(def => {\n      if (def.regex.test(shaderSource)) {\n        if (def.deprecated) {\n          log.deprecated(def.old, def.new)();\n        } else {\n          log.removed(def.old, def.new)();\n        }\n      }\n    });\n  }\n  _parseDeprecationDefinitions(deprecations) {\n    deprecations.forEach(def => {\n      switch (def.type) {\n        case 'function':\n          def.regex = new RegExp(\"\\\\b\".concat(def.old, \"\\\\(\"));\n          break;\n        default:\n          def.regex = new RegExp(\"\".concat(def.type, \" \").concat(def.old, \";\"));\n      }\n    });\n    return deprecations;\n  }\n  _defaultGetUniforms() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const uniforms = {};\n    const propTypes = this.uniforms;\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), \"\".concat(this.name, \": invalid \").concat(key));\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n    return uniforms;\n  }\n}\nexport function normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n    if (module.uniforms && !module.getUniforms) {\n      const shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n  return module;\n}\nfunction normalizeInjections(injections) {\n  const result = {\n    vs: {},\n    fs: {}\n  };\n  for (const hook in injections) {\n    let injection = injections[hook];\n    const stage = hook.slice(0, 2);\n    if (typeof injection === 'string') {\n      injection = {\n        order: 0,\n        injection\n      };\n    }\n    result[stage][hook] = injection;\n  }\n  return result;\n}","map":{"version":3,"sources":["../../../src/lib/shader-module.js"],"names":["assert","parsePropTypes","VERTEX_SHADER","FRAGMENT_SHADER","ShaderModule","constructor","name","vs","fs","dependencies","uniforms","getUniforms","deprecations","defines","inject","vertexShader","fragmentShader","getModuleUniforms","_parseDeprecationDefinitions","injections","normalizeInjections","getModuleSource","type","moduleSource","toUpperCase","replace","opts","_defaultGetUniforms","getDefines","checkDeprecations","shaderSource","log","forEach","def","regex","test","deprecated","old","new","removed","RegExp","propTypes","key","propDef","private","validate","value","normalizeShaderModule","module","normalized","shaderModule","bind","result","hook","injection","stage","slice","order"],"mappings":"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","sourcesContent":["import {assert} from '../utils';\nimport {parsePropTypes} from './filters/prop-types';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nexport default class ShaderModule {\n  constructor({\n    name,\n    vs,\n    fs,\n    dependencies = [],\n    uniforms,\n    getUniforms,\n    deprecations = [],\n    defines = {},\n    inject = {},\n    // DEPRECATED\n    vertexShader,\n    fragmentShader\n  }) {\n    assert(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n    this.injections = normalizeInjections(inject);\n\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n\n  // Extracts the source code chunk for the specified shader type from the named shader module\n  getModuleSource(type) {\n    let moduleSource;\n    switch (type) {\n      case VERTEX_SHADER:\n        moduleSource = this.vs || '';\n        break;\n      case FRAGMENT_SHADER:\n        moduleSource = this.fs || '';\n        break;\n      default:\n        assert(false);\n    }\n\n    return `\\\n#define MODULE_${this.name.toUpperCase().replace(/[^0-9a-z]/gi, '_')}\n${moduleSource}\\\n// END MODULE_${this.name}\n\n`;\n  }\n\n  getUniforms(opts, uniforms) {\n    if (this.getModuleUniforms) {\n      return this.getModuleUniforms(opts, uniforms);\n    }\n    // Build uniforms from the uniforms array\n    if (this.uniforms) {\n      return this._defaultGetUniforms(opts);\n    }\n    return {};\n  }\n\n  getDefines() {\n    return this.defines;\n  }\n\n  // Warn about deprecated uniforms or functions\n  checkDeprecations(shaderSource, log) {\n    this.deprecations.forEach(def => {\n      if (def.regex.test(shaderSource)) {\n        if (def.deprecated) {\n          log.deprecated(def.old, def.new)();\n        } else {\n          log.removed(def.old, def.new)();\n        }\n      }\n    });\n  }\n\n  _parseDeprecationDefinitions(deprecations) {\n    deprecations.forEach(def => {\n      switch (def.type) {\n        case 'function':\n          def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n          break;\n        default:\n          def.regex = new RegExp(`${def.type} ${def.old};`);\n      }\n    });\n\n    return deprecations;\n  }\n\n  _defaultGetUniforms(opts = {}) {\n    const uniforms = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n\n// This utility mutates the original module\n// Keeping for backward compatibility\n// TODO - remove in v8\nexport function normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n    if (module.uniforms && !module.getUniforms) {\n      const shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n  return module;\n}\n\nfunction normalizeInjections(injections) {\n  const result = {\n    vs: {},\n    fs: {}\n  };\n\n  for (const hook in injections) {\n    let injection = injections[hook];\n    const stage = hook.slice(0, 2);\n\n    if (typeof injection === 'string') {\n      injection = {\n        order: 0,\n        injection\n      };\n    }\n\n    result[stage][hook] = injection;\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}