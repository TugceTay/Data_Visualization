{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar _marked = _regeneratorRuntime.mark(makeMeshPrimitiveIterator);\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { getZeroOffsetArrayBuffer } from '@loaders.gl/loader-utils';\nimport GLTFScenegraph from '../gltf-scenegraph';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../gltf-constants';\nimport { getGLTFAccessors, getGLTFAccessor } from '../gltf-utils/gltf-attribute-utils';\nexport function decode(_x, _x2, _x3) {\n  return _decode.apply(this, arguments);\n}\nfunction _decode() {\n  _decode = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(gltfData, options, context) {\n    var scenegraph, promises, _iterator4, _step4, primitive;\n    return _regeneratorRuntime.wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (options.gltf.decompressMeshes) {\n              _context2.next = 2;\n              break;\n            }\n            return _context2.abrupt(\"return\");\n          case 2:\n            scenegraph = new GLTFScenegraph(gltfData);\n            promises = [];\n            _iterator4 = _createForOfIteratorHelper(makeMeshPrimitiveIterator(scenegraph));\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                primitive = _step4.value;\n                if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n                  promises.push(decompressPrimitive(primitive, scenegraph, options, context));\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n            _context2.next = 8;\n            return Promise.all(promises);\n          case 8:\n            scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _decode.apply(this, arguments);\n}\nexport function encode(gltfData) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var scenegraph = new GLTFScenegraph(gltfData);\n  var _iterator = _createForOfIteratorHelper(scenegraph.json.meshes || []),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var mesh = _step.value;\n      compressMesh(mesh, options);\n      scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction decompressPrimitive(_x4, _x5, _x6, _x7) {\n  return _decompressPrimitive.apply(this, arguments);\n}\nfunction _decompressPrimitive() {\n  _decompressPrimitive = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(primitive, scenegraph, options, context) {\n    var compressedPrimitive, buffer, bufferCopy, parse, dracoOptions, decodedData, originalAccessors, _i, _arr, _arr$_i, name, index;\n    return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            compressedPrimitive = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n            buffer = scenegraph.getTypedArrayForBufferView(compressedPrimitive.bufferView);\n            bufferCopy = getZeroOffsetArrayBuffer(buffer.buffer, buffer.byteOffset);\n            parse = context.parse;\n            dracoOptions = _objectSpread({}, options);\n            delete dracoOptions['3d-tiles'];\n            _context3.next = 8;\n            return parse(bufferCopy, DracoLoader, dracoOptions, context);\n          case 8:\n            decodedData = _context3.sent;\n            originalAccessors = {};\n            for (_i = 0, _arr = [].concat(_toConsumableArray(Object.entries(primitive.attributes)), [['indices', primitive.indices]]); _i < _arr.length; _i++) {\n              _arr$_i = _slicedToArray(_arr[_i], 2), name = _arr$_i[0], index = _arr$_i[1];\n              originalAccessors[name] = scenegraph.getAccessor(index);\n            }\n            primitive.attributes = getGLTFAccessors(decodedData.attributes, originalAccessors);\n            if (decodedData.indices) {\n              primitive.indices = getGLTFAccessor(decodedData.indices, originalAccessors.indices || {});\n            }\n            checkPrimitive(primitive);\n          case 14:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _decompressPrimitive.apply(this, arguments);\n}\nfunction compressMesh(attributes, indices) {\n  var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n  var options = arguments.length > 3 ? arguments[3] : undefined;\n  var context = arguments.length > 4 ? arguments[4] : undefined;\n  if (!options.DracoWriter || !options.DracoLoader) {\n    throw new Error('DracoWriter/DracoLoader not available');\n  }\n  var compressedData = options.DracoWriter.encodeSync({\n    attributes: attributes\n  });\n  var parseSync = context.parseSync;\n  var decodedData = parseSync({\n    attributes: attributes\n  });\n  var fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n  var bufferViewIndex = options.addBufferView(compressedData);\n  var glTFMesh = {\n    primitives: [{\n      attributes: fauxAccessors,\n      mode: mode,\n      extensions: _defineProperty({}, KHR_DRACO_MESH_COMPRESSION, {\n        bufferView: bufferViewIndex,\n        attributes: fauxAccessors\n      })\n    }]\n  };\n  return glTFMesh;\n}\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('Empty glTF primitive detected: Draco decompression failure?');\n  }\n}\nfunction makeMeshPrimitiveIterator(scenegraph) {\n  var _iterator2, _step2, mesh, _iterator3, _step3, primitive;\n  return _regeneratorRuntime.wrap(function makeMeshPrimitiveIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _iterator2 = _createForOfIteratorHelper(scenegraph.json.meshes || []);\n          _context.prev = 1;\n          _iterator2.s();\n        case 3:\n          if ((_step2 = _iterator2.n()).done) {\n            _context.next = 24;\n            break;\n          }\n          mesh = _step2.value;\n          _iterator3 = _createForOfIteratorHelper(mesh.primitives);\n          _context.prev = 6;\n          _iterator3.s();\n        case 8:\n          if ((_step3 = _iterator3.n()).done) {\n            _context.next = 14;\n            break;\n          }\n          primitive = _step3.value;\n          _context.next = 12;\n          return primitive;\n        case 12:\n          _context.next = 8;\n          break;\n        case 14:\n          _context.next = 19;\n          break;\n        case 16:\n          _context.prev = 16;\n          _context.t0 = _context[\"catch\"](6);\n          _iterator3.e(_context.t0);\n        case 19:\n          _context.prev = 19;\n          _iterator3.f();\n          return _context.finish(19);\n        case 22:\n          _context.next = 3;\n          break;\n        case 24:\n          _context.next = 29;\n          break;\n        case 26:\n          _context.prev = 26;\n          _context.t1 = _context[\"catch\"](1);\n          _iterator2.e(_context.t1);\n        case 29:\n          _context.prev = 29;\n          _iterator2.f();\n          return _context.finish(29);\n        case 32:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[1, 26, 29, 32], [6, 16, 19, 22]]);\n}","map":{"version":3,"sources":["../../../../src/lib/extensions/KHR_draco_mesh_compression.js"],"names":["DracoLoader","getZeroOffsetArrayBuffer","GLTFScenegraph","KHR_DRACO_MESH_COMPRESSION","getGLTFAccessors","getGLTFAccessor","decode","gltfData","options","context","gltf","decompressMeshes","scenegraph","promises","primitive","makeMeshPrimitiveIterator","getObjectExtension","push","decompressPrimitive","Promise","all","removeExtension","encode","mesh","json","meshes","compressMesh","addRequiredExtension","compressedPrimitive","buffer","getTypedArrayForBufferView","bufferView","bufferCopy","byteOffset","parse","dracoOptions","decodedData","originalAccessors","name","index","Object","entries","attributes","indices","getAccessor","checkPrimitive","mode","DracoWriter","Error","compressedData","encodeSync","parseSync","fauxAccessors","_addFauxAttributes","bufferViewIndex","addBufferView","glTFMesh","primitives","extensions","keys","length"],"mappings":"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","sourcesContent":["// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n\n/* eslint-disable camelcase */\n\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {getZeroOffsetArrayBuffer} from '@loaders.gl/loader-utils';\nimport GLTFScenegraph from '../gltf-scenegraph';\nimport {KHR_DRACO_MESH_COMPRESSION} from '../gltf-constants';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\n// Note: We have a \"soft dependency\" on Draco to avoid bundling it when not needed\nexport async function decode(gltfData, options, context) {\n  if (!options.gltf.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new GLTFScenegraph(gltfData);\n  const promises = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(primitive, scenegraph, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options = {}) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(primitive, scenegraph, options, context) {\n  const compressedPrimitive = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n\n  const buffer = scenegraph.getTypedArrayForBufferView(compressedPrimitive.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = getZeroOffsetArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  // this will generate an exception if DracoLoader is not installed\n  const {parse} = context;\n  const dracoOptions = {...options};\n  // The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = await parse(bufferCopy, DracoLoader, dracoOptions, context);\n\n  const originalAccessors = {};\n  for (const [name, index] of [\n    ...Object.entries(primitive.attributes),\n    ['indices', primitive.indices]\n  ]) {\n    originalAccessors[name] = scenegraph.getAccessor(index);\n  }\n\n  primitive.attributes = getGLTFAccessors(decodedData.attributes, originalAccessors);\n\n  if (decodedData.indices) {\n    primitive.indices = getGLTFAccessor(decodedData.indices, originalAccessors.indices || {});\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode = 4, options, context) {\n  if (!options.DracoWriter || !options.DracoLoader) {\n    throw new Error('DracoWriter/DracoLoader not available');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  const {parseSync} = context;\n  const decodedData = parseSync({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('Empty glTF primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}