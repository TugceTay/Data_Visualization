{"ast":null,"code":"import { isWebGL2 } from '@luma.gl/gltools';\nimport { Buffer, TransformFeedback } from '@luma.gl/webgl';\nimport { assert } from '@luma.gl/webgl';\nexport default class BufferTransform {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.currentIndex = 0;\n    this.feedbackMap = {};\n    this.varyings = null;\n    this.bindings = [];\n    this.resources = {};\n    this._initialize(props);\n    Object.seal(this);\n  }\n  setupResources(opts) {\n    for (const binding of this.bindings) {\n      this._setupTransformFeedback(binding, opts);\n    }\n  }\n  updateModelProps() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      varyings\n    } = this;\n    if (varyings.length > 0) {\n      props = Object.assign({}, props, {\n        varyings\n      });\n    }\n    return props;\n  }\n  getDrawOptions() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const binding = this.bindings[this.currentIndex];\n    const {\n      sourceBuffers,\n      transformFeedback\n    } = binding;\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    return {\n      attributes,\n      transformFeedback\n    };\n  }\n  swap() {\n    if (this.feedbackMap) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n  update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._setupBuffers(opts);\n  }\n  getBuffer(varyingName) {\n    const {\n      feedbackBuffers\n    } = this.bindings[this.currentIndex];\n    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;\n    if (!bufferOrParams) {\n      return null;\n    }\n    return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n  }\n  getData() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      varyingName\n    } = options;\n    const buffer = this.getBuffer(varyingName);\n    if (buffer) {\n      return buffer.getData();\n    }\n    return null;\n  }\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n  }\n  _initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._setupBuffers(props);\n    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);\n    if (this.varyings.length > 0) {\n      assert(isWebGL2(this.gl));\n    }\n  }\n  _getFeedbackBuffers(props) {\n    const {\n      sourceBuffers = {}\n    } = props;\n    const feedbackBuffers = {};\n    if (this.bindings[this.currentIndex]) {\n      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);\n    }\n    if (this.feedbackMap) {\n      for (const sourceName in this.feedbackMap) {\n        const feedbackName = this.feedbackMap[sourceName];\n        if (sourceName in sourceBuffers) {\n          feedbackBuffers[feedbackName] = sourceName;\n        }\n      }\n    }\n    Object.assign(feedbackBuffers, props.feedbackBuffers);\n    for (const bufferName in feedbackBuffers) {\n      const bufferOrRef = feedbackBuffers[bufferName];\n      if (typeof bufferOrRef === 'string') {\n        const sourceBuffer = sourceBuffers[bufferOrRef];\n        const {\n          byteLength,\n          usage,\n          accessor\n        } = sourceBuffer;\n        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {\n          byteLength,\n          usage,\n          accessor\n        });\n      }\n    }\n    return feedbackBuffers;\n  }\n  _setupBuffers() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceBuffers = null\n    } = props;\n    Object.assign(this.feedbackMap, props.feedbackMap);\n    const feedbackBuffers = this._getFeedbackBuffers(props);\n    this._updateBindings({\n      sourceBuffers,\n      feedbackBuffers\n    });\n  }\n  _setupTransformFeedback(binding, _ref) {\n    let {\n      model\n    } = _ref;\n    const {\n      program\n    } = model;\n    binding.transformFeedback = new TransformFeedback(this.gl, {\n      program,\n      buffers: binding.feedbackBuffers\n    });\n  }\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this.feedbackMap) {\n      const {\n        sourceBuffers,\n        feedbackBuffers\n      } = this._swapBuffers(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n  _updateBinding(binding, opts) {\n    if (!binding) {\n      return {\n        sourceBuffers: Object.assign({}, opts.sourceBuffers),\n        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)\n      };\n    }\n    Object.assign(binding.sourceBuffers, opts.sourceBuffers);\n    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);\n    if (binding.transformFeedback) {\n      binding.transformFeedback.setBuffers(binding.feedbackBuffers);\n    }\n    return binding;\n  }\n  _swapBuffers(opts) {\n    if (!this.feedbackMap) {\n      return null;\n    }\n    const sourceBuffers = Object.assign({}, opts.sourceBuffers);\n    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];\n      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];\n      assert(feedbackBuffers[dstName] instanceof Buffer);\n    }\n    return {\n      sourceBuffers,\n      feedbackBuffers\n    };\n  }\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n    this.resources[name] = buffer;\n    return buffer;\n  }\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n}","map":{"version":3,"sources":["../../../src/transform/buffer-transform.js"],"names":["isWebGL2","Buffer","TransformFeedback","assert","BufferTransform","constructor","gl","props","currentIndex","feedbackMap","varyings","bindings","resources","_initialize","Object","seal","setupResources","opts","binding","_setupTransformFeedback","updateModelProps","length","assign","getDrawOptions","sourceBuffers","transformFeedback","attributes","swap","_getNextIndex","update","_setupBuffers","getBuffer","varyingName","feedbackBuffers","bufferOrParams","buffer","getData","options","delete","name","keys","_getFeedbackBuffers","sourceName","feedbackName","bufferName","bufferOrRef","sourceBuffer","byteLength","usage","accessor","_createNewBuffer","_updateBindings","model","program","buffers","_updateBinding","_swapBuffers","nextIndex","setBuffers","srcName","dstName"],"mappings":"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","sourcesContent":["import {isWebGL2} from '@luma.gl/gltools';\nimport {Buffer, TransformFeedback} from '@luma.gl/webgl';\nimport {assert} from '@luma.gl/webgl';\n\nexport default class BufferTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this.feedbackMap = {};\n    this.varyings = null; // varyings array\n    this.bindings = []; // each element is an object : {sourceBuffers, feedbackBuffers, transformFeedback}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  setupResources(opts) {\n    for (const binding of this.bindings) {\n      this._setupTransformFeedback(binding, opts);\n    }\n  }\n\n  updateModelProps(props = {}) {\n    const {varyings} = this;\n    if (varyings.length > 0) {\n      props = Object.assign({}, props, {varyings});\n    }\n    return props;\n  }\n\n  getDrawOptions(opts = {}) {\n    const binding = this.bindings[this.currentIndex];\n    const {sourceBuffers, transformFeedback} = binding;\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n\n    return {attributes, transformFeedback};\n  }\n\n  swap() {\n    if (this.feedbackMap) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupBuffers(opts);\n  }\n\n  // returns current feedbackBuffer of given name\n  getBuffer(varyingName) {\n    const {feedbackBuffers} = this.bindings[this.currentIndex];\n    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;\n    if (!bufferOrParams) {\n      return null;\n    }\n    return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n  }\n\n  getData(options = {}) {\n    const {varyingName} = options;\n    const buffer = this.getBuffer(varyingName);\n    if (buffer) {\n      return buffer.getData();\n    }\n    return null;\n  }\n\n  // Delete owned resources.\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    this._setupBuffers(props);\n    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);\n    if (this.varyings.length > 0) {\n      // if writting to buffers make sure it is WebGL2\n      assert(isWebGL2(this.gl));\n    }\n  }\n\n  // auto create feedback buffers if requested\n  _getFeedbackBuffers(props) {\n    const {sourceBuffers = {}} = props;\n    const feedbackBuffers = {};\n    if (this.bindings[this.currentIndex]) {\n      // this gurantees a partial feedback buffer set doesn't update\n      // previously set buffers during auto creation mode.\n      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);\n    }\n    if (this.feedbackMap) {\n      // feedbackMap is defined as sourceBuffer as key and feedbackBuffer name as object\n      for (const sourceName in this.feedbackMap) {\n        const feedbackName = this.feedbackMap[sourceName];\n        if (sourceName in sourceBuffers) {\n          feedbackBuffers[feedbackName] = sourceName;\n        }\n      }\n    }\n    Object.assign(feedbackBuffers, props.feedbackBuffers);\n    for (const bufferName in feedbackBuffers) {\n      const bufferOrRef = feedbackBuffers[bufferName];\n      if (typeof bufferOrRef === 'string') {\n        // Create new buffer with same layout and settings as source buffer\n        const sourceBuffer = sourceBuffers[bufferOrRef];\n        const {byteLength, usage, accessor} = sourceBuffer;\n        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {\n          byteLength,\n          usage,\n          accessor\n        });\n      }\n    }\n\n    return feedbackBuffers;\n  }\n\n  _setupBuffers(props = {}) {\n    const {sourceBuffers = null} = props;\n    Object.assign(this.feedbackMap, props.feedbackMap);\n    const feedbackBuffers = this._getFeedbackBuffers(props);\n    this._updateBindings({sourceBuffers, feedbackBuffers});\n  }\n\n  _setupTransformFeedback(binding, {model}) {\n    const {program} = model;\n    binding.transformFeedback = new TransformFeedback(this.gl, {\n      program,\n      buffers: binding.feedbackBuffers\n    });\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this.feedbackMap) {\n      const {sourceBuffers, feedbackBuffers} = this._swapBuffers(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    if (!binding) {\n      return {\n        sourceBuffers: Object.assign({}, opts.sourceBuffers),\n        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)\n      };\n    }\n    Object.assign(binding.sourceBuffers, opts.sourceBuffers);\n    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);\n    if (binding.transformFeedback) {\n      binding.transformFeedback.setBuffers(binding.feedbackBuffers);\n    }\n    return binding;\n  }\n\n  _swapBuffers(opts) {\n    if (!this.feedbackMap) {\n      return null;\n    }\n    const sourceBuffers = Object.assign({}, opts.sourceBuffers);\n    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];\n      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];\n\n      // make sure the new destination buffer is a Buffer object\n      assert(feedbackBuffers[dstName] instanceof Buffer);\n    }\n    return {sourceBuffers, feedbackBuffers};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n    this.resources[name] = buffer;\n    return buffer;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}