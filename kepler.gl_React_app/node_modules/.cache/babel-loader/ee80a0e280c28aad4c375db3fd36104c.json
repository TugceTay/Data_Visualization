{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { MAGIC_ARRAY } from '../constants';\nimport { encode3DTileHeader, encode3DTileByteLength } from './helpers/encode-3d-tile-header';\nexport function encodeComposite3DTile(tile, dataView, byteOffset, options, encode3DTile) {\n  tile = _objectSpread({\n    magic: MAGIC_ARRAY.COMPOSITE,\n    tiles: []\n  }, tile);\n  var byteOffsetStart = byteOffset;\n  byteOffset += encode3DTileHeader(tile, dataView, byteOffset);\n  if (dataView) {\n    dataView.setUint32(byteOffset, tile.tiles.length, true);\n  }\n  byteOffset += 4;\n  for (var i = 0; i < tile.tiles.length; ++i) {\n    byteOffset += encode3DTile(tile.tiles[i], dataView, byteOffset, options);\n  }\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n  return byteOffset;\n}","map":{"version":3,"sources":["../../../../src/lib/encoders/encode-3d-tile-composite.js"],"names":["MAGIC_ARRAY","encode3DTileHeader","encode3DTileByteLength","encodeComposite3DTile","tile","dataView","byteOffset","options","encode3DTile","magic","COMPOSITE","tiles","byteOffsetStart","setUint32","length","i"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,SAAQA,WAAR,QAA0B,cAA1B;AACA,SAAQC,kBAAR,EAA4BC,sBAA5B,QAAyD,iCAAzD;AAEA,OAAO,SAASC,qBAAT,CAA+BC,IAA/B,EAAqCC,QAArC,EAA+CC,UAA/C,EAA2DC,OAA3D,EAAoEC,YAApE,EAAkF;EAEvFJ,IAAI,GAAA,aAAA,CAAA;IAAIK,KAAK,EAAET,WAAW,CAACU,SAAvB;IAAkCC,KAAK,EAAE;EAAzC,CAAA,EAAgDP,IAAhD,CAAJA;EAEA,IAAMQ,eAAe,GAAGN,UAAxB;EAEAA,UAAU,IAAIL,kBAAkB,CAACG,IAAD,EAAOC,QAAP,EAAiBC,UAAjB,CAAhCA;EAEA,IAAID,QAAJ,EAAc;IACZA,QAAQ,CAACQ,SAATR,CAAmBC,UAAnBD,EAA+BD,IAAI,CAACO,KAALP,CAAWU,MAA1CT,EAAkD,IAAlDA,CAAAA;EACD;EACDC,UAAU,IAAI,CAAdA;EAEA,KAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,IAAI,CAACO,KAALP,CAAWU,MAA/B,EAAuC,EAAEC,CAAzC,EAA4C;IAC1CT,UAAU,IAAIE,YAAY,CAACJ,IAAI,CAACO,KAALP,CAAWW,CAAXX,CAAD,EAAgBC,QAAhB,EAA0BC,UAA1B,EAAsCC,OAAtC,CAA1BD;EACD;EAGDJ,sBAAsB,CAACG,QAAD,EAAWO,eAAX,EAA4BN,UAAU,GAAGM,eAAzC,CAAtBV;EAEA,OAAOI,UAAP;AACD","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {MAGIC_ARRAY} from '../constants';\nimport {encode3DTileHeader, encode3DTileByteLength} from './helpers/encode-3d-tile-header';\n\nexport function encodeComposite3DTile(tile, dataView, byteOffset, options, encode3DTile) {\n  // Add default magic for this tile type\n  tile = {magic: MAGIC_ARRAY.COMPOSITE, tiles: [], ...tile};\n\n  const byteOffsetStart = byteOffset;\n\n  byteOffset += encode3DTileHeader(tile, dataView, byteOffset);\n\n  if (dataView) {\n    dataView.setUint32(byteOffset, tile.tiles.length, true); // tilesLength\n  }\n  byteOffset += 4;\n\n  for (let i = 0; i < tile.tiles.length; ++i) {\n    byteOffset += encode3DTile(tile.tiles[i], dataView, byteOffset, options);\n  }\n\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n\n  return byteOffset;\n}\n"]},"metadata":{},"sourceType":"module"}