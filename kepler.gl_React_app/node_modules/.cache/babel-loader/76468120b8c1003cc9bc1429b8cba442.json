{"ast":null,"code":"import { log } from '@deck.gl/core';\nexport function getScale(domain, range, scaleFunction) {\n  var scale = scaleFunction;\n  scale.domain = function () {\n    return domain;\n  };\n  scale.range = function () {\n    return range;\n  };\n  return scale;\n}\nexport function getQuantizeScale(domain, range) {\n  var scaleFunction = function scaleFunction(value) {\n    return quantizeScale(domain, range, value);\n  };\n  return getScale(domain, range, scaleFunction);\n}\nexport function getLinearScale(domain, range) {\n  var scaleFunction = function scaleFunction(value) {\n    return linearScale(domain, range, value);\n  };\n  return getScale(domain, range, scaleFunction);\n}\nexport function getQuantileScale(domain, range) {\n  var sortedDomain = domain.sort(ascending);\n  var i = 0;\n  var n = Math.max(1, range.length);\n  var thresholds = new Array(n - 1);\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedDomain, i / n);\n  }\n  var scaleFunction = function scaleFunction(value) {\n    return thresholdsScale(thresholds, range, value);\n  };\n  scaleFunction.thresholds = function () {\n    return thresholds;\n  };\n  return getScale(domain, range, scaleFunction);\n}\nfunction ascending(a, b) {\n  return a - b;\n}\nfunction threshold(domain, fraction) {\n  var domainLength = domain.length;\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n  var domainFraction = (domainLength - 1) * fraction;\n  var lowIndex = Math.floor(domainFraction);\n  var low = domain[lowIndex];\n  var high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\nfunction bisectRight(a, x) {\n  var lo = 0;\n  var hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (ascending(a[mid], x) > 0) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\nfunction thresholdsScale(thresholds, range, value) {\n  return range[bisectRight(thresholds, value)];\n}\nfunction ordinalScale(domain, domainMap, range, value) {\n  var key = \"\".concat(value);\n  var d = domainMap.get(key);\n  if (d === undefined) {\n    d = domain.push(value);\n    domainMap.set(key, d);\n  }\n  return range[(d - 1) % range.length];\n}\nexport function getOrdinalScale(domain, range) {\n  var domainMap = new Map();\n  var uniqueDomain = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n  try {\n    for (var _iterator = domain[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var d = _step.value;\n      var key = \"\".concat(d);\n      if (!domainMap.has(key)) {\n        domainMap.set(key, uniqueDomain.push(d));\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n  var scaleFunction = function scaleFunction(value) {\n    return ordinalScale(uniqueDomain, domainMap, range, value);\n  };\n  return getScale(domain, range, scaleFunction);\n}\nexport function quantizeScale(domain, range, value) {\n  var domainRange = domain[1] - domain[0];\n  if (domainRange <= 0) {\n    log.warn('quantizeScale: invalid domain, returning range[0]')();\n    return range[0];\n  }\n  var step = domainRange / range.length;\n  var idx = Math.floor((value - domain[0]) / step);\n  var clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n  return range[clampIdx];\n}\nexport function linearScale(domain, range, value) {\n  return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];\n}\nfunction notNullOrUndefined(d) {\n  return d !== undefined && d !== null;\n}\nexport function unique(values) {\n  var results = [];\n  values.forEach(function (v) {\n    if (!results.includes(v) && notNullOrUndefined(v)) {\n      results.push(v);\n    }\n  });\n  return results;\n}\nfunction getTruthyValues(data, valueAccessor) {\n  var values = typeof valueAccessor === 'function' ? data.map(valueAccessor) : data;\n  return values.filter(notNullOrUndefined);\n}\nexport function getLinearDomain(data, valueAccessor) {\n  var sorted = getTruthyValues(data, valueAccessor).sort();\n  return sorted.length ? [sorted[0], sorted[sorted.length - 1]] : [0, 0];\n}\nexport function getQuantileDomain(data, valueAccessor) {\n  return getTruthyValues(data, valueAccessor);\n}\nexport function getOrdinalDomain(data, valueAccessor) {\n  return unique(getTruthyValues(data, valueAccessor));\n}\nexport function getScaleDomain(scaleType, data, valueAccessor) {\n  switch (scaleType) {\n    case 'quantize':\n    case 'linear':\n      return getLinearDomain(data, valueAccessor);\n    case 'quantile':\n      return getQuantileDomain(data, valueAccessor);\n    case 'ordinal':\n      return getOrdinalDomain(data, valueAccessor);\n    default:\n      return getLinearDomain(data, valueAccessor);\n  }\n}\nexport function clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nexport function getScaleFunctionByScaleType(scaleType) {\n  switch (scaleType) {\n    case 'quantize':\n      return getQuantizeScale;\n    case 'linear':\n      return getLinearScale;\n    case 'quantile':\n      return getQuantileScale;\n    case 'ordinal':\n      return getOrdinalScale;\n    default:\n      return getQuantizeScale;\n  }\n}","map":{"version":3,"sources":["../../../src/utils/scale-utils.js"],"names":["log","getScale","domain","range","scaleFunction","scale","getQuantizeScale","quantizeScale","value","getLinearScale","linearScale","getQuantileScale","sortedDomain","sort","ascending","i","n","Math","max","length","thresholds","Array","threshold","thresholdsScale","a","b","fraction","domainLength","domainFraction","lowIndex","floor","low","high","bisectRight","x","lo","hi","mid","ordinalScale","domainMap","key","d","get","undefined","push","set","getOrdinalScale","Map","uniqueDomain","has","domainRange","warn","step","idx","clampIdx","min","notNullOrUndefined","unique","values","results","forEach","includes","v","getTruthyValues","data","valueAccessor","map","filter","getLinearDomain","sorted","getQuantileDomain","getOrdinalDomain","getScaleDomain","scaleType","clamp","getScaleFunctionByScaleType"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {log} from '@deck.gl/core';\n\n// a scale function wrapper just like d3-scales\nexport function getScale(domain, range, scaleFunction) {\n  const scale = scaleFunction;\n  scale.domain = () => domain;\n  scale.range = () => range;\n\n  return scale;\n}\n\n// Quantize scale is similar to linear scales,\n// except it uses a discrete rather than continuous range\n// return a quantize scale function\nexport function getQuantizeScale(domain, range) {\n  const scaleFunction = value => quantizeScale(domain, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\n\n// return a linear scale function\nexport function getLinearScale(domain, range) {\n  const scaleFunction = value => linearScale(domain, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\n\nexport function getQuantileScale(domain, range) {\n  // calculate threshold\n  const sortedDomain = domain.sort(ascending);\n  let i = 0;\n  const n = Math.max(1, range.length);\n  const thresholds = new Array(n - 1);\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedDomain, i / n);\n  }\n\n  const scaleFunction = value => thresholdsScale(thresholds, range, value);\n  scaleFunction.thresholds = () => thresholds;\n\n  return getScale(domain, range, scaleFunction);\n}\n\nfunction ascending(a, b) {\n  return a - b;\n}\n\nfunction threshold(domain, fraction) {\n  const domainLength = domain.length;\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n\n  const domainFraction = (domainLength - 1) * fraction;\n  const lowIndex = Math.floor(domainFraction);\n  const low = domain[lowIndex];\n  const high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\n\nfunction bisectRight(a, x) {\n  let lo = 0;\n  let hi = a.length;\n  while (lo < hi) {\n    const mid = (lo + hi) >>> 1;\n    if (ascending(a[mid], x) > 0) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\n\n// return a quantize scale function\nfunction thresholdsScale(thresholds, range, value) {\n  return range[bisectRight(thresholds, value)];\n}\n\n// ordinal Scale\nfunction ordinalScale(domain, domainMap, range, value) {\n  const key = `${value}`;\n  let d = domainMap.get(key);\n  if (d === undefined) {\n    // update the domain\n    d = domain.push(value);\n    domainMap.set(key, d);\n  }\n  return range[(d - 1) % range.length];\n}\n\nexport function getOrdinalScale(domain, range) {\n  const domainMap = new Map();\n  const uniqueDomain = [];\n  for (const d of domain) {\n    const key = `${d}`;\n    if (!domainMap.has(key)) {\n      domainMap.set(key, uniqueDomain.push(d));\n    }\n  }\n\n  const scaleFunction = value => ordinalScale(uniqueDomain, domainMap, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\n\n// Quantize scale is similar to linear scales,\n// except it uses a discrete rather than continuous range\nexport function quantizeScale(domain, range, value) {\n  const domainRange = domain[1] - domain[0];\n  if (domainRange <= 0) {\n    log.warn('quantizeScale: invalid domain, returning range[0]')();\n    return range[0];\n  }\n  const step = domainRange / range.length;\n  const idx = Math.floor((value - domain[0]) / step);\n  const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n\n  return range[clampIdx];\n}\n\n// Linear scale maps continuous domain to continuous range\nexport function linearScale(domain, range, value) {\n  return ((value - domain[0]) / (domain[1] - domain[0])) * (range[1] - range[0]) + range[0];\n}\n\n// get scale domains\nfunction notNullOrUndefined(d) {\n  return d !== undefined && d !== null;\n}\n\nexport function unique(values) {\n  const results = [];\n  values.forEach(v => {\n    if (!results.includes(v) && notNullOrUndefined(v)) {\n      results.push(v);\n    }\n  });\n\n  return results;\n}\n\nfunction getTruthyValues(data, valueAccessor) {\n  const values = typeof valueAccessor === 'function' ? data.map(valueAccessor) : data;\n  return values.filter(notNullOrUndefined);\n}\n\nexport function getLinearDomain(data, valueAccessor) {\n  const sorted = getTruthyValues(data, valueAccessor).sort();\n  return sorted.length ? [sorted[0], sorted[sorted.length - 1]] : [0, 0];\n}\n\nexport function getQuantileDomain(data, valueAccessor) {\n  return getTruthyValues(data, valueAccessor);\n}\n\nexport function getOrdinalDomain(data, valueAccessor) {\n  return unique(getTruthyValues(data, valueAccessor));\n}\n\nexport function getScaleDomain(scaleType, data, valueAccessor) {\n  switch (scaleType) {\n    case 'quantize':\n    case 'linear':\n      return getLinearDomain(data, valueAccessor);\n\n    case 'quantile':\n      return getQuantileDomain(data, valueAccessor);\n\n    case 'ordinal':\n      return getOrdinalDomain(data, valueAccessor);\n\n    default:\n      return getLinearDomain(data, valueAccessor);\n  }\n}\n\nexport function clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n\nexport function getScaleFunctionByScaleType(scaleType) {\n  switch (scaleType) {\n    case 'quantize':\n      return getQuantizeScale;\n    case 'linear':\n      return getLinearScale;\n    case 'quantile':\n      return getQuantileScale;\n    case 'ordinal':\n      return getOrdinalScale;\n\n    default:\n      return getQuantizeScale;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}