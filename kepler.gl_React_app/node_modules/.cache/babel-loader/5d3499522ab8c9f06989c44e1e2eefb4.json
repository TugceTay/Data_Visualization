{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { getMeshBoundingBox } from '@loaders.gl/loader-utils';\nvar GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\nvar DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\nvar DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\nvar DracoParser = function () {\n  function DracoParser(draco) {\n    _classCallCheck(this, DracoParser);\n    this.draco = draco;\n    this.drawMode = 'TRIANGLE';\n    this.metadataQuerier = {};\n  }\n  _createClass(DracoParser, [{\n    key: \"destroy\",\n    value: function destroy() {}\n  }, {\n    key: \"destroyGeometry\",\n    value: function destroyGeometry(dracoGeometry) {\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry.dracoGeometry);\n      }\n    }\n  }, {\n    key: \"parseSync\",\n    value: function parseSync(arrayBuffer) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.metadataQuerier = new this.draco.MetadataQuerier();\n      var buffer = new this.draco.DecoderBuffer();\n      buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n      var decoder = new this.draco.Decoder();\n      var data = {};\n      var dracoStatus;\n      var dracoGeometry;\n      var header;\n      try {\n        var geometryType = decoder.GetEncodedGeometryType(buffer);\n        switch (geometryType) {\n          case this.draco.TRIANGULAR_MESH:\n            dracoGeometry = new this.draco.Mesh();\n            dracoStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n            header = {\n              type: GEOMETRY_TYPE.TRIANGULAR_MESH,\n              faceCount: dracoGeometry.num_faces(),\n              attributeCount: dracoGeometry.num_attributes(),\n              vertexCount: dracoGeometry.num_points()\n            };\n            break;\n          case this.draco.POINT_CLOUD:\n            dracoGeometry = new this.draco.PointCloud();\n            dracoStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n            header = {\n              type: GEOMETRY_TYPE.POINT_CLOUD,\n              attributeCount: dracoGeometry.num_attributes(),\n              vertexCount: dracoGeometry.num_points()\n            };\n            break;\n          default:\n            throw new Error('Unknown DRACO geometry type.');\n        }\n        if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n          var message = \"DRACO decompression failed: \".concat(dracoStatus.error_msg());\n          if (dracoGeometry) {\n            this.draco.destroy(dracoGeometry);\n          }\n          throw new Error(message);\n        }\n        data.loaderData = {\n          header: header\n        };\n        this._extractDRACOGeometry(decoder, dracoGeometry, geometryType, data, options);\n        var metadata = this._getGeometryMetadata(decoder, dracoGeometry);\n        data.header = {\n          vertexCount: header.vertexCount,\n          boundingBox: getMeshBoundingBox(data.attributes),\n          metadata: metadata\n        };\n      } finally {\n        this.draco.destroy(decoder);\n        this.draco.destroy(buffer);\n        this.draco.destroy(dracoGeometry);\n        this.draco.destroy(this.metadataQuerier);\n      }\n      return data;\n    }\n  }, {\n    key: \"_extractDRACOGeometry\",\n    value: function _extractDRACOGeometry(decoder, dracoGeometry, geometryType, geometry, options) {\n      var attributes = this._getAttributes(decoder, dracoGeometry, options);\n      var positionAttribute = attributes.POSITION;\n      if (!positionAttribute) {\n        throw new Error('DRACO decompressor: No position attribute found.');\n      }\n      if (geometryType === this.draco.TRIANGULAR_MESH) {\n        attributes.indices = this.drawMode === 'TRIANGLE_STRIP' ? this._getMeshStripIndices(decoder, dracoGeometry) : this._getMeshFaceIndices(decoder, dracoGeometry);\n        geometry.mode = this.drawMode === 'TRIANGLE_STRIP' ? 5 : 4;\n      } else {\n        geometry.mode = 0;\n      }\n      if (attributes.indices) {\n        geometry.indices = {\n          value: attributes.indices,\n          size: 1\n        };\n        delete attributes.indices;\n      }\n      geometry.attributes = attributes;\n      return geometry;\n    }\n  }, {\n    key: \"getPositionAttributeMetadata\",\n    value: function getPositionAttributeMetadata(positionAttribute) {\n      this.metadata = this.metadata || {};\n      this.metadata.attributes = this.metadata.attributes || {};\n      var posTransform = new this.draco.AttributeQuantizationTransform();\n      if (posTransform.InitFromAttribute(positionAttribute)) {\n        this.metadata.attributes.position.isQuantized = true;\n        this.metadata.attributes.position.maxRange = posTransform.range();\n        this.metadata.attributes.position.numQuantizationBits = posTransform.quantization_bits();\n        this.metadata.attributes.position.minValues = new Float32Array(3);\n        for (var i = 0; i < 3; ++i) {\n          this.metadata.attributes.position.minValues[i] = posTransform.min_value(i);\n        }\n      }\n      this.draco.destroy(posTransform);\n    }\n  }, {\n    key: \"_getAttributes\",\n    value: function _getAttributes(decoder, dracoGeometry, options) {\n      var attributes = {};\n      var numPoints = dracoGeometry.num_points();\n      for (var attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n        var dracoAttribute = decoder.GetAttribute(dracoGeometry, attributeId);\n        var attributeMetadata = this._getAttributeMetadata(decoder, dracoGeometry, attributeId);\n        var attributeData = {\n          uniqueId: dracoAttribute.unique_id(),\n          attributeType: dracoAttribute.attribute_type(),\n          dataType: DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()],\n          size: dracoAttribute.size(),\n          numComponents: dracoAttribute.num_components(),\n          byteOffset: dracoAttribute.byte_offset(),\n          byteStride: dracoAttribute.byte_stride(),\n          normalized: dracoAttribute.normalized(),\n          metadata: attributeMetadata\n        };\n        var attributeName = this._deduceAttributeName(attributeData, options);\n        var _this$_getAttributeTy = this._getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName),\n          typedArray = _this$_getAttributeTy.typedArray;\n        attributes[attributeName] = {\n          value: typedArray,\n          size: typedArray.length / numPoints,\n          metadata: attributeMetadata\n        };\n      }\n      return attributes;\n    }\n  }, {\n    key: \"_getMeshFaceIndices\",\n    value: function _getMeshFaceIndices(decoder, dracoGeometry) {\n      var numFaces = dracoGeometry.num_faces();\n      var numIndices = numFaces * 3;\n      var indices = new Uint32Array(numIndices);\n      var dracoArray = new this.draco.DracoInt32Array();\n      for (var i = 0; i < numFaces; ++i) {\n        decoder.GetFaceFromMesh(dracoGeometry, i, dracoArray);\n        var index = i * 3;\n        indices[index] = dracoArray.GetValue(0);\n        indices[index + 1] = dracoArray.GetValue(1);\n        indices[index + 2] = dracoArray.GetValue(2);\n      }\n      this.draco.destroy(dracoArray);\n      return indices;\n    }\n  }, {\n    key: \"_getMeshStripIndices\",\n    value: function _getMeshStripIndices(decoder, dracoGeometry) {\n      var dracoArray = new this.draco.DracoInt32Array();\n      decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      var indices = new Uint32Array(dracoArray.size());\n      for (var i = 0; i < dracoArray.size(); ++i) {\n        indices[i] = dracoArray.GetValue(i);\n      }\n      this.draco.destroy(dracoArray);\n      return indices;\n    }\n  }, {\n    key: \"_getAttributeTypedArray\",\n    value: function _getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName) {\n      if (dracoAttribute.ptr === 0) {\n        var message = \"DRACO decode bad attribute \".concat(attributeName);\n        throw new Error(message);\n      }\n      var attributeType = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];\n      var numComponents = dracoAttribute.num_components();\n      var numPoints = dracoGeometry.num_points();\n      var numValues = numPoints * numComponents;\n      var dracoArray;\n      var typedArray;\n      switch (attributeType) {\n        case Float32Array:\n          dracoArray = new this.draco.DracoFloat32Array();\n          decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Float32Array(numValues);\n          break;\n        case Int8Array:\n          dracoArray = new this.draco.DracoInt8Array();\n          decoder.GetAttributeInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Int8Array(numValues);\n          break;\n        case Int16Array:\n          dracoArray = new this.draco.DracoInt16Array();\n          decoder.GetAttributeInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Int16Array(numValues);\n          break;\n        case Int32Array:\n          dracoArray = new this.draco.DracoInt32Array();\n          decoder.GetAttributeInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Int32Array(numValues);\n          break;\n        case Uint8Array:\n          dracoArray = new this.draco.DracoUInt8Array();\n          decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Uint8Array(numValues);\n          break;\n        case Uint16Array:\n          dracoArray = new this.draco.DracoUInt16Array();\n          decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Uint16Array(numValues);\n          break;\n        case Uint32Array:\n          dracoArray = new this.draco.DracoUInt32Array();\n          decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Uint32Array(numValues);\n          break;\n        default:\n          var errorMsg = 'DRACO decoder: unexpected attribute type.';\n          throw new Error(errorMsg);\n      }\n      for (var i = 0; i < numValues; i++) {\n        typedArray[i] = dracoArray.GetValue(i);\n      }\n      this.draco.destroy(dracoArray);\n      return {\n        typedArray: typedArray,\n        components: numComponents\n      };\n    }\n  }, {\n    key: \"_deduceAttributeName\",\n    value: function _deduceAttributeName(attributeData, options) {\n      var _options$extraAttribu = options.extraAttributes,\n        extraAttributes = _options$extraAttribu === void 0 ? {} : _options$extraAttribu;\n      if (extraAttributes && _typeof(extraAttributes) === 'object') {\n        for (var _i = 0, _Object$entries = Object.entries(extraAttributes); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            attributeName = _Object$entries$_i[0],\n            attributeUniqueId = _Object$entries$_i[1];\n          if (attributeUniqueId === attributeData.uniqueId) {\n            return attributeName;\n          }\n        }\n      }\n      for (var dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n        var attributeType = this.draco[dracoAttributeConstant];\n        if (attributeData.attributeType === attributeType) {\n          return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n        }\n      }\n      if (attributeData.metadata) {\n        var entryName = options.attributeNameEntry || 'name';\n        if (attributeData.metadata[entryName]) {\n          return attributeData.metadata[entryName].string;\n        }\n      }\n      return \"CUSTOM_ATTRIBUTE_\".concat(attributeData.uniqueId);\n    }\n  }, {\n    key: \"_getGeometryMetadata\",\n    value: function _getGeometryMetadata(decoder, dracoGeometry) {\n      var dracoMetadata = decoder.GetMetadata(dracoGeometry);\n      return this._queryDracoMetadata(dracoMetadata);\n    }\n  }, {\n    key: \"_getAttributeMetadata\",\n    value: function _getAttributeMetadata(decoder, dracoGeometry, attributeId) {\n      var dracoMetadata = decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n      return this._queryDracoMetadata(dracoMetadata);\n    }\n  }, {\n    key: \"_queryDracoMetadata\",\n    value: function _queryDracoMetadata(dracoMetadata) {\n      if (!dracoMetadata || !dracoMetadata.ptr) {\n        return {};\n      }\n      var result = {};\n      var numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n      for (var entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n        var entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n        result[entryName] = {\n          \"int\": this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n          string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n          \"double\": this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n          intArray: this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName)\n        };\n      }\n      return result;\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(arrayBuffer, options) {\n      return this.parseSync(arrayBuffer, options);\n    }\n  }]);\n  return DracoParser;\n}();\nexport { DracoParser as default };","map":{"version":3,"sources":["../../../src/lib/draco-parser.js"],"names":["getMeshBoundingBox","GEOMETRY_TYPE","TRIANGULAR_MESH","POINT_CLOUD","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","DracoParser","draco","drawMode","metadataQuerier","dracoGeometry","destroy","arrayBuffer","options","MetadataQuerier","buffer","DecoderBuffer","Init","byteLength","decoder","Decoder","data","dracoStatus","header","geometryType","GetEncodedGeometryType","Mesh","DecodeBufferToMesh","type","faceCount","num_faces","attributeCount","num_attributes","vertexCount","num_points","PointCloud","DecodeBufferToPointCloud","Error","ok","ptr","message","error_msg","loaderData","_extractDRACOGeometry","metadata","_getGeometryMetadata","boundingBox","attributes","geometry","_getAttributes","positionAttribute","indices","_getMeshStripIndices","_getMeshFaceIndices","mode","value","size","posTransform","AttributeQuantizationTransform","InitFromAttribute","position","isQuantized","maxRange","range","numQuantizationBits","quantization_bits","minValues","i","min_value","numPoints","attributeId","dracoAttribute","GetAttribute","attributeMetadata","_getAttributeMetadata","attributeData","uniqueId","unique_id","attributeType","attribute_type","dataType","data_type","numComponents","num_components","byteOffset","byte_offset","byteStride","byte_stride","normalized","attributeName","_deduceAttributeName","typedArray","_getAttributeTypedArray","length","numFaces","numIndices","dracoArray","DracoInt32Array","GetFaceFromMesh","index","GetValue","GetTriangleStripsFromMesh","numValues","DracoFloat32Array","GetAttributeFloatForAllPoints","DracoInt8Array","GetAttributeInt8ForAllPoints","DracoInt16Array","GetAttributeInt16ForAllPoints","GetAttributeInt32ForAllPoints","DracoUInt8Array","GetAttributeUInt8ForAllPoints","DracoUInt16Array","GetAttributeUInt16ForAllPoints","DracoUInt32Array","GetAttributeUInt32ForAllPoints","errorMsg","components","extraAttributes","attributeUniqueId","Object","entries","dracoAttributeConstant","entryName","attributeNameEntry","string","dracoMetadata","GetMetadata","_queryDracoMetadata","GetAttributeMetadata","result","numEntries","NumEntries","entryIndex","GetEntryName","GetIntEntry","GetStringEntry","GetDoubleEntry","intArray","GetIntEntryArray","parseSync"],"mappings":"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","sourcesContent":["// This code is inspired by example code in the DRACO repository\n/** @typedef {import('../types/draco-types')} Draco3D */\n/** @typedef {import('../types/draco-types').Decoder} Decoder */\nimport {getMeshBoundingBox} from '@loaders.gl/loader-utils';\n\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nexport default class DracoParser {\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco) {\n    /** @type {Draco3D} */\n    this.draco = draco;\n    this.drawMode = 'TRIANGLE';\n    this.metadataQuerier = {};\n  }\n\n  destroy() {}\n\n  destroyGeometry(dracoGeometry) {\n    if (dracoGeometry) {\n      this.draco.destroy(dracoGeometry.dracoGeometry);\n    }\n  }\n\n  // NOTE: caller must call `destroyGeometry` on the return value after using it\n  parseSync(arrayBuffer, options = {}) {\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    const decoder = new this.draco.Decoder();\n\n    const data = {};\n    let dracoStatus;\n    let dracoGeometry;\n    let header;\n\n    try {\n      const geometryType = decoder.GetEncodedGeometryType(buffer);\n      switch (geometryType) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoGeometry = new this.draco.Mesh();\n          dracoStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n          header = {\n            type: GEOMETRY_TYPE.TRIANGULAR_MESH,\n            faceCount: dracoGeometry.num_faces(),\n            attributeCount: dracoGeometry.num_attributes(),\n            vertexCount: dracoGeometry.num_points()\n          };\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoGeometry = new this.draco.PointCloud();\n          dracoStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          header = {\n            type: GEOMETRY_TYPE.POINT_CLOUD,\n            attributeCount: dracoGeometry.num_attributes(),\n            vertexCount: dracoGeometry.num_points()\n          };\n          break;\n\n        default:\n          throw new Error('Unknown DRACO geometry type.');\n      }\n\n      // @ts-ignore .ptr\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        if (dracoGeometry) {\n          this.draco.destroy(dracoGeometry);\n        }\n        throw new Error(message);\n      }\n\n      data.loaderData = {header};\n\n      this._extractDRACOGeometry(decoder, dracoGeometry, geometryType, data, options);\n      const metadata = this._getGeometryMetadata(decoder, dracoGeometry);\n\n      data.header = {\n        vertexCount: header.vertexCount,\n        boundingBox: getMeshBoundingBox(data.attributes),\n        metadata\n      };\n    } finally {\n      this.draco.destroy(decoder);\n      this.draco.destroy(buffer);\n      this.draco.destroy(dracoGeometry);\n      this.draco.destroy(this.metadataQuerier);\n    }\n\n    return data;\n  }\n\n  /**\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   * @param {*} geometryType\n   * @param {*} geometry\n   * @param {object} options\n   */\n  _extractDRACOGeometry(decoder, dracoGeometry, geometryType, geometry, options) {\n    const attributes = this._getAttributes(decoder, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO decompressor: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (geometryType === this.draco.TRIANGULAR_MESH) {\n      attributes.indices =\n        this.drawMode === 'TRIANGLE_STRIP'\n          ? /**\n             *\n             * @param {*} decoder\n             * @param {*} dracoGeometry\n             */\n            this._getMeshStripIndices(decoder, dracoGeometry)\n          : this._getMeshFaceIndices(decoder, dracoGeometry);\n      geometry.mode =\n        this.drawMode === 'TRIANGLE_STRIP'\n          ? 5 // GL.TRIANGLE_STRIP\n          : 4; // GL.TRIANGLES\n    } else {\n      geometry.mode = 0; // GL.POINTS\n    }\n\n    if (attributes.indices) {\n      geometry.indices = {value: attributes.indices, size: 1};\n      delete attributes.indices;\n    }\n    geometry.attributes = attributes;\n\n    return geometry;\n  }\n\n  getPositionAttributeMetadata(positionAttribute) {\n    this.metadata = this.metadata || {};\n    this.metadata.attributes = this.metadata.attributes || {};\n\n    const posTransform = new this.draco.AttributeQuantizationTransform();\n    if (posTransform.InitFromAttribute(positionAttribute)) {\n      // Quantized attribute. Store the quantization parameters into the attribute\n      this.metadata.attributes.position.isQuantized = true;\n      this.metadata.attributes.position.maxRange = posTransform.range();\n      this.metadata.attributes.position.numQuantizationBits = posTransform.quantization_bits();\n      this.metadata.attributes.position.minValues = new Float32Array(3);\n      for (let i = 0; i < 3; ++i) {\n        this.metadata.attributes.position.minValues[i] = posTransform.min_value(i);\n      }\n    }\n    this.draco.destroy(posTransform);\n  }\n\n  _getAttributes(decoder, dracoGeometry, options) {\n    const attributes = {};\n    const numPoints = dracoGeometry.num_points();\n    // const attributeUniqueIdMap = {};\n\n    // Note: Draco docs do not seem clear on `GetAttribute` accepting a zero-based index,\n    // but it seems to work this way\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeMetadata = this._getAttributeMetadata(decoder, dracoGeometry, attributeId);\n      const attributeData = {\n        uniqueId: dracoAttribute.unique_id(),\n        attributeType: dracoAttribute.attribute_type(),\n        dataType: DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()],\n        size: dracoAttribute.size(),\n        numComponents: dracoAttribute.num_components(),\n        byteOffset: dracoAttribute.byte_offset(),\n        byteStride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        metadata: attributeMetadata\n      };\n\n      // DRACO does not store attribute names - We need to deduce an attribute name\n      const attributeName = this._deduceAttributeName(attributeData, options);\n\n      const {typedArray} = this._getAttributeTypedArray(\n        decoder,\n        dracoGeometry,\n        dracoAttribute,\n        attributeName\n      );\n      attributes[attributeName] = {\n        value: typedArray,\n        size: typedArray.length / numPoints,\n        metadata: attributeMetadata\n      };\n    }\n\n    return attributes;\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   */\n  _getMeshFaceIndices(decoder, dracoGeometry) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n\n    const numIndices = numFaces * 3;\n    const indices = new Uint32Array(numIndices);\n    const dracoArray = new this.draco.DracoInt32Array();\n    for (let i = 0; i < numFaces; ++i) {\n      decoder.GetFaceFromMesh(dracoGeometry, i, dracoArray);\n      const index = i * 3;\n      indices[index] = dracoArray.GetValue(0);\n      indices[index + 1] = dracoArray.GetValue(1);\n      indices[index + 2] = dracoArray.GetValue(2);\n    }\n\n    this.draco.destroy(dracoArray);\n    return indices;\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   */\n  _getMeshStripIndices(decoder, dracoGeometry) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    /* const numStrips = */ decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n    const indices = new Uint32Array(dracoArray.size());\n    for (let i = 0; i < dracoArray.size(); ++i) {\n      indices[i] = dracoArray.GetValue(i);\n    }\n    this.draco.destroy(dracoArray);\n    return indices;\n  }\n\n  /**\n   *\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   * @param {*} dracoAttribute\n   * @param {*} attributeName\n   */\n  _getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName) {\n    if (dracoAttribute.ptr === 0) {\n      const message = `DRACO decode bad attribute ${attributeName}`;\n      // console.error(message);\n      throw new Error(message);\n    }\n\n    const attributeType = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];\n    const numComponents = dracoAttribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    let dracoArray;\n    let typedArray;\n\n    switch (attributeType) {\n      case Float32Array:\n        dracoArray = new this.draco.DracoFloat32Array();\n        decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Float32Array(numValues);\n        break;\n\n      case Int8Array:\n        dracoArray = new this.draco.DracoInt8Array();\n        decoder.GetAttributeInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int8Array(numValues);\n        break;\n\n      case Int16Array:\n        dracoArray = new this.draco.DracoInt16Array();\n        decoder.GetAttributeInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int16Array(numValues);\n        break;\n\n      case Int32Array:\n        dracoArray = new this.draco.DracoInt32Array();\n        decoder.GetAttributeInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int32Array(numValues);\n        break;\n\n      case Uint8Array:\n        dracoArray = new this.draco.DracoUInt8Array();\n        decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint8Array(numValues);\n        break;\n\n      case Uint16Array:\n        dracoArray = new this.draco.DracoUInt16Array();\n        decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint16Array(numValues);\n        break;\n\n      case Uint32Array:\n        dracoArray = new this.draco.DracoUInt32Array();\n        decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint32Array(numValues);\n        break;\n\n      default:\n        const errorMsg = 'DRACO decoder: unexpected attribute type.';\n        // console.error(errorMsg);\n        throw new Error(errorMsg);\n    }\n\n    // Copy data from decoder.\n    for (let i = 0; i < numValues; i++) {\n      typedArray[i] = dracoArray.GetValue(i);\n    }\n\n    this.draco.destroy(dracoArray);\n\n    return {typedArray, components: numComponents};\n  }\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param {object} attributeData\n   */\n  _deduceAttributeName(attributeData, options) {\n    const {extraAttributes = {}} = options;\n    if (extraAttributes && typeof extraAttributes === 'object') {\n      for (const [attributeName, attributeUniqueId] of Object.entries(extraAttributes)) {\n        if (attributeUniqueId === attributeData.uniqueId) {\n          return attributeName;\n        }\n      }\n    }\n\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeData.attributeType === attributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    if (attributeData.metadata) {\n      const entryName = options.attributeNameEntry || 'name';\n      if (attributeData.metadata[entryName]) {\n        return attributeData.metadata[entryName].string;\n      }\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${attributeData.uniqueId}`;\n  }\n\n  _getGeometryMetadata(decoder, dracoGeometry) {\n    const dracoMetadata = decoder.GetMetadata(dracoGeometry);\n    return this._queryDracoMetadata(dracoMetadata);\n  }\n\n  _getAttributeMetadata(decoder, dracoGeometry, attributeId) {\n    const dracoMetadata = decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._queryDracoMetadata(dracoMetadata);\n  }\n\n  // The not so wonderful world of undocumented Draco APIs :(\n  _queryDracoMetadata(dracoMetadata) {\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray: this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName)\n      };\n    }\n    return result;\n  }\n\n  // DEPRECATED\n\n  decode(arrayBuffer, options) {\n    return this.parseSync(arrayBuffer, options);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}