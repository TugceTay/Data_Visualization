{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { Vector3, Matrix3, Matrix4, degrees } from '@math.gl/core';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { assert } from '@loaders.gl/loader-utils';\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\nvar scratchScale = new Vector3();\nvar scratchNorthWest = new Vector3();\nvar scratchSouthEast = new Vector3();\nvar scratchTransform = new Matrix4();\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n  if (boundingVolumeHeader.region) {\n    var _boundingVolumeHeader = _slicedToArray(boundingVolumeHeader.region, 6),\n      west = _boundingVolumeHeader[0],\n      south = _boundingVolumeHeader[1],\n      east = _boundingVolumeHeader[2],\n      north = _boundingVolumeHeader[3],\n      minHeight = _boundingVolumeHeader[4],\n      maxHeight = _boundingVolumeHeader[5];\n    var northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);\n    var southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);\n    var centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);\n    var radius = new Vector3().subVectors(northWest, southEast).len() / 2.0;\n    return createSphere([centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius], new Matrix4());\n  }\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\nfunction createBox(box, transform, result) {\n  var center = new Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n  var xAxis = transform.transformAsVector(box.slice(3, 6));\n  var yAxis = transform.transformAsVector(box.slice(6, 9));\n  var zAxis = transform.transformAsVector(box.slice(9, 12));\n  var halfAxes = new Matrix3([xAxis[0], xAxis[1], xAxis[2], yAxis[0], yAxis[1], yAxis[2], zAxis[0], zAxis[1], zAxis[2]]);\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n  return new OrientedBoundingBox(center, halfAxes);\n}\nfunction createSphere(sphere, transform, result) {\n  var center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  var scale = transform.getScale(scratchScale);\n  var uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  var radius = sphere[3] * uniformScale;\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n  return new BoundingSphere(center, radius);\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/bounding-volume.js"],"names":["Vector3","Matrix3","Matrix4","degrees","BoundingSphere","OrientedBoundingBox","Ellipsoid","assert","defined","x","undefined","scratchScale","scratchNorthWest","scratchSouthEast","scratchTransform","createBoundingVolume","boundingVolumeHeader","transform","result","box","createBox","region","west","south","east","north","minHeight","maxHeight","northWest","WGS84","cartographicToCartesian","southEast","centerInCartesian","addVectors","multiplyScalar","radius","subVectors","len","createSphere","sphere","Error","center","xAxis","transformAsVector","slice","yAxis","zAxis","halfAxes","scale","getScale","uniformScale","Math","max"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, Matrix3, Matrix4, degrees} from '@math.gl/core';\nimport {BoundingSphere, OrientedBoundingBox} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {assert} from '@loaders.gl/loader-utils';\n\n// const scratchProjectedBoundingSphere = new BoundingSphere();\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n// const scratchMatrix = new Matrix3();\nconst scratchScale = new Vector3();\nconst scratchNorthWest = new Vector3();\nconst scratchSouthEast = new Vector3();\n// const scratchRectangle = new Rectangle();\n// const scratchOrientedBoundingBox = new OrientedBoundingBox();\nconst scratchTransform = new Matrix4();\n\n/**\n * Create a bounding volume from the tile's bounding volume header.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {Matrix4} transform The transform to apply to the bounding volume.\n * @param [result] The object onto which to store the result.\n * @returns The modified result parameter or a new TileBoundingVolume instance if none was provided.\n */\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n\n  // boundingVolume schema:\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n  if (boundingVolumeHeader.region) {\n    // [west, south, east, north, minimum height, maximum height]\n    // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n    // Heights are in meters above (or below) the WGS 84 ellipsoid.\n    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;\n\n    const northWest = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(west), degrees(north), minHeight],\n      scratchNorthWest\n    );\n    const southEast = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(east), degrees(south), maxHeight],\n      scratchSouthEast\n    );\n    const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);\n    const radius = new Vector3().subVectors(northWest, southEast).len() / 2.0;\n\n    // TODO improve region boundingVolume\n    // for now, create a sphere as the boundingVolume instead of box\n    return createSphere(\n      [centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius],\n      new Matrix4()\n    );\n  }\n\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n\nfunction createBox(box, transform, result) {\n  // box: An array of 12 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box.\n  // The next three elements (with indices 3, 4, and 5) define the x axis direction and half-length.\n  // The next three elements (indices 6, 7, and 8) define the y axis direction and half-length.\n  // The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.\n  const center = new Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n\n  const xAxis = transform.transformAsVector(box.slice(3, 6));\n  const yAxis = transform.transformAsVector(box.slice(6, 9));\n  const zAxis = transform.transformAsVector(box.slice(9, 12));\n  const halfAxes = new Matrix3([\n    xAxis[0],\n    xAxis[1],\n    xAxis[2],\n    yAxis[0],\n    yAxis[1],\n    yAxis[2],\n    zAxis[0],\n    zAxis[1],\n    zAxis[2]\n  ]);\n\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n\n  return new OrientedBoundingBox(center, halfAxes);\n}\n\n/*\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  const minimumHeight = region[4];\n  const maximumHeight = region[5];\n\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    Ellipsoid.WGS84,\n    scratchOrientedBoundingBox\n  );\n  const center = orientedBoundingBox.center;\n  const halfAxes = orientedBoundingBox.halfAxes;\n\n  // A region bounding volume is not transformed by the transform in the tileset JSON,\n  // but may be transformed by additional transforms applied in Cesium.\n  // This is why the transform is calculated as the difference between the initial transform and the current transform.\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.inverseTransformation(initialTransform, scratchTransform),\n    scratchTransform\n  );\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getRotation(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n*/\n\nfunction createSphere(sphere, transform, result) {\n  // Find the transformed center\n  const center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  const scale = transform.getScale(scratchScale);\n\n  const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  const radius = sphere[3] * uniformScale;\n\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n\n  return new BoundingSphere(center, radius);\n}\n"]},"metadata":{},"sourceType":"module"}