{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\nfunction noop() {}\nvar DracoBuilder = function () {\n  function DracoBuilder(draco) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, DracoBuilder);\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n    this.log = options.log || noop;\n  }\n  _createClass(DracoBuilder, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.destroyEncodedObject(this.dracoMeshBuilder);\n      this.destroyEncodedObject(this.dracoEncoder);\n      this.destroyEncodedObject(this.dracoMetadataBuilder);\n      this.dracoMeshBuilder = null;\n      this.dracoEncoder = null;\n      this.draco = null;\n    }\n  }, {\n    key: \"destroyEncodedObject\",\n    value: function destroyEncodedObject(object) {\n      if (object) {\n        this.draco.destroy(object);\n      }\n    }\n  }, {\n    key: \"encodeSync\",\n    value: function encodeSync(mesh) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this._setOptions(options);\n      return options.pointcloud ? this._encodePointCloud(mesh, options) : this._encodeMesh(mesh, options);\n    }\n  }, {\n    key: \"_getAttributesFromMesh\",\n    value: function _getAttributesFromMesh(mesh) {\n      var attributes = _objectSpread(_objectSpread({}, mesh), mesh.attributes);\n      if (mesh.indices) {\n        attributes.indices = mesh.indices;\n      }\n      return attributes;\n    }\n  }, {\n    key: \"_encodePointCloud\",\n    value: function _encodePointCloud(pointcloud, options) {\n      var dracoPointCloud = new this.draco.PointCloud();\n      if (options.metadata) {\n        this._addGeometryMetadata(dracoPointCloud, options.metadata);\n      }\n      var attributes = this._getAttributesFromMesh(pointcloud);\n      this._createDracoPointCloud(dracoPointCloud, attributes, options);\n      var dracoData = new this.draco.DracoInt8Array();\n      try {\n        var encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(dracoPointCloud, false, dracoData);\n        if (!(encodedLen > 0)) {\n          throw new Error('Draco encoding failed.');\n        }\n        this.log(\"DRACO encoded \".concat(dracoPointCloud.num_points(), \" points\\n        with \").concat(dracoPointCloud.num_attributes(), \" attributes into \").concat(encodedLen, \" bytes\"));\n        return dracoInt8ArrayToArrayBuffer(dracoData);\n      } finally {\n        this.destroyEncodedObject(dracoData);\n        this.destroyEncodedObject(dracoPointCloud);\n      }\n    }\n  }, {\n    key: \"_encodeMesh\",\n    value: function _encodeMesh(mesh, options) {\n      var dracoMesh = new this.draco.Mesh();\n      if (options.metadata) {\n        this._addGeometryMetadata(dracoMesh, options.metadata);\n      }\n      var attributes = this._getAttributesFromMesh(mesh);\n      this._createDracoMesh(dracoMesh, attributes, options);\n      var dracoData = new this.draco.DracoInt8Array();\n      try {\n        var encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n        if (encodedLen <= 0) {\n          throw new Error('Draco encoding failed.');\n        }\n        this.log(\"DRACO encoded \".concat(dracoMesh.num_points(), \" points\\n        with \").concat(dracoMesh.num_attributes(), \" attributes into \").concat(encodedLen, \" bytes\"));\n        return dracoInt8ArrayToArrayBuffer(dracoData);\n      } finally {\n        this.destroyEncodedObject(dracoData);\n        this.destroyEncodedObject(dracoMesh);\n      }\n    }\n  }, {\n    key: \"_setOptions\",\n    value: function _setOptions(options) {\n      if ('speed' in options) {\n        var _this$dracoEncoder;\n        (_this$dracoEncoder = this.dracoEncoder).SetSpeedOptions.apply(_this$dracoEncoder, _toConsumableArray(options.speed));\n      }\n      if ('method' in options) {\n        var dracoMethod = this.draco[options.method];\n        this.dracoEncoder.SetEncodingMethod(dracoMethod);\n      }\n      if ('quantization' in options) {\n        for (var attribute in options.quantization) {\n          var bits = options.quantization[attribute];\n          var dracoPosition = this.draco[attribute];\n          this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n        }\n      }\n    }\n  }, {\n    key: \"_createDracoMesh\",\n    value: function _createDracoMesh(dracoMesh, attributes, options) {\n      var optionalMetadata = options.attributesMetadata || {};\n      try {\n        var positions = this._getPositionAttribute(attributes);\n        if (!positions) {\n          throw new Error('positions');\n        }\n        var vertexCount = positions.length / 3;\n        for (var attributeName in attributes) {\n          var attribute = attributes[attributeName];\n          attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n          var uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n          if (uniqueId !== -1) {\n            this._addAttributeMetadata(dracoMesh, uniqueId, _objectSpread({\n              name: attributeName\n            }, optionalMetadata[attributeName] || {}));\n          }\n        }\n      } catch (error) {\n        this.destroyEncodedObject(dracoMesh);\n        throw error;\n      }\n      return dracoMesh;\n    }\n  }, {\n    key: \"_createDracoPointCloud\",\n    value: function _createDracoPointCloud(dracoPointCloud, attributes, options) {\n      var optionalMetadata = options.attributesMetadata || {};\n      try {\n        var positions = this._getPositionAttribute(attributes);\n        if (!positions) {\n          throw new Error('positions');\n        }\n        var vertexCount = positions.length / 3;\n        for (var attributeName in attributes) {\n          var attribute = attributes[attributeName];\n          attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n          var uniqueId = this._addAttributeToMesh(dracoPointCloud, attributeName, attribute, vertexCount);\n          if (uniqueId !== -1) {\n            this._addAttributeMetadata(dracoPointCloud, uniqueId, _objectSpread({\n              name: attributeName\n            }, optionalMetadata[attributeName] || {}));\n          }\n        }\n      } catch (error) {\n        this.destroyEncodedObject(dracoPointCloud);\n        throw error;\n      }\n      return dracoPointCloud;\n    }\n  }, {\n    key: \"_addAttributeToMesh\",\n    value: function _addAttributeToMesh(mesh, attributeName, attribute, vertexCount) {\n      if (!ArrayBuffer.isView(attribute)) {\n        return -1;\n      }\n      var type = this._getDracoAttributeType(attributeName);\n      var size = attribute.length / vertexCount;\n      if (type === 'indices') {\n        var numFaces = attribute.length / 3;\n        this.log(\"Adding attribute \".concat(attributeName, \", size \").concat(numFaces));\n        this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n        return -1;\n      }\n      this.log(\"Adding attribute \".concat(attributeName, \", size \").concat(size));\n      var builder = this.dracoMeshBuilder;\n      var buffer = attribute.buffer;\n      switch (attribute.constructor) {\n        case Int8Array:\n          return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n        case Int16Array:\n          return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n        case Int32Array:\n          return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n        case Uint8Array:\n        case Uint8ClampedArray:\n          return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n        case Uint16Array:\n          return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n        case Uint32Array:\n          return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n        case Float32Array:\n        default:\n          return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n      }\n    }\n  }, {\n    key: \"_getDracoAttributeType\",\n    value: function _getDracoAttributeType(attributeName) {\n      switch (attributeName.toLowerCase()) {\n        case 'indices':\n          return 'indices';\n        case 'position':\n        case 'positions':\n        case 'vertices':\n          return this.draco.POSITION;\n        case 'normal':\n        case 'normals':\n          return this.draco.NORMAL;\n        case 'color':\n        case 'colors':\n          return this.draco.COLOR;\n        case 'texCoord':\n        case 'texCoords':\n          return this.draco.TEX_COORD;\n        default:\n          return this.draco.GENERIC;\n      }\n    }\n  }, {\n    key: \"_getPositionAttribute\",\n    value: function _getPositionAttribute(attributes) {\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        var dracoType = this._getDracoAttributeType(attributeName);\n        if (dracoType === this.draco.POSITION) {\n          return attribute;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_addGeometryMetadata\",\n    value: function _addGeometryMetadata(dracoGeometry, metadata) {\n      var dracoMetadata = new this.draco.Metadata();\n      this._populateDracoMetadata(dracoMetadata, metadata);\n      this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n    }\n  }, {\n    key: \"_addAttributeMetadata\",\n    value: function _addAttributeMetadata(dracoGeometry, uniqueAttributeId, metadata) {\n      var dracoAttributeMetadata = new this.draco.Metadata();\n      this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n      this.dracoMeshBuilder.SetMetadataForAttribute(dracoGeometry, uniqueAttributeId, dracoAttributeMetadata);\n    }\n  }, {\n    key: \"_populateDracoMetadata\",\n    value: function _populateDracoMetadata(dracoMetadata, metadata) {\n      var _iterator = _createForOfIteratorHelper(getEntries(metadata)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            value = _step$value[1];\n          switch (_typeof(value)) {\n            case 'number':\n              if (Math.trunc(value) === value) {\n                this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n              } else {\n                this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n              }\n              break;\n            case 'string':\n            default:\n              this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n  return DracoBuilder;\n}();\nexport { DracoBuilder as default };\nfunction dracoInt8ArrayToArrayBuffer(dracoData) {\n  var byteLength = dracoData.size();\n  var outputBuffer = new ArrayBuffer(byteLength);\n  var outputData = new Int8Array(outputBuffer);\n  for (var i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n  return outputBuffer;\n}\nfunction getEntries(container) {\n  var hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n  return hasEntriesFunc ? container.entries() : Object.entries(container);\n}","map":{"version":3,"sources":["../../../src/lib/draco-builder.js"],"names":["GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","noop","DracoBuilder","draco","options","dracoEncoder","Encoder","dracoMeshBuilder","MeshBuilder","dracoMetadataBuilder","MetadataBuilder","log","destroyEncodedObject","object","destroy","mesh","_setOptions","pointcloud","_encodePointCloud","_encodeMesh","attributes","indices","dracoPointCloud","PointCloud","metadata","_addGeometryMetadata","_getAttributesFromMesh","_createDracoPointCloud","dracoData","DracoInt8Array","encodedLen","EncodePointCloudToDracoBuffer","Error","num_points","num_attributes","dracoInt8ArrayToArrayBuffer","dracoMesh","Mesh","_createDracoMesh","EncodeMeshToDracoBuffer","SetSpeedOptions","speed","dracoMethod","method","SetEncodingMethod","attribute","quantization","bits","dracoPosition","SetAttributeQuantization","optionalMetadata","attributesMetadata","positions","_getPositionAttribute","vertexCount","length","attributeName","uniqueId","_addAttributeToMesh","_addAttributeMetadata","name","error","ArrayBuffer","isView","type","_getDracoAttributeType","size","numFaces","AddFacesToMesh","builder","buffer","constructor","Int8Array","AddInt8Attribute","Int16Array","AddInt16Attribute","Int32Array","AddInt32Attribute","Uint8Array","Uint8ClampedArray","AddUInt8Attribute","Uint16Array","AddUInt16Attribute","Uint32Array","AddUInt32Attribute","Float32Array","AddFloatAttribute","toLowerCase","COLOR","TEX_COORD","GENERIC","dracoType","dracoGeometry","dracoMetadata","Metadata","_populateDracoMetadata","AddMetadata","uniqueAttributeId","dracoAttributeMetadata","SetMetadataForAttribute","key","value","getEntries","Math","trunc","AddIntEntry","AddDoubleEntry","AddStringEntry","byteLength","outputBuffer","outputData","i","GetValue","container","hasEntriesFunc","entries","hasOwnProperty","Object"],"mappings":"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","sourcesContent":["// This code is inspired by example code in the DRACO repository\n/** @typedef {import('../types/draco-types')} Draco3D */\n/** @typedef {import('../types/draco-types').TypedArray} TypedArray */\n/** @typedef {import('../types/draco-types').DracoInt8Array} DracoInt8Array */\n/** @typedef {import('../types/draco-types').Encoder} Encoder */\n/** @typedef {import('../types/draco-types').Mesh} Mesh */\n/** @typedef {import('../types/draco-types').PointCloud} PointCloud */\n/** @typedef {import('../types/draco-types').Metadata} Metadata */\n/** @typedef {import('../types/draco-types').PointCloudBuilder} PointCloudBuilder */\n/** @typedef {import('../types/draco-types').MetadataBuilder} MetadataBuilder */\n\n// Native Draco attribute names to GLTF attribute names.\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\n\nfunction noop() {}\n\nexport default class DracoBuilder {\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco, options = {}) {\n    /** @type {Draco3D} */\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n    this.log = options.log || noop;\n  }\n\n  destroy() {\n    this.destroyEncodedObject(this.dracoMeshBuilder);\n    this.destroyEncodedObject(this.dracoEncoder);\n    this.destroyEncodedObject(this.dracoMetadataBuilder);\n    // @ts-ignore\n    this.dracoMeshBuilder = null;\n    // @ts-ignore\n    this.dracoEncoder = null;\n    // @ts-ignore\n    this.draco = null;\n  }\n\n  // TBD - when does this need to be called?\n  destroyEncodedObject(object) {\n    if (object) {\n      this.draco.destroy(object);\n    }\n  }\n\n  // Encode mesh=({})\n  encodeSync(mesh, options = {}) {\n    this._setOptions(options);\n\n    return options.pointcloud\n      ? this._encodePointCloud(mesh, options)\n      : this._encodeMesh(mesh, options);\n  }\n\n  // PRIVATE\n\n  _getAttributesFromMesh(mesh) {\n    // TODO - Change the encodePointCloud interface instead?\n    const attributes = {...mesh, ...mesh.attributes};\n    // Fold indices into the attributes\n    if (mesh.indices) {\n      attributes.indices = mesh.indices;\n    }\n    return attributes;\n  }\n\n  _encodePointCloud(pointcloud, options) {\n    const dracoPointCloud = new this.draco.PointCloud();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoPointCloud, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(pointcloud);\n\n    // Build a `DracoPointCloud` from the input data\n    this._createDracoPointCloud(dracoPointCloud, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(\n        dracoPointCloud,\n        false,\n        dracoData\n      );\n\n      if (!(encodedLen > 0)) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoPointCloud.num_points()} points\n        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoPointCloud);\n    }\n  }\n\n  _encodeMesh(mesh, options) {\n    const dracoMesh = new this.draco.Mesh();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoMesh, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(mesh);\n\n    // Build a `DracoMesh` from the input data\n    this._createDracoMesh(dracoMesh, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n      if (encodedLen <= 0) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoMesh.num_points()} points\n        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoMesh);\n    }\n  }\n\n  /**\n   * Set encoding options.\n   * @param {{speed?: any; method?: any; quantization?: any;}} options\n   */\n  _setOptions(options) {\n    if ('speed' in options) {\n      // @ts-ignore\n      this.dracoEncoder.SetSpeedOptions(...options.speed);\n    }\n    if ('method' in options) {\n      const dracoMethod = this.draco[options.method];\n      // assert(dracoMethod)\n      this.dracoEncoder.SetEncodingMethod(dracoMethod);\n    }\n    if ('quantization' in options) {\n      for (const attribute in options.quantization) {\n        const bits = options.quantization[attribute];\n        const dracoPosition = this.draco[attribute];\n        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n      }\n    }\n  }\n\n  /**\n   * @param {Mesh} dracoMesh\n   * @param {object} attributes\n   * @returns {Mesh}\n   */\n  _createDracoMesh(dracoMesh, attributes, options) {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoMesh, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoMesh);\n      throw error;\n    }\n\n    return dracoMesh;\n  }\n\n  /**\n   * @param {PointCloud} dracoPointCloud\n   * @param {object} attributes\n   * @returns {PointCloud}\n   */\n  _createDracoPointCloud(dracoPointCloud, attributes, options) {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(\n          dracoPointCloud,\n          attributeName,\n          attribute,\n          vertexCount\n        );\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoPointCloud);\n      throw error;\n    }\n\n    return dracoPointCloud;\n  }\n\n  /**\n   * @param {PointCloud} mesh\n   * @param {string} attributeName\n   * @param {TypedArray} attribute\n   * @param {number} vertexCount\n   */\n  _addAttributeToMesh(mesh, attributeName, attribute, vertexCount) {\n    if (!ArrayBuffer.isView(attribute)) {\n      return -1;\n    }\n\n    const type = this._getDracoAttributeType(attributeName);\n    // @ts-ignore TODO/fix types\n    const size = attribute.length / vertexCount;\n\n    if (type === 'indices') {\n      // @ts-ignore TODO/fix types\n      const numFaces = attribute.length / 3;\n      this.log(`Adding attribute ${attributeName}, size ${numFaces}`);\n\n      // @ts-ignore assumes mesh is a Mesh, not a point cloud\n      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n      return -1;\n    }\n\n    this.log(`Adding attribute ${attributeName}, size ${size}`);\n\n    const builder = this.dracoMeshBuilder;\n    const {buffer} = attribute;\n\n    switch (attribute.constructor) {\n      case Int8Array:\n        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n\n      case Int16Array:\n        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n\n      case Int32Array:\n        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n      case Uint8Array:\n      case Uint8ClampedArray:\n        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n\n      case Uint16Array:\n        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n\n      case Uint32Array:\n        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n\n      case Float32Array:\n      default:\n        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n    }\n  }\n\n  /**\n   * DRACO can compress attributes of know type better\n   * TODO - expose an attribute type map?\n   * @param {*} attributeName\n   */\n  _getDracoAttributeType(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'indices':\n        return 'indices';\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return this.draco.POSITION;\n      case 'normal':\n      case 'normals':\n        return this.draco.NORMAL;\n      case 'color':\n      case 'colors':\n        return this.draco.COLOR;\n      case 'texCoord':\n      case 'texCoords':\n        return this.draco.TEX_COORD;\n      default:\n        return this.draco.GENERIC;\n    }\n  }\n\n  _getPositionAttribute(attributes) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const dracoType = this._getDracoAttributeType(attributeName);\n      if (dracoType === this.draco.POSITION) {\n        return attribute;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add metadata for the geometry.\n   * @param {PointCloud} dracoGeometry - WASM Draco Object\n   * @param {Map<string, string>|{[key: string]: string}} metadata\n   */\n  _addGeometryMetadata(dracoGeometry, metadata) {\n    const dracoMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoMetadata, metadata);\n    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n  }\n\n  /**\n   * Add metadata for an attribute to geometry.\n   * @param {PointCloud} dracoGeometry - WASM Draco Object\n   * @param {number} uniqueAttributeId\n   * @param {Map<string, string>|{[key: string]: string}} metadata\n   */\n  _addAttributeMetadata(dracoGeometry, uniqueAttributeId, metadata) {\n    // Note: Draco JS IDL doesn't seem to expose draco.AttributeMetadata, however it seems to\n    // create such objects automatically from draco.Metadata object.\n    const dracoAttributeMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n    // Draco3d doc note: Directly add attribute metadata to geometry.\n    // You can do this without explicitly adding |GeometryMetadata| to mesh.\n    this.dracoMeshBuilder.SetMetadataForAttribute(\n      dracoGeometry,\n      uniqueAttributeId,\n      dracoAttributeMetadata\n    );\n  }\n\n  /**\n   * Add contents of object or map to a WASM Draco Metadata Object\n   * @param {Metadata} dracoMetadata - WASM Draco Object\n   * @param {Map<string, string>|{[key: string]: string}} metadata\n   */\n  _populateDracoMetadata(dracoMetadata, metadata) {\n    for (const [key, value] of getEntries(metadata)) {\n      switch (typeof value) {\n        case 'number':\n          if (Math.trunc(value) === value) {\n            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n          } else {\n            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n          }\n          break;\n        case 'string':\n        default:\n          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n      }\n    }\n  }\n}\n\n// HELPER FUNCTIONS\n\n/**\n * Copy encoded data to buffer\n * @param {DracoInt8Array} dracoData\n */\nfunction dracoInt8ArrayToArrayBuffer(dracoData) {\n  const byteLength = dracoData.size();\n  const outputBuffer = new ArrayBuffer(byteLength);\n  const outputData = new Int8Array(outputBuffer);\n  for (let i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n  return outputBuffer;\n}\n\n/** Enable iteration over either an object or a map */\nfunction getEntries(container) {\n  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n  return hasEntriesFunc ? container.entries() : Object.entries(container);\n}\n"]},"metadata":{},"sourceType":"module"}