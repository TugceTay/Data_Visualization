{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.scenegraphVisConfigs = exports.scenegraphPosAccessor = exports.scenegraphOptionalColumns = exports.scenegraphRequiredColumns = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _meshLayers = require(\"@deck.gl/mesh-layers\");\nvar _core = require(\"@loaders.gl/core\");\nvar _gltf = require(\"@loaders.gl/gltf\");\nvar _baseLayer = _interopRequireDefault(require(\"../base-layer\"));\nvar _scenegraphLayerIcon = _interopRequireDefault(require(\"./scenegraph-layer-icon\"));\nvar _scenegraphInfoModal = _interopRequireDefault(require(\"./scenegraph-info-modal\"));\nvar _layerFactory = require(\"../layer-factory\");\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar scenegraphRequiredColumns = ['lat', 'lng'];\nexports.scenegraphRequiredColumns = scenegraphRequiredColumns;\nvar scenegraphOptionalColumns = ['altitude'];\nexports.scenegraphOptionalColumns = scenegraphOptionalColumns;\nfunction fetch(url, _ref) {\n  var propName = _ref.propName,\n    layer = _ref.layer;\n  if (propName === 'scenegraph') {\n    return (0, _core.load)(url, _gltf.GLTFLoader, layer.getLoadOptions());\n  }\n  return fetch(url).then(function (response) {\n    return response.json();\n  });\n}\nvar scenegraphPosAccessor = function scenegraphPosAccessor(_ref2) {\n  var lat = _ref2.lat,\n    lng = _ref2.lng,\n    altitude = _ref2.altitude;\n  return function (dc) {\n    return function (d) {\n      return [dc.valueAt(d.index, lng.fieldIdx), dc.valueAt(d.index, lat.fieldIdx), altitude && altitude.fieldIdx > -1 ? dc.valueAt(d.index, altitude.fieldIdx) : 0];\n    };\n  };\n};\nexports.scenegraphPosAccessor = scenegraphPosAccessor;\nvar scenegraphVisConfigs = {\n  opacity: 'opacity',\n  colorRange: 'colorRange',\n  //\n  sizeScale: 'sizeScale',\n  angleX: _objectSpread(_objectSpread({}, _layerFactory.LAYER_VIS_CONFIGS.angle), {}, {\n    property: 'angleX',\n    label: 'angle X'\n  }),\n  angleY: _objectSpread(_objectSpread({}, _layerFactory.LAYER_VIS_CONFIGS.angle), {}, {\n    property: 'angleY',\n    label: 'angle Y'\n  }),\n  angleZ: _objectSpread(_objectSpread({}, _layerFactory.LAYER_VIS_CONFIGS.angle), {}, {\n    property: 'angleZ',\n    defaultValue: 90,\n    label: 'angle Z'\n  })\n};\nexports.scenegraphVisConfigs = scenegraphVisConfigs;\nvar DEFAULT_MODEL = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb';\nvar DEFAULT_TRANSITION = [0, 0, 0];\nvar DEFAULT_SCALE = [1, 1, 1];\nvar DEFAULT_COLOR = [255, 255, 255, 255];\nvar ScenegraphLayer = /*#__PURE__*/function (_Layer) {\n  (0, _inherits2[\"default\"])(ScenegraphLayer, _Layer);\n  var _super = _createSuper(ScenegraphLayer);\n  function ScenegraphLayer(props) {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, ScenegraphLayer);\n    _this = _super.call(this, props);\n    _this.registerVisConfig(scenegraphVisConfigs);\n    _this.getPositionAccessor = function (dataContainer) {\n      return scenegraphPosAccessor(_this.config.columns)(dataContainer);\n    }; // prepare layer info modal\n\n    _this._layerInfoModal = (0, _scenegraphInfoModal[\"default\"])();\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(ScenegraphLayer, [{\n    key: \"type\",\n    get: function get() {\n      return '3D';\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return scenegraphRequiredColumns;\n    }\n  }, {\n    key: \"optionalColumns\",\n    get: function get() {\n      return scenegraphOptionalColumns;\n    }\n  }, {\n    key: \"columnPairs\",\n    get: function get() {\n      return this.defaultPointColumnPairs;\n    }\n  }, {\n    key: \"layerIcon\",\n    get: function get() {\n      return _scenegraphLayerIcon[\"default\"];\n    }\n  }, {\n    key: \"layerInfoModal\",\n    get: function get() {\n      return {\n        id: 'scenegraphInfo',\n        template: this._layerInfoModal,\n        modalProps: {\n          title: 'How to use Scenegraph'\n        }\n      };\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(_ref3, getPosition) {\n      var dataContainer = _ref3.dataContainer,\n        filteredIndex = _ref3.filteredIndex;\n      var data = [];\n      for (var i = 0; i < filteredIndex.length; i++) {\n        var index = filteredIndex[i];\n        var pos = getPosition({\n          index: index\n        }); // if doesn't have point lat or lng, do not add the point\n        // deck.gl can't handle position = null\n\n        if (pos.every(Number.isFinite)) {\n          data.push({\n            position: pos,\n            index: index\n          });\n        }\n      }\n      return data;\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, oldLayerData) {\n      var _datasets$this$config = datasets[this.config.dataId],\n        gpuFilter = _datasets$this$config.gpuFilter,\n        dataContainer = _datasets$this$config.dataContainer;\n      var _this$updateData = this.updateData(datasets, oldLayerData),\n        data = _this$updateData.data;\n      var getPosition = this.getPositionAccessor(dataContainer);\n      return {\n        data: data,\n        getPosition: getPosition,\n        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)()\n      };\n    }\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer, getPosition) {\n      var bounds = this.getPointsBounds(dataContainer, getPosition);\n      this.updateMeta({\n        bounds: bounds\n      });\n    }\n  }, {\n    key: \"renderLayer\",\n    value: function renderLayer(opts) {\n      var data = opts.data,\n        gpuFilter = opts.gpuFilter;\n      var _this$config$visConfi = this.config.visConfig,\n        _this$config$visConfi2 = _this$config$visConfi.sizeScale,\n        sizeScale = _this$config$visConfi2 === void 0 ? 1 : _this$config$visConfi2,\n        _this$config$visConfi3 = _this$config$visConfi.angleX,\n        angleX = _this$config$visConfi3 === void 0 ? 0 : _this$config$visConfi3,\n        _this$config$visConfi4 = _this$config$visConfi.angleY,\n        angleY = _this$config$visConfi4 === void 0 ? 0 : _this$config$visConfi4,\n        _this$config$visConfi5 = _this$config$visConfi.angleZ,\n        angleZ = _this$config$visConfi5 === void 0 ? 90 : _this$config$visConfi5;\n      return [new _meshLayers.ScenegraphLayer(_objectSpread(_objectSpread(_objectSpread({}, this.getDefaultDeckLayerProps(opts)), data), {}, {\n        fetch: fetch,\n        scenegraph: this.config.visConfig.scenegraph || DEFAULT_MODEL,\n        sizeScale: sizeScale,\n        getTranslation: DEFAULT_TRANSITION,\n        getScale: DEFAULT_SCALE,\n        getOrientation: [angleX, angleY, angleZ],\n        getColor: DEFAULT_COLOR,\n        // parameters\n        parameters: {\n          depthTest: true,\n          blend: false\n        },\n        // update triggers\n        updateTriggers: {\n          getOrientation: {\n            angleX: angleX,\n            angleY: angleY,\n            angleZ: angleZ\n          },\n          getPosition: this.config.columns,\n          getFilterValue: gpuFilter.filterValueUpdateTriggers\n        }\n      }))];\n    }\n  }]);\n  return ScenegraphLayer;\n}(_baseLayer[\"default\"]);\nexports[\"default\"] = ScenegraphLayer;","map":{"version":3,"sources":["../../../src/layers/scenegraph-layer/scenegraph-layer.js"],"names":["scenegraphRequiredColumns","scenegraphOptionalColumns","fetch","url","propName","layer","GLTFLoader","getLoadOptions","then","response","json","scenegraphPosAccessor","lat","lng","altitude","dc","valueAt","d","index","fieldIdx","scenegraphVisConfigs","opacity","colorRange","sizeScale","angleX","LAYER_VIS_CONFIGS","angle","property","label","angleY","angleZ","defaultValue","DEFAULT_MODEL","DEFAULT_TRANSITION","DEFAULT_SCALE","DEFAULT_COLOR","ScenegraphLayer","Layer","props","registerVisConfig","getPositionAccessor","config","columns","dataContainer","_layerInfoModal","defaultPointColumnPairs","ScenegraphLayerIcon","id","template","modalProps","title","filteredIndex","getPosition","data","i","length","pos","every","Number","isFinite","push","position","datasets","oldLayerData","gpuFilter","dataId","updateData","getFilterValue","filterValueAccessor","bounds","getPointsBounds","updateMeta","opts","visConfig","DeckScenegraphLayer","getDefaultDeckLayerProps","scenegraph","getTranslation","getScale","getOrientation","getColor","parameters","depthTest","blend","updateTriggers","filterValueUpdateTriggers"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {ScenegraphLayer as DeckScenegraphLayer} from '@deck.gl/mesh-layers';\nimport {load} from '@loaders.gl/core';\nimport {GLTFLoader} from '@loaders.gl/gltf';\n\nimport Layer from '../base-layer';\nimport ScenegraphLayerIcon from './scenegraph-layer-icon';\nimport ScenegraphInfoModalFactory from './scenegraph-info-modal';\nimport {LAYER_VIS_CONFIGS} from 'layers/layer-factory';\n\nexport const scenegraphRequiredColumns = ['lat', 'lng'];\nexport const scenegraphOptionalColumns = ['altitude'];\n\nfunction fetch(url, {propName, layer}) {\n  if (propName === 'scenegraph') {\n    return load(url, GLTFLoader, layer.getLoadOptions());\n  }\n\n  return fetch(url).then(response => response.json());\n}\n\nexport const scenegraphPosAccessor = ({lat, lng, altitude}) => dc => d => [\n  dc.valueAt(d.index, lng.fieldIdx),\n  dc.valueAt(d.index, lat.fieldIdx),\n  altitude && altitude.fieldIdx > -1 ? dc.valueAt(d.index, altitude.fieldIdx) : 0\n];\n\nexport const scenegraphVisConfigs = {\n  opacity: 'opacity',\n  colorRange: 'colorRange',\n  //\n  sizeScale: 'sizeScale',\n  angleX: {\n    ...LAYER_VIS_CONFIGS.angle,\n    property: 'angleX',\n    label: 'angle X'\n  },\n  angleY: {\n    ...LAYER_VIS_CONFIGS.angle,\n    property: 'angleY',\n    label: 'angle Y'\n  },\n  angleZ: {\n    ...LAYER_VIS_CONFIGS.angle,\n    property: 'angleZ',\n    defaultValue: 90,\n    label: 'angle Z'\n  }\n};\n\nconst DEFAULT_MODEL =\n  'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb';\nconst DEFAULT_TRANSITION = [0, 0, 0];\nconst DEFAULT_SCALE = [1, 1, 1];\nconst DEFAULT_COLOR = [255, 255, 255, 255];\n\nexport default class ScenegraphLayer extends Layer {\n  constructor(props) {\n    super(props);\n\n    this.registerVisConfig(scenegraphVisConfigs);\n    this.getPositionAccessor = dataContainer =>\n      scenegraphPosAccessor(this.config.columns)(dataContainer);\n\n    // prepare layer info modal\n    this._layerInfoModal = ScenegraphInfoModalFactory();\n  }\n\n  get type() {\n    return '3D';\n  }\n\n  get requiredLayerColumns() {\n    return scenegraphRequiredColumns;\n  }\n\n  get optionalColumns() {\n    return scenegraphOptionalColumns;\n  }\n\n  get columnPairs() {\n    return this.defaultPointColumnPairs;\n  }\n\n  get layerIcon() {\n    return ScenegraphLayerIcon;\n  }\n\n  get layerInfoModal() {\n    return {\n      id: 'scenegraphInfo',\n      template: this._layerInfoModal,\n      modalProps: {\n        title: 'How to use Scenegraph'\n      }\n    };\n  }\n\n  calculateDataAttribute({dataContainer, filteredIndex}, getPosition) {\n    const data = [];\n\n    for (let i = 0; i < filteredIndex.length; i++) {\n      const index = filteredIndex[i];\n      const pos = getPosition({index});\n\n      // if doesn't have point lat or lng, do not add the point\n      // deck.gl can't handle position = null\n      if (pos.every(Number.isFinite)) {\n        data.push({\n          position: pos,\n          index\n        });\n      }\n    }\n    return data;\n  }\n\n  formatLayerData(datasets, oldLayerData) {\n    const {gpuFilter, dataContainer} = datasets[this.config.dataId];\n    const {data} = this.updateData(datasets, oldLayerData);\n    const getPosition = this.getPositionAccessor(dataContainer);\n    return {\n      data,\n      getPosition,\n      getFilterValue: gpuFilter.filterValueAccessor(dataContainer)()\n    };\n  }\n\n  updateLayerMeta(dataContainer, getPosition) {\n    const bounds = this.getPointsBounds(dataContainer, getPosition);\n    this.updateMeta({bounds});\n  }\n\n  renderLayer(opts) {\n    const {data, gpuFilter} = opts;\n\n    const {\n      visConfig: {sizeScale = 1, angleX = 0, angleY = 0, angleZ = 90}\n    } = this.config;\n\n    return [\n      new DeckScenegraphLayer({\n        ...this.getDefaultDeckLayerProps(opts),\n        ...data,\n        fetch,\n        scenegraph: this.config.visConfig.scenegraph || DEFAULT_MODEL,\n        sizeScale,\n        getTranslation: DEFAULT_TRANSITION,\n        getScale: DEFAULT_SCALE,\n        getOrientation: [angleX, angleY, angleZ],\n        getColor: DEFAULT_COLOR,\n        // parameters\n        parameters: {depthTest: true, blend: false},\n        // update triggers\n        updateTriggers: {\n          getOrientation: {angleX, angleY, angleZ},\n          getPosition: this.config.columns,\n          getFilterValue: gpuFilter.filterValueUpdateTriggers\n        }\n      })\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}