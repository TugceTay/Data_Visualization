{"ast":null,"code":"import { decomposeCompositeGLType } from '../webgl-utils/attribute-utils';\nimport { assert } from '../utils/assert';\nconst ERR_ARGUMENT = 'UniformBufferLayout illegal argument';\nconst GL_FLOAT = 0x1406;\nconst GL_INT = 0x1404;\nconst GL_UNSIGNED_INT = 0x1405;\nexport default class UniformBufferLayout {\n  constructor(layout) {\n    this.layout = {};\n    this.size = 0;\n    for (const key in layout) {\n      this._addUniform(key, layout[key]);\n    }\n    this.size += (4 - this.size % 4) % 4;\n    const data = new Float32Array(this.size);\n    this.typedArray = {\n      [GL_FLOAT]: data,\n      [GL_INT]: new Int32Array(data.buffer),\n      [GL_UNSIGNED_INT]: new Uint32Array(data.buffer)\n    };\n  }\n  getBytes() {\n    return this.size * 4;\n  }\n  getData() {\n    return this.typedArray[GL_FLOAT];\n  }\n  getSubData(index) {\n    let data;\n    let offset;\n    if (index === undefined) {\n      data = this.data;\n      offset = 0;\n    } else {\n      const begin = this.offsets[index];\n      const end = begin + this.sizes[index];\n      data = this.data.subarray(begin, end);\n      offset = begin * 4;\n    }\n    return {\n      data,\n      offset\n    };\n  }\n  setUniforms(values) {\n    for (const key in values) {\n      this._setValue(key, values[key]);\n    }\n    return this;\n  }\n  _setValue(key, value) {\n    const layout = this.layout[key];\n    assert(layout, 'UniformLayoutStd140 illegal argument');\n    const typedArray = this.typedArray[layout.type];\n    if (layout.size === 1) {\n      typedArray[layout.offset] = value;\n    } else {\n      typedArray.set(value, layout.offset);\n    }\n  }\n  _addUniform(key, uniformType) {\n    const typeAndComponents = decomposeCompositeGLType(uniformType);\n    assert(typeAndComponents, ERR_ARGUMENT);\n    const {\n      type,\n      components: count\n    } = typeAndComponents;\n    this.size = this._alignTo(this.size, count);\n    const offset = this.size;\n    this.size += count;\n    this.layout[key] = {\n      type,\n      size: count,\n      offset\n    };\n  }\n  _alignTo(size, count) {\n    switch (count) {\n      case 1:\n        return size;\n      case 2:\n        return size + size % 2;\n      default:\n        return size + (4 - size % 4) % 4;\n    }\n  }\n}","map":{"version":3,"sources":["../../../src/classes/uniform-buffer-layout.js"],"names":["decomposeCompositeGLType","assert","ERR_ARGUMENT","GL_FLOAT","GL_INT","GL_UNSIGNED_INT","UniformBufferLayout","constructor","layout","size","key","_addUniform","data","Float32Array","typedArray","Int32Array","buffer","Uint32Array","getBytes","getData","getSubData","index","offset","undefined","begin","offsets","end","sizes","subarray","setUniforms","values","_setValue","value","type","set","uniformType","typeAndComponents","components","count","_alignTo"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n/* eslint-disable camelcase */\nimport {decomposeCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {assert} from '../utils/assert';\n\nconst ERR_ARGUMENT = 'UniformBufferLayout illegal argument';\n\n// Local constants - these will \"collapse\" during minification\nconst GL_FLOAT = 0x1406;\nconst GL_INT = 0x1404;\nconst GL_UNSIGNED_INT = 0x1405;\n\n// Std140 layout for uniforms\nexport default class UniformBufferLayout {\n  constructor(layout) {\n    this.layout = {};\n    this.size = 0;\n\n    // Add layout (type, size and offset) definitions for each uniform in the layout\n    for (const key in layout) {\n      this._addUniform(key, layout[key]);\n    }\n\n    this.size += (4 - (this.size % 4)) % 4;\n\n    // Allocate three typed arrays pointing at same memory\n    const data = new Float32Array(this.size);\n    this.typedArray = {\n      [GL_FLOAT]: data,\n      [GL_INT]: new Int32Array(data.buffer),\n      [GL_UNSIGNED_INT]: new Uint32Array(data.buffer)\n    };\n  }\n\n  // Get number of bytes needed for buffer allocation\n  getBytes() {\n    return this.size * 4;\n  }\n\n  // Get the current data as Float32Array, for bufferSubData\n  getData() {\n    return this.typedArray[GL_FLOAT];\n  }\n\n  // Get offset and data for one object (for bufferSubData)\n  getSubData(index) {\n    let data;\n    let offset;\n    if (index === undefined) {\n      data = this.data;\n      offset = 0;\n    } else {\n      const begin = this.offsets[index];\n      const end = begin + this.sizes[index];\n      data = this.data.subarray(begin, end);\n      offset = begin * 4;\n    }\n    return {data, offset};\n  }\n\n  // Set a map of values\n  setUniforms(values) {\n    for (const key in values) {\n      this._setValue(key, values[key]);\n    }\n    return this;\n  }\n\n  _setValue(key, value) {\n    const layout = this.layout[key];\n    assert(layout, 'UniformLayoutStd140 illegal argument');\n    const typedArray = this.typedArray[layout.type];\n    if (layout.size === 1) {\n      // single value -> just set it\n      typedArray[layout.offset] = value;\n    } else {\n      // vector/matrix -> copy the supplied (typed) array, starting from offset\n      typedArray.set(value, layout.offset);\n    }\n  }\n\n  _addUniform(key, uniformType) {\n    const typeAndComponents = decomposeCompositeGLType(uniformType);\n    assert(typeAndComponents, ERR_ARGUMENT);\n    const {type, components: count} = typeAndComponents;\n\n    // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n    this.size = this._alignTo(this.size, count);\n    // Use the aligned size as the offset of the current uniform.\n    const offset = this.size;\n    // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n    this.size += count;\n\n    this.layout[key] = {type, size: count, offset};\n  }\n\n  // Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes)\n  _alignTo(size, count) {\n    switch (count) {\n      case 1:\n        return size; // Pad upwards to even multiple of 2\n      case 2:\n        return size + (size % 2); // Pad upwards to even multiple of 2\n      default:\n        return size + ((4 - (size % 4)) % 4); // Pad upwards to even multiple of 4\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}