{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _DEFAULT_SAMPLER;\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport assert from './utils/assert';\nimport { getAccessorArrayTypeAndLength } from './gltf-utils/gltf-utils';\nvar COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nvar BYTES = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\nvar GL_SAMPLER = {\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\nvar SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\nvar DEFAULT_SAMPLER = (_DEFAULT_SAMPLER = {}, _defineProperty(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MAG_FILTER, GL_SAMPLER.LINEAR), _defineProperty(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MIN_FILTER, GL_SAMPLER.NEAREST_MIPMAP_LINEAR), _defineProperty(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_S, GL_SAMPLER.REPEAT), _defineProperty(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_, GL_SAMPLER.REPEAT), _DEFAULT_SAMPLER);\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\nvar GLTFPostProcessor = function () {\n  function GLTFPostProcessor() {\n    _classCallCheck(this, GLTFPostProcessor);\n  }\n  _createClass(GLTFPostProcessor, [{\n    key: \"postProcess\",\n    value: function postProcess(gltf) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var json = gltf.json,\n        _gltf$buffers = gltf.buffers,\n        buffers = _gltf$buffers === void 0 ? [] : _gltf$buffers,\n        _gltf$images = gltf.images,\n        images = _gltf$images === void 0 ? [] : _gltf$images,\n        _gltf$baseUri = gltf.baseUri,\n        baseUri = _gltf$baseUri === void 0 ? '' : _gltf$baseUri;\n      assert(json);\n      this.baseUri = baseUri;\n      this.json = json;\n      this.buffers = buffers;\n      this.images = images;\n      this._resolveTree(this.json, options);\n      return this.json;\n    }\n  }, {\n    key: \"_resolveTree\",\n    value: function _resolveTree(json) {\n      var _this = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (json.bufferViews) {\n        json.bufferViews = json.bufferViews.map(function (bufView, i) {\n          return _this._resolveBufferView(bufView, i);\n        });\n      }\n      if (json.images) {\n        json.images = json.images.map(function (image, i) {\n          return _this._resolveImage(image, i);\n        });\n      }\n      if (json.samplers) {\n        json.samplers = json.samplers.map(function (sampler, i) {\n          return _this._resolveSampler(sampler, i);\n        });\n      }\n      if (json.textures) {\n        json.textures = json.textures.map(function (texture, i) {\n          return _this._resolveTexture(texture, i);\n        });\n      }\n      if (json.accessors) {\n        json.accessors = json.accessors.map(function (accessor, i) {\n          return _this._resolveAccessor(accessor, i);\n        });\n      }\n      if (json.materials) {\n        json.materials = json.materials.map(function (material, i) {\n          return _this._resolveMaterial(material, i);\n        });\n      }\n      if (json.meshes) {\n        json.meshes = json.meshes.map(function (mesh, i) {\n          return _this._resolveMesh(mesh, i);\n        });\n      }\n      if (json.nodes) {\n        json.nodes = json.nodes.map(function (node, i) {\n          return _this._resolveNode(node, i);\n        });\n      }\n      if (json.skins) {\n        json.skins = json.skins.map(function (skin, i) {\n          return _this._resolveSkin(skin, i);\n        });\n      }\n      if (json.scenes) {\n        json.scenes = json.scenes.map(function (scene, i) {\n          return _this._resolveScene(scene, i);\n        });\n      }\n      if (json.scene !== undefined) {\n        json.scene = json.scenes[this.json.scene];\n      }\n    }\n  }, {\n    key: \"getScene\",\n    value: function getScene(index) {\n      return this._get('scenes', index);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(index) {\n      return this._get('nodes', index);\n    }\n  }, {\n    key: \"getSkin\",\n    value: function getSkin(index) {\n      return this._get('skins', index);\n    }\n  }, {\n    key: \"getMesh\",\n    value: function getMesh(index) {\n      return this._get('meshes', index);\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(index) {\n      return this._get('materials', index);\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(index) {\n      return this._get('accessors', index);\n    }\n  }, {\n    key: \"getCamera\",\n    value: function getCamera(index) {\n      return null;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture(index) {\n      return this._get('textures', index);\n    }\n  }, {\n    key: \"getSampler\",\n    value: function getSampler(index) {\n      return this._get('samplers', index);\n    }\n  }, {\n    key: \"getImage\",\n    value: function getImage(index) {\n      return this._get('images', index);\n    }\n  }, {\n    key: \"getBufferView\",\n    value: function getBufferView(index) {\n      return this._get('bufferViews', index);\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(index) {\n      return this._get('buffers', index);\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(array, index) {\n      if (_typeof(index) === 'object') {\n        return index;\n      }\n      var object = this.json[array] && this.json[array][index];\n      if (!object) {\n        console.warn(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n      }\n      return object;\n    }\n  }, {\n    key: \"_resolveScene\",\n    value: function _resolveScene(scene, index) {\n      var _this2 = this;\n      scene.id = scene.id || \"scene-\".concat(index);\n      scene.nodes = (scene.nodes || []).map(function (node) {\n        return _this2.getNode(node);\n      });\n      return scene;\n    }\n  }, {\n    key: \"_resolveNode\",\n    value: function _resolveNode(node, index) {\n      var _this3 = this;\n      node.id = node.id || \"node-\".concat(index);\n      if (node.children) {\n        node.children = node.children.map(function (child) {\n          return _this3.getNode(child);\n        });\n      }\n      if (node.mesh !== undefined) {\n        node.mesh = this.getMesh(node.mesh);\n      }\n      if (node.camera !== undefined) {\n        node.camera = this.getCamera(node.camera);\n      }\n      if (node.skin !== undefined) {\n        node.skin = this.getSkin(node.skin);\n      }\n      return node;\n    }\n  }, {\n    key: \"_resolveSkin\",\n    value: function _resolveSkin(skin, index) {\n      skin.id = skin.id || \"skin-\".concat(index);\n      skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n      return skin;\n    }\n  }, {\n    key: \"_resolveMesh\",\n    value: function _resolveMesh(mesh, index) {\n      var _this4 = this;\n      mesh.id = mesh.id || \"mesh-\".concat(index);\n      if (mesh.primitives) {\n        mesh.primitives = mesh.primitives.map(function (primitive) {\n          primitive = _objectSpread({}, primitive);\n          var attributes = primitive.attributes;\n          primitive.attributes = {};\n          for (var attribute in attributes) {\n            primitive.attributes[attribute] = _this4.getAccessor(attributes[attribute]);\n          }\n          if (primitive.indices !== undefined) {\n            primitive.indices = _this4.getAccessor(primitive.indices);\n          }\n          if (primitive.material !== undefined) {\n            primitive.material = _this4.getMaterial(primitive.material);\n          }\n          return primitive;\n        });\n      }\n      return mesh;\n    }\n  }, {\n    key: \"_resolveMaterial\",\n    value: function _resolveMaterial(material, index) {\n      material.id = material.id || \"material-\".concat(index);\n      if (material.normalTexture) {\n        material.normalTexture = _objectSpread({}, material.normalTexture);\n        material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n      }\n      if (material.occlusionTexture) {\n        material.occlustionTexture = _objectSpread({}, material.occlustionTexture);\n        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n      }\n      if (material.emissiveTexture) {\n        material.emmisiveTexture = _objectSpread({}, material.emmisiveTexture);\n        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n      }\n      if (material.pbrMetallicRoughness) {\n        material.pbrMetallicRoughness = _objectSpread({}, material.pbrMetallicRoughness);\n        var mr = material.pbrMetallicRoughness;\n        if (mr.baseColorTexture) {\n          mr.baseColorTexture = _objectSpread({}, mr.baseColorTexture);\n          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n        }\n        if (mr.metallicRoughnessTexture) {\n          mr.metallicRoughnessTexture = _objectSpread({}, mr.metallicRoughnessTexture);\n          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n        }\n      }\n      return material;\n    }\n  }, {\n    key: \"_resolveAccessor\",\n    value: function _resolveAccessor(accessor, index) {\n      accessor.id = accessor.id || \"accessor-\".concat(index);\n      if (accessor.bufferView !== undefined) {\n        accessor.bufferView = this.getBufferView(accessor.bufferView);\n      }\n      accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n      accessor.components = getSizeFromAccessorType(accessor.type);\n      accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n      if (accessor.bufferView) {\n        var buffer = accessor.bufferView.buffer;\n        var _getAccessorArrayType = getAccessorArrayTypeAndLength(accessor, accessor.bufferView),\n          ArrayType = _getAccessorArrayType.ArrayType,\n          length = _getAccessorArrayType.length;\n        var byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n        accessor.value = new ArrayType(buffer.arrayBuffer, byteOffset, length);\n      }\n      return accessor;\n    }\n  }, {\n    key: \"_resolveTexture\",\n    value: function _resolveTexture(texture, index) {\n      texture.id = texture.id || \"texture-\".concat(index);\n      texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n      texture.source = this.getImage(texture.source);\n      return texture;\n    }\n  }, {\n    key: \"_resolveSampler\",\n    value: function _resolveSampler(sampler, index) {\n      sampler.id = sampler.id || \"sampler-\".concat(index);\n      sampler.parameters = {};\n      for (var key in sampler) {\n        var glEnum = this._enumSamplerParameter(key);\n        if (glEnum !== undefined) {\n          sampler.parameters[glEnum] = sampler[key];\n        }\n      }\n      return sampler;\n    }\n  }, {\n    key: \"_enumSamplerParameter\",\n    value: function _enumSamplerParameter(key) {\n      return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n    }\n  }, {\n    key: \"_resolveImage\",\n    value: function _resolveImage(image, index) {\n      image.id = image.id || \"image-\".concat(index);\n      if (image.bufferView !== undefined) {\n        image.bufferView = this.getBufferView(image.bufferView);\n      }\n      var preloadedImage = this.images[index];\n      if (preloadedImage) {\n        image.image = preloadedImage;\n      }\n      return image;\n    }\n  }, {\n    key: \"_resolveBufferView\",\n    value: function _resolveBufferView(bufferView, index) {\n      bufferView.id = bufferView.id || \"bufferView-\".concat(index);\n      var bufferIndex = bufferView.buffer;\n      bufferView.buffer = this.buffers[bufferIndex];\n      var arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n      var byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n      if ('byteOffset' in bufferView) {\n        byteOffset += bufferView.byteOffset;\n      }\n      bufferView.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n      return bufferView;\n    }\n  }, {\n    key: \"_resolveCamera\",\n    value: function _resolveCamera(camera, index) {\n      camera.id = camera.id || \"camera-\".concat(index);\n      if (camera.perspective) {}\n      if (camera.orthographic) {}\n      return camera;\n    }\n  }]);\n  return GLTFPostProcessor;\n}();\nexport default function postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}","map":{"version":3,"sources":["../../../src/lib/post-process-gltf.js"],"names":["assert","getAccessorArrayTypeAndLength","COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","BYTES","GL_SAMPLER","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","REPEAT","LINEAR","NEAREST_MIPMAP_LINEAR","SAMPLER_PARAMETER_GLTF_TO_GL","magFilter","minFilter","wrapS","wrapT","DEFAULT_SAMPLER","TEXTURE_WRAP_","getBytesFromComponentType","componentType","getSizeFromAccessorType","type","GLTFPostProcessor","gltf","options","json","buffers","images","baseUri","_resolveTree","bufferViews","map","bufView","i","_resolveBufferView","image","_resolveImage","samplers","sampler","_resolveSampler","textures","texture","_resolveTexture","accessors","accessor","_resolveAccessor","materials","material","_resolveMaterial","meshes","mesh","_resolveMesh","nodes","node","_resolveNode","skins","skin","_resolveSkin","scenes","scene","_resolveScene","undefined","index","_get","array","object","console","warn","id","getNode","children","child","getMesh","camera","getCamera","getSkin","inverseBindMatrices","getAccessor","primitives","primitive","attributes","attribute","indices","getMaterial","normalTexture","getTexture","occlusionTexture","occlustionTexture","emissiveTexture","emmisiveTexture","pbrMetallicRoughness","mr","baseColorTexture","metallicRoughnessTexture","bufferView","getBufferView","bytesPerComponent","components","bytesPerElement","buffer","ArrayType","length","byteOffset","value","arrayBuffer","getSampler","source","getImage","parameters","key","glEnum","_enumSamplerParameter","preloadedImage","bufferIndex","data","Uint8Array","byteLength","perspective","orthographic","postProcessGLTF","postProcess"],"mappings":"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","sourcesContent":["import assert from './utils/assert';\nimport {getAccessorArrayTypeAndLength} from './gltf-utils/gltf-utils';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  postProcess(gltf, options = {}) {\n    const {json, buffers = [], images = [], baseUri = ''} = gltf;\n    assert(json);\n\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    // scene = {...scene};\n    scene.id = scene.id || `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map(node => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    // node = {...node};\n    node.id = node.id || `node-${index}`;\n    if (node.children) {\n      node.children = node.children.map(child => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    // skin = {...skin};\n    skin.id = skin.id || `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    // mesh = {...mesh};\n    mesh.id = mesh.id || `mesh-${index}`;\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map(primitive => {\n        primitive = {...primitive};\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    // material = {...material};\n    material.id = material.id || `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture = {...material.normalTexture};\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {...material.occlustionTexture};\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {...material.emmisiveTexture};\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {...mr.baseColorTexture};\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    // accessor = {...accessor};\n    accessor.id = accessor.id || `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset =\n        (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      accessor.value = new ArrayType(buffer.arrayBuffer, byteOffset, length);\n    }\n\n    return accessor;\n  }\n\n  _resolveTexture(texture, index) {\n    // texture = {...texture};\n    texture.id = texture.id || `texture-${index}`;\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    // sampler = {...sampler};\n    sampler.id = sampler.id || `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    // image = {...image};\n    image.id = image.id || `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView, index) {\n    // bufferView = {...bufferView};\n    bufferView.id = bufferView.id || `bufferView-${index}`;\n    const bufferIndex = bufferView.buffer;\n    bufferView.buffer = this.buffers[bufferIndex];\n\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    bufferView.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return bufferView;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || `camera-${index}`;\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\n\nexport default function postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n"]},"metadata":{},"sourceType":"module"}