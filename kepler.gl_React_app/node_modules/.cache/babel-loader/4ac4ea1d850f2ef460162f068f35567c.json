{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { ImageLoader } from '@loaders.gl/images';\nimport { parseJSON, getZeroOffsetArrayBuffer } from '@loaders.gl/loader-utils';\nimport assert from './utils/assert';\nimport { resolveUrl } from './gltf-utils/resolve-url';\nimport { getTypedArrayForBufferView } from './gltf-utils/get-typed-array';\nimport { decodeExtensions } from './extensions/gltf-extensions';\nimport parseGLBSync, { isGLB } from './parse-glb';\nimport normalizeGLTFV1 from './normalize-gltf-v1';\nimport postProcessGLTF from './post-process-gltf';\nexport function isGLTF(arrayBuffer) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var dataView = new DataView(arrayBuffer);\n  var byteOffset = 0;\n  return isGLB(dataView, byteOffset);\n}\nexport function parseGLTF(_x, _x2) {\n  return _parseGLTF.apply(this, arguments);\n}\nfunction _parseGLTF() {\n  _parseGLTF = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(gltf, arrayBufferOrString) {\n    var byteOffset,\n      options,\n      context,\n      promises,\n      _promise,\n      promise,\n      _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            byteOffset = _args.length > 2 && _args[2] !== undefined ? _args[2] : 0;\n            options = _args.length > 3 ? _args[3] : undefined;\n            context = _args.length > 4 ? _args[4] : undefined;\n            parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n            normalizeGLTFV1(gltf, {\n              normalize: options.gltf.normalize\n            });\n            promises = [];\n            if (!(options.gltf.loadBuffers && gltf.json.buffers)) {\n              _context.next = 9;\n              break;\n            }\n            _context.next = 9;\n            return loadBuffers(gltf, options, context);\n          case 9:\n            if (options.gltf.loadImages) {\n              _promise = loadImages(gltf, options, context);\n              promises.push(_promise);\n            }\n            promise = decodeExtensions(gltf, options, context);\n            promises.push(promise);\n            _context.next = 14;\n            return Promise.all(promises);\n          case 14:\n            return _context.abrupt(\"return\", options.gltf.postProcess ? postProcessGLTF(gltf, options) : gltf);\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseGLTF.apply(this, arguments);\n}\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    var textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n  if (typeof data === 'string') {\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    var glb = {};\n    byteOffset = parseGLBSync(glb, data, byteOffset, options);\n    assert(glb.type === 'glTF', \"Invalid GLB magic string \".concat(glb.type));\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, \"GLTF: must be ArrayBuffer or string\");\n  }\n  var buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    var binChunks = gltf._glb.binChunks;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n  }\n  var images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\nfunction loadBuffers(_x3, _x4, _x5) {\n  return _loadBuffers.apply(this, arguments);\n}\nfunction _loadBuffers() {\n  _loadBuffers = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(gltf, options, context) {\n    var i, buffer, fetch, uri, response, arrayBuffer;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            i = 0;\n          case 1:\n            if (!(i < gltf.json.buffers.length)) {\n              _context2.next = 18;\n              break;\n            }\n            buffer = gltf.json.buffers[i];\n            if (!buffer.uri) {\n              _context2.next = 15;\n              break;\n            }\n            fetch = context.fetch;\n            assert(fetch);\n            uri = resolveUrl(buffer.uri, options);\n            _context2.next = 9;\n            return fetch(uri);\n          case 9:\n            response = _context2.sent;\n            _context2.next = 12;\n            return response.arrayBuffer();\n          case 12:\n            arrayBuffer = _context2.sent;\n            gltf.buffers[i] = {\n              arrayBuffer: arrayBuffer,\n              byteOffset: 0,\n              byteLength: arrayBuffer.byteLength\n            };\n            delete buffer.uri;\n          case 15:\n            ++i;\n            _context2.next = 1;\n            break;\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadBuffers.apply(this, arguments);\n}\nfunction loadImages(_x6, _x7, _x8) {\n  return _loadImages.apply(this, arguments);\n}\nfunction _loadImages() {\n  _loadImages = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(gltf, options, context) {\n    var images, promises, i;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            images = gltf.json.images || [];\n            promises = [];\n            for (i = 0; i < images.length; ++i) {\n              promises.push(loadImage(gltf, images[i], i, options, context));\n            }\n            _context3.next = 5;\n            return Promise.all(promises);\n          case 5:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _loadImages.apply(this, arguments);\n}\nfunction loadImage(_x9, _x10, _x11, _x12, _x13) {\n  return _loadImage.apply(this, arguments);\n}\nfunction _loadImage() {\n  _loadImage = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4(gltf, image, i, options, context) {\n    var fetch, parse, arrayBuffer, uri, response, array, parsedImage;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            fetch = context.fetch, parse = context.parse;\n            if (!image.uri) {\n              _context4.next = 9;\n              break;\n            }\n            uri = resolveUrl(image.uri, options);\n            _context4.next = 5;\n            return fetch(uri);\n          case 5:\n            response = _context4.sent;\n            _context4.next = 8;\n            return response.arrayBuffer();\n          case 8:\n            arrayBuffer = _context4.sent;\n          case 9:\n            if (Number.isFinite(image.bufferView)) {\n              array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n              arrayBuffer = getZeroOffsetArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n            }\n            assert(arrayBuffer, 'glTF image has no data');\n            _context4.next = 13;\n            return parse(arrayBuffer, ImageLoader, {}, context);\n          case 13:\n            parsedImage = _context4.sent;\n            gltf.images[i] = parsedImage;\n          case 15:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _loadImage.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/lib/parse-gltf.js"],"names":["ImageLoader","parseJSON","getZeroOffsetArrayBuffer","assert","resolveUrl","getTypedArrayForBufferView","decodeExtensions","parseGLBSync","isGLB","normalizeGLTFV1","postProcessGLTF","isGLTF","arrayBuffer","options","dataView","DataView","byteOffset","parseGLTF","gltf","arrayBufferOrString","context","parseGLTFContainerSync","normalize","promises","loadBuffers","json","buffers","loadImages","promise","push","Promise","all","postProcess","data","uri","baseUri","ArrayBuffer","textDecoder","TextDecoder","decode","glb","type","_glb","Array","length","fill","header","hasBinChunk","binChunks","byteLength","images","i","buffer","fetch","response","loadImage","image","parse","Number","isFinite","bufferView","array","parsedImage"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements, no-restricted-globals */\n/* global TextDecoder */\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, getZeroOffsetArrayBuffer} from '@loaders.gl/loader-utils';\nimport assert from './utils/assert';\nimport {resolveUrl} from './gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from './gltf-utils/get-typed-array';\nimport {decodeExtensions} from './extensions/gltf-extensions';\nimport parseGLBSync, {isGLB} from './parse-glb';\nimport normalizeGLTFV1 from './normalize-gltf-v1';\nimport postProcessGLTF from './post-process-gltf';\n\nexport function isGLTF(arrayBuffer, options = {}) {\n  const dataView = new DataView(arrayBuffer);\n  const byteOffset = 0;\n  return isGLB(dataView, byteOffset);\n}\n\nexport async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options.gltf.normalize});\n\n  /** @type {Promise[]} */\n  const promises = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options.gltf.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options.gltf.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options.gltf.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb = {};\n    byteOffset = parseGLBSync(glb, data, byteOffset, options);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, `GLTF: must be ArrayBuffer or string`);\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n// Asynchronously fetch and parse buffers, store in buffers array outside of json\nasync function loadBuffers(gltf, options, context) {\n  for (let i = 0; i < gltf.json.buffers.length; ++i) {\n    const buffer = gltf.json.buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await fetch(uri);\n      const arrayBuffer = await response.arrayBuffer();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    }\n  }\n}\n\nasync function loadImages(gltf, options, context) {\n  const images = gltf.json.images || [];\n\n  const promises = [];\n  for (let i = 0; i < images.length; ++i) {\n    promises.push(loadImage(gltf, images[i], i, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n// Asynchronously fetches and parses one image, store in images array outside of json\nasync function loadImage(gltf, image, i, options, context) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = getZeroOffsetArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  const parsedImage = await parse(arrayBuffer, ImageLoader, {}, context);\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  gltf.images[i] = parsedImage;\n}\n"]},"metadata":{},"sourceType":"module"}