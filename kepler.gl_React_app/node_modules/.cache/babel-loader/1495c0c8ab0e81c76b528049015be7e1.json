{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport WorkerPool from './worker-pool';\nvar DEFAULT_MAX_CONCURRENCY = 5;\nvar WorkerFarm = function () {\n  _createClass(WorkerFarm, null, [{\n    key: \"isSupported\",\n    value: function isSupported() {\n      return typeof Worker !== 'undefined';\n    }\n  }]);\n  function WorkerFarm(_ref) {\n    var _ref$maxConcurrency = _ref.maxConcurrency,\n      maxConcurrency = _ref$maxConcurrency === void 0 ? DEFAULT_MAX_CONCURRENCY : _ref$maxConcurrency,\n      _ref$onMessage = _ref.onMessage,\n      onMessage = _ref$onMessage === void 0 ? null : _ref$onMessage,\n      _ref$onDebug = _ref.onDebug,\n      onDebug = _ref$onDebug === void 0 ? function () {} : _ref$onDebug,\n      _ref$reuseWorkers = _ref.reuseWorkers,\n      reuseWorkers = _ref$reuseWorkers === void 0 ? true : _ref$reuseWorkers;\n    _classCallCheck(this, WorkerFarm);\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n    this.workerPools = new Map();\n    this.reuseWorkers = reuseWorkers;\n  }\n  _createClass(WorkerFarm, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('maxConcurrency' in props) {\n        this.maxConcurrency = props.maxConcurrency;\n      }\n      if ('onDebug' in props) {\n        this.onDebug = props.onDebug;\n      }\n      if ('reuseWorkers' in props) {\n        this.reuseWorkers = props.reuseWorkers;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.workerPools.forEach(function (workerPool) {\n        return workerPool.destroy();\n      });\n    }\n  }, {\n    key: \"process\",\n    value: function () {\n      var _process = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(workerSource, workerName, data) {\n        var workerPool;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                workerPool = this._getWorkerPool(workerSource, workerName);\n                return _context.abrupt(\"return\", workerPool.process(data));\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function process(_x, _x2, _x3) {\n        return _process.apply(this, arguments);\n      }\n      return process;\n    }()\n  }, {\n    key: \"_getWorkerPool\",\n    value: function _getWorkerPool(workerSource, workerName) {\n      var workerPool = this.workerPools.get(workerName);\n      if (!workerPool) {\n        workerPool = new WorkerPool({\n          source: workerSource,\n          name: workerName,\n          onMessage: onWorkerMessage.bind(null, this.onMessage),\n          maxConcurrency: this.maxConcurrency,\n          onDebug: this.onDebug,\n          reuseWorkers: this.reuseWorkers\n        });\n        this.workerPools.set(workerName, workerPool);\n      }\n      return workerPool;\n    }\n  }]);\n  return WorkerFarm;\n}();\nexport { WorkerFarm as default };\nfunction onWorkerMessage(onMessage, _ref2) {\n  var worker = _ref2.worker,\n    data = _ref2.data,\n    resolve = _ref2.resolve,\n    reject = _ref2.reject;\n  if (onMessage) {\n    onMessage({\n      worker: worker,\n      data: data,\n      resolve: resolve,\n      reject: reject\n    });\n    return;\n  }\n  switch (data.type) {\n    case 'done':\n      resolve(data.result);\n      break;\n    case 'error':\n      reject(data.message);\n      break;\n    default:\n  }\n}","map":{"version":3,"sources":["../../../../src/lib/worker-utils/worker-farm.js"],"names":["WorkerPool","DEFAULT_MAX_CONCURRENCY","WorkerFarm","Worker","maxConcurrency","onMessage","onDebug","reuseWorkers","workerPools","Map","props","forEach","workerPool","destroy","workerSource","workerName","data","_getWorkerPool","process","get","source","name","onWorkerMessage","bind","set","worker","resolve","reject","type","result","message"],"mappings":"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","sourcesContent":["import WorkerPool from './worker-pool';\n\nconst DEFAULT_MAX_CONCURRENCY = 5;\n\n/**\n * Process multiple data messages with a \"farm\" of different workers (in worker pools)\n */\nexport default class WorkerFarm {\n  static isSupported() {\n    return typeof Worker !== 'undefined';\n  }\n\n  constructor({\n    maxConcurrency = DEFAULT_MAX_CONCURRENCY,\n    onMessage = null,\n    onDebug = () => {},\n    reuseWorkers = true\n  }) {\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n    this.workerPools = new Map();\n    this.reuseWorkers = reuseWorkers;\n  }\n\n  setProps(props) {\n    if ('maxConcurrency' in props) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n\n    if ('onDebug' in props) {\n      this.onDebug = props.onDebug;\n    }\n\n    if ('reuseWorkers' in props) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n  }\n\n  destroy() {\n    this.workerPools.forEach(workerPool => workerPool.destroy());\n  }\n\n  /**\n   * Process binary data in a worker\n   * @param {any} data - data (containing binary typed arrays) to be transferred to worker\n   * @returns a Promise with data containing typed arrays transferred back from work\n   */\n  async process(workerSource, workerName, data) {\n    const workerPool = this._getWorkerPool(workerSource, workerName);\n    return workerPool.process(data);\n  }\n\n  // PRIVATE\n\n  _getWorkerPool(workerSource, workerName) {\n    let workerPool = this.workerPools.get(workerName);\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        source: workerSource,\n        name: workerName,\n        onMessage: onWorkerMessage.bind(null, this.onMessage),\n        maxConcurrency: this.maxConcurrency,\n        onDebug: this.onDebug,\n        reuseWorkers: this.reuseWorkers\n      });\n      this.workerPools.set(workerName, workerPool);\n    }\n    return workerPool;\n  }\n}\n\nfunction onWorkerMessage(onMessage, {worker, data, resolve, reject}) {\n  if (onMessage) {\n    onMessage({worker, data, resolve, reject});\n    return;\n  }\n\n  switch (data.type) {\n    case 'done':\n      resolve(data.result);\n      break;\n\n    case 'error':\n      reject(data.message);\n      break;\n\n    default:\n  }\n}\n"]},"metadata":{},"sourceType":"module"}