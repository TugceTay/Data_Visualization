{"ast":null,"code":"import { makeStringIterator } from './string-iterator';\nimport { makeArrayBufferIterator } from './array-buffer-iterator';\nimport { makeBlobIterator } from './blob-iterator';\nimport { assert } from '@loaders.gl/loader-utils';\nimport { makeStreamIterator } from './stream-iterator';\nimport { isBlob, isReadableStream, isResponse } from '../../javascript-utils/is-type';\nexport function makeIterator(data) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof data === 'string') {\n    return makeStringIterator(data, options);\n  }\n  if (data instanceof ArrayBuffer) {\n    return makeArrayBufferIterator(data, options);\n  }\n  if (isBlob(data)) {\n    return makeBlobIterator(data, options);\n  }\n  if (isReadableStream(data)) {\n    return makeStreamIterator(data);\n  }\n  if (isResponse(data)) {\n    return makeStreamIterator(data.body);\n  }\n  return assert(false);\n}","map":{"version":3,"sources":["../../../../src/iterator-utils/make-iterator/make-iterator.js"],"names":["makeStringIterator","makeArrayBufferIterator","makeBlobIterator","assert","makeStreamIterator","isBlob","isReadableStream","isResponse","makeIterator","data","options","ArrayBuffer","body"],"mappings":"AAAA,SAAQA,kBAAR,QAAiC,mBAAjC;AACA,SAAQC,uBAAR,QAAsC,yBAAtC;AACA,SAAQC,gBAAR,QAA+B,iBAA/B;AACA,SAAQC,MAAR,QAAqB,0BAArB;AACA,SAAQC,kBAAR,QAAiC,mBAAjC;AACA,SAAQC,MAAR,EAAgBC,gBAAhB,EAAkCC,UAAlC,QAAmD,gCAAnD;AAaA,OAAO,SAASC,YAAT,CAAsBC,IAAtB,EAA0C;EAAA,IAAdC,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;EAC/C,IAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;IAE5B,OAAOT,kBAAkB,CAACS,IAAD,EAAOC,OAAP,CAAzB;EACD;EACD,IAAID,IAAI,YAAYE,WAApB,EAAiC;IAC/B,OAAOV,uBAAuB,CAACQ,IAAD,EAAOC,OAAP,CAA9B;EACD;EACD,IAAIL,MAAM,CAACI,IAAD,CAAV,EAAkB;IAChB,OAAOP,gBAAgB,CAACO,IAAD,EAAOC,OAAP,CAAvB;EACD;EACD,IAAIJ,gBAAgB,CAACG,IAAD,CAApB,EAA4B;IAC1B,OAAOL,kBAAkB,CAACK,IAAD,CAAzB;EACD;EACD,IAAIF,UAAU,CAACE,IAAD,CAAd,EAAsB;IACpB,OAAOL,kBAAkB,CAACK,IAAI,CAACG,IAAN,CAAzB;EACD;EACD,OAAOT,MAAM,CAAC,KAAD,CAAb;AACD","sourcesContent":["import {makeStringIterator} from './string-iterator';\nimport {makeArrayBufferIterator} from './array-buffer-iterator';\nimport {makeBlobIterator} from './blob-iterator';\nimport {assert} from '@loaders.gl/loader-utils';\nimport {makeStreamIterator} from './stream-iterator';\nimport {isBlob, isReadableStream, isResponse} from '../../javascript-utils/is-type';\n\n/**\n * Returns an iterator that breaks its input into chunks and yields them one-by-one.\n *\n * @param data a big `ArrayBuffer`, `Blob` or string, or a stream.\n * @param {object} options\n * @param {number} [options.chunkSize]  max number of bytes per chunk. chunkSize is ignored for streams.\n * @returns iterator or async iterator that yields chunks of specified size.\n *\n * This function can e.g. be used to enable data sources that can only be read atomically\n * (such as `Blob` and `File` via `FileReader`) to still be parsed in batches.\n */\nexport function makeIterator(data, options = {}) {\n  if (typeof data === 'string') {\n    // Note: Converts string chunks to binary\n    return makeStringIterator(data, options);\n  }\n  if (data instanceof ArrayBuffer) {\n    return makeArrayBufferIterator(data, options);\n  }\n  if (isBlob(data)) {\n    return makeBlobIterator(data, options);\n  }\n  if (isReadableStream(data)) {\n    return makeStreamIterator(data);\n  }\n  if (isResponse(data)) {\n    return makeStreamIterator(data.body);\n  }\n  return assert(false);\n}\n"]},"metadata":{},"sourceType":"module"}