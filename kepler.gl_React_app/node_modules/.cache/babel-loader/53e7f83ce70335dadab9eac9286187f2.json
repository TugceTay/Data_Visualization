{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSavedMapsErrorUpdater = exports.getSavedMapsSuccessUpdater = exports.getSavedMapsUpdater = exports.setCloudProviderUpdater = exports.resetProviderStatusUpdater = exports.loadCloudMapErrorUpdater = exports.loadCloudMapSuccessUpdater = exports.loadCloudMapUpdater = exports.exportFileErrorUpdater = exports.postSaveLoadSuccessUpdater = exports.exportFileSuccessUpdater = exports.exportFileToCloudUpdater = exports.INITIAL_PROVIDER_STATE = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _tasks = require(\"react-palm/tasks\");\nvar _console = _interopRequireDefault(require(\"global/console\"));\nvar _utils = require(\"../utils/utils\");\nvar _tasks2 = require(\"../tasks/tasks\");\nvar _providerActions = require(\"../actions/provider-actions\");\nvar _uiStateActions = require(\"../actions/ui-state-actions\");\nvar _actions = require(\"../actions/actions\");\nvar _defaultSettings = require(\"../constants/default-settings\");\nvar _cloudProviders = require(\"../cloud-providers\");\nvar _dataProcessor = require(\"../processors/data-processor\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar INITIAL_PROVIDER_STATE = {\n  isProviderLoading: false,\n  isCloudMapLoading: false,\n  providerError: null,\n  currentProvider: null,\n  successInfo: {},\n  mapSaved: null,\n  visualizations: []\n};\nexports.INITIAL_PROVIDER_STATE = INITIAL_PROVIDER_STATE;\nfunction createActionTask(action, payload) {\n  if (typeof action === 'function') {\n    return (0, _tasks2.ACTION_TASK)().map(function (_) {\n      return action(payload);\n    });\n  }\n  return null;\n}\nfunction _validateProvider(provider, method) {\n  if (!provider) {\n    _console[\"default\"].error(\"provider is not defined\");\n    return false;\n  }\n  if (typeof provider[method] !== 'function') {\n    _console[\"default\"].error(\"\".concat(method, \" is not a function of Cloud provider: \").concat(provider.name));\n    return false;\n  }\n  return true;\n}\n/**\n * @type {typeof import('./provider-state-updaters').createGlobalNotificationTasks}\n */\n\nfunction createGlobalNotificationTasks(_ref) {\n  var type = _ref.type,\n    message = _ref.message,\n    _ref$delayClose = _ref.delayClose,\n    delayClose = _ref$delayClose === void 0 ? true : _ref$delayClose;\n  var id = (0, _utils.generateHashId)();\n  var successNote = {\n    id: id,\n    type: _defaultSettings.DEFAULT_NOTIFICATION_TYPES[type || ''] || _defaultSettings.DEFAULT_NOTIFICATION_TYPES.success,\n    topic: _defaultSettings.DEFAULT_NOTIFICATION_TOPICS.global,\n    message: message\n  };\n  var task = (0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _uiStateActions.addNotification)(successNote);\n  });\n  return delayClose ? [task, (0, _tasks2.DELAY_TASK)(3000).map(function (_) {\n    return (0, _uiStateActions.removeNotification)(id);\n  })] : [task];\n}\n/**\n * This method will export the current kepler config file to the chosen cloud proder\n * add returns a share URL\n *\n * @type {typeof import('./provider-state-updaters').exportFileToCloudUpdater}\n */\n\nvar exportFileToCloudUpdater = function exportFileToCloudUpdater(state, action) {\n  var _action$payload = action.payload,\n    mapData = _action$payload.mapData,\n    provider = _action$payload.provider,\n    _action$payload$optio = _action$payload.options,\n    options = _action$payload$optio === void 0 ? {} : _action$payload$optio,\n    onSuccess = _action$payload.onSuccess,\n    onError = _action$payload.onError,\n    closeModal = _action$payload.closeModal;\n  if (!_validateProvider(provider, 'uploadMap')) {\n    return state;\n  }\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: true,\n    currentProvider: provider.name\n  }); // payload called by provider.uploadMap\n\n  var payload = {\n    mapData: mapData,\n    options: options\n  };\n  var uploadFileTask = (0, _tasks2.EXPORT_FILE_TO_CLOUD_TASK)({\n    provider: provider,\n    payload: payload\n  }).bimap(\n  // success\n  function (response) {\n    return (0, _providerActions.exportFileSuccess)({\n      response: response,\n      provider: provider,\n      options: options,\n      onSuccess: onSuccess,\n      closeModal: closeModal\n    });\n  },\n  // error\n  function (error) {\n    return (0, _providerActions.exportFileError)({\n      error: error,\n      provider: provider,\n      options: options,\n      onError: onError\n    });\n  });\n  return (0, _tasks.withTask)(newState, uploadFileTask);\n};\n/**\n *\n * @type {typeof import('./provider-state-updaters').exportFileSuccessUpdater}\n */\n\nexports.exportFileToCloudUpdater = exportFileToCloudUpdater;\nvar exportFileSuccessUpdater = function exportFileSuccessUpdater(state, action) {\n  var _action$payload2 = action.payload,\n    response = _action$payload2.response,\n    provider = _action$payload2.provider,\n    _action$payload2$opti = _action$payload2.options,\n    options = _action$payload2$opti === void 0 ? {} : _action$payload2$opti,\n    onSuccess = _action$payload2.onSuccess,\n    closeModal = _action$payload2.closeModal;\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false,\n    // TODO: do we always have to store this?\n    successInfo: response\n  }, !options.isPublic ? {\n    mapSaved: provider.name\n  } : {});\n  var tasks = [createActionTask(onSuccess, {\n    response: response,\n    provider: provider,\n    options: options\n  }), closeModal && (0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _providerActions.postSaveLoadSuccess)(\"Map saved to \".concat(state.currentProvider, \"!\"));\n  })].filter(function (d) {\n    return d;\n  });\n  return tasks.length ? (0, _tasks.withTask)(newState, tasks) : newState;\n};\n/**\n * Close modal on success and display notification\n * @type {typeof import('./provider-state-updaters').postSaveLoadSuccessUpdater}\n */\n\nexports.exportFileSuccessUpdater = exportFileSuccessUpdater;\nvar postSaveLoadSuccessUpdater = function postSaveLoadSuccessUpdater(state, action) {\n  var message = action.payload || \"Saved / Load to \".concat(state.currentProvider, \" Success\");\n  var tasks = [(0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _uiStateActions.toggleModal)(null);\n  }), (0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _providerActions.resetProviderStatus)();\n  })].concat((0, _toConsumableArray2[\"default\"])(createGlobalNotificationTasks({\n    message: message\n  })));\n  return (0, _tasks.withTask)(state, tasks);\n};\n/**\n *\n * @type {typeof import('./provider-state-updaters').exportFileErrorUpdater}\n */\n\nexports.postSaveLoadSuccessUpdater = postSaveLoadSuccessUpdater;\nvar exportFileErrorUpdater = function exportFileErrorUpdater(state, action) {\n  var _action$payload3 = action.payload,\n    error = _action$payload3.error,\n    provider = _action$payload3.provider,\n    onError = _action$payload3.onError;\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false\n  });\n  if (isFileConflict(error)) {\n    newState.mapSaved = provider.name;\n    return (0, _tasks.withTask)(newState, [(0, _tasks2.ACTION_TASK)().map(function (_) {\n      return (0, _uiStateActions.toggleModal)(_defaultSettings.OVERWRITE_MAP_ID);\n    })]);\n  }\n  newState.providerError = (0, _utils.getError)(error);\n  var task = createActionTask(onError, {\n    error: error,\n    provider: provider\n  });\n  return task ? (0, _tasks.withTask)(newState, task) : newState;\n};\nexports.exportFileErrorUpdater = exportFileErrorUpdater;\nvar loadCloudMapUpdater = function loadCloudMapUpdater(state, action) {\n  var _action$payload4 = action.payload,\n    loadParams = _action$payload4.loadParams,\n    provider = _action$payload4.provider,\n    onSuccess = _action$payload4.onSuccess,\n    onError = _action$payload4.onError;\n  if (!loadParams) {\n    _console[\"default\"].warn('load map error: loadParams is undefined');\n    return state;\n  }\n  if (!_validateProvider(provider, 'downloadMap')) {\n    return state;\n  }\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: true,\n    isCloudMapLoading: true\n  }); // payload called by provider.downloadMap\n\n  var uploadFileTask = (0, _tasks2.LOAD_CLOUD_MAP_TASK)({\n    provider: provider,\n    payload: loadParams\n  }).bimap(\n  // success\n  function (response) {\n    return (0, _providerActions.loadCloudMapSuccess)({\n      response: response,\n      loadParams: loadParams,\n      provider: provider,\n      onSuccess: onSuccess,\n      onError: onError\n    });\n  },\n  // error\n  function (error) {\n    return (0, _providerActions.loadCloudMapError)({\n      error: error,\n      provider: provider,\n      onError: onError\n    });\n  });\n  return (0, _tasks.withTask)(newState, uploadFileTask);\n};\nexports.loadCloudMapUpdater = loadCloudMapUpdater;\nfunction isFileConflict(error) {\n  return error && error.message === _cloudProviders.FILE_CONFLICT_MSG;\n}\nfunction checkLoadMapResponseError(response) {\n  if (!response || !(0, _utils.isPlainObject)(response)) {\n    return new Error('Load map response is empty');\n  }\n  if (!(0, _utils.isPlainObject)(response.map)) {\n    return new Error(\"Load map response should be an object property \\\"map\\\"\");\n  }\n  if (!response.map.datasets || !response.map.config) {\n    return new Error(\"Load map response.map should be an object with property datasets or config\");\n  }\n  return null;\n}\nfunction getDatasetHandler(format) {\n  var defaultHandler = _dataProcessor.DATASET_HANDLERS[_defaultSettings.DATASET_FORMATS.csv];\n  if (!format) {\n    _console[\"default\"].warn('format is not provided in load map response, will use csv by default');\n    return defaultHandler;\n  }\n  if (!_dataProcessor.DATASET_HANDLERS[format]) {\n    var supportedFormat = Object.keys(_defaultSettings.DATASET_FORMATS).map(function (k) {\n      return \"'\".concat(k, \"'\");\n    }).join(', ');\n    _console[\"default\"].warn(\"unknown format \".concat(format, \". Please use one of \").concat(supportedFormat, \", will use csv by default\"));\n    return defaultHandler;\n  }\n  return _dataProcessor.DATASET_HANDLERS[format];\n}\nfunction parseLoadMapResponse(response, loadParams, provider) {\n  var map = response.map,\n    format = response.format;\n  var processorMethod = getDatasetHandler(format);\n  var parsedDatasets = (0, _utils.toArray)(map.datasets).map(function (ds, i) {\n    if (format === _defaultSettings.DATASET_FORMATS.keplergl) {\n      // no need to obtain id, directly pass them in\n      return processorMethod(ds);\n    }\n    var info = ds && ds.info || {\n      id: (0, _utils.generateHashId)(6)\n    };\n    var data = processorMethod(ds.data || ds);\n    return {\n      info: info,\n      data: data\n    };\n  });\n  var info = _objectSpread(_objectSpread({}, map.info), {}, {\n    provider: provider.name,\n    loadParams: loadParams\n  });\n  return _objectSpread({\n    datasets: parsedDatasets,\n    info: info\n  }, map.config ? {\n    config: map.config\n  } : {});\n}\n/**\n *\n * @type {typeof import('./provider-state-updaters').loadCloudMapSuccessUpdater}\n */\n\nvar loadCloudMapSuccessUpdater = function loadCloudMapSuccessUpdater(state, action) {\n  var _action$payload5 = action.payload,\n    response = _action$payload5.response,\n    loadParams = _action$payload5.loadParams,\n    provider = _action$payload5.provider,\n    onSuccess = _action$payload5.onSuccess,\n    onError = _action$payload5.onError;\n  var formatError = checkLoadMapResponseError(response);\n  if (formatError) {\n    // if response format is not correct\n    return exportFileErrorUpdater(state, {\n      payload: {\n        error: formatError,\n        provider: provider,\n        onError: onError\n      }\n    });\n  }\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    mapSaved: provider.name,\n    currentProvider: provider.name,\n    isCloudMapLoading: false,\n    isProviderLoading: false\n  });\n  var payload = parseLoadMapResponse(response, loadParams, provider);\n  var tasks = [(0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _actions.addDataToMap)(payload);\n  }), createActionTask(onSuccess, {\n    response: response,\n    loadParams: loadParams,\n    provider: provider\n  }), (0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _providerActions.postSaveLoadSuccess)(\"Map from \".concat(provider.name, \" loaded\"));\n  })].filter(function (d) {\n    return d;\n  });\n  return tasks.length ? (0, _tasks.withTask)(newState, tasks) : newState;\n};\n/**\n *\n * @type {typeof import('./provider-state-updaters').loadCloudMapErrorUpdater}\n */\n\nexports.loadCloudMapSuccessUpdater = loadCloudMapSuccessUpdater;\nvar loadCloudMapErrorUpdater = function loadCloudMapErrorUpdater(state, action) {\n  var message = (0, _utils.getError)(action.payload.error) || \"Error loading saved map\";\n  _console[\"default\"].warn(message);\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false,\n    isCloudMapLoading: false,\n    providerError: null\n  });\n  return (0, _tasks.withTask)(newState, createGlobalNotificationTasks({\n    type: 'error',\n    message: message,\n    delayClose: false\n  }));\n};\n/**\n *\n * @type {typeof import('./provider-state-updaters').resetProviderStatusUpdater}\n */\n\nexports.loadCloudMapErrorUpdater = loadCloudMapErrorUpdater;\nvar resetProviderStatusUpdater = function resetProviderStatusUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false,\n    providerError: null,\n    isCloudMapLoading: false,\n    successInfo: {}\n  });\n};\n/**\n * Set current cloudProvider\n * @type {typeof import('./provider-state-updaters').setCloudProviderUpdater}\n */\n\nexports.resetProviderStatusUpdater = resetProviderStatusUpdater;\nvar setCloudProviderUpdater = function setCloudProviderUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false,\n    providerError: null,\n    successInfo: {},\n    currentProvider: action.payload\n  });\n};\n/**\n *\n * @type {typeof import('./provider-state-updaters').getSavedMapsUpdater}\n */\n\nexports.setCloudProviderUpdater = setCloudProviderUpdater;\nvar getSavedMapsUpdater = function getSavedMapsUpdater(state, action) {\n  var provider = action.payload;\n  if (!_validateProvider(provider, 'listMaps')) {\n    return state;\n  }\n  var getSavedMapsTask = (0, _tasks2.GET_SAVED_MAPS_TASK)(provider).bimap(\n  // success\n  function (visualizations) {\n    return (0, _providerActions.getSavedMapsSuccess)({\n      visualizations: visualizations,\n      provider: provider\n    });\n  },\n  // error\n  function (error) {\n    return (0, _providerActions.getSavedMapsError)({\n      error: error,\n      provider: provider\n    });\n  });\n  return (0, _tasks.withTask)(_objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: true\n  }), getSavedMapsTask);\n};\n/**\n *\n * @type {typeof import('./provider-state-updaters').getSavedMapsSuccessUpdater}\n */\n\nexports.getSavedMapsUpdater = getSavedMapsUpdater;\nvar getSavedMapsSuccessUpdater = function getSavedMapsSuccessUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false,\n    visualizations: action.payload.visualizations\n  });\n};\n/**\n *\n * @type {typeof import('./provider-state-updaters').getSavedMapsErrorUpdater}\n */\n\nexports.getSavedMapsSuccessUpdater = getSavedMapsSuccessUpdater;\nvar getSavedMapsErrorUpdater = function getSavedMapsErrorUpdater(state, action) {\n  var message = (0, _utils.getError)(action.payload.error) || \"Error getting saved maps from \".concat(state.currentProvider);\n  _console[\"default\"].warn(action.payload.error);\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    currentProvider: null,\n    isProviderLoading: false\n  });\n  return (0, _tasks.withTask)(newState, createGlobalNotificationTasks({\n    type: 'error',\n    message: message,\n    delayClose: false\n  }));\n};\nexports.getSavedMapsErrorUpdater = getSavedMapsErrorUpdater;","map":{"version":3,"sources":["../../src/reducers/provider-state-updaters.js"],"names":["INITIAL_PROVIDER_STATE","isProviderLoading","isCloudMapLoading","providerError","currentProvider","successInfo","mapSaved","visualizations","createActionTask","action","payload","map","_validateProvider","provider","method","Console","error","name","createGlobalNotificationTasks","type","message","delayClose","id","successNote","DEFAULT_NOTIFICATION_TYPES","success","topic","DEFAULT_NOTIFICATION_TOPICS","global","task","exportFileToCloudUpdater","state","mapData","options","onSuccess","onError","closeModal","newState","uploadFileTask","bimap","response","exportFileSuccessUpdater","isPublic","tasks","filter","d","length","postSaveLoadSuccessUpdater","exportFileErrorUpdater","isFileConflict","OVERWRITE_MAP_ID","loadCloudMapUpdater","loadParams","warn","FILE_CONFLICT_MSG","checkLoadMapResponseError","Error","datasets","config","getDatasetHandler","format","defaultHandler","DATASET_HANDLERS","DATASET_FORMATS","csv","supportedFormat","keys","k","join","parseLoadMapResponse","processorMethod","parsedDatasets","ds","i","keplergl","info","data","loadCloudMapSuccessUpdater","formatError","loadCloudMapErrorUpdater","resetProviderStatusUpdater","setCloudProviderUpdater","getSavedMapsUpdater","getSavedMapsTask","getSavedMapsSuccessUpdater","getSavedMapsErrorUpdater"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {withTask} from 'react-palm/tasks';\nimport {default as Console} from 'global/console';\nimport {generateHashId, getError, isPlainObject, toArray} from 'utils/utils';\nimport {\n  EXPORT_FILE_TO_CLOUD_TASK,\n  ACTION_TASK,\n  DELAY_TASK,\n  LOAD_CLOUD_MAP_TASK,\n  GET_SAVED_MAPS_TASK\n} from 'tasks/tasks';\nimport {\n  exportFileSuccess,\n  exportFileError,\n  postSaveLoadSuccess,\n  loadCloudMapSuccess,\n  getSavedMapsSuccess,\n  getSavedMapsError,\n  loadCloudMapError,\n  resetProviderStatus\n} from 'actions/provider-actions';\nimport {removeNotification, toggleModal, addNotification} from 'actions/ui-state-actions';\nimport {addDataToMap} from 'actions/actions';\nimport {\n  DEFAULT_NOTIFICATION_TYPES,\n  DEFAULT_NOTIFICATION_TOPICS,\n  DATASET_FORMATS,\n  OVERWRITE_MAP_ID\n} from 'constants/default-settings';\n\nimport {FILE_CONFLICT_MSG} from 'cloud-providers';\nimport {DATASET_HANDLERS} from 'processors/data-processor';\n\nexport const INITIAL_PROVIDER_STATE = {\n  isProviderLoading: false,\n  isCloudMapLoading: false,\n  providerError: null,\n  currentProvider: null,\n  successInfo: {},\n  mapSaved: null,\n  visualizations: []\n};\n\nfunction createActionTask(action, payload) {\n  if (typeof action === 'function') {\n    return ACTION_TASK().map(_ => action(payload));\n  }\n\n  return null;\n}\n\nfunction _validateProvider(provider, method) {\n  if (!provider) {\n    Console.error(`provider is not defined`);\n    return false;\n  }\n\n  if (typeof provider[method] !== 'function') {\n    Console.error(`${method} is not a function of Cloud provider: ${provider.name}`);\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * @type {typeof import('./provider-state-updaters').createGlobalNotificationTasks}\n */\nfunction createGlobalNotificationTasks({type, message, delayClose = true}) {\n  const id = generateHashId();\n  const successNote = {\n    id,\n    type: DEFAULT_NOTIFICATION_TYPES[type || ''] || DEFAULT_NOTIFICATION_TYPES.success,\n    topic: DEFAULT_NOTIFICATION_TOPICS.global,\n    message\n  };\n  const task = ACTION_TASK().map(_ => addNotification(successNote));\n  return delayClose ? [task, DELAY_TASK(3000).map(_ => removeNotification(id))] : [task];\n}\n\n/**\n * This method will export the current kepler config file to the chosen cloud proder\n * add returns a share URL\n *\n * @type {typeof import('./provider-state-updaters').exportFileToCloudUpdater}\n */\nexport const exportFileToCloudUpdater = (state, action) => {\n  const {mapData, provider, options = {}, onSuccess, onError, closeModal} = action.payload;\n\n  if (!_validateProvider(provider, 'uploadMap')) {\n    return state;\n  }\n\n  const newState = {\n    ...state,\n    isProviderLoading: true,\n    currentProvider: provider.name\n  };\n\n  // payload called by provider.uploadMap\n  const payload = {\n    mapData,\n    options\n  };\n  const uploadFileTask = EXPORT_FILE_TO_CLOUD_TASK({provider, payload}).bimap(\n    // success\n    response => exportFileSuccess({response, provider, options, onSuccess, closeModal}),\n    // error\n    error => exportFileError({error, provider, options, onError})\n  );\n\n  return withTask(newState, uploadFileTask);\n};\n\n/**\n *\n * @type {typeof import('./provider-state-updaters').exportFileSuccessUpdater}\n */\nexport const exportFileSuccessUpdater = (state, action) => {\n  const {response, provider, options = {}, onSuccess, closeModal} = action.payload;\n\n  const newState = {\n    ...state,\n    isProviderLoading: false,\n    // TODO: do we always have to store this?\n    successInfo: response,\n    ...(!options.isPublic\n      ? {\n          mapSaved: provider.name\n        }\n      : {})\n  };\n\n  const tasks = [\n    createActionTask(onSuccess, {response, provider, options}),\n    closeModal &&\n      ACTION_TASK().map(_ => postSaveLoadSuccess(`Map saved to ${state.currentProvider}!`))\n  ].filter(d => d);\n\n  return tasks.length ? withTask(newState, tasks) : newState;\n};\n\n/**\n * Close modal on success and display notification\n * @type {typeof import('./provider-state-updaters').postSaveLoadSuccessUpdater}\n */\nexport const postSaveLoadSuccessUpdater = (state, action) => {\n  const message = action.payload || `Saved / Load to ${state.currentProvider} Success`;\n\n  const tasks = [\n    ACTION_TASK().map(_ => toggleModal(null)),\n    ACTION_TASK().map(_ => resetProviderStatus()),\n    ...createGlobalNotificationTasks({message})\n  ];\n\n  return withTask(state, tasks);\n};\n\n/**\n *\n * @type {typeof import('./provider-state-updaters').exportFileErrorUpdater}\n */\nexport const exportFileErrorUpdater = (state, action) => {\n  const {error, provider, onError} = action.payload;\n\n  const newState = {\n    ...state,\n    isProviderLoading: false\n  };\n\n  if (isFileConflict(error)) {\n    newState.mapSaved = provider.name;\n    return withTask(newState, [ACTION_TASK().map(_ => toggleModal(OVERWRITE_MAP_ID))]);\n  }\n\n  newState.providerError = getError(error);\n  const task = createActionTask(onError, {error, provider});\n\n  return task ? withTask(newState, task) : newState;\n};\n\nexport const loadCloudMapUpdater = (state, action) => {\n  const {loadParams, provider, onSuccess, onError} = action.payload;\n  if (!loadParams) {\n    Console.warn('load map error: loadParams is undefined');\n    return state;\n  }\n  if (!_validateProvider(provider, 'downloadMap')) {\n    return state;\n  }\n\n  const newState = {\n    ...state,\n    isProviderLoading: true,\n    isCloudMapLoading: true\n  };\n\n  // payload called by provider.downloadMap\n  const uploadFileTask = LOAD_CLOUD_MAP_TASK({provider, payload: loadParams}).bimap(\n    // success\n    response => loadCloudMapSuccess({response, loadParams, provider, onSuccess, onError}),\n    // error\n    error => loadCloudMapError({error, provider, onError})\n  );\n\n  return withTask(newState, uploadFileTask);\n};\n\nfunction isFileConflict(error) {\n  return error && error.message === FILE_CONFLICT_MSG;\n}\n\nfunction checkLoadMapResponseError(response) {\n  if (!response || !isPlainObject(response)) {\n    return new Error('Load map response is empty');\n  }\n  if (!isPlainObject(response.map)) {\n    return new Error(`Load map response should be an object property \"map\"`);\n  }\n  if (!response.map.datasets || !response.map.config) {\n    return new Error(`Load map response.map should be an object with property datasets or config`);\n  }\n\n  return null;\n}\n\nfunction getDatasetHandler(format) {\n  const defaultHandler = DATASET_HANDLERS[DATASET_FORMATS.csv];\n  if (!format) {\n    Console.warn('format is not provided in load map response, will use csv by default');\n    return defaultHandler;\n  }\n\n  if (!DATASET_HANDLERS[format]) {\n    const supportedFormat = Object.keys(DATASET_FORMATS)\n      .map(k => `'${k}'`)\n      .join(', ');\n    Console.warn(\n      `unknown format ${format}. Please use one of ${supportedFormat}, will use csv by default`\n    );\n    return defaultHandler;\n  }\n\n  return DATASET_HANDLERS[format];\n}\n\nfunction parseLoadMapResponse(response, loadParams, provider) {\n  const {map, format} = response;\n  const processorMethod = getDatasetHandler(format);\n\n  const parsedDatasets = toArray(map.datasets).map((ds, i) => {\n    if (format === DATASET_FORMATS.keplergl) {\n      // no need to obtain id, directly pass them in\n      return processorMethod(ds);\n    }\n    const info = (ds && ds.info) || {id: generateHashId(6)};\n    const data = processorMethod(ds.data || ds);\n    return {info, data};\n  });\n\n  const info = {\n    ...map.info,\n    provider: provider.name,\n    loadParams\n  };\n  return {\n    datasets: parsedDatasets,\n    info,\n    ...(map.config ? {config: map.config} : {})\n  };\n}\n\n/**\n *\n * @type {typeof import('./provider-state-updaters').loadCloudMapSuccessUpdater}\n */\nexport const loadCloudMapSuccessUpdater = (state, action) => {\n  const {response, loadParams, provider, onSuccess, onError} = action.payload;\n\n  const formatError = checkLoadMapResponseError(response);\n  if (formatError) {\n    // if response format is not correct\n    return exportFileErrorUpdater(state, {\n      payload: {error: formatError, provider, onError}\n    });\n  }\n\n  const newState = {\n    ...state,\n    mapSaved: provider.name,\n    currentProvider: provider.name,\n    isCloudMapLoading: false,\n    isProviderLoading: false\n  };\n\n  const payload = parseLoadMapResponse(response, loadParams, provider);\n\n  const tasks = [\n    ACTION_TASK().map(_ => addDataToMap(payload)),\n    createActionTask(onSuccess, {response, loadParams, provider}),\n    ACTION_TASK().map(_ => postSaveLoadSuccess(`Map from ${provider.name} loaded`))\n  ].filter(d => d);\n\n  return tasks.length ? withTask(newState, tasks) : newState;\n};\n\n/**\n *\n * @type {typeof import('./provider-state-updaters').loadCloudMapErrorUpdater}\n */\nexport const loadCloudMapErrorUpdater = (state, action) => {\n  const message = getError(action.payload.error) || `Error loading saved map`;\n\n  Console.warn(message);\n\n  const newState = {\n    ...state,\n    isProviderLoading: false,\n    isCloudMapLoading: false,\n    providerError: null\n  };\n\n  return withTask(\n    newState,\n    createGlobalNotificationTasks({type: 'error', message, delayClose: false})\n  );\n};\n\n/**\n *\n * @type {typeof import('./provider-state-updaters').resetProviderStatusUpdater}\n */\nexport const resetProviderStatusUpdater = (state, action) => ({\n  ...state,\n  isProviderLoading: false,\n  providerError: null,\n  isCloudMapLoading: false,\n  successInfo: {}\n});\n\n/**\n * Set current cloudProvider\n * @type {typeof import('./provider-state-updaters').setCloudProviderUpdater}\n */\nexport const setCloudProviderUpdater = (state, action) => ({\n  ...state,\n  isProviderLoading: false,\n  providerError: null,\n  successInfo: {},\n  currentProvider: action.payload\n});\n\n/**\n *\n * @type {typeof import('./provider-state-updaters').getSavedMapsUpdater}\n */\nexport const getSavedMapsUpdater = (state, action) => {\n  const provider = action.payload;\n  if (!_validateProvider(provider, 'listMaps')) {\n    return state;\n  }\n\n  const getSavedMapsTask = GET_SAVED_MAPS_TASK(provider).bimap(\n    // success\n    visualizations => getSavedMapsSuccess({visualizations, provider}),\n    // error\n    error => getSavedMapsError({error, provider})\n  );\n\n  return withTask(\n    {\n      ...state,\n      isProviderLoading: true\n    },\n    getSavedMapsTask\n  );\n};\n\n/**\n *\n * @type {typeof import('./provider-state-updaters').getSavedMapsSuccessUpdater}\n */\nexport const getSavedMapsSuccessUpdater = (state, action) => ({\n  ...state,\n  isProviderLoading: false,\n  visualizations: action.payload.visualizations\n});\n\n/**\n *\n * @type {typeof import('./provider-state-updaters').getSavedMapsErrorUpdater}\n */\nexport const getSavedMapsErrorUpdater = (state, action) => {\n  const message =\n    getError(action.payload.error) || `Error getting saved maps from ${state.currentProvider}`;\n\n  Console.warn(action.payload.error);\n\n  const newState = {\n    ...state,\n    currentProvider: null,\n    isProviderLoading: false\n  };\n\n  return withTask(\n    newState,\n    createGlobalNotificationTasks({type: 'error', message, delayClose: false})\n  );\n};\n"]},"metadata":{},"sourceType":"script"}