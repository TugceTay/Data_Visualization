{"ast":null,"code":"import { Matrix4, Vector3, clamp } from '@math.gl/core';\nvar scratchPositionNormal = new Vector3();\nvar scratchCartographic = new Vector3();\nvar scratchMatrix = new Matrix4();\nvar scratchCenter = new Vector3();\nvar scratchPosition = new Vector3();\nvar scratchDirection = new Vector3();\nexport function calculateDynamicScreenSpaceError(root, _ref) {\n  var camera = _ref.camera,\n    mapProjection = _ref.mapProjection;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$dynamicScree = options.dynamicScreenSpaceErrorHeightFalloff,\n    dynamicScreenSpaceErrorHeightFalloff = _options$dynamicScree === void 0 ? 0.25 : _options$dynamicScree,\n    _options$dynamicScree2 = options.dynamicScreenSpaceErrorDensity,\n    dynamicScreenSpaceErrorDensity = _options$dynamicScree2 === void 0 ? 0.00278 : _options$dynamicScree2;\n  var up;\n  var direction;\n  var height;\n  var minimumHeight;\n  var maximumHeight;\n  var tileBoundingVolume = root.contentBoundingVolume;\n  if (tileBoundingVolume instanceof TileBoundingRegion) {\n    up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n    direction = camera.directionWC;\n    height = camera.positionCartographic.height;\n    minimumHeight = tileBoundingVolume.minimumHeight;\n    maximumHeight = tileBoundingVolume.maximumHeight;\n  } else {\n    var transformLocal = Matrix4.inverseTransformation(root.computedTransform, scratchMatrix);\n    var ellipsoid = mapProjection.ellipsoid;\n    var boundingVolume = tileBoundingVolume.boundingVolume;\n    var centerLocal = Matrix4.multiplyByPoint(transformLocal, boundingVolume.center, scratchCenter);\n    if (Cartesian3.magnitude(centerLocal) > ellipsoid.minimumRadius) {\n      var centerCartographic = Cartographic.fromCartesian(centerLocal, ellipsoid, scratchCartographic);\n      up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n      direction = camera.directionWC;\n      height = camera.positionCartographic.height;\n      minimumHeight = 0.0;\n      maximumHeight = centerCartographic.height * 2.0;\n    } else {\n      var positionLocal = Matrix4.multiplyByPoint(transformLocal, camera.positionWC, scratchPosition);\n      up = Cartesian3.UNIT_Z;\n      direction = Matrix4.multiplyByPointAsVector(transformLocal, camera.directionWC, scratchDirection);\n      direction = Cartesian3.normalize(direction, direction);\n      height = positionLocal.z;\n      if (tileBoundingVolume instanceof TileOrientedBoundingBox) {\n        var boxHeight = root._header.boundingVolume.box[11];\n        minimumHeight = centerLocal.z - boxHeight;\n        maximumHeight = centerLocal.z + boxHeight;\n      } else if (tileBoundingVolume instanceof TileBoundingSphere) {\n        var radius = boundingVolume.radius;\n        minimumHeight = centerLocal.z - radius;\n        maximumHeight = centerLocal.z + radius;\n      }\n    }\n  }\n  var heightFalloff = dynamicScreenSpaceErrorHeightFalloff;\n  var heightClose = minimumHeight + (maximumHeight - minimumHeight) * heightFalloff;\n  var heightFar = maximumHeight;\n  var t = clamp((height - heightClose) / (heightFar - heightClose), 0.0, 1.0);\n  var dot = Math.abs(Cartesian3.dot(direction, up));\n  var horizonFactor = 1.0 - dot;\n  horizonFactor = horizonFactor * (1.0 - t);\n  return dynamicScreenSpaceErrorDensity * horizonFactor;\n}\nexport function fog(distanceToCamera, density) {\n  var scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n}\nexport function getDynamicScreenSpaceError(tileset, distanceToCamera) {\n  if (tileset.dynamicScreenSpaceError && tileset._dynamicScreenSpaceErrorComputedDensity) {\n    var density = tileset._dynamicScreenSpaceErrorComputedDensity;\n    var factor = tileset.dynamicScreenSpaceErrorFactor;\n    var dynamicError = fog(distanceToCamera, density) * factor;\n    return dynamicError;\n  }\n  return 0;\n}\nexport function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {\n  var tileset = tile.tileset;\n  var parentLodMetricValue = tile.parent && tile.parent.lodMetricValue || tile.lodMetricValue;\n  var lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;\n  if (lodMetricValue === 0.0) {\n    return 0.0;\n  }\n  var distance = Math.max(tile._distanceToCamera, 1e-7);\n  var height = frameState.height,\n    sseDenominator = frameState.sseDenominator;\n  var error = lodMetricValue * height / (distance * sseDenominator);\n  error -= getDynamicScreenSpaceError(tileset, distance);\n  return error;\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/tiles-3d-lod.js"],"names":["Matrix4","Vector3","clamp","scratchPositionNormal","scratchCartographic","scratchMatrix","scratchCenter","scratchPosition","scratchDirection","calculateDynamicScreenSpaceError","root","camera","mapProjection","options","dynamicScreenSpaceErrorHeightFalloff","dynamicScreenSpaceErrorDensity","up","direction","height","minimumHeight","maximumHeight","tileBoundingVolume","contentBoundingVolume","TileBoundingRegion","Cartesian3","normalize","positionWC","directionWC","positionCartographic","transformLocal","inverseTransformation","computedTransform","ellipsoid","boundingVolume","centerLocal","multiplyByPoint","center","magnitude","minimumRadius","centerCartographic","Cartographic","fromCartesian","positionLocal","UNIT_Z","multiplyByPointAsVector","z","TileOrientedBoundingBox","boxHeight","_header","box","TileBoundingSphere","radius","heightFalloff","heightClose","heightFar","t","dot","Math","abs","horizonFactor","fog","distanceToCamera","density","scalar","exp","getDynamicScreenSpaceError","tileset","dynamicScreenSpaceError","_dynamicScreenSpaceErrorComputedDensity","factor","dynamicScreenSpaceErrorFactor","dynamicError","getTiles3DScreenSpaceError","tile","frameState","useParentLodMetric","parentLodMetricValue","parent","lodMetricValue","distance","max","_distanceToCamera","sseDenominator","error"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// TODO - Dynamic screen space error provides an optimization when looking at\n// tilesets from above\n\n/* eslint-disable */\n// @ts-nocheck\nimport {Matrix4, Vector3, clamp} from '@math.gl/core';\n\nconst scratchPositionNormal = new Vector3();\nconst scratchCartographic = new Vector3();\nconst scratchMatrix = new Matrix4();\nconst scratchCenter = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchDirection = new Vector3();\n\n// eslint-disable-next-line max-statements, complexity\nexport function calculateDynamicScreenSpaceError(root, {camera, mapProjection}, options = {}) {\n  const {\n    dynamicScreenSpaceErrorHeightFalloff = 0.25,\n    dynamicScreenSpaceErrorDensity = 0.00278\n  } = options;\n\n  let up;\n  let direction;\n  let height;\n  let minimumHeight;\n  let maximumHeight;\n\n  const tileBoundingVolume = root.contentBoundingVolume;\n\n  if (tileBoundingVolume instanceof TileBoundingRegion) {\n    up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n    direction = camera.directionWC;\n    height = camera.positionCartographic.height;\n    minimumHeight = tileBoundingVolume.minimumHeight;\n    maximumHeight = tileBoundingVolume.maximumHeight;\n  } else {\n    // Transform camera position and direction into the local coordinate system of the tileset\n    const transformLocal = Matrix4.inverseTransformation(root.computedTransform, scratchMatrix);\n    const ellipsoid = mapProjection.ellipsoid;\n    const boundingVolume = tileBoundingVolume.boundingVolume;\n    const centerLocal = Matrix4.multiplyByPoint(\n      transformLocal,\n      boundingVolume.center,\n      scratchCenter\n    );\n    if (Cartesian3.magnitude(centerLocal) > ellipsoid.minimumRadius) {\n      // The tileset is defined in WGS84. Approximate the minimum and maximum height.\n      const centerCartographic = Cartographic.fromCartesian(\n        centerLocal,\n        ellipsoid,\n        scratchCartographic\n      );\n      up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n      direction = camera.directionWC;\n      height = camera.positionCartographic.height;\n      minimumHeight = 0.0;\n      maximumHeight = centerCartographic.height * 2.0;\n    } else {\n      // The tileset is defined in local coordinates (z-up)\n      const positionLocal = Matrix4.multiplyByPoint(\n        transformLocal,\n        camera.positionWC,\n        scratchPosition\n      );\n      up = Cartesian3.UNIT_Z;\n      direction = Matrix4.multiplyByPointAsVector(\n        transformLocal,\n        camera.directionWC,\n        scratchDirection\n      );\n      direction = Cartesian3.normalize(direction, direction);\n      height = positionLocal.z;\n      if (tileBoundingVolume instanceof TileOrientedBoundingBox) {\n        // Assuming z-up, the last component stores the half-height of the box\n        const boxHeight = root._header.boundingVolume.box[11];\n        minimumHeight = centerLocal.z - boxHeight;\n        maximumHeight = centerLocal.z + boxHeight;\n      } else if (tileBoundingVolume instanceof TileBoundingSphere) {\n        const radius = boundingVolume.radius;\n        minimumHeight = centerLocal.z - radius;\n        maximumHeight = centerLocal.z + radius;\n      }\n    }\n  }\n\n  // The range where the density starts to lessen. Start at the quarter height of the tileset.\n  const heightFalloff = dynamicScreenSpaceErrorHeightFalloff;\n  const heightClose = minimumHeight + (maximumHeight - minimumHeight) * heightFalloff;\n  const heightFar = maximumHeight;\n\n  const t = clamp((height - heightClose) / (heightFar - heightClose), 0.0, 1.0);\n\n  // Increase density as the camera tilts towards the horizon\n  const dot = Math.abs(Cartesian3.dot(direction, up));\n\n  let horizonFactor = 1.0 - dot;\n\n  // Weaken the horizon factor as the camera height increases, implying the camera is further away from the tileset.\n  // The goal is to increase density for the \"street view\", not when viewing the tileset from a distance.\n  horizonFactor = horizonFactor * (1.0 - t);\n\n  return dynamicScreenSpaceErrorDensity * horizonFactor;\n}\n\nexport function fog(distanceToCamera, density) {\n  const scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n}\n\nexport function getDynamicScreenSpaceError(tileset, distanceToCamera) {\n  if (tileset.dynamicScreenSpaceError && tileset._dynamicScreenSpaceErrorComputedDensity) {\n    const density = tileset._dynamicScreenSpaceErrorComputedDensity;\n    const factor = tileset.dynamicScreenSpaceErrorFactor;\n    // TODO: Refined screen space error that minimizes tiles in non-first-person\n    const dynamicError = fog(distanceToCamera, density) * factor;\n    return dynamicError;\n  }\n\n  return 0;\n}\n\nexport function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {\n  const tileset = tile.tileset;\n  const parentLodMetricValue = (tile.parent && tile.parent.lodMetricValue) || tile.lodMetricValue;\n  const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;\n\n  // Leaf tiles do not have any error so save the computation\n  if (lodMetricValue === 0.0) {\n    return 0.0;\n  }\n\n  // TODO: Orthographic Frustum needs special treatment?\n  // this._getOrthograhicScreenSpaceError();\n\n  // Avoid divide by zero when viewer is inside the tile\n  const distance = Math.max(tile._distanceToCamera, 1e-7);\n  const {height, sseDenominator} = frameState;\n  let error = (lodMetricValue * height) / (distance * sseDenominator);\n\n  error -= getDynamicScreenSpaceError(tileset, distance);\n\n  return error;\n}\n"]},"metadata":{},"sourceType":"module"}