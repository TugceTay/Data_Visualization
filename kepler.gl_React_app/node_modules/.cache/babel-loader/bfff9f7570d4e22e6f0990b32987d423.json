{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { CompositeLayer, _flatten as flatten } from '@deck.gl/core';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport Tileset2D, { STRATEGY_DEFAULT } from './tileset-2d';\nimport { urlType, getURLFromTemplate } from './utils';\nvar defaultProps = {\n  data: [],\n  dataComparator: urlType.equals,\n  renderSubLayers: {\n    type: 'function',\n    value: function value(props) {\n      return new GeoJsonLayer(props);\n    },\n    compare: false\n  },\n  getTileData: {\n    type: 'function',\n    optional: true,\n    value: null,\n    compare: false\n  },\n  onViewportLoad: {\n    type: 'function',\n    optional: true,\n    value: null,\n    compare: false\n  },\n  onTileLoad: {\n    type: 'function',\n    value: function value(tile) {},\n    compare: false\n  },\n  onTileError: {\n    type: 'function',\n    value: function value(err) {\n      return console.error(err);\n    },\n    compare: false\n  },\n  extent: {\n    type: 'array',\n    optional: true,\n    value: null,\n    compare: true\n  },\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: 0,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: STRATEGY_DEFAULT,\n  zRange: null,\n  maxRequests: 8\n};\nvar TileLayer = function (_CompositeLayer) {\n  _inherits(TileLayer, _CompositeLayer);\n  function TileLayer() {\n    _classCallCheck(this, TileLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(TileLayer).apply(this, arguments));\n  }\n  _createClass(TileLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        tiles: [],\n        isLoaded: false\n      };\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n        oldProps = _ref2.oldProps,\n        context = _ref2.context,\n        changeFlags = _ref2.changeFlags;\n      var tileset = this.state.tileset;\n      var createTileCache = !tileset || changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);\n      if (createTileCache) {\n        var maxZoom = props.maxZoom,\n          minZoom = props.minZoom,\n          tileSize = props.tileSize,\n          maxCacheSize = props.maxCacheSize,\n          maxCacheByteSize = props.maxCacheByteSize,\n          refinementStrategy = props.refinementStrategy,\n          extent = props.extent,\n          maxRequests = props.maxRequests;\n        tileset = new Tileset2D({\n          getTileData: this.getTileData.bind(this),\n          maxCacheSize: maxCacheSize,\n          maxCacheByteSize: maxCacheByteSize,\n          maxZoom: maxZoom,\n          minZoom: minZoom,\n          tileSize: tileSize,\n          refinementStrategy: refinementStrategy,\n          extent: extent,\n          onTileLoad: this._onTileLoad.bind(this),\n          onTileError: this._onTileError.bind(this),\n          maxRequests: maxRequests\n        });\n        this.setState({\n          tileset: tileset\n        });\n      } else if (changeFlags.propsChanged || changeFlags.updateTriggersChanged) {\n        tileset.setOptions(props);\n        this.state.tileset.tiles.forEach(function (tile) {\n          tile.layers = null;\n        });\n      }\n      this._updateTileset();\n    }\n  }, {\n    key: \"_updateTileset\",\n    value: function _updateTileset() {\n      var tileset = this.state.tileset;\n      var _this$props = this.props,\n        onViewportLoad = _this$props.onViewportLoad,\n        zRange = _this$props.zRange;\n      var frameNumber = tileset.update(this.context.viewport, {\n        zRange: zRange\n      });\n      var isLoaded = tileset.isLoaded;\n      var loadingStateChanged = this.state.isLoaded !== isLoaded;\n      var tilesetChanged = this.state.frameNumber !== frameNumber;\n      if (isLoaded && onViewportLoad && (loadingStateChanged || tilesetChanged)) {\n        onViewportLoad(tileset.selectedTiles.map(function (tile) {\n          return tile.data;\n        }));\n      }\n      if (tilesetChanged) {\n        this.setState({\n          frameNumber: frameNumber\n        });\n      }\n      this.state.isLoaded = isLoaded;\n    }\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(tile) {\n      var layer = this.getCurrentLayer();\n      layer.props.onTileLoad(tile);\n      if (tile.isVisible) {\n        this.setNeedsUpdate();\n      }\n    }\n  }, {\n    key: \"_onTileError\",\n    value: function _onTileError(error, tile) {\n      var layer = this.getCurrentLayer();\n      layer.props.onTileError(error);\n      layer._updateTileset();\n      if (tile.isVisible) {\n        this.setNeedsUpdate();\n      }\n    }\n  }, {\n    key: \"getTileData\",\n    value: function getTileData(tile) {\n      var _this$props2 = this.props,\n        getTileData = _this$props2.getTileData,\n        fetch = _this$props2.fetch,\n        data = _this$props2.data;\n      tile.url = getURLFromTemplate(data, tile);\n      if (getTileData) {\n        return getTileData(tile);\n      }\n      if (tile.url) {\n        return fetch(tile.url, {\n          layer: this\n        });\n      }\n      return null;\n    }\n  }, {\n    key: \"renderSubLayers\",\n    value: function renderSubLayers(props) {\n      return this.props.renderSubLayers(props);\n    }\n  }, {\n    key: \"getHighlightedObjectIndex\",\n    value: function getHighlightedObjectIndex() {\n      return -1;\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info,\n        sourceLayer = _ref3.sourceLayer;\n      info.sourceLayer = sourceLayer;\n      info.tile = sourceLayer.props.tile;\n      return info;\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this = this;\n      var visible = this.props.visible;\n      return this.state.tileset.tiles.map(function (tile) {\n        var isVisible = visible && tile.isVisible;\n        var highlightedObjectIndex = _this.getHighlightedObjectIndex(tile);\n        if (!tile.isLoaded) {} else if (!tile.layers) {\n          var layers = _this.renderSubLayers(Object.assign({}, _this.props, {\n            id: \"\".concat(_this.id, \"-\").concat(tile.x, \"-\").concat(tile.y, \"-\").concat(tile.z),\n            data: tile.data,\n            visible: isVisible,\n            _offset: 0,\n            tile: tile,\n            highlightedObjectIndex: highlightedObjectIndex\n          }));\n          tile.layers = flatten(layers, Boolean);\n        } else if (tile.layers[0] && (tile.layers[0].props.visible !== isVisible || tile.layers[0].props.highlightedObjectIndex !== highlightedObjectIndex)) {\n          tile.layers = tile.layers.map(function (layer) {\n            return layer.clone({\n              visible: isVisible,\n              highlightedObjectIndex: highlightedObjectIndex\n            });\n          });\n        }\n        return tile.layers;\n      });\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      var tileset = this.state.tileset;\n      return tileset.selectedTiles.every(function (tile) {\n        return tile.layers && tile.layers.every(function (layer) {\n          return layer.isLoaded;\n        });\n      });\n    }\n  }]);\n  return TileLayer;\n}(CompositeLayer);\nexport { TileLayer as default };\nTileLayer.layerName = 'TileLayer';\nTileLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/tile-layer/tile-layer.js"],"names":["CompositeLayer","_flatten","flatten","GeoJsonLayer","Tileset2D","STRATEGY_DEFAULT","urlType","getURLFromTemplate","defaultProps","data","dataComparator","equals","renderSubLayers","type","value","props","compare","getTileData","optional","onViewportLoad","onTileLoad","onTileError","console","error","err","extent","tileSize","maxZoom","minZoom","maxCacheSize","maxCacheByteSize","refinementStrategy","zRange","maxRequests","TileLayer","state","tiles","isLoaded","tileset","selectedTiles","every","tile","layers","layer","changeFlags","somethingChanged","oldProps","context","createTileCache","dataChanged","updateTriggersChanged","all","bind","_onTileLoad","_onTileError","setState","propsChanged","setOptions","forEach","_updateTileset","frameNumber","update","viewport","loadingStateChanged","tilesetChanged","map","getCurrentLayer","isVisible","setNeedsUpdate","fetch","url","info","sourceLayer","visible","highlightedObjectIndex","getHighlightedObjectIndex","assign","id","x","y","z","_offset","Boolean","clone","layerName"],"mappings":"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","sourcesContent":["import {CompositeLayer, _flatten as flatten} from '@deck.gl/core';\nimport {GeoJsonLayer} from '@deck.gl/layers';\n\nimport Tileset2D, {STRATEGY_DEFAULT} from './tileset-2d';\nimport {urlType, getURLFromTemplate} from './utils';\n\nconst defaultProps = {\n  data: [],\n  dataComparator: urlType.equals,\n  renderSubLayers: {type: 'function', value: props => new GeoJsonLayer(props), compare: false},\n  getTileData: {type: 'function', optional: true, value: null, compare: false},\n  // TODO - change to onViewportLoad to align with Tile3DLayer\n  onViewportLoad: {type: 'function', optional: true, value: null, compare: false},\n  onTileLoad: {type: 'function', value: tile => {}, compare: false},\n  // eslint-disable-next-line\n  onTileError: {type: 'function', value: err => console.error(err), compare: false},\n  extent: {type: 'array', optional: true, value: null, compare: true},\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: 0,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: STRATEGY_DEFAULT,\n  zRange: null,\n  maxRequests: 8\n};\n\nexport default class TileLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      tiles: [],\n      isLoaded: false\n    };\n  }\n\n  get isLoaded() {\n    const {tileset} = this.state;\n    return tileset.selectedTiles.every(\n      tile => tile.layers && tile.layers.every(layer => layer.isLoaded)\n    );\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, context, changeFlags}) {\n    let {tileset} = this.state;\n    const createTileCache =\n      !tileset ||\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData));\n\n    if (createTileCache) {\n      const {\n        maxZoom,\n        minZoom,\n        tileSize,\n        maxCacheSize,\n        maxCacheByteSize,\n        refinementStrategy,\n        extent,\n        maxRequests\n      } = props;\n      tileset = new Tileset2D({\n        getTileData: this.getTileData.bind(this),\n        maxCacheSize,\n        maxCacheByteSize,\n        maxZoom,\n        minZoom,\n        tileSize,\n        refinementStrategy,\n        extent,\n        onTileLoad: this._onTileLoad.bind(this),\n        onTileError: this._onTileError.bind(this),\n        maxRequests\n      });\n      this.setState({tileset});\n    } else if (changeFlags.propsChanged || changeFlags.updateTriggersChanged) {\n      tileset.setOptions(props);\n      // if any props changed, delete the cached layers\n      this.state.tileset.tiles.forEach(tile => {\n        tile.layers = null;\n      });\n    }\n\n    this._updateTileset();\n  }\n\n  _updateTileset() {\n    const {tileset} = this.state;\n    const {onViewportLoad, zRange} = this.props;\n    const frameNumber = tileset.update(this.context.viewport, {zRange});\n    const {isLoaded} = tileset;\n\n    const loadingStateChanged = this.state.isLoaded !== isLoaded;\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n\n    if (isLoaded && onViewportLoad && (loadingStateChanged || tilesetChanged)) {\n      onViewportLoad(tileset.selectedTiles.map(tile => tile.data));\n    }\n\n    if (tilesetChanged) {\n      // Save the tileset frame number - trigger a rerender\n      this.setState({frameNumber});\n    }\n    // Save the loaded state - should not trigger a rerender\n    this.state.isLoaded = isLoaded;\n  }\n\n  _onTileLoad(tile) {\n    const layer = this.getCurrentLayer();\n    layer.props.onTileLoad(tile);\n\n    if (tile.isVisible) {\n      this.setNeedsUpdate();\n    }\n  }\n\n  _onTileError(error, tile) {\n    const layer = this.getCurrentLayer();\n    layer.props.onTileError(error);\n    // errorred tiles should not block rendering, are considered \"loaded\" with empty data\n    layer._updateTileset();\n\n    if (tile.isVisible) {\n      this.setNeedsUpdate();\n    }\n  }\n\n  // Methods for subclass to override\n\n  getTileData(tile) {\n    const {getTileData, fetch, data} = this.props;\n\n    tile.url = getURLFromTemplate(data, tile);\n\n    if (getTileData) {\n      return getTileData(tile);\n    }\n    if (tile.url) {\n      return fetch(tile.url, {layer: this});\n    }\n    return null;\n  }\n\n  renderSubLayers(props) {\n    return this.props.renderSubLayers(props);\n  }\n\n  getHighlightedObjectIndex() {\n    return -1;\n  }\n\n  getPickingInfo({info, sourceLayer}) {\n    info.sourceLayer = sourceLayer;\n    info.tile = sourceLayer.props.tile;\n    return info;\n  }\n\n  renderLayers() {\n    const {visible} = this.props;\n    return this.state.tileset.tiles.map(tile => {\n      // For a tile to be visible:\n      // - parent layer must be visible\n      // - tile must be visible in the current viewport\n      const isVisible = visible && tile.isVisible;\n      const highlightedObjectIndex = this.getHighlightedObjectIndex(tile);\n      // cache the rendered layer in the tile\n      if (!tile.isLoaded) {\n        // no op\n      } else if (!tile.layers) {\n        const layers = this.renderSubLayers(\n          Object.assign({}, this.props, {\n            id: `${this.id}-${tile.x}-${tile.y}-${tile.z}`,\n            data: tile.data,\n            visible: isVisible,\n            _offset: 0,\n            tile,\n            highlightedObjectIndex\n          })\n        );\n        tile.layers = flatten(layers, Boolean);\n      } else if (\n        tile.layers[0] &&\n        (tile.layers[0].props.visible !== isVisible ||\n          tile.layers[0].props.highlightedObjectIndex !== highlightedObjectIndex)\n      ) {\n        tile.layers = tile.layers.map(layer =>\n          layer.clone({visible: isVisible, highlightedObjectIndex})\n        );\n      }\n      return tile.layers;\n    });\n  }\n}\n\nTileLayer.layerName = 'TileLayer';\nTileLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}