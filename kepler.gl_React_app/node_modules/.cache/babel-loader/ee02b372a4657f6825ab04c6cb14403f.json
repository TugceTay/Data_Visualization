{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport Tile2DHeader from './tile-2d-header';\nimport { getTileIndices as _getTileIndices, tileToBoundingBox } from './utils';\nimport { RequestScheduler } from '@loaders.gl/loader-utils';\nvar TILE_STATE_UNKNOWN = 0;\nvar TILE_STATE_VISIBLE = 1;\nvar TILE_STATE_PLACEHOLDER = 3;\nvar TILE_STATE_HIDDEN = 4;\nvar TILE_STATE_SELECTED = 5;\nexport var STRATEGY_NEVER = 'never';\nexport var STRATEGY_REPLACE = 'no-overlap';\nexport var STRATEGY_DEFAULT = 'best-available';\nvar DEFAULT_CACHE_SCALE = 5;\nvar Tileset2D = function () {\n  function Tileset2D(opts) {\n    var _this = this;\n    _classCallCheck(this, Tileset2D);\n    this.opts = opts;\n    this._getTileData = opts.getTileData;\n    this.onTileError = opts.onTileError;\n    this.onTileLoad = function (tile) {\n      opts.onTileLoad(tile);\n      if (_this.opts.maxCacheByteSize) {\n        _this._cacheByteSize += tile.byteLength;\n        _this._resizeCache();\n      }\n    };\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n    this.setOptions(opts);\n  }\n  _createClass(Tileset2D, [{\n    key: \"setOptions\",\n    value: function setOptions(opts) {\n      Object.assign(this.opts, opts);\n      if (Number.isFinite(opts.maxZoom)) {\n        this._maxZoom = Math.floor(opts.maxZoom);\n      }\n      if (Number.isFinite(opts.minZoom)) {\n        this._minZoom = Math.ceil(opts.minZoom);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(viewport) {\n      var _this2 = this;\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        zRange = _ref.zRange;\n      if (!viewport.equals(this._viewport)) {\n        this._viewport = viewport;\n        var tileIndices = this.getTileIndices({\n          viewport: viewport,\n          maxZoom: this._maxZoom,\n          minZoom: this._minZoom,\n          zRange: zRange\n        });\n        this._selectedTiles = tileIndices.map(function (index) {\n          return _this2._getTile(index, true);\n        });\n        if (this._dirty) {\n          this._rebuildTree();\n        }\n      }\n      var changed = this.updateTileStates();\n      if (this._dirty) {\n        this._resizeCache();\n      }\n      if (changed) {\n        this._frameNumber++;\n      }\n      return this._frameNumber;\n    }\n  }, {\n    key: \"getTileIndices\",\n    value: function getTileIndices(_ref2) {\n      var viewport = _ref2.viewport,\n        maxZoom = _ref2.maxZoom,\n        minZoom = _ref2.minZoom,\n        zRange = _ref2.zRange;\n      var _this$opts = this.opts,\n        tileSize = _this$opts.tileSize,\n        extent = _this$opts.extent;\n      return _getTileIndices({\n        viewport: viewport,\n        maxZoom: maxZoom,\n        minZoom: minZoom,\n        zRange: zRange,\n        tileSize: tileSize,\n        extent: extent\n      });\n    }\n  }, {\n    key: \"getTileMetadata\",\n    value: function getTileMetadata(_ref3) {\n      var x = _ref3.x,\n        y = _ref3.y,\n        z = _ref3.z;\n      return {\n        bbox: tileToBoundingBox(this._viewport, x, y, z)\n      };\n    }\n  }, {\n    key: \"getParentIndex\",\n    value: function getParentIndex(tileIndex) {\n      tileIndex.x = Math.floor(tileIndex.x / 2);\n      tileIndex.y = Math.floor(tileIndex.y / 2);\n      tileIndex.z -= 1;\n      return tileIndex;\n    }\n  }, {\n    key: \"updateTileStates\",\n    value: function updateTileStates() {\n      this._updateTileStates(this.selectedTiles);\n      var changed = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = this._cache.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var tile = _step.value;\n          var isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n          if (tile.isVisible !== isVisible) {\n            changed = true;\n            tile.isVisible = isVisible;\n          }\n          tile.isSelected = tile.state === TILE_STATE_SELECTED;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return changed;\n    }\n  }, {\n    key: \"_rebuildTree\",\n    value: function _rebuildTree() {\n      var _cache = this._cache;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        for (var _iterator2 = _cache.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var tile = _step2.value;\n          tile.parent = null;\n          tile.children.length = 0;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n      try {\n        for (var _iterator3 = _cache.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _tile = _step3.value;\n          var parent = this._getNearestAncestor(_tile.x, _tile.y, _tile.z);\n          _tile.parent = parent;\n          if (parent) {\n            parent.children.push(_tile);\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateTileStates\",\n    value: function _updateTileStates(selectedTiles) {\n      var _cache = this._cache;\n      var refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n      try {\n        for (var _iterator4 = _cache.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var tile = _step4.value;\n          tile.state = TILE_STATE_UNKNOWN;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n            _iterator4[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n      try {\n        for (var _iterator5 = selectedTiles[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _tile2 = _step5.value;\n          _tile2.state = TILE_STATE_SELECTED;\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n            _iterator5[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n      if (refinementStrategy === STRATEGY_NEVER) {\n        return;\n      }\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n      try {\n        for (var _iterator6 = selectedTiles[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _tile3 = _step6.value;\n          getPlaceholderInAncestors(_tile3, refinementStrategy);\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n            _iterator6[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n      try {\n        for (var _iterator7 = selectedTiles[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var _tile4 = _step7.value;\n          if (needsPlaceholder(_tile4)) {\n            getPlaceholderInChildren(_tile4);\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n            _iterator7[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_resizeCache\",\n    value: function _resizeCache() {\n      var _cache = this._cache,\n        opts = this.opts;\n      var maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n      var maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n      var overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n      if (overflown) {\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n        try {\n          for (var _iterator8 = _cache[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var _step8$value = _slicedToArray(_step8.value, 2),\n              tileId = _step8$value[0],\n              tile = _step8$value[1];\n            if (!tile.isVisible) {\n              this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n              _cache[\"delete\"](tileId);\n            }\n            if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8[\"return\"] != null) {\n              _iterator8[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n        this._rebuildTree();\n        this._dirty = true;\n      }\n      if (this._dirty) {\n        this._tiles = Array.from(this._cache.values()).sort(function (t1, t2) {\n          return t1.z - t2.z;\n        });\n        this._dirty = false;\n      }\n    }\n  }, {\n    key: \"_getTile\",\n    value: function _getTile(_ref4, create) {\n      var x = _ref4.x,\n        y = _ref4.y,\n        z = _ref4.z;\n      var tileId = \"\".concat(x, \",\").concat(y, \",\").concat(z);\n      var tile = this._cache.get(tileId);\n      if (!tile && create) {\n        tile = new Tile2DHeader({\n          x: x,\n          y: y,\n          z: z,\n          onTileLoad: this.onTileLoad,\n          onTileError: this.onTileError\n        });\n        Object.assign(tile, this.getTileMetadata(tile));\n        tile.loadData(this._getTileData, this._requestScheduler);\n        this._cache.set(tileId, tile);\n        this._dirty = true;\n      } else if (tile && tile.isCancelled) {\n        tile.loadData(this._getTileData, this._requestScheduler);\n      }\n      return tile;\n    }\n  }, {\n    key: \"_getNearestAncestor\",\n    value: function _getNearestAncestor(x, y, z) {\n      var _this$_minZoom = this._minZoom,\n        _minZoom = _this$_minZoom === void 0 ? 0 : _this$_minZoom;\n      var index = {\n        x: x,\n        y: y,\n        z: z\n      };\n      while (index.z > _minZoom) {\n        index = this.getParentIndex(index);\n        var parent = this._getTile(index);\n        if (parent) {\n          return parent;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"tiles\",\n    get: function get() {\n      return this._tiles;\n    }\n  }, {\n    key: \"selectedTiles\",\n    get: function get() {\n      return this._selectedTiles;\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return this._selectedTiles.every(function (tile) {\n        return tile.isLoaded;\n      });\n    }\n  }]);\n  return Tileset2D;\n}();\nexport { Tileset2D as default };\nfunction needsPlaceholder(tile) {\n  var t = tile;\n  while (t) {\n    if (t.state & TILE_STATE_VISIBLE === 0) {\n      return true;\n    }\n    if (t.isLoaded) {\n      return false;\n    }\n    t = t.parent;\n  }\n  return true;\n}\nfunction getPlaceholderInAncestors(tile, refinementStrategy) {\n  var parent;\n  var state = TILE_STATE_PLACEHOLDER;\n  while (parent = tile.parent) {\n    if (tile.isLoaded) {\n      state = TILE_STATE_HIDDEN;\n      if (refinementStrategy === STRATEGY_DEFAULT) {\n        return;\n      }\n    }\n    parent.state = Math.max(parent.state, state);\n    tile = parent;\n  }\n}\nfunction getPlaceholderInChildren(tile) {\n  var _iteratorNormalCompletion9 = true;\n  var _didIteratorError9 = false;\n  var _iteratorError9 = undefined;\n  try {\n    for (var _iterator9 = tile.children[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n      var child = _step9.value;\n      child.state = Math.max(child.state, TILE_STATE_PLACEHOLDER);\n      if (!child.isLoaded) {\n        getPlaceholderInChildren(child);\n      }\n    }\n  } catch (err) {\n    _didIteratorError9 = true;\n    _iteratorError9 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion9 && _iterator9[\"return\"] != null) {\n        _iterator9[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError9) {\n        throw _iteratorError9;\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../../src/tile-layer/tileset-2d.js"],"names":["Tile2DHeader","getTileIndices","tileToBoundingBox","RequestScheduler","TILE_STATE_UNKNOWN","TILE_STATE_VISIBLE","TILE_STATE_PLACEHOLDER","TILE_STATE_HIDDEN","TILE_STATE_SELECTED","STRATEGY_NEVER","STRATEGY_REPLACE","STRATEGY_DEFAULT","DEFAULT_CACHE_SCALE","Tileset2D","opts","_getTileData","getTileData","onTileError","onTileLoad","tile","maxCacheByteSize","_cacheByteSize","byteLength","_resizeCache","_requestScheduler","maxRequests","throttleRequests","_cache","Map","_tiles","_dirty","_viewport","_selectedTiles","_frameNumber","setOptions","every","isLoaded","Object","assign","Number","isFinite","maxZoom","_maxZoom","Math","floor","minZoom","_minZoom","ceil","viewport","zRange","equals","tileIndices","map","_getTile","index","_rebuildTree","changed","updateTileStates","tileSize","extent","x","y","z","bbox","tileIndex","_updateTileStates","selectedTiles","values","isVisible","Boolean","state","isSelected","parent","children","length","_getNearestAncestor","push","refinementStrategy","getPlaceholderInAncestors","needsPlaceholder","getPlaceholderInChildren","maxCacheSize","Infinity","overflown","size","tileId","from","sort","t1","t2","create","get","getTileMetadata","loadData","set","isCancelled","getParentIndex","t","max","child"],"mappings":"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","sourcesContent":["import Tile2DHeader from './tile-2d-header';\nimport {getTileIndices, tileToBoundingBox} from './utils';\nimport {RequestScheduler} from '@loaders.gl/loader-utils';\n\nconst TILE_STATE_UNKNOWN = 0;\nconst TILE_STATE_VISIBLE = 1;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\nconst TILE_STATE_PLACEHOLDER = 3;\nconst TILE_STATE_HIDDEN = 4;\n// tiles that should be displayed in the current viewport\nconst TILE_STATE_SELECTED = 5;\n\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\n\nconst DEFAULT_CACHE_SCALE = 5;\n\n/**\n * Manages loading and purging of tiles data. This class caches recently visited tiles\n * and only create new tiles if they are present.\n */\n\nexport default class Tileset2D {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts) {\n    this.opts = opts;\n    this._getTileData = opts.getTileData;\n\n    this.onTileError = opts.onTileError;\n    this.onTileLoad = tile => {\n      opts.onTileLoad(tile);\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n\n    this.setOptions(opts);\n  }\n\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  /**\n   * Update the cache with the given viewport and triggers callback onUpdate.\n   * @param {*} viewport\n   * @param {*} onUpdate\n   */\n  update(viewport, {zRange} = {}) {\n    if (!viewport.equals(this._viewport)) {\n      this._viewport = viewport;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n    }\n\n    // Update tile states\n    const changed = this.updateTileStates();\n\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n    return this._frameNumber;\n  }\n\n  /* Public interface for subclassing */\n\n  // Returns array of {x, y, z}\n  getTileIndices({viewport, maxZoom, minZoom, zRange}) {\n    const {tileSize, extent} = this.opts;\n    return getTileIndices({viewport, maxZoom, minZoom, zRange, tileSize, extent});\n  }\n\n  // Add custom metadata to tiles\n  getTileMetadata({x, y, z}) {\n    return {bbox: tileToBoundingBox(this._viewport, x, y, z)};\n  }\n\n  // Returns {x, y, z} of the parent tile\n  getParentIndex(tileIndex) {\n    // Perf: mutate the input object to avoid GC\n    tileIndex.x = Math.floor(tileIndex.x / 2);\n    tileIndex.y = Math.floor(tileIndex.y / 2);\n    tileIndex.z -= 1;\n    return tileIndex;\n  }\n\n  // Returns true if any tile's visibility changed\n  updateTileStates() {\n    this._updateTileStates(this.selectedTiles);\n\n    let changed = false;\n    for (const tile of this._cache.values()) {\n      const isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n      if (tile.isVisible !== isVisible) {\n        changed = true;\n        tile.isVisible = isVisible;\n      }\n\n      // isSelected used in request scheduler\n      tile.isSelected = tile.state === TILE_STATE_SELECTED;\n    }\n\n    return changed;\n  }\n\n  /* Private methods */\n\n  // This needs to be called every time some tiles have been added/removed from cache\n  _rebuildTree() {\n    const {_cache} = this;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      tile.children.length = 0;\n    }\n\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile.x, tile.y, tile.z);\n      tile.parent = parent;\n      if (parent) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  // A selected tile is always visible.\n  // Never show two overlapping tiles.\n  // If a selected tile is loading, try showing a cached ancester with the closest z\n  // If a selected tile is loading, and no ancester is shown - try showing cached\n  // descendants with the closest z\n  _updateTileStates(selectedTiles) {\n    const {_cache} = this;\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.state = TILE_STATE_UNKNOWN;\n    }\n\n    // For all the selected && pending tiles:\n    // - pick the closest ancestor as placeholder\n    // - if no ancestor is visible, pick the closest children as placeholder\n    for (const tile of selectedTiles) {\n      tile.state = TILE_STATE_SELECTED;\n    }\n\n    if (refinementStrategy === STRATEGY_NEVER) {\n      return;\n    }\n    for (const tile of selectedTiles) {\n      getPlaceholderInAncestors(tile, refinementStrategy);\n    }\n    for (const tile of selectedTiles) {\n      if (needsPlaceholder(tile)) {\n        getPlaceholderInChildren(tile);\n      }\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  _resizeCache() {\n    const {_cache, opts} = this;\n\n    const maxCacheSize =\n      opts.maxCacheSize ||\n      (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [tileId, tile] of _cache) {\n        if (!tile.isVisible) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n          _cache.delete(tileId);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values())\n        // sort by zoom level so that smaller tiles are displayed on top\n        .sort((t1, t2) => t1.z - t2.z);\n\n      this._dirty = false;\n    }\n  }\n  /* eslint-enable complexity */\n\n  _getTile({x, y, z}, create) {\n    const tileId = `${x},${y},${z}`;\n    let tile = this._cache.get(tileId);\n\n    if (!tile && create) {\n      tile = new Tile2DHeader({\n        x,\n        y,\n        z,\n        onTileLoad: this.onTileLoad,\n        onTileError: this.onTileError\n      });\n      Object.assign(tile, this.getTileMetadata(tile));\n      tile.loadData(this._getTileData, this._requestScheduler);\n      this._cache.set(tileId, tile);\n      this._dirty = true;\n    } else if (tile && tile.isCancelled) {\n      tile.loadData(this._getTileData, this._requestScheduler);\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(x, y, z) {\n    const {_minZoom = 0} = this;\n    let index = {x, y, z};\n\n    while (index.z > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n\n// A selected tile needs placeholder from its children if\n// - it is not loaded\n// - none of its ancestors is visible and loaded\nfunction needsPlaceholder(tile) {\n  let t = tile;\n  while (t) {\n    if (t.state & (TILE_STATE_VISIBLE === 0)) {\n      return true;\n    }\n    if (t.isLoaded) {\n      return false;\n    }\n    t = t.parent;\n  }\n  return true;\n}\n\nfunction getPlaceholderInAncestors(tile, refinementStrategy) {\n  let parent;\n  let state = TILE_STATE_PLACEHOLDER;\n  while ((parent = tile.parent)) {\n    if (tile.isLoaded) {\n      // If a tile is loaded, mark all its ancestors as hidden\n      state = TILE_STATE_HIDDEN;\n      if (refinementStrategy === STRATEGY_DEFAULT) {\n        return;\n      }\n    }\n    parent.state = Math.max(parent.state, state);\n    tile = parent;\n  }\n}\n\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    child.state = Math.max(child.state, TILE_STATE_PLACEHOLDER);\n    if (!child.isLoaded) {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}