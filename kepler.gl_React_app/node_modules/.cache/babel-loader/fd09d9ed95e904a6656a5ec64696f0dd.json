{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport assert from '../utils/assert';\nvar Schema = function () {\n  function Schema(fields) {\n    var metadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, Schema);\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n  _createClass(Schema, [{\n    key: \"compareTo\",\n    value: function compareTo(other) {\n      if (this.fields.metadata !== other.fields.metadata) {\n        return false;\n      }\n      if (this.fields.length !== other.fields.length) {\n        return false;\n      }\n      for (var i = 0; i < this.fields.length; ++i) {\n        if (!this.fields[i].compareTo(other.fields[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"select\",\n    value: function select() {\n      var nameMap = Object.create(null);\n      for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {\n        columnNames[_key] = arguments[_key];\n      }\n      for (var _i = 0, _columnNames = columnNames; _i < _columnNames.length; _i++) {\n        var name = _columnNames[_i];\n        nameMap[name] = true;\n      }\n      var selectedFields = columnNames.filter(function (field) {\n        return nameMap[field.name];\n      });\n      return new Schema(selectedFields, this.metadata);\n    }\n  }, {\n    key: \"selectAt\",\n    value: function selectAt() {\n      var _this = this;\n      for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        columnIndices[_key2] = arguments[_key2];\n      }\n      var selectedFields = columnIndices.map(function (index) {\n        return _this.fields[index];\n      }).filter(Boolean);\n      return new Schema(selectedFields, this.metadata);\n    }\n  }, {\n    key: \"assign\",\n    value: function assign(schemaOrFields) {\n      var metadata = this.metadata;\n      var fields = schemaOrFields;\n      if (schemaOrFields instanceof Schema) {\n        var otherSchema = schemaOrFields;\n        fields = otherSchema.fields;\n        metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n      }\n      var fieldMap = Object.create(null);\n      var _iterator = _createForOfIteratorHelper(this.fields),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var field = _step.value;\n          fieldMap[field.name] = field;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(fields),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _field = _step2.value;\n          fieldMap[_field.name] = _field;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var mergedFields = Object.values(fieldMap);\n      return new Schema(mergedFields, metadata);\n    }\n  }]);\n  return Schema;\n}();\nexport { Schema as default };\nfunction checkNames(fields) {\n  var usedNames = {};\n  var _iterator3 = _createForOfIteratorHelper(fields),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var field = _step3.value;\n      if (usedNames[field.name]) {\n        console.warn('Schema: duplicated field name', field.name, field);\n      }\n      usedNames[field.name] = true;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\nfunction mergeMaps(m1, m2) {\n  return new Map([].concat(_toConsumableArray(m1 || new Map()), _toConsumableArray(m2 || new Map())));\n}","map":{"version":3,"sources":["../../../../src/lib/schema/schema.js"],"names":["assert","Schema","fields","metadata","Array","isArray","checkNames","Map","other","length","i","compareTo","columnNames","nameMap","Object","create","name","selectedFields","filter","field","columnIndices","map","index","Boolean","schemaOrFields","otherSchema","mergeMaps","fieldMap","mergedFields","values","usedNames","console","warn","m1","m2"],"mappings":"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","sourcesContent":["import assert from '../utils/assert';\n\n// ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n// https://loaders.gl/arrowjs/docs/api-reference/schema\nexport default class Schema {\n  constructor(fields, metadata = null) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields\n  compareTo(other) {\n    if (this.fields.metadata !== other.fields.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames) {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = columnNames.filter(field => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices) {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map(index => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields) {\n    let metadata = this.metadata;\n\n    let fields = schemaOrFields;\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields) {\n  const usedNames = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps(m1, m2) {\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n"]},"metadata":{},"sourceType":"module"}