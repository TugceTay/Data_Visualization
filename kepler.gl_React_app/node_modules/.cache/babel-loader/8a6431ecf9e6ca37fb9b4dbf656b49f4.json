{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { Vector3, Matrix4 } from '@math.gl/core';\nimport { CullingVolume } from '@math.gl/culling';\nimport { load } from '@loaders.gl/core';\nimport { assert, path } from '@loaders.gl/loader-utils';\nimport { TILE_REFINEMENT, TILE_CONTENT_STATE, TILESET_TYPE } from '../constants';\nimport { createBoundingVolume } from './helpers/bounding-volume';\nimport { getTiles3DScreenSpaceError } from './helpers/tiles-3d-lod';\nimport { getI3ScreenSize } from './helpers/i3s-lod';\nvar scratchVector = new Vector3();\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\nvar TileHeader = function () {\n  function TileHeader(tileset, header, parentHeader) {\n    _classCallCheck(this, TileHeader);\n    assert(_typeof(header) === 'object');\n    this.header = header;\n    this.tileset = tileset;\n    this.id = header.id;\n    this.url = header.url;\n    this.parent = parentHeader;\n    this.refine = this._getRefine(header.refine);\n    this.type = header.type;\n    this.contentUrl = header.contentUrl;\n    this.lodMetricType = null;\n    this.lodMetricValue = null;\n    this.boundingVolume = null;\n    this.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    this.gpuMemoryUsageInBytes = 0;\n    this.children = [];\n    this.depth = 0;\n    this._cacheNode = null;\n    this._frameNumber = null;\n    this._cacheNode = null;\n    this._initializeLodMetric(header);\n    this._initializeTransforms(header);\n    this._initializeBoundingVolumes(header);\n    this._initializeContent(header);\n    this._initializeRenderingState(header);\n    this._lodJudge = null;\n    this._expireDate = null;\n    this._expiredContent = null;\n    this._getPriority = this._getPriority.bind(this);\n    Object.seal(this);\n  }\n  _createClass(TileHeader, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.header = null;\n    }\n  }, {\n    key: \"isDestroyed\",\n    value: function isDestroyed() {\n      return this.header === null;\n    }\n  }, {\n    key: \"getScreenSpaceError\",\n    value: function getScreenSpaceError(frameState, useParentLodMetric) {\n      switch (this.tileset.type) {\n        case TILESET_TYPE.I3S:\n          return getI3ScreenSize(this, frameState);\n        case TILESET_TYPE.TILES3D:\n          return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);\n        default:\n          console.error('Unsupported tileset type');\n          return null;\n      }\n    }\n  }, {\n    key: \"_getPriority\",\n    value: function _getPriority() {\n      if (!this.isVisible) {\n        return -1;\n      }\n      if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {\n        return -1;\n      }\n      return Math.max(1e7 - this._priority, 0) || 0;\n    }\n  }, {\n    key: \"loadContent\",\n    value: function () {\n      var _loadContent = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {\n        var expired, requestToken, contentUrl, fetchOptions, loader, options;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.hasEmptyContent) {\n                  _context.next = 2;\n                  break;\n                }\n                return _context.abrupt(\"return\", false);\n              case 2:\n                if (!this.content) {\n                  _context.next = 4;\n                  break;\n                }\n                return _context.abrupt(\"return\", true);\n              case 4:\n                expired = this.contentExpired;\n                if (expired) {\n                  this._expireDate = null;\n                }\n                this.contentState = TILE_CONTENT_STATE.LOADING;\n                _context.next = 9;\n                return this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority);\n              case 9:\n                requestToken = _context.sent;\n                if (requestToken) {\n                  _context.next = 13;\n                  break;\n                }\n                this.contentState = TILE_CONTENT_STATE.UNLOADED;\n                return _context.abrupt(\"return\", false);\n              case 13:\n                _context.prev = 13;\n                contentUrl = this.tileset.getTileUrl(this.contentUrl);\n                fetchOptions = this.tileset.fetchOptions;\n                loader = this.tileset.loader;\n                options = _objectSpread(_objectSpread({}, fetchOptions), {}, _defineProperty({}, loader.id, {\n                  tile: this.header,\n                  tileset: this.tileset.tileset,\n                  isTileset: 'auto',\n                  isTileHeader: false,\n                  assetGltfUpAxis: this.tileset.asset.gltfUpAxis\n                }));\n                _context.next = 20;\n                return load(contentUrl, loader, options);\n              case 20:\n                this.content = _context.sent;\n                if (this._isTileset()) {\n                  this.tileset._initializeTileHeaders(this.content, this, path.dirname(this.contentUrl));\n                }\n                this.contentState = TILE_CONTENT_STATE.READY;\n                this._onContentLoaded();\n                return _context.abrupt(\"return\", true);\n              case 27:\n                _context.prev = 27;\n                _context.t0 = _context[\"catch\"](13);\n                this.contentState = TILE_CONTENT_STATE.FAILED;\n                throw _context.t0;\n              case 31:\n                _context.prev = 31;\n                requestToken.done();\n                return _context.finish(31);\n              case 34:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[13, 27, 31, 34]]);\n      }));\n      function loadContent() {\n        return _loadContent.apply(this, arguments);\n      }\n      return loadContent;\n    }()\n  }, {\n    key: \"unloadContent\",\n    value: function unloadContent() {\n      if (this.content && this.content.destroy) {\n        this.content.destroy();\n      }\n      this.content = null;\n      this.contentState = TILE_CONTENT_STATE.UNLOADED;\n      return true;\n    }\n  }, {\n    key: \"updateVisibility\",\n    value: function updateVisibility(frameState) {\n      if (this._frameNumber === frameState.frameNumber) {\n        return;\n      }\n      var parent = this.parent;\n      var parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;\n      var parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;\n      this._updateTransform(parentTransform);\n      this._distanceToCamera = this.distanceToTile(frameState);\n      this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n      this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask);\n      this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n      this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n      this._priority = this.lodMetricValue;\n      this._frameNumber = frameState.frameNumber;\n    }\n  }, {\n    key: \"visibility\",\n    value: function visibility(frameState, parentVisibilityPlaneMask) {\n      var cullingVolume = frameState.cullingVolume;\n      var boundingVolume = this.boundingVolume;\n      return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    }\n  }, {\n    key: \"contentVisibility\",\n    value: function contentVisibility(frameState) {\n      return true;\n    }\n  }, {\n    key: \"distanceToTile\",\n    value: function distanceToTile(frameState) {\n      var boundingVolume = this.boundingVolume;\n      return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));\n    }\n  }, {\n    key: \"cameraSpaceZDepth\",\n    value: function cameraSpaceZDepth(_ref) {\n      var camera = _ref.camera;\n      var boundingVolume = this.boundingVolume;\n      scratchVector.subVectors(boundingVolume.center, camera.position);\n      return camera.direction.dot(scratchVector);\n    }\n  }, {\n    key: \"insideViewerRequestVolume\",\n    value: function insideViewerRequestVolume(frameState) {\n      var viewerRequestVolume = this._viewerRequestVolume;\n      return !viewerRequestVolume || viewerRequestVolume.distanceToCamera(frameState.camera.position) === 0.0;\n    }\n  }, {\n    key: \"_initializeLodMetric\",\n    value: function _initializeLodMetric(header) {\n      if ('lodMetricType' in header) {\n        this.lodMetricType = header.lodMetricType;\n      } else {\n        this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType;\n        console.warn(\"3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType\");\n      }\n      if ('lodMetricValue' in header) {\n        this.lodMetricValue = header.lodMetricValue;\n      } else {\n        this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue;\n        console.warn(\"3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue\");\n      }\n    }\n  }, {\n    key: \"_initializeTransforms\",\n    value: function _initializeTransforms(tileHeader) {\n      this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n      var parent = this.parent;\n      var tileset = this.tileset;\n      var parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();\n      this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n      var parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n      this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n    }\n  }, {\n    key: \"_initializeBoundingVolumes\",\n    value: function _initializeBoundingVolumes(tileHeader) {\n      this._contentBoundingVolume = null;\n      this._viewerRequestVolume = null;\n      this._updateBoundingVolume(tileHeader);\n    }\n  }, {\n    key: \"_initializeContent\",\n    value: function _initializeContent(tileHeader) {\n      this.content = {\n        _tileset: this.tileset,\n        _tile: this\n      };\n      this.hasEmptyContent = true;\n      this.contentState = TILE_CONTENT_STATE.UNLOADED;\n      this.hasTilesetContent = false;\n      if (tileHeader.contentUrl) {\n        this.content = null;\n        this.hasEmptyContent = false;\n      }\n    }\n  }, {\n    key: \"_initializeRenderingState\",\n    value: function _initializeRenderingState(header) {\n      this.depth = header.level;\n      this._shouldRefine = false;\n      this._distanceToCamera = 0;\n      this._centerZDepth = 0;\n      this._screenSpaceError = 0;\n      this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n      this._visible = false;\n      this._inRequestVolume = false;\n      this._stackLength = 0;\n      this._selectionDepth = 0;\n      this._frameNumber = 0;\n      this._touchedFrame = 0;\n      this._visitedFrame = 0;\n      this._selectedFrame = 0;\n      this._requestedFrame = 0;\n      this._priority = 0.0;\n    }\n  }, {\n    key: \"_getRefine\",\n    value: function _getRefine(refine) {\n      return refine || this.parent && this.parent.refine || TILE_REFINEMENT.REPLACE;\n    }\n  }, {\n    key: \"_isTileset\",\n    value: function _isTileset() {\n      return this.contentUrl.indexOf('.json') !== -1;\n    }\n  }, {\n    key: \"_onContentLoaded\",\n    value: function _onContentLoaded() {\n      switch (this.content && this.content.type) {\n        case 'vctr':\n        case 'geom':\n          this.tileset.traverser.disableSkipLevelOfDetail = true;\n          break;\n        default:\n      }\n      if (this._isTileset()) {\n        this.hasTilesetContent = true;\n      }\n    }\n  }, {\n    key: \"_updateBoundingVolume\",\n    value: function _updateBoundingVolume(header) {\n      this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);\n      var content = header.content;\n      if (!content) {\n        return;\n      }\n      if (content.boundingVolume) {\n        this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);\n      }\n      if (header.viewerRequestVolume) {\n        this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);\n      }\n    }\n  }, {\n    key: \"_updateTransform\",\n    value: function _updateTransform() {\n      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix4();\n      var computedTransform = parentTransform.clone().multiplyRight(this.transform);\n      var didTransformChange = !computedTransform.equals(this.computedTransform);\n      if (!didTransformChange) {\n        return;\n      }\n      this.computedTransform = computedTransform;\n      this._updateBoundingVolume(this.header);\n    }\n  }, {\n    key: \"updateExpiration\",\n    value: function updateExpiration() {\n      if (defined(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n        var now = Date.now();\n        if (Date.lessThan(this._expireDate, now)) {\n          this.contentState = TILE_CONTENT_STATE.EXPIRED;\n          this._expiredContent = this.content;\n        }\n      }\n    }\n  }, {\n    key: \"selected\",\n    get: function get() {\n      return this._selectedFrame === this.tileset._frameNumber;\n    }\n  }, {\n    key: \"isVisible\",\n    get: function get() {\n      return this._visible;\n    }\n  }, {\n    key: \"isVisibleAndInRequestVolume\",\n    get: function get() {\n      return this._visible && this._inRequestVolume;\n    }\n  }, {\n    key: \"hasRenderContent\",\n    get: function get() {\n      return !this.hasEmptyContent && !this.hasTilesetContent;\n    }\n  }, {\n    key: \"hasChildren\",\n    get: function get() {\n      return this.children.length > 0 || this.header.children && this.header.children.length > 0;\n    }\n  }, {\n    key: \"contentReady\",\n    get: function get() {\n      return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;\n    }\n  }, {\n    key: \"contentAvailable\",\n    get: function get() {\n      return Boolean(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);\n    }\n  }, {\n    key: \"hasUnloadedContent\",\n    get: function get() {\n      return this.hasRenderContent && this.contentUnloaded;\n    }\n  }, {\n    key: \"contentUnloaded\",\n    get: function get() {\n      return this.contentState === TILE_CONTENT_STATE.UNLOADED;\n    }\n  }, {\n    key: \"contentExpired\",\n    get: function get() {\n      return this.contentState === TILE_CONTENT_STATE.EXPIRED;\n    }\n  }, {\n    key: \"contentFailed\",\n    get: function get() {\n      return this.contentState === TILE_CONTENT_STATE.FAILED;\n    }\n  }, {\n    key: \"extras\",\n    get: function get() {\n      return this.header.extras;\n    }\n  }]);\n  return TileHeader;\n}();\nexport { TileHeader as default };","map":{"version":3,"sources":["../../../src/tileset/tile-3d.js"],"names":["Vector3","Matrix4","CullingVolume","load","assert","path","TILE_REFINEMENT","TILE_CONTENT_STATE","TILESET_TYPE","createBoundingVolume","getTiles3DScreenSpaceError","getI3ScreenSize","scratchVector","defined","x","undefined","TileHeader","tileset","header","parentHeader","id","url","parent","refine","_getRefine","type","contentUrl","lodMetricType","lodMetricValue","boundingVolume","content","contentState","UNLOADED","gpuMemoryUsageInBytes","children","depth","_cacheNode","_frameNumber","_initializeLodMetric","_initializeTransforms","_initializeBoundingVolumes","_initializeContent","_initializeRenderingState","_lodJudge","_expireDate","_expiredContent","_getPriority","bind","Object","seal","_selectedFrame","_visible","_inRequestVolume","hasEmptyContent","hasTilesetContent","length","READY","Boolean","contentReady","hasRenderContent","contentFailed","contentUnloaded","EXPIRED","FAILED","frameState","useParentLodMetric","I3S","TILES3D","console","error","isVisible","Math","max","_priority","expired","contentExpired","LOADING","requestToken","_requestScheduler","scheduleRequest","getTileUrl","fetchOptions","loader","options","tile","isTileset","isTileHeader","assetGltfUpAxis","asset","gltfUpAxis","_isTileset","_initializeTileHeaders","dirname","_onContentLoaded","done","destroy","frameNumber","parentTransform","computedTransform","modelMatrix","parentVisibilityPlaneMask","_visibilityPlaneMask","MASK_INDETERMINATE","_updateTransform","_distanceToCamera","distanceToTile","_screenSpaceError","getScreenSpaceError","visibility","MASK_OUTSIDE","insideViewerRequestVolume","cullingVolume","computeVisibilityWithPlaneMask","sqrt","distanceSquaredTo","camera","position","subVectors","center","direction","dot","viewerRequestVolume","_viewerRequestVolume","distanceToCamera","warn","tileHeader","transform","clone","multiplyRight","parentInitialTransform","_initialTransform","_contentBoundingVolume","_updateBoundingVolume","_tileset","_tile","level","_shouldRefine","_centerZDepth","_stackLength","_selectionDepth","_touchedFrame","_visitedFrame","_requestedFrame","REPLACE","indexOf","traverser","disableSkipLevelOfDetail","didTransformChange","equals","now","Date","lessThan","extras"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport {Vector3, Matrix4} from '@math.gl/core';\nimport {CullingVolume} from '@math.gl/culling';\n\nimport {load} from '@loaders.gl/core';\nimport {assert, path} from '@loaders.gl/loader-utils';\nimport {TILE_REFINEMENT, TILE_CONTENT_STATE, TILESET_TYPE} from '../constants';\n\nimport {createBoundingVolume} from './helpers/bounding-volume';\nimport {getTiles3DScreenSpaceError} from './helpers/tiles-3d-lod';\nimport {getI3ScreenSize} from './helpers/i3s-lod';\n\nconst scratchVector = new Vector3();\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n// A Tile3DHeader represents a tile as Tileset3D. When a tile is first created, its content is not loaded;\n// the content is loaded on-demand when needed based on the view.\n// Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.\nexport default class TileHeader {\n  // eslint-disable-next-line max-statements\n  constructor(tileset, header, parentHeader) {\n    assert(typeof header === 'object');\n\n    // PUBLIC MEMBERS\n    // original tile data\n    this.header = header;\n    // The tileset containing this tile.\n    this.tileset = tileset;\n    this.id = header.id;\n    this.url = header.url;\n    // This tile's parent or `undefined` if this tile is the root.\n    this.parent = parentHeader;\n    this.refine = this._getRefine(header.refine);\n    this.type = header.type;\n    this.contentUrl = header.contentUrl;\n    // The error, in meters, introduced if this tile is rendered and its children are not.\n    this.lodMetricType = null;\n    this.lodMetricValue = null;\n    // Specifies the type of refine that is used when traversing this tile for rendering.\n    this.boundingVolume = null;\n    // The tile's content.  This represents the actual tile's payload,\n    // not the content's metadata in the tileset JSON file.\n    this.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    this.gpuMemoryUsageInBytes = 0;\n    // The tile's children - an array of Tile3D objects.\n    this.children = [];\n\n    this.depth = 0;\n\n    // PRIVATE MEMBERS\n    this._cacheNode = null;\n    this._frameNumber = null;\n    this._cacheNode = null;\n\n    this._initializeLodMetric(header);\n    this._initializeTransforms(header);\n    this._initializeBoundingVolumes(header);\n    this._initializeContent(header);\n    this._initializeRenderingState(header);\n\n    // TODO i3s specific, needs to remove\n    this._lodJudge = null;\n\n    // TODO Cesium 3d tiles specific\n    this._expireDate = null;\n    this._expiredContent = null;\n\n    this._getPriority = this._getPriority.bind(this);\n\n    Object.seal(this);\n  }\n\n  destroy() {\n    this.header = null;\n  }\n\n  isDestroyed() {\n    return this.header === null;\n  }\n\n  get selected() {\n    return this._selectedFrame === this.tileset._frameNumber;\n  }\n\n  get isVisible() {\n    return this._visible;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n\n  // Returns true if tile is not an empty tile and not an external tileset\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n\n  get hasChildren() {\n    return this.children.length > 0 || (this.header.children && this.header.children.length > 0);\n  }\n\n  // Determines if the tile's content is ready. This is automatically `true` for\n  // tile's with empty content.\n  get contentReady() {\n    return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;\n  }\n\n  // Determines if the tile has available content to render.  `true` if the tile's\n  // content is ready or if it has expired content this renders while new content loads; otherwise,\n  get contentAvailable() {\n    return Boolean(\n      (this.contentReady && this.hasRenderContent) || (this._expiredContent && !this.contentFailed)\n    );\n  }\n\n  // Returns true if tile has renderable content but it's unloaded\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n\n  // Determines if the tile's content has not be requested. `true` if tile's\n  // content has not be requested; otherwise, `false`.\n  get contentUnloaded() {\n    return this.contentState === TILE_CONTENT_STATE.UNLOADED;\n  }\n\n  // Determines if the tile's content is expired. `true` if tile's\n  // content is expired; otherwise, `false`.\n  get contentExpired() {\n    return this.contentState === TILE_CONTENT_STATE.EXPIRED;\n  }\n\n  // Determines if the tile's content failed to load.  `true` if the tile's\n  // content failed to load; otherwise, `false`.\n  get contentFailed() {\n    return this.contentState === TILE_CONTENT_STATE.FAILED;\n  }\n\n  // Get the tile's screen space error.\n  getScreenSpaceError(frameState, useParentLodMetric) {\n    switch (this.tileset.type) {\n      case TILESET_TYPE.I3S:\n        return getI3ScreenSize(this, frameState);\n      case TILESET_TYPE.TILES3D:\n        return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);\n      default:\n        // eslint-disable-next-line\n        console.error('Unsupported tileset type');\n        return null;\n    }\n  }\n\n  _getPriority() {\n    // Check if any reason to abort\n    if (!this.isVisible) {\n      return -1;\n    }\n    if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {\n      return -1;\n    }\n\n    return Math.max(1e7 - this._priority, 0) || 0;\n  }\n\n  // Requests the tile's content.\n  // The request may not be made if the Request Scheduler can't prioritize it.\n  // eslint-disable-next-line max-statements\n  async loadContent() {\n    if (this.hasEmptyContent) {\n      return false;\n    }\n\n    if (this.content) {\n      return true;\n    }\n\n    const expired = this.contentExpired;\n\n    if (expired) {\n      this._expireDate = null;\n    }\n\n    this.contentState = TILE_CONTENT_STATE.LOADING;\n\n    const requestToken = await this.tileset._requestScheduler.scheduleRequest(\n      this.id,\n      this._getPriority\n    );\n\n    if (!requestToken) {\n      // cancelled\n      this.contentState = TILE_CONTENT_STATE.UNLOADED;\n      return false;\n    }\n\n    try {\n      const contentUrl = this.tileset.getTileUrl(this.contentUrl);\n      // The content can be a binary tile ot a JSON tileset\n      const fetchOptions = this.tileset.fetchOptions;\n      const loader = this.tileset.loader;\n      const options = {\n        ...fetchOptions,\n        [loader.id]: {\n          tile: this.header,\n          tileset: this.tileset.tileset,\n          isTileset: 'auto',\n          isTileHeader: false,\n          assetGltfUpAxis: this.tileset.asset.gltfUpAxis\n        }\n      };\n\n      this.content = await load(contentUrl, loader, options);\n      if (this._isTileset()) {\n        // Add tile headers for the nested tilset's subtree\n        // Async update of the tree should be fine since there would never be edits to the same node\n        // TODO - we need to capture the child tileset's URL\n        this.tileset._initializeTileHeaders(this.content, this, path.dirname(this.contentUrl));\n      }\n\n      this.contentState = TILE_CONTENT_STATE.READY;\n      this._onContentLoaded();\n      return true;\n    } catch (error) {\n      // Tile is unloaded before the content finishes loading\n      this.contentState = TILE_CONTENT_STATE.FAILED;\n      throw error;\n    } finally {\n      requestToken.done();\n    }\n  }\n\n  // Unloads the tile's content.\n  unloadContent() {\n    if (this.content && this.content.destroy) {\n      this.content.destroy();\n    }\n    this.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    return true;\n  }\n\n  // Update the tile's visibility.\n  updateVisibility(frameState) {\n    if (this._frameNumber === frameState.frameNumber) {\n      // Return early if visibility has already been checked during the traversal.\n      // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n      return;\n    }\n\n    const parent = this.parent;\n    const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;\n    const parentVisibilityPlaneMask = parent\n      ? parent._visibilityPlaneMask\n      : CullingVolume.MASK_INDETERMINATE;\n\n    this._updateTransform(parentTransform);\n    this._distanceToCamera = this.distanceToTile(frameState);\n    this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n    this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n\n    this._priority = this.lodMetricValue;\n    this._frameNumber = frameState.frameNumber;\n  }\n\n  // Determines whether the tile's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n  visibility(frameState, parentVisibilityPlaneMask) {\n    const {cullingVolume} = frameState;\n    const {boundingVolume} = this;\n\n    // TODO Cesium specific - restore clippingPlanes\n    // const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;\n    // if (clippingPlanes && clippingPlanes.enabled) {\n    //   const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n    //     boundingVolume,\n    //     clippingPlanesOriginMatrix\n    //   );\n    //   this._isClipped = intersection !== Intersect.INSIDE;\n    //   if (intersection === Intersect.OUTSIDE) {\n    //     return CullingVolume.MASK_OUTSIDE;\n    //   }\n    // }\n\n    // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n  }\n\n  // Assuming the tile's bounding volume intersects the culling volume, determines\n  // whether the tile's content's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n  contentVisibility(frameState) {\n    return true;\n\n    // TODO restore\n    /*\n    // Assumes the tile's bounding volume intersects the culling volume already, so\n    // just return Intersect.INSIDE if there is no content bounding volume.\n    if (!defined(this.contentBoundingVolume)) {\n      return Intersect.INSIDE;\n    }\n\n    if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n      // The tile's bounding volume is completely inside the culling volume so\n      // the content bounding volume must also be inside.\n      return Intersect.INSIDE;\n    }\n\n    // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n    // tile's (not the content's) bounding volume intersects the culling volume?\n    const cullingVolume = frameState.cullingVolume;\n    const boundingVolume = tile.contentBoundingVolume;\n\n    const tileset = this.tileset;\n    const clippingPlanes = tileset.clippingPlanes;\n    if (defined(clippingPlanes) && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        tileset.clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return Intersect.OUTSIDE;\n      }\n    }\n\n    return cullingVolume.computeVisibility(boundingVolume);\n    */\n  }\n\n  // Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n  distanceToTile(frameState) {\n    const boundingVolume = this.boundingVolume;\n    return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));\n  }\n\n  // Computes the tile's camera-space z-depth.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Number} The distance, in meters.\n  cameraSpaceZDepth({camera}) {\n    const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n    scratchVector.subVectors(boundingVolume.center, camera.position);\n    return camera.direction.dot(scratchVector);\n  }\n\n  /**\n   * Checks if the camera is inside the viewer request volume.\n   * @param {FrameState} frameState The frame state.\n   * @returns {Boolean} Whether the camera is inside the volume.\n   */\n  insideViewerRequestVolume(frameState) {\n    const viewerRequestVolume = this._viewerRequestVolume;\n    return (\n      !viewerRequestVolume ||\n      viewerRequestVolume.distanceToCamera(frameState.camera.position) === 0.0\n    );\n  }\n\n  _initializeLodMetric(header) {\n    if ('lodMetricType' in header) {\n      this.lodMetricType = header.lodMetricType;\n    } else {\n      this.lodMetricType = (this.parent && this.parent.lodMetricType) || this.tileset.lodMetricType;\n      // eslint-disable-next-line\n      console.warn(`3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType`);\n    }\n\n    // This is used to compute screen space error, i.e., the error measured in pixels.\n    if ('lodMetricValue' in header) {\n      this.lodMetricValue = header.lodMetricValue;\n    } else {\n      this.lodMetricValue =\n        (this.parent && this.parent.lodMetricValue) || this.tileset.lodMetricValue;\n      // eslint-disable-next-line\n      console.warn(\n        `3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue`\n      );\n    }\n  }\n\n  _initializeTransforms(tileHeader) {\n    // The local transform of this tile.\n    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n\n    const parent = this.parent;\n    const tileset = this.tileset;\n\n    const parentTransform =\n      parent && parent.computedTransform\n        ? parent.computedTransform.clone()\n        : tileset.modelMatrix.clone();\n    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n\n    const parentInitialTransform =\n      parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(tileHeader) {\n    this._contentBoundingVolume = null;\n    this._viewerRequestVolume = null;\n\n    this._updateBoundingVolume(tileHeader);\n  }\n\n  _initializeContent(tileHeader) {\n    // Empty tile by default\n    this.content = {_tileset: this.tileset, _tile: this};\n    this.hasEmptyContent = true;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n\n    // When `true`, the tile's content points to an external tileset.\n    // This is `false` until the tile's content is loaded.\n    this.hasTilesetContent = false;\n\n    if (tileHeader.contentUrl) {\n      this.content = null;\n      this.hasEmptyContent = false;\n    }\n  }\n\n  // TODO - remove anything not related to basic visibility detection\n  _initializeRenderingState(header) {\n    this.depth = header.level;\n    this._shouldRefine = false;\n\n    // Members this are updated every frame for tree traversal and rendering optimizations:\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._screenSpaceError = 0;\n    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n    this._visible = false;\n    this._inRequestVolume = false;\n\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n\n    this._frameNumber = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n\n    this._priority = 0.0;\n  }\n\n  _getRefine(refine) {\n    // Inherit from parent tile if omitted.\n    return refine || (this.parent && this.parent.refine) || TILE_REFINEMENT.REPLACE;\n  }\n\n  _isTileset() {\n    return this.contentUrl.indexOf('.json') !== -1;\n  }\n\n  _onContentLoaded() {\n    // Vector and Geometry tile rendering do not support the skip LOD optimization.\n    switch (this.content && this.content.type) {\n      case 'vctr':\n      case 'geom':\n        this.tileset.traverser.disableSkipLevelOfDetail = true;\n        break;\n      default:\n    }\n\n    // The content may be tileset json\n    if (this._isTileset()) {\n      this.hasTilesetContent = true;\n    }\n  }\n\n  _updateBoundingVolume(header) {\n    // Update the bounding volumes\n    this.boundingVolume = createBoundingVolume(\n      header.boundingVolume,\n      this.computedTransform,\n      this.boundingVolume\n    );\n\n    const content = header.content;\n    if (!content) {\n      return;\n    }\n\n    // TODO Cesium specific\n    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n    // around only the features in the tile. This box is useful for culling for rendering,\n    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n    // since it only bounds features in the tile, not the entire tile, children may be\n    // outside of this box.\n    if (content.boundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        content.boundingVolume,\n        this.computedTransform,\n        this._contentBoundingVolume\n      );\n    }\n    if (header.viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        header.viewerRequestVolume,\n        this.computedTransform,\n        this._viewerRequestVolume\n      );\n    }\n  }\n\n  // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n  _updateTransform(parentTransform = new Matrix4()) {\n    const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n    const didTransformChange = !computedTransform.equals(this.computedTransform);\n\n    if (!didTransformChange) {\n      return;\n    }\n\n    this.computedTransform = computedTransform;\n\n    this._updateBoundingVolume(this.header);\n  }\n\n  // TODO Cesium specific\n  // Update whether the tile has expired.\n  updateExpiration() {\n    if (defined(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const now = Date.now();\n      if (Date.lessThan(this._expireDate, now)) {\n        this.contentState = TILE_CONTENT_STATE.EXPIRED;\n        this._expiredContent = this.content;\n      }\n    }\n  }\n\n  get extras() {\n    return this.header.extras;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}