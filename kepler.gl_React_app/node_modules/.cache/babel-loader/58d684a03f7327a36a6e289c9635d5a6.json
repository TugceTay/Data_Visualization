{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nvar ColumnarTableBatch = function () {\n  function ColumnarTableBatch(schema) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, ColumnarTableBatch);\n    this.schema = schema;\n    this.batchSize = options.batchSize || 'auto';\n    this.length = 0;\n    this.allocated = 0;\n    this.columns = null;\n    this.isChunkComplete = false;\n    this.reallocateColumns();\n  }\n  _createClass(ColumnarTableBatch, [{\n    key: \"addRow\",\n    value: function addRow(row) {\n      this.reallocateColumns();\n      for (var fieldName in row) {\n        this.columns[fieldName][this.length] = row[fieldName];\n      }\n      this.length++;\n    }\n  }, {\n    key: \"chunkComplete\",\n    value: function chunkComplete() {\n      this.isChunkComplete = true;\n    }\n  }, {\n    key: \"isFull\",\n    value: function isFull() {\n      if (this.batchSize === 'auto') {\n        return this.isChunkComplete;\n      }\n      return this.length >= this.allocated;\n    }\n  }, {\n    key: \"getBatch\",\n    value: function getBatch() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.pruneColumns();\n      var columns = Array.isArray(this.schema) ? this.columns : {};\n      if (!Array.isArray(this.schema)) {\n        for (var fieldName in this.schema) {\n          var field = this.schema[fieldName];\n          columns[field.name] = this.columns[field.index];\n        }\n      }\n      this.columns = null;\n      this.isChunkComplete = false;\n      return {\n        data: columns,\n        schema: this.schema,\n        length: this.length\n      };\n    }\n  }, {\n    key: \"reallocateColumns\",\n    value: function reallocateColumns() {\n      if (this.length < this.allocated) {\n        return;\n      }\n      this.allocated = this.allocated > 0 ? this.allocated *= 2 : this.batchSize;\n      this.columns = [];\n      for (var fieldName in this.schema) {\n        var field = this.schema[fieldName];\n        var ArrayType = field.type || Float32Array;\n        var oldColumn = this.columns[field.index];\n        if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n          var typedArray = new ArrayType(this.allocated);\n          typedArray.set(oldColumn);\n          this.columns[field.index] = typedArray;\n        } else if (oldColumn) {\n          oldColumn.length = this.allocated;\n          this.columns[field.index] = oldColumn;\n        } else {\n          this.columns[field.index] = new ArrayType(this.allocated);\n        }\n      }\n    }\n  }, {\n    key: \"pruneColumns\",\n    value: function pruneColumns() {\n      var _this = this;\n      this.columns = this.columns.map(function (column) {\n        return column.slice(0, _this.length);\n      });\n    }\n  }]);\n  return ColumnarTableBatch;\n}();\nexport { ColumnarTableBatch as default };","map":{"version":3,"sources":["../../../../src/lib/table/columnar-table-batch.js"],"names":["ColumnarTableBatch","schema","options","batchSize","length","allocated","columns","isChunkComplete","reallocateColumns","row","fieldName","pruneColumns","Array","isArray","field","name","index","data","ArrayType","type","Float32Array","oldColumn","ArrayBuffer","isView","typedArray","set","map","column","slice"],"mappings":"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","sourcesContent":["export default class ColumnarTableBatch {\n  constructor(schema, options = {}) {\n    this.schema = schema;\n    this.batchSize = options.batchSize || 'auto';\n\n    this.length = 0;\n    this.allocated = 0;\n    this.columns = null;\n    this.isChunkComplete = false;\n\n    this.reallocateColumns();\n  }\n\n  addRow(row) {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this.reallocateColumns();\n    for (const fieldName in row) {\n      this.columns[fieldName][this.length] = row[fieldName];\n    }\n    this.length++;\n  }\n\n  // Is this TableBatch full?\n  chunkComplete() {\n    this.isChunkComplete = true;\n  }\n\n  isFull() {\n    if (this.batchSize === 'auto') {\n      return this.isChunkComplete;\n    }\n    return this.length >= this.allocated;\n  }\n\n  getBatch(options = {}) {\n    this.pruneColumns();\n    const columns = Array.isArray(this.schema) ? this.columns : {};\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    // columns should match schema format\n    if (!Array.isArray(this.schema)) {\n      for (const fieldName in this.schema) {\n        const field = this.schema[fieldName];\n        columns[field.name] = this.columns[field.index];\n      }\n    }\n\n    this.columns = null;\n    this.isChunkComplete = false;\n\n    return {data: columns, schema: this.schema, length: this.length};\n  }\n\n  // HELPERS\n\n  reallocateColumns() {\n    if (this.length < this.allocated) {\n      return;\n    }\n\n    this.allocated = this.allocated > 0 ? (this.allocated *= 2) : this.batchSize;\n    this.columns = [];\n\n    for (const fieldName in this.schema) {\n      const field = this.schema[fieldName];\n      const ArrayType = field.type || Float32Array;\n      const oldColumn = this.columns[field.index];\n\n      if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n        // Copy the old data to the new array\n        const typedArray = new ArrayType(this.allocated);\n        typedArray.set(oldColumn);\n        this.columns[field.index] = typedArray;\n      } else if (oldColumn) {\n        // Plain array\n        oldColumn.length = this.allocated;\n        this.columns[field.index] = oldColumn;\n      } else {\n        // Create new\n        this.columns[field.index] = new ArrayType(this.allocated);\n      }\n    }\n  }\n\n  pruneColumns() {\n    this.columns = this.columns.map(column => column.slice(0, this.length));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}