{"ast":null,"code":"import { log } from '@luma.gl/gltools';\nimport Accessor from './accessor';\nimport Buffer from './buffer';\nimport VertexArrayObject from './vertex-array-object';\nimport { assert } from '../utils/assert';\nimport { stubRemovedMethods } from '../utils/stub-methods';\nconst ERR_ATTRIBUTE_TYPE = 'VertexArray: attributes must be Buffers or constants (i.e. typed array)';\nconst MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;\nconst DEPRECATIONS_V6 = ['setBuffers', 'setGeneric', 'clearBindings', 'setLocations', 'setGenericValues', 'setDivisor', 'enable', 'disable'];\nexport default class VertexArray {\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const id = opts.id || opts.program && opts.program.id;\n    this.id = id;\n    this.gl = gl;\n    this.configuration = null;\n    this.elements = null;\n    this.elementsAccessor = null;\n    this.values = null;\n    this.accessors = null;\n    this.unused = null;\n    this.drawParams = null;\n    this.buffer = null;\n    this.attributes = {};\n    this.vertexArrayObject = new VertexArrayObject(gl);\n    stubRemovedMethods(this, 'VertexArray', 'v6.0', DEPRECATIONS_V6);\n    this.initialize(opts);\n    Object.seal(this);\n  }\n  delete() {\n    if (this.buffer) {\n      this.buffer.delete();\n    }\n    this.vertexArrayObject.delete();\n  }\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.reset();\n    this.configuration = null;\n    this.bindOnUse = false;\n    return this.setProps(props);\n  }\n  reset() {\n    this.elements = null;\n    this.elementsAccessor = null;\n    const {\n      MAX_ATTRIBUTES\n    } = this.vertexArrayObject;\n    this.values = new Array(MAX_ATTRIBUTES).fill(null);\n    this.accessors = new Array(MAX_ATTRIBUTES).fill(null);\n    this.unused = {};\n    this.drawParams = null;\n    return this;\n  }\n  setProps(props) {\n    if ('program' in props) {\n      this.configuration = props.program && props.program.configuration;\n    }\n    if ('configuration' in props) {\n      this.configuration = props.configuration;\n    }\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('elements' in props) {\n      this.setElementBuffer(props.elements);\n    }\n    if ('bindOnUse' in props) {\n      props = props.bindOnUse;\n    }\n    return this;\n  }\n  clearDrawParams() {\n    this.drawParams = null;\n  }\n  getDrawParams() {\n    this.drawParams = this.drawParams || this._updateDrawParams();\n    return this.drawParams;\n  }\n  setAttributes(attributes) {\n    Object.assign(this.attributes, attributes);\n    this.vertexArrayObject.bind(() => {\n      for (const locationOrName in attributes) {\n        const value = attributes[locationOrName];\n        this._setAttribute(locationOrName, value);\n      }\n      this.gl.bindBuffer(34962, null);\n    });\n    return this;\n  }\n  setElementBuffer() {\n    let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.elements = elementBuffer;\n    this.elementsAccessor = accessor;\n    this.clearDrawParams();\n    this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);\n    return this;\n  }\n  setBuffer(locationOrName, buffer) {\n    let appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (buffer.target === 34963) {\n      return this.setElementBuffer(buffer, appAccessor);\n    }\n    const {\n      location,\n      accessor\n    } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);\n    if (location >= 0) {\n      this.values[location] = buffer;\n      this.accessors[location] = accessor;\n      this.clearDrawParams();\n      this.vertexArrayObject.setBuffer(location, buffer, accessor);\n    }\n    return this;\n  }\n  setConstant(locationOrName, arrayValue) {\n    let appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      location,\n      accessor\n    } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({\n      size: arrayValue.length\n    }, appAccessor));\n    if (location >= 0) {\n      arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);\n      this.values[location] = arrayValue;\n      this.accessors[location] = accessor;\n      this.clearDrawParams();\n      this.vertexArrayObject.enable(location, false);\n    }\n    return this;\n  }\n  unbindBuffers() {\n    this.vertexArrayObject.bind(() => {\n      if (this.elements) {\n        this.vertexArrayObject.setElementBuffer(null);\n      }\n      this.buffer = this.buffer || new Buffer(this.gl, {\n        accessor: {\n          size: 4\n        }\n      });\n      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n        if (this.values[location] instanceof Buffer) {\n          this.gl.disableVertexAttribArray(location);\n          this.gl.bindBuffer(34962, this.buffer.handle);\n          this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);\n        }\n      }\n    });\n    return this;\n  }\n  bindBuffers() {\n    this.vertexArrayObject.bind(() => {\n      if (this.elements) {\n        this.setElementBuffer(this.elements);\n      }\n      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n        const buffer = this.values[location];\n        if (buffer instanceof Buffer) {\n          this.setBuffer(location, buffer);\n        }\n      }\n    });\n    return this;\n  }\n  bindForDraw(vertexCount, instanceCount, func) {\n    let value;\n    this.vertexArrayObject.bind(() => {\n      this._setConstantAttributes(vertexCount, instanceCount);\n      value = func();\n    });\n    return value;\n  }\n  _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {\n    const INVALID_RESULT = {\n      location: -1,\n      accessor: null\n    };\n    const {\n      location,\n      name\n    } = this._getAttributeIndex(locationOrName);\n    if (!Number.isFinite(location) || location < 0) {\n      this.unused[locationOrName] = value;\n      log.once(3, () => \"unused value \".concat(locationOrName, \" in \").concat(this.id))();\n      return INVALID_RESULT;\n    }\n    const accessInfo = this._getAttributeInfo(name || location);\n    if (!accessInfo) {\n      return INVALID_RESULT;\n    }\n    const currentAccessor = this.accessors[location] || {};\n    const accessor = Accessor.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);\n    const {\n      size,\n      type\n    } = accessor;\n    assert(Number.isFinite(size) && Number.isFinite(type));\n    return {\n      location,\n      accessor\n    };\n  }\n  _getAttributeInfo(attributeName) {\n    return this.configuration && this.configuration.getAttributeInfo(attributeName);\n  }\n  _getAttributeIndex(locationOrName) {\n    const location = Number(locationOrName);\n    if (Number.isFinite(location)) {\n      return {\n        location\n      };\n    }\n    const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);\n    const name = multiLocation ? multiLocation[1] : locationOrName;\n    const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;\n    if (this.configuration) {\n      return {\n        location: this.configuration.getAttributeLocation(name) + locationOffset,\n        name\n      };\n    }\n    return {\n      location: -1\n    };\n  }\n  _setAttribute(locationOrName, value) {\n    if (value instanceof Buffer) {\n      this.setBuffer(locationOrName, value);\n    } else if (Array.isArray(value) && value.length && value[0] instanceof Buffer) {\n      const buffer = value[0];\n      const accessor = value[1];\n      this.setBuffer(locationOrName, buffer, accessor);\n    } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {\n      const constant = value;\n      this.setConstant(locationOrName, constant);\n    } else if (value.buffer instanceof Buffer) {\n      const accessor = value;\n      this.setBuffer(locationOrName, accessor.buffer, accessor);\n    } else {\n      throw new Error(ERR_ATTRIBUTE_TYPE);\n    }\n  }\n  _setConstantAttributes(vertexCount, instanceCount) {\n    const elementCount = Math.max(vertexCount | 0, instanceCount | 0);\n    let constant = this.values[0];\n    if (ArrayBuffer.isView(constant)) {\n      this._setConstantAttributeZero(constant, elementCount);\n    }\n    for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n      constant = this.values[location];\n      if (ArrayBuffer.isView(constant)) {\n        this._setConstantAttribute(location, constant);\n      }\n    }\n  }\n  _setConstantAttributeZero(constant, elementCount) {\n    if (VertexArrayObject.isSupported(this.gl, {\n      constantAttributeZero: true\n    })) {\n      this._setConstantAttribute(0, constant);\n      return;\n    }\n    const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);\n    this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);\n  }\n  _setConstantAttribute(location, constant) {\n    VertexArrayObject.setConstant(this.gl, location, constant);\n  }\n  _updateDrawParams() {\n    const drawParams = {\n      isIndexed: false,\n      isInstanced: false,\n      indexCount: Infinity,\n      vertexCount: Infinity,\n      instanceCount: Infinity\n    };\n    for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n      this._updateDrawParamsForLocation(drawParams, location);\n    }\n    if (this.elements) {\n      drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);\n      drawParams.isIndexed = true;\n      drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;\n      drawParams.indexOffset = this.elementsAccessor.offset || 0;\n    }\n    if (drawParams.indexCount === Infinity) {\n      drawParams.indexCount = 0;\n    }\n    if (drawParams.vertexCount === Infinity) {\n      drawParams.vertexCount = 0;\n    }\n    if (drawParams.instanceCount === Infinity) {\n      drawParams.instanceCount = 0;\n    }\n    return drawParams;\n  }\n  _updateDrawParamsForLocation(drawParams, location) {\n    const value = this.values[location];\n    const accessor = this.accessors[location];\n    if (!value) {\n      return;\n    }\n    const {\n      divisor\n    } = accessor;\n    const isInstanced = divisor > 0;\n    drawParams.isInstanced = drawParams.isInstanced || isInstanced;\n    if (value instanceof Buffer) {\n      const buffer = value;\n      if (isInstanced) {\n        const instanceCount = buffer.getVertexCount(accessor);\n        drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);\n      } else {\n        const vertexCount = buffer.getVertexCount(accessor);\n        drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);\n      }\n    }\n  }\n  setElements() {\n    let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    log.deprecated('setElements', 'setElementBuffer')();\n    return this.setElementBuffer(elementBuffer, accessor);\n  }\n}","map":{"version":3,"sources":["../../../src/classes/vertex-array.js"],"names":["log","Accessor","Buffer","VertexArrayObject","assert","stubRemovedMethods","ERR_ATTRIBUTE_TYPE","MULTI_LOCATION_ATTRIBUTE_REGEXP","DEPRECATIONS_V6","VertexArray","constructor","gl","opts","id","program","configuration","elements","elementsAccessor","values","accessors","unused","drawParams","buffer","attributes","vertexArrayObject","initialize","Object","seal","delete","props","reset","bindOnUse","setProps","MAX_ATTRIBUTES","Array","fill","setAttributes","setElementBuffer","clearDrawParams","getDrawParams","_updateDrawParams","assign","bind","locationOrName","value","_setAttribute","bindBuffer","elementBuffer","accessor","setBuffer","appAccessor","target","location","_resolveLocationAndAccessor","setConstant","arrayValue","size","length","_normalizeConstantArrayValue","enable","unbindBuffers","disableVertexAttribArray","handle","vertexAttribPointer","bindBuffers","bindForDraw","vertexCount","instanceCount","func","_setConstantAttributes","valueAccessor","INVALID_RESULT","name","_getAttributeIndex","Number","isFinite","once","accessInfo","_getAttributeInfo","currentAccessor","resolve","type","attributeName","getAttributeInfo","multiLocation","exec","locationOffset","getAttributeLocation","isArray","ArrayBuffer","isView","constant","Error","elementCount","Math","max","_setConstantAttributeZero","_setConstantAttribute","isSupported","constantAttributeZero","getConstantBuffer","isIndexed","isInstanced","indexCount","Infinity","_updateDrawParamsForLocation","getElementCount","indexType","indexOffset","offset","divisor","getVertexCount","min","setElements","deprecated"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {log} from '@luma.gl/gltools';\nimport Accessor from './accessor';\nimport Buffer from './buffer';\nimport VertexArrayObject from './vertex-array-object';\nimport {assert} from '../utils/assert';\nimport {stubRemovedMethods} from '../utils/stub-methods';\n\nconst ERR_ATTRIBUTE_TYPE =\n  'VertexArray: attributes must be Buffers or constants (i.e. typed array)';\n\n// This is done to support mat type attributes.\n// See section \"Notes about setting mat type attributes\"\n// in vertex-array.md\nconst MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;\n\nconst DEPRECATIONS_V6 = [\n  'setBuffers',\n  'setGeneric',\n  'clearBindings',\n  'setLocations',\n  'setGenericValues',\n  'setDivisor',\n  'enable',\n  'disable'\n];\n\nexport default class VertexArray {\n  constructor(gl, opts = {}) {\n    // Use program's id if program is supplied but no id is supplied\n    const id = opts.id || (opts.program && opts.program.id);\n    // super(gl, Object.assign({}, opts, {id}));\n\n    this.id = id;\n    this.gl = gl;\n    this.configuration = null;\n\n    // Extracted information\n    this.elements = null;\n    this.elementsAccessor = null;\n    this.values = null;\n    this.accessors = null;\n    this.unused = null;\n    this.drawParams = null;\n    this.buffer = null; // For attribute 0 on desktops, and created when unbinding buffers\n\n    this.attributes = {};\n\n    this.vertexArrayObject = new VertexArrayObject(gl);\n\n    // Issue errors when using removed methods\n    stubRemovedMethods(this, 'VertexArray', 'v6.0', DEPRECATIONS_V6);\n\n    this.initialize(opts);\n    Object.seal(this);\n  }\n\n  delete() {\n    if (this.buffer) {\n      this.buffer.delete();\n    }\n\n    this.vertexArrayObject.delete();\n  }\n\n  initialize(props = {}) {\n    this.reset();\n    this.configuration = null;\n    this.bindOnUse = false;\n    return this.setProps(props);\n  }\n\n  // Resets all attributes (to default valued constants)\n  reset() {\n    // this.vertexArrayObject.reset();\n\n    this.elements = null;\n    this.elementsAccessor = null;\n    const {MAX_ATTRIBUTES} = this.vertexArrayObject;\n    this.values = new Array(MAX_ATTRIBUTES).fill(null);\n    this.accessors = new Array(MAX_ATTRIBUTES).fill(null);\n    this.unused = {};\n\n    // Auto detects draw params\n    this.drawParams = null;\n\n    return this;\n  }\n\n  setProps(props) {\n    if ('program' in props) {\n      this.configuration = props.program && props.program.configuration;\n    }\n    if ('configuration' in props) {\n      this.configuration = props.configuration;\n    }\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('elements' in props) {\n      this.setElementBuffer(props.elements);\n    }\n    if ('bindOnUse' in props) {\n      props = props.bindOnUse;\n    }\n    return this;\n  }\n\n  // Automatically called if buffers changed through VertexArray API\n  clearDrawParams() {\n    this.drawParams = null;\n  }\n\n  getDrawParams() {\n    // Auto deduced draw parameters\n    this.drawParams = this.drawParams || this._updateDrawParams();\n\n    return this.drawParams;\n  }\n\n  // Set (bind) an array or map of vertex array buffers, either in numbered or named locations.\n  // For names that are not present in `location`, the supplied buffers will be ignored.\n  // if a single buffer of type GL.ELEMENT_ARRAY_BUFFER is present, it will be set as elements\n  //   Signatures:\n  //     {attributeName: buffer}\n  //     {attributeName: [buffer, accessor]}\n  //     {attributeName: (typed) array} => constant\n  setAttributes(attributes) {\n    Object.assign(this.attributes, attributes);\n    this.vertexArrayObject.bind(() => {\n      for (const locationOrName in attributes) {\n        const value = attributes[locationOrName];\n        this._setAttribute(locationOrName, value);\n      }\n      // Make sure we don't leave any bindings\n      this.gl.bindBuffer(GL.ARRAY_BUFFER, null);\n    });\n\n    return this;\n  }\n\n  // Set (bind) an elements buffer, for indexed rendering.\n  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER. Constants not supported\n  setElementBuffer(elementBuffer = null, accessor = {}) {\n    this.elements = elementBuffer; // Save value for debugging\n    this.elementsAccessor = accessor;\n    this.clearDrawParams();\n    this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);\n\n    return this;\n  }\n\n  // Set a location in vertex attributes array to a buffer\n  setBuffer(locationOrName, buffer, appAccessor = {}) {\n    // Check target\n    if (buffer.target === GL.ELEMENT_ARRAY_BUFFER) {\n      return this.setElementBuffer(buffer, appAccessor);\n    }\n\n    const {location, accessor} = this._resolveLocationAndAccessor(\n      locationOrName,\n      buffer,\n      buffer.accessor,\n      appAccessor\n    );\n\n    if (location >= 0) {\n      this.values[location] = buffer;\n      this.accessors[location] = accessor;\n      this.clearDrawParams();\n      this.vertexArrayObject.setBuffer(location, buffer, accessor);\n    }\n\n    return this;\n  }\n\n  // Set attribute to constant value (small typed array corresponding to one vertex' worth of data)\n  setConstant(locationOrName, arrayValue, appAccessor = {}) {\n    const {location, accessor} = this._resolveLocationAndAccessor(\n      locationOrName,\n      arrayValue,\n      // Ensure that size isn't taken from program for multi-column\n      // attributes\n      Object.assign({size: arrayValue.length}, appAccessor)\n    );\n\n    if (location >= 0) {\n      arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);\n\n      this.values[location] = arrayValue;\n      this.accessors[location] = accessor;\n      this.clearDrawParams();\n\n      // NOTE: We set the actual constant value later on bind. We can't set the value now since\n      // constants are global and affect all other VertexArrays that have disabled attributes\n      // in the same location.\n      // We do disable the attribute which makes it use the global constant value at that location\n      this.vertexArrayObject.enable(location, false);\n    }\n\n    return this;\n  }\n\n  // Workaround for Chrome TransformFeedback binding issue\n  // If required, unbind temporarily to avoid conflicting with TransformFeedback\n  unbindBuffers() {\n    this.vertexArrayObject.bind(() => {\n      if (this.elements) {\n        this.vertexArrayObject.setElementBuffer(null);\n      }\n\n      // Chrome does not like buffers that are bound to several binding points,\n      // so we need to offer and unbind facility\n      // WebGL offers disabling, but no clear way to set a VertexArray buffer to `null`\n      // So we just bind all the attributes to the dummy \"attribute zero\" buffer\n      this.buffer = this.buffer || new Buffer(this.gl, {accessor: {size: 4}});\n\n      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n        if (this.values[location] instanceof Buffer) {\n          this.gl.disableVertexAttribArray(location);\n          this.gl.bindBuffer(GL.ARRAY_BUFFER, this.buffer.handle);\n          this.gl.vertexAttribPointer(location, 1, GL.FLOAT, false, 0, 0);\n        }\n      }\n    });\n    return this;\n  }\n\n  // Workaround for Chrome TransformFeedback binding issue\n  // If required, rebind rebind after temporary unbind\n  bindBuffers() {\n    this.vertexArrayObject.bind(() => {\n      if (this.elements) {\n        this.setElementBuffer(this.elements);\n      }\n\n      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n        const buffer = this.values[location];\n        if (buffer instanceof Buffer) {\n          this.setBuffer(location, buffer);\n        }\n      }\n    });\n    return this;\n  }\n\n  // Bind for use\n  // When a vertex array is about to be used, we must:\n  // - Set constant attributes (since these are stored on the context and reset on bind)\n  // - Check if we need to initialize the buffer\n  bindForDraw(vertexCount, instanceCount, func) {\n    let value;\n\n    this.vertexArrayObject.bind(() => {\n      // Make sure that any constant attributes are updated (stored on the context, not the VAO)\n      // Also handles attribute 0\n      this._setConstantAttributes(vertexCount, instanceCount);\n\n      value = func();\n    });\n\n    return value;\n  }\n\n  // PRIVATE\n\n  // Resolve locations and accessors\n  _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {\n    const INVALID_RESULT = {\n      location: -1,\n      accessor: null\n    };\n\n    const {location, name} = this._getAttributeIndex(locationOrName);\n    if (!Number.isFinite(location) || location < 0) {\n      this.unused[locationOrName] = value;\n      log.once(3, () => `unused value ${locationOrName} in ${this.id}`)();\n      return INVALID_RESULT;\n    }\n\n    const accessInfo = this._getAttributeInfo(name || location);\n\n    // Attribute location wasn't directly found.\n    // Likely due to multi-location attributes (e.g. matrix)\n    if (!accessInfo) {\n      return INVALID_RESULT;\n    }\n\n    // Resolve the partial accessors into a final accessor\n    const currentAccessor = this.accessors[location] || {};\n    const accessor = Accessor.resolve(\n      accessInfo.accessor,\n      currentAccessor,\n      valueAccessor,\n      appAccessor\n    );\n\n    const {size, type} = accessor;\n    assert(Number.isFinite(size) && Number.isFinite(type));\n\n    return {location, accessor};\n  }\n\n  _getAttributeInfo(attributeName) {\n    return this.configuration && this.configuration.getAttributeInfo(attributeName);\n  }\n\n  _getAttributeIndex(locationOrName) {\n    const location = Number(locationOrName);\n    if (Number.isFinite(location)) {\n      return {location};\n    }\n\n    const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);\n    const name = multiLocation ? multiLocation[1] : locationOrName;\n    const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;\n\n    if (this.configuration) {\n      return {\n        location: this.configuration.getAttributeLocation(name) + locationOffset,\n        name\n      };\n    }\n\n    return {location: -1};\n  }\n\n  _setAttribute(locationOrName, value) {\n    if (value instanceof Buffer) {\n      //  Signature: {attributeName: Buffer}\n      this.setBuffer(locationOrName, value);\n    } else if (Array.isArray(value) && value.length && value[0] instanceof Buffer) {\n      // Signature: {attributeName: [buffer, accessor]}\n      const buffer = value[0];\n      const accessor = value[1];\n      this.setBuffer(locationOrName, buffer, accessor);\n    } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {\n      // Signature: {attributeName: constant}, constant == short (typed) array\n      const constant = value;\n      this.setConstant(locationOrName, constant);\n    } else if (value.buffer instanceof Buffer) {\n      // luma.gl v7: Support accessor objects with 'buffer' field\n      // for interleaved data\n      // Signature: {attributeName: {...accessor, buffer}}\n      const accessor = value;\n      this.setBuffer(locationOrName, accessor.buffer, accessor);\n    } else {\n      throw new Error(ERR_ATTRIBUTE_TYPE);\n    }\n  }\n\n  // Updates all constant attribute values (constants are used when vertex attributes are disabled).\n  // This needs to be done repeatedly since in contrast to buffer bindings,\n  // constants are stored on the WebGL context, not the VAO\n  _setConstantAttributes(vertexCount, instanceCount) {\n    // TODO - use accessor to determine what length to use\n    const elementCount = Math.max(vertexCount | 0, instanceCount | 0);\n    let constant = this.values[0];\n    if (ArrayBuffer.isView(constant)) {\n      this._setConstantAttributeZero(constant, elementCount);\n    }\n\n    for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n      constant = this.values[location];\n      if (ArrayBuffer.isView(constant)) {\n        this._setConstantAttribute(location, constant);\n      }\n    }\n  }\n\n  _setConstantAttributeZero(constant, elementCount) {\n    if (VertexArrayObject.isSupported(this.gl, {constantAttributeZero: true})) {\n      this._setConstantAttribute(0, constant);\n      return;\n    }\n\n    // Get a dummy buffer populated with repeated constants\n    const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);\n\n    // Set the buffer on location 0\n    this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);\n  }\n\n  _setConstantAttribute(location, constant) {\n    VertexArrayObject.setConstant(this.gl, location, constant);\n  }\n\n  // Walks the buffers and updates draw parameters\n  _updateDrawParams() {\n    const drawParams = {\n      isIndexed: false,\n      isInstanced: false,\n      indexCount: Infinity,\n      vertexCount: Infinity,\n      instanceCount: Infinity\n    };\n\n    for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n      this._updateDrawParamsForLocation(drawParams, location);\n    }\n\n    if (this.elements) {\n      // indexing is autodetected - buffer with target GL.ELEMENT_ARRAY_BUFFER\n      // index type is saved for drawElement calls\n      drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);\n      drawParams.isIndexed = true;\n      drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;\n      drawParams.indexOffset = this.elementsAccessor.offset || 0;\n    }\n\n    // Post-calculation checks\n    if (drawParams.indexCount === Infinity) {\n      drawParams.indexCount = 0;\n    }\n    if (drawParams.vertexCount === Infinity) {\n      drawParams.vertexCount = 0;\n    }\n    if (drawParams.instanceCount === Infinity) {\n      drawParams.instanceCount = 0;\n    }\n\n    return drawParams;\n  }\n\n  _updateDrawParamsForLocation(drawParams, location) {\n    const value = this.values[location];\n    const accessor = this.accessors[location];\n\n    if (!value) {\n      return;\n    }\n\n    // Check if instanced (whether buffer or constant)\n    const {divisor} = accessor;\n    const isInstanced = divisor > 0;\n    drawParams.isInstanced = drawParams.isInstanced || isInstanced;\n\n    if (value instanceof Buffer) {\n      const buffer = value;\n\n      if (isInstanced) {\n        // instance attribute\n        const instanceCount = buffer.getVertexCount(accessor);\n        drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);\n      } else {\n        // normal attribute\n        const vertexCount = buffer.getVertexCount(accessor);\n        drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);\n      }\n    }\n  }\n\n  // DEPRECATED in v6.x - but not warnings not properly implemented\n\n  setElements(elementBuffer = null, accessor = {}) {\n    log.deprecated('setElements', 'setElementBuffer')();\n    return this.setElementBuffer(elementBuffer, accessor);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}