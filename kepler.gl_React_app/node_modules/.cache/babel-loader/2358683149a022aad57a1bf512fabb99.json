{"ast":null,"code":"import { Matrix3, _MathUtils } from '@math.gl/core';\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\nexport default function computeEigenDecomposition(matrix) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n  let count = 0;\n  let sweep = 0;\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n    jMatrixTranspose.copy(jMatrix).transpose();\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n  return result;\n}\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\nfunction offDiagonalFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\nfunction shurDecomposition(matrix, result) {\n  const tolerance = _MathUtils.EPSILON15;\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n  let c = 1.0;\n  let s = 0.0;\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n  return result;\n}","map":{"version":3,"sources":["../../../../src/lib/algorithms/compute-eigen-decomposition.ts"],"names":["Matrix3","_MathUtils","scratchMatrix","scratchUnitary","scratchDiagonal","jMatrix","jMatrixTranspose","computeEigenDecomposition","matrix","result","EIGEN_TOLERANCE","EPSILON20","EIGEN_MAX_SWEEPS","count","sweep","unitaryMatrix","diagonalMatrix","identity","copy","epsilon","computeFrobeniusNorm","offDiagonalFrobeniusNorm","shurDecomposition","transpose","multiplyRight","multiplyLeft","unitary","toTarget","diagonal","norm","i","temp","Math","sqrt","rowVal","colVal","getElementIndex","tolerance","EPSILON15","maxDiagonal","rotAxis","abs","p","q","c","s","qq","pp","qp","tau","t","IDENTITY","to"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Matrix3, _MathUtils} from '@math.gl/core';\n\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\n\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\nexport type EigenDecomposition = {\n  unitary: Matrix3;\n  diagonal: Matrix3;\n};\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n *\n * - Returns a diagonal matrix and unitary matrix such that:\n * `matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)`\n * - The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * - This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n * section 8.4.3 The Classical Jacobi Algorithm\n *\n * @param matrix The 3x3 matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param result Optional object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symmetric matrix\n * const result = {\n *   unitary : new Matrix3(),\n *   diagonal : new Matrix3()\n * };\n * computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Matrix3.transpose(result.unitary, new Matrix3());\n * const b = Matrix3.multiply(result.unitary, result.diagonal, new Matrix3());\n * Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = result.diagonal.getColumn(0, new Vector3()).x;  // first eigenvalue\n * const v = result.unitary.getColumn(0, new Vector3());          // first eigenvector\n * const c = v.multiplyByScalar(lambda);                          // equal to v.transformByMatrix3(a)\n */\nexport default function computeEigenDecomposition(\n  matrix: number[],\n  // @ts-expect-error accept empty object type\n  result: EigenDecomposition = {}\n): EigenDecomposition {\n  const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n\n  let count = 0;\n  let sweep = 0;\n\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n\n    jMatrixTranspose.copy(jMatrix).transpose();\n\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n\n  return result;\n}\n\nfunction computeFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\n// Computes the \"off-diagonal\" Frobenius norm.\n// Assumes matrix is symmetric.\nfunction offDiagonalFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\n// The routine takes a matrix, which is assumed to be symmetric, and\n// finds the largest off-diagonal term, and then creates\n// a matrix (result) which can be used to help reduce it\n//\n// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n// section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n//\n// eslint-disable-next-line max-statements\nfunction shurDecomposition(matrix: Matrix3, result: Matrix3): Matrix3 {\n  const tolerance = _MathUtils.EPSILON15;\n\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n\n  let c = 1.0;\n  let s = 0.0;\n\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  // Copy into result\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}