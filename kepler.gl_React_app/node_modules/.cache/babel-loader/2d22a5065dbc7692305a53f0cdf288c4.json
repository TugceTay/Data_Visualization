{"ast":null,"code":"import { log, COORDINATE_SYSTEM } from '@deck.gl/core';\nvar R_EARTH = 6378000;\nfunction toFinite(n) {\n  return Number.isFinite(n) ? n : 0;\n}\nexport function getBoundingBox(attributes, vertexCount) {\n  var positions = attributes.positions.value;\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var y;\n  var x;\n  for (var i = 0; i < vertexCount; i++) {\n    x = positions[i * 3];\n    y = positions[i * 3 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n  var boundingBox = {\n    xMin: toFinite(xMin),\n    xMax: toFinite(xMax),\n    yMin: toFinite(yMin),\n    yMax: toFinite(yMax)\n  };\n  return boundingBox;\n}\nfunction getTranslation(boundingBox, gridOffset, coordinateSystem, viewport) {\n  var width = viewport.width,\n    height = viewport.height;\n  var worldOrigin = coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];\n  log.assert([COORDINATE_SYSTEM.CARTESIAN, COORDINATE_SYSTEM.LNGLAT, COORDINATE_SYSTEM.DEFAULT].includes(coordinateSystem));\n  var xMin = boundingBox.xMin,\n    yMin = boundingBox.yMin;\n  return [-1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]), -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])];\n}\nexport function alignToCell(inValue, cellSize) {\n  var sign = inValue < 0 ? -1 : 1;\n  var value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n  value = Math.floor(value / cellSize) * cellSize;\n  return value * sign;\n}\nexport function getGridOffset(boundingBox, cellSize) {\n  var convertToMeters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!convertToMeters) {\n    return {\n      xOffset: cellSize,\n      yOffset: cellSize\n    };\n  }\n  var yMin = boundingBox.yMin,\n    yMax = boundingBox.yMax;\n  var centerLat = (yMin + yMax) / 2;\n  return calculateGridLatLonOffset(cellSize, centerLat);\n}\nexport function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {\n  var gridOffset = getGridOffset(boundingBox, cellSize, coordinateSystem !== COORDINATE_SYSTEM.CARTESIAN);\n  var translation = getTranslation(boundingBox, gridOffset, coordinateSystem, viewport);\n  var xMin = boundingBox.xMin,\n    yMin = boundingBox.yMin,\n    xMax = boundingBox.xMax,\n    yMax = boundingBox.yMax;\n  var width = xMax - xMin + gridOffset.xOffset;\n  var height = yMax - yMin + gridOffset.yOffset;\n  var numCol = Math.ceil(width / gridOffset.xOffset);\n  var numRow = Math.ceil(height / gridOffset.yOffset);\n  return {\n    gridOffset: gridOffset,\n    translation: translation,\n    width: width,\n    height: height,\n    numCol: numCol,\n    numRow: numRow\n  };\n}\nfunction calculateGridLatLonOffset(cellSize, latitude) {\n  var yOffset = calculateLatOffset(cellSize);\n  var xOffset = calculateLonOffset(latitude, cellSize);\n  return {\n    yOffset: yOffset,\n    xOffset: xOffset\n  };\n}\nfunction calculateLatOffset(dy) {\n  return dy / R_EARTH * (180 / Math.PI);\n}\nfunction calculateLonOffset(lat, dx) {\n  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n}","map":{"version":3,"sources":["../../../src/utils/grid-aggregation-utils.js"],"names":["log","COORDINATE_SYSTEM","R_EARTH","toFinite","n","Number","isFinite","getBoundingBox","attributes","vertexCount","positions","value","yMin","Infinity","yMax","xMin","xMax","y","x","i","boundingBox","getTranslation","gridOffset","coordinateSystem","viewport","width","height","worldOrigin","CARTESIAN","assert","LNGLAT","DEFAULT","includes","alignToCell","xOffset","yOffset","inValue","cellSize","sign","Math","abs","floor","getGridOffset","convertToMeters","centerLat","calculateGridLatLonOffset","getGridParams","translation","numCol","ceil","numRow","latitude","calculateLatOffset","calculateLonOffset","dy","PI","lat","dx","cos"],"mappings":"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","sourcesContent":["import {log, COORDINATE_SYSTEM} from '@deck.gl/core';\nconst R_EARTH = 6378000;\n\nfunction toFinite(n) {\n  return Number.isFinite(n) ? n : 0;\n}\n\n// Parse input data to build positions, wights and bounding box.\n/* eslint-disable max-statements */\nexport function getBoundingBox(attributes, vertexCount) {\n  // TODO - value might not exist (e.g. attribute transition)\n  const positions = attributes.positions.value;\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < vertexCount; i++) {\n    x = positions[i * 3];\n    y = positions[i * 3 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  const boundingBox = {\n    xMin: toFinite(xMin),\n    xMax: toFinite(xMax),\n    yMin: toFinite(yMin),\n    yMax: toFinite(yMax)\n  };\n\n  return boundingBox;\n}\n/* eslint-enable max-statements */\n\n// Returns XY translation for positions to peform aggregation in +ve sapce\nfunction getTranslation(boundingBox, gridOffset, coordinateSystem, viewport) {\n  const {width, height} = viewport;\n\n  // Origin to define grid\n  // DEFAULT coordinate system is treated as LNGLAT\n  const worldOrigin =\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];\n\n  // Other coordinate systems not supported/verified yet.\n  log.assert(\n    [COORDINATE_SYSTEM.CARTESIAN, COORDINATE_SYSTEM.LNGLAT, COORDINATE_SYSTEM.DEFAULT].includes(\n      coordinateSystem\n    )\n  );\n\n  const {xMin, yMin} = boundingBox;\n  return [\n    // Align origin to match grid cell boundaries in CPU and GPU aggregations\n    -1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]),\n    -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])\n  ];\n}\n\n// Aligns `inValue` to given `cellSize`\nexport function alignToCell(inValue, cellSize) {\n  const sign = inValue < 0 ? -1 : 1;\n\n  let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n\n  value = Math.floor(value / cellSize) * cellSize;\n\n  return value * sign;\n}\n\n/**\n * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space\n * @param {object} boundingBox - {xMin, yMin, xMax, yMax} contains bounding box of data\n * @param {number} cellSize - grid cell size in meters\n * @param {boolean, optional} converToDegrees - when true offsets are converted from meters to lng/lat (degree) space\n * @returns {xOffset, yOffset} - cellSize size\n */\n\nexport function getGridOffset(boundingBox, cellSize, convertToMeters = true) {\n  if (!convertToMeters) {\n    return {xOffset: cellSize, yOffset: cellSize};\n  }\n\n  const {yMin, yMax} = boundingBox;\n  const centerLat = (yMin + yMax) / 2;\n\n  return calculateGridLatLonOffset(cellSize, centerLat);\n}\n\nexport function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {\n  const gridOffset = getGridOffset(\n    boundingBox,\n    cellSize,\n    coordinateSystem !== COORDINATE_SYSTEM.CARTESIAN\n  );\n\n  const translation = getTranslation(boundingBox, gridOffset, coordinateSystem, viewport);\n\n  const {xMin, yMin, xMax, yMax} = boundingBox;\n\n  const width = xMax - xMin + gridOffset.xOffset;\n  const height = yMax - yMin + gridOffset.yOffset;\n\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n  return {gridOffset, translation, width, height, numCol, numRow};\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = calculateLatOffset(cellSize);\n  const xOffset = calculateLonOffset(latitude, cellSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction calculateLatOffset(dy) {\n  return (dy / R_EARTH) * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction calculateLonOffset(lat, dx) {\n  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);\n}\n"]},"metadata":{},"sourceType":"module"}