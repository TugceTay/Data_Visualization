{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.renderedSize = renderedSize;\nexports.adjustCellsToContainer = adjustCellsToContainer;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _document = _interopRequireDefault(require(\"global/document\"));\nvar _dataUtils = require(\"../../../utils/data-utils\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar MIN_GHOST_CELL_SIZE = 200;\n/**\n * Measure rows and column content to determine min width for each column\n * @param {*} param0\n */\n\nfunction renderedSize(_ref) {\n  var _ref$text = _ref.text,\n    dataContainer = _ref$text.dataContainer,\n    column = _ref$text.column,\n    _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'string' : _ref$type,\n    colIdx = _ref.colIdx,\n    _ref$numRowsToCalcula = _ref.numRowsToCalculate,\n    numRowsToCalculate = _ref$numRowsToCalcula === void 0 ? 10 : _ref$numRowsToCalcula,\n    _ref$fontSize = _ref.fontSize,\n    fontSize = _ref$fontSize === void 0 ? 12 : _ref$fontSize,\n    _ref$font = _ref.font,\n    font = _ref$font === void 0 ? 'Lato' : _ref$font,\n    _ref$cellPadding = _ref.cellPadding,\n    cellPadding = _ref$cellPadding === void 0 ? 40 : _ref$cellPadding,\n    _ref$maxCellSize = _ref.maxCellSize,\n    maxCellSize = _ref$maxCellSize === void 0 ? 400 : _ref$maxCellSize,\n    _ref$maxHeaderSize = _ref.maxHeaderSize,\n    maxHeaderSize = _ref$maxHeaderSize === void 0 ? 150 : _ref$maxHeaderSize,\n    _ref$minCellSize = _ref.minCellSize,\n    minCellSize = _ref$minCellSize === void 0 ? 45 : _ref$minCellSize,\n    _ref$optionsButton = _ref.optionsButton,\n    optionsButton = _ref$optionsButton === void 0 ? 30 : _ref$optionsButton;\n  if (!_document[\"default\"]) {\n    return {\n      row: 0,\n      header: 0\n    };\n  }\n  var textCanvas = _document[\"default\"].createElement('canvas');\n  _document[\"default\"].body.appendChild(textCanvas);\n  var context = textCanvas.getContext('2d');\n  context.font = [fontSize, font].join('px ');\n  var rowsToSample = (0, _toConsumableArray2[\"default\"])(Array(numRowsToCalculate)).map(function () {\n    return Math.floor(Math.random() * (dataContainer.numRows() - 1));\n  }); // If we have less than 10 rows, lets measure all of them\n\n  if (dataContainer.numRows() <= numRowsToCalculate) {\n    rowsToSample = Array.from(Array(dataContainer.numRows()).keys());\n  }\n  var rowWidth = Math.max.apply(Math, (0, _toConsumableArray2[\"default\"])(rowsToSample.map(function (rowIdx) {\n    return Math.ceil(context.measureText((0, _dataUtils.parseFieldValue)(dataContainer.valueAt(rowIdx, colIdx), type)).width) + cellPadding;\n  }))); // header cell only has left padding\n\n  var headerWidth = Math.ceil(context.measureText(column).width) + cellPadding / 2 + optionsButton;\n  var minRowWidth = minCellSize + cellPadding;\n  var minHeaderWidth = minCellSize + cellPadding / 2 + optionsButton;\n  var clampedRowWidth = clamp(minRowWidth, maxCellSize, rowWidth);\n  var clampedHeaderWidth = clamp(minHeaderWidth, maxHeaderSize, headerWidth); // cleanup\n\n  textCanvas.parentElement.removeChild(textCanvas);\n  return {\n    row: clampedRowWidth,\n    header: clampedHeaderWidth\n  };\n}\nfunction clamp(min, max, value) {\n  return Math.max(Math.min(max, value), min);\n}\nfunction getColumnOrder() {\n  var pinnedColumns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var unpinnedColumns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return [].concat((0, _toConsumableArray2[\"default\"])(pinnedColumns), (0, _toConsumableArray2[\"default\"])(unpinnedColumns));\n}\nfunction getMinCellSize(cellSizeCache) {\n  return Object.keys(cellSizeCache).reduce(function (accu, col) {\n    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, col, cellSizeCache[col].row));\n  }, {});\n}\nfunction getSizeSum(sizeCache, key) {\n  return Object.keys(sizeCache).reduce(function (acc, val) {\n    return acc + (key ? sizeCache[val][key] : sizeCache[val]);\n  }, 0);\n}\n/**\n * Expand cell to fit both row and header, if there is still room left,\n * expand last cell to fit the entire width of the container\n * @param {object} cellSizeCache\n * @param {string[]} columnOrder\n * @param {number} containerWidth\n * @param {number} roomToFill\n */\n\nfunction expandCellSize(cellSizeCache, columnOrder, containerWidth, roomToFill) {\n  var remaining = roomToFill;\n  var expandedCellSize = columnOrder.reduce(function (accu, col) {\n    var size = cellSizeCache[col].row;\n    if (cellSizeCache[col].row < cellSizeCache[col].header && remaining > 0) {\n      // if we are cutting off the header, expand to fit it\n      size = cellSizeCache[col].header - cellSizeCache[col].row < remaining ? cellSizeCache[col].header : cellSizeCache[col].row + remaining;\n      remaining -= size - cellSizeCache[col].row;\n    }\n    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, col, size));\n  }, {});\n  var ghost = null;\n  if (remaining > 0 && remaining < MIN_GHOST_CELL_SIZE) {\n    // expand last cell\n    var lastCell = columnOrder[columnOrder.length - 1];\n    expandedCellSize[lastCell] += remaining;\n  } else if (remaining >= MIN_GHOST_CELL_SIZE) {\n    // if too much left add a ghost cell\n    ghost = remaining;\n  }\n  return {\n    cellSizeCache: expandedCellSize,\n    ghost: ghost\n  };\n}\n/**\n * Adjust cell size based on container width\n * @param {number} containerWidth\n * @param {Object} cellSizeCache\n * @param {string[]} pinnedColumns\n * @param {string[]} unpinnedColumns\n */\n\nfunction adjustCellsToContainer(containerWidth, cellSizeCache, pinnedColumns, unpinnedColumns) {\n  var minRowSum = getSizeSum(cellSizeCache, 'row');\n  if (minRowSum >= containerWidth) {\n    // we apply the min Width to all cells\n    return {\n      cellSizeCache: getMinCellSize(cellSizeCache)\n    };\n  } // if we have some room to expand\n\n  var columnOrder = getColumnOrder(pinnedColumns, unpinnedColumns);\n  return expandCellSize(cellSizeCache, columnOrder, containerWidth, containerWidth - minRowSum);\n}","map":{"version":3,"sources":["../../../../src/components/common/data-table/cell-size.js"],"names":["MIN_GHOST_CELL_SIZE","renderedSize","text","dataContainer","column","type","colIdx","numRowsToCalculate","fontSize","font","cellPadding","maxCellSize","maxHeaderSize","minCellSize","optionsButton","document","row","header","textCanvas","createElement","body","appendChild","context","getContext","join","rowsToSample","Array","map","Math","floor","random","numRows","from","keys","rowWidth","max","ceil","measureText","valueAt","rowIdx","width","headerWidth","minRowWidth","minHeaderWidth","clampedRowWidth","clamp","clampedHeaderWidth","parentElement","removeChild","min","value","getColumnOrder","pinnedColumns","unpinnedColumns","getMinCellSize","cellSizeCache","reduce","accu","col","getSizeSum","sizeCache","key","acc","val","expandCellSize","columnOrder","containerWidth","roomToFill","remaining","expandedCellSize","size","ghost","lastCell","length","adjustCellsToContainer","minRowSum"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport document from 'global/document';\nimport {parseFieldValue} from 'utils/data-utils';\n\nconst MIN_GHOST_CELL_SIZE = 200;\n\n/**\n * Measure rows and column content to determine min width for each column\n * @param {*} param0\n */\nexport function renderedSize({\n  text: {dataContainer, column},\n  type = 'string',\n  colIdx,\n  numRowsToCalculate = 10,\n  fontSize = 12,\n  font = 'Lato',\n  cellPadding = 40,\n  maxCellSize = 400,\n  maxHeaderSize = 150,\n  minCellSize = 45,\n  optionsButton = 30\n}) {\n  if (!document) {\n    return {\n      row: 0,\n      header: 0\n    };\n  }\n  const textCanvas = document.createElement('canvas');\n  document.body.appendChild(textCanvas);\n  const context = textCanvas.getContext('2d');\n  context.font = [fontSize, font].join('px ');\n\n  let rowsToSample = [...Array(numRowsToCalculate)].map(() =>\n    Math.floor(Math.random() * (dataContainer.numRows() - 1))\n  );\n\n  // If we have less than 10 rows, lets measure all of them\n  if (dataContainer.numRows() <= numRowsToCalculate) {\n    rowsToSample = Array.from(Array(dataContainer.numRows()).keys());\n  }\n  const rowWidth = Math.max(\n    ...rowsToSample.map(\n      rowIdx =>\n        Math.ceil(\n          context.measureText(parseFieldValue(dataContainer.valueAt(rowIdx, colIdx), type)).width\n        ) + cellPadding\n    )\n  );\n  // header cell only has left padding\n  const headerWidth =\n    Math.ceil(context.measureText(column).width) + cellPadding / 2 + optionsButton;\n\n  const minRowWidth = minCellSize + cellPadding;\n  const minHeaderWidth = minCellSize + cellPadding / 2 + optionsButton;\n\n  const clampedRowWidth = clamp(minRowWidth, maxCellSize, rowWidth);\n  const clampedHeaderWidth = clamp(minHeaderWidth, maxHeaderSize, headerWidth);\n\n  // cleanup\n  textCanvas.parentElement.removeChild(textCanvas);\n\n  return {\n    row: clampedRowWidth,\n    header: clampedHeaderWidth\n  };\n}\n\nfunction clamp(min, max, value) {\n  return Math.max(Math.min(max, value), min);\n}\n\nfunction getColumnOrder(pinnedColumns = [], unpinnedColumns = []) {\n  return [...pinnedColumns, ...unpinnedColumns];\n}\n\nfunction getMinCellSize(cellSizeCache) {\n  return Object.keys(cellSizeCache).reduce(\n    (accu, col) => ({\n      ...accu,\n      [col]: cellSizeCache[col].row\n    }),\n    {}\n  );\n}\n\nfunction getSizeSum(sizeCache, key) {\n  return Object.keys(sizeCache).reduce(\n    (acc, val) => acc + (key ? sizeCache[val][key] : sizeCache[val]),\n    0\n  );\n}\n\n/**\n * Expand cell to fit both row and header, if there is still room left,\n * expand last cell to fit the entire width of the container\n * @param {object} cellSizeCache\n * @param {string[]} columnOrder\n * @param {number} containerWidth\n * @param {number} roomToFill\n */\nfunction expandCellSize(cellSizeCache, columnOrder, containerWidth, roomToFill) {\n  let remaining = roomToFill;\n\n  const expandedCellSize = columnOrder.reduce((accu, col) => {\n    let size = cellSizeCache[col].row;\n    if (cellSizeCache[col].row < cellSizeCache[col].header && remaining > 0) {\n      // if we are cutting off the header, expand to fit it\n      size =\n        cellSizeCache[col].header - cellSizeCache[col].row < remaining\n          ? cellSizeCache[col].header\n          : cellSizeCache[col].row + remaining;\n      remaining -= size - cellSizeCache[col].row;\n    }\n\n    return {\n      ...accu,\n      [col]: size\n    };\n  }, {});\n\n  let ghost = null;\n  if (remaining > 0 && remaining < MIN_GHOST_CELL_SIZE) {\n    // expand last cell\n    const lastCell = columnOrder[columnOrder.length - 1];\n    expandedCellSize[lastCell] += remaining;\n  } else if (remaining >= MIN_GHOST_CELL_SIZE) {\n    // if too much left add a ghost cell\n    ghost = remaining;\n  }\n\n  return {\n    cellSizeCache: expandedCellSize,\n    ghost\n  };\n}\n\n/**\n * Adjust cell size based on container width\n * @param {number} containerWidth\n * @param {Object} cellSizeCache\n * @param {string[]} pinnedColumns\n * @param {string[]} unpinnedColumns\n */\nexport function adjustCellsToContainer(\n  containerWidth,\n  cellSizeCache,\n  pinnedColumns,\n  unpinnedColumns\n) {\n  const minRowSum = getSizeSum(cellSizeCache, 'row');\n  if (minRowSum >= containerWidth) {\n    // we apply the min Width to all cells\n    return {cellSizeCache: getMinCellSize(cellSizeCache)};\n  }\n\n  // if we have some room to expand\n  const columnOrder = getColumnOrder(pinnedColumns, unpinnedColumns);\n  return expandCellSize(cellSizeCache, columnOrder, containerWidth, containerWidth - minRowSum);\n}\n"]},"metadata":{},"sourceType":"script"}