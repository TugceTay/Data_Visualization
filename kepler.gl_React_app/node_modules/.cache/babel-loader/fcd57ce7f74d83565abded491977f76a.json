{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar ShaderAttribute = function () {\n  function ShaderAttribute(dataColumn, opts) {\n    _classCallCheck(this, ShaderAttribute);\n    this.opts = opts;\n    this.source = dataColumn;\n  }\n  _createClass(ShaderAttribute, [{\n    key: \"getValue\",\n    value: function getValue() {\n      var buffer = this.source.getBuffer();\n      var accessor = this.getAccessor();\n      if (buffer) {\n        return [buffer, accessor];\n      }\n      var value = this.source.value;\n      var size = accessor.size;\n      var constantValue = value;\n      if (value && value.length !== size) {\n        constantValue = new Float32Array(size);\n        var index = accessor.elementOffset || 0;\n        for (var i = 0; i < size; ++i) {\n          constantValue[i] = value[index + i];\n        }\n      }\n      return constantValue;\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor() {\n      return _objectSpread({}, this.source.getAccessor(), {}, this.opts);\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.source.value;\n    }\n  }]);\n  return ShaderAttribute;\n}();\nexport { ShaderAttribute as default };","map":{"version":3,"sources":["../../../../src/lib/attribute/shader-attribute.js"],"names":["ShaderAttribute","dataColumn","opts","source","value","buffer","getBuffer","accessor","getAccessor","size","constantValue","length","Float32Array","index","elementOffset","i"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAGqBA,e;EACnB,SAAA,eAAA,CAAYC,UAAZ,EAAwBC,IAAxB,EAA8B;IAAA,eAAA,CAAA,IAAA,EAAA,eAAA,CAAA;IAE5B,IAAA,CAAKA,IAAL,GAAYA,IAAZ;IACA,IAAA,CAAKC,MAAL,GAAcF,UAAd;EACD;;;+BAMU;MACT,IAAMI,MAAM,GAAG,IAAA,CAAKF,MAAL,CAAYG,SAAZ,EAAf;MACA,IAAMC,QAAQ,GAAG,IAAA,CAAKC,WAAL,EAAjB;MACA,IAAIH,MAAJ,EAAY;QACV,OAAO,CAACA,MAAD,EAASE,QAAT,CAAP;MACD;MALQ,IAOFH,KAPE,GAOO,IAAA,CAAKD,MAPZ,CAOFC,KAPE;MAAA,IAQFK,IARE,GAQMF,QARN,CAQFE,IARE;MAST,IAAIC,aAAa,GAAGN,KAApB;MAEA,IAAIA,KAAK,IAAIA,KAAK,CAACO,MAANP,KAAiBK,IAA9B,EAAoC;QAClCC,aAAa,GAAG,IAAIE,YAAJ,CAAiBH,IAAjB,CAAhBC;QAEA,IAAMG,KAAK,GAAGN,QAAQ,CAACO,aAATP,IAA0B,CAAxC;QACA,KAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAApB,EAA0B,EAAEM,CAA5B,EAA+B;UAC7BL,aAAa,CAACK,CAAD,CAAbL,GAAmBN,KAAK,CAACS,KAAK,GAAGE,CAAT,CAAxBL;QACD;MACF;MAED,OAAOA,aAAP;IACD;;;kCAEa;MACZ,OAAA,aAAA,CAAA,CAAA,CAAA,EAEK,IAAA,CAAKP,MAAL,CAAYK,WAAZ,EAFL,EAAA,CAAA,CAAA,EAIK,IAAA,CAAKN,IAJV,CAAA;IAMD;;;wBAlCW;MACV,OAAO,IAAA,CAAKC,MAAL,CAAYC,KAAnB;IACD;;;;SATkBJ,e","sourcesContent":["/* eslint-disable complexity */\n\n/* This class creates a luma.gl-compatible \"view\" on top of a DataColumn instance */\nexport default class ShaderAttribute {\n  constructor(dataColumn, opts) {\n    // Options that cannot be changed later\n    this.opts = opts;\n    this.source = dataColumn;\n  }\n\n  get value() {\n    return this.source.value;\n  }\n\n  getValue() {\n    const buffer = this.source.getBuffer();\n    const accessor = this.getAccessor();\n    if (buffer) {\n      return [buffer, accessor];\n    }\n\n    const {value} = this.source;\n    const {size} = accessor;\n    let constantValue = value;\n\n    if (value && value.length !== size) {\n      constantValue = new Float32Array(size);\n      // initiate offset values\n      const index = accessor.elementOffset || 0; // element offset\n      for (let i = 0; i < size; ++i) {\n        constantValue[i] = value[index + i];\n      }\n    }\n\n    return constantValue;\n  }\n\n  getAccessor() {\n    return {\n      // source data accessor\n      ...this.source.getAccessor(),\n      // shader attribute overrides\n      ...this.opts\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}