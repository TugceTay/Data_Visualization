{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _wrapAsyncGenerator from \"@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _awaitAsyncGenerator from \"@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _asyncIterator from \"@babel/runtime/helpers/esm/asyncIterator\";\nimport _asyncGeneratorDelegate from \"@babel/runtime/helpers/esm/asyncGeneratorDelegate\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport { assert } from '@loaders.gl/loader-utils';\nimport { concatenateChunksAsync, makeTransformIterator } from '@loaders.gl/loader-utils';\nimport { isLoaderObject } from '../loader-utils/normalize-loader';\nimport { normalizeOptions } from '../loader-utils/option-utils';\nimport { getLoaderContext } from '../loader-utils/context-utils';\nimport { getAsyncIteratorFromData, getReadableStream } from '../loader-utils/get-data';\nimport { getResourceUrlAndType } from '../utils/resource-utils';\nimport { selectLoader } from './select-loader';\nimport { parse } from './parse';\nexport function parseInBatches(_x2, _x3, _x4, _x5) {\n  return _parseInBatches.apply(this, arguments);\n}\nfunction _parseInBatches() {\n  _parseInBatches = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(data, loaders, options, context) {\n    var _getResourceUrlAndTyp, url, loader;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            assert(!context || typeof context !== 'string', 'parseInBatches no longer accepts final url');\n            if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n              context = options;\n              options = loaders;\n              loaders = null;\n            }\n            _context.next = 4;\n            return data;\n          case 4:\n            data = _context.sent;\n            options = options || {};\n            _getResourceUrlAndTyp = getResourceUrlAndType(data), url = _getResourceUrlAndTyp.url;\n            _context.next = 9;\n            return selectLoader(data, loaders, options);\n          case 9:\n            loader = _context.sent;\n            if (loader) {\n              _context.next = 12;\n              break;\n            }\n            return _context.abrupt(\"return\", null);\n          case 12:\n            options = normalizeOptions(options, loader, loaders, url);\n            context = getLoaderContext({\n              url: url,\n              parseInBatches: parseInBatches,\n              parse: parse,\n              loaders: loaders\n            }, options, context);\n            _context.next = 16;\n            return parseWithLoaderInBatches(loader, data, options, context);\n          case 16:\n            return _context.abrupt(\"return\", _context.sent);\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseInBatches.apply(this, arguments);\n}\nfunction parseWithLoaderInBatches(_x6, _x7, _x8, _x9) {\n  return _parseWithLoaderInBatches.apply(this, arguments);\n}\nfunction _parseWithLoaderInBatches() {\n  _parseWithLoaderInBatches = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(loader, data, options, context) {\n    var outputIterator, metadataBatch, makeMetadataBatchIterator, _makeMetadataBatchIterator;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _makeMetadataBatchIterator = function _makeMetadataBatchIte2() {\n              _makeMetadataBatchIterator = _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee2(iterator) {\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.next = 2;\n                        return metadataBatch;\n                      case 2:\n                        return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(iterator), _awaitAsyncGenerator), \"t0\", 3);\n                      case 3:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n              return _makeMetadataBatchIterator.apply(this, arguments);\n            };\n            makeMetadataBatchIterator = function _makeMetadataBatchIte(_x) {\n              return _makeMetadataBatchIterator.apply(this, arguments);\n            };\n            _context3.next = 4;\n            return parseToOutputIterator(loader, data, options, context);\n          case 4:\n            outputIterator = _context3.sent;\n            if (options.metadata) {\n              _context3.next = 7;\n              break;\n            }\n            return _context3.abrupt(\"return\", outputIterator);\n          case 7:\n            metadataBatch = {\n              batchType: 'metadata',\n              metadata: {\n                _loader: loader,\n                _context: context\n              },\n              data: [],\n              bytesUsed: 0\n            };\n            return _context3.abrupt(\"return\", makeMetadataBatchIterator(outputIterator));\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _parseWithLoaderInBatches.apply(this, arguments);\n}\nfunction parseToOutputIterator(_x10, _x11, _x12, _x13) {\n  return _parseToOutputIterator.apply(this, arguments);\n}\nfunction _parseToOutputIterator() {\n  _parseToOutputIterator = _asyncToGenerator(_regeneratorRuntime.mark(function _callee5(loader, data, options, context) {\n    var inputIterator, iteratorChain, stream, parseChunkInBatches, _parseChunkInBatches;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _parseChunkInBatches = function _parseChunkInBatches3() {\n              _parseChunkInBatches = _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee4() {\n                var inputIterator, arrayBuffer;\n                return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                  while (1) {\n                    switch (_context4.prev = _context4.next) {\n                      case 0:\n                        _context4.next = 2;\n                        return _awaitAsyncGenerator(getAsyncIteratorFromData(data));\n                      case 2:\n                        inputIterator = _context4.sent;\n                        _context4.next = 5;\n                        return _awaitAsyncGenerator(concatenateChunksAsync(inputIterator));\n                      case 5:\n                        arrayBuffer = _context4.sent;\n                        _context4.next = 8;\n                        return loader.parse(arrayBuffer, options, context, loader);\n                      case 8:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }\n                }, _callee4);\n              }));\n              return _parseChunkInBatches.apply(this, arguments);\n            };\n            parseChunkInBatches = function _parseChunkInBatches2() {\n              return _parseChunkInBatches.apply(this, arguments);\n            };\n            if (!loader.parseInBatches) {\n              _context5.next = 10;\n              break;\n            }\n            _context5.next = 5;\n            return getAsyncIteratorFromData(data);\n          case 5:\n            inputIterator = _context5.sent;\n            iteratorChain = applyInputTransforms(inputIterator, options);\n            _context5.next = 9;\n            return loader.parseInBatches(iteratorChain, options, context, loader);\n          case 9:\n            return _context5.abrupt(\"return\", _context5.sent);\n          case 10:\n            if (!loader.parseStreamInBatches) {\n              _context5.next = 17;\n              break;\n            }\n            _context5.next = 13;\n            return getReadableStream(data);\n          case 13:\n            stream = _context5.sent;\n            if (!stream) {\n              _context5.next = 17;\n              break;\n            }\n            if (options.transforms) {\n              console.warn('options.transforms not implemented for loaders that use `parseStreamInBatches`');\n            }\n            return _context5.abrupt(\"return\", loader.parseStreamInBatches(stream, options, context));\n          case 17:\n            _context5.next = 19;\n            return parseChunkInBatches();\n          case 19:\n            return _context5.abrupt(\"return\", _context5.sent);\n          case 20:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _parseToOutputIterator.apply(this, arguments);\n}\nfunction applyInputTransforms(inputIterator, options) {\n  var iteratorChain = inputIterator;\n  var _iterator = _createForOfIteratorHelper(options.transforms || []),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var Transform = _step.value;\n      iteratorChain = makeTransformIterator(iteratorChain, Transform, options);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return iteratorChain;\n}","map":{"version":3,"sources":["../../../../src/lib/api/parse-in-batches.js"],"names":["assert","concatenateChunksAsync","makeTransformIterator","isLoaderObject","normalizeOptions","getLoaderContext","getAsyncIteratorFromData","getReadableStream","getResourceUrlAndType","selectLoader","parse","parseInBatches","data","loaders","options","context","Array","isArray","url","loader","parseWithLoaderInBatches","outputIterator","parseToOutputIterator","metadata","metadataBatch","batchType","_loader","_context","bytesUsed","makeMetadataBatchIterator","iterator","inputIterator","iteratorChain","applyInputTransforms","parseStreamInBatches","stream","transforms","console","warn","parseChunkInBatches","arrayBuffer","Transform"],"mappings":"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","sourcesContent":["import {assert} from '@loaders.gl/loader-utils';\nimport {concatenateChunksAsync, makeTransformIterator} from '@loaders.gl/loader-utils';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {normalizeOptions} from '../loader-utils/option-utils';\nimport {getLoaderContext} from '../loader-utils/context-utils';\nimport {getAsyncIteratorFromData, getReadableStream} from '../loader-utils/get-data';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {selectLoader} from './select-loader';\n\n// Ensure `parse` is available in context if loader falls back to `parse`\nimport {parse} from './parse';\n\nexport async function parseInBatches(data, loaders, options, context) {\n  assert(!context || typeof context !== 'string', 'parseInBatches no longer accepts final url');\n\n  // Signature: parseInBatches(data, options, url) - Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = options;\n    options = loaders;\n    loaders = null;\n  }\n\n  data = await data; // Resolve any promise\n  options = options || {};\n\n  // Extract a url for auto detection\n  const {url} = getResourceUrlAndType(data);\n\n  // Chooses a loader and normalizes it\n  // Note - only uses URL and contentType for streams and iterator inputs\n  const loader = await selectLoader(data, loaders, options);\n  // Note: if options.nothrow was set, it is possible that no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n\n  // Normalize options\n  options = normalizeOptions(options, loader, loaders, url);\n  context = getLoaderContext({url, parseInBatches, parse, loaders}, options, context);\n\n  return await parseWithLoaderInBatches(loader, data, options, context);\n}\n\n/**\n * Loader has beens selected and context has been prepared, see if we need to emit a metadata batch\n */\nasync function parseWithLoaderInBatches(loader, data, options, context) {\n  const outputIterator = await parseToOutputIterator(loader, data, options, context);\n\n  // Generate metadata batch if requested\n  if (!options.metadata) {\n    return outputIterator;\n  }\n\n  const metadataBatch = {\n    batchType: 'metadata',\n    metadata: {\n      _loader: loader,\n      _context: context\n    },\n    // Populate with some default fields to avoid crashing\n    data: [],\n    bytesUsed: 0\n  };\n\n  async function* makeMetadataBatchIterator(iterator) {\n    yield metadataBatch;\n    yield* iterator;\n  }\n\n  return makeMetadataBatchIterator(outputIterator);\n}\n\n/**\n * Prep work is done, now it is time to start parsing into an output operator\n * The approach depends on which parse function the loader exposes\n * `parseInBatches` (preferred), `parseStreamInBatches` (limited), `parse` (fallback)\n */\nasync function parseToOutputIterator(loader, data, options, context) {\n  if (loader.parseInBatches) {\n    const inputIterator = await getAsyncIteratorFromData(data);\n\n    const iteratorChain = applyInputTransforms(inputIterator, options);\n\n    return await loader.parseInBatches(iteratorChain, options, context, loader);\n  }\n\n  if (loader.parseStreamInBatches) {\n    const stream = await getReadableStream(data);\n    if (stream) {\n      if (options.transforms) {\n        // eslint-disable-next-line\n        console.warn(\n          'options.transforms not implemented for loaders that use `parseStreamInBatches`'\n        );\n      }\n      return loader.parseStreamInBatches(stream, options, context);\n    }\n  }\n\n  // Fallback: load atomically using `parse` concatenating input iterator into single chunk\n  async function* parseChunkInBatches() {\n    const inputIterator = await getAsyncIteratorFromData(data);\n    const arrayBuffer = await concatenateChunksAsync(inputIterator);\n    // yield a single batch, the output from loader.parse()\n    yield loader.parse(arrayBuffer, options, context, loader);\n  }\n\n  return await parseChunkInBatches();\n}\n\n/**\n * Create an iterator chain with any transform iterators (crypto, decompression)\n * @param inputIterator\n * @param options\n */\nfunction applyInputTransforms(inputIterator, options) {\n  let iteratorChain = inputIterator;\n  for (const Transform of options.transforms || []) {\n    // @ts-ignore\n    iteratorChain = makeTransformIterator(iteratorChain, Transform, options);\n  }\n  return iteratorChain;\n}\n"]},"metadata":{},"sourceType":"module"}