{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { getMeshBoundingBox } from '@loaders.gl/loader-utils';\nimport decode, { DECODING_STEPS } from './decode-quantized-mesh';\nfunction getMeshAttributes(vertexData, header, bounds) {\n  var minHeight = header.minHeight,\n    maxHeight = header.maxHeight;\n  var _ref = bounds || [0, 0, 1, 1],\n    _ref2 = _slicedToArray(_ref, 4),\n    minX = _ref2[0],\n    minY = _ref2[1],\n    maxX = _ref2[2],\n    maxY = _ref2[3];\n  var xScale = maxX - minX;\n  var yScale = maxY - minY;\n  var zScale = maxHeight - minHeight;\n  var nCoords = vertexData.length / 3;\n  var positions = new Float32Array(nCoords * 3);\n  var texCoords = new Float32Array(nCoords * 2);\n  for (var i = 0; i < nCoords; i++) {\n    var x = vertexData[i] / 32767;\n    var y = vertexData[i + nCoords] / 32767;\n    var z = vertexData[i + nCoords * 2] / 32767;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = y * yScale + minY;\n    positions[3 * i + 2] = z * zScale + minHeight;\n    texCoords[2 * i + 0] = x;\n    texCoords[2 * i + 1] = y;\n  }\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n  };\n}\nfunction getTileMesh(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n  var bounds = options.bounds;\n  var _decode = decode(arrayBuffer, DECODING_STEPS.triangleIndices),\n    header = _decode.header,\n    vertexData = _decode.vertexData,\n    triangleIndices = _decode.triangleIndices;\n  var attributes = getMeshAttributes(vertexData, header, bounds);\n  return {\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangleIndices.length,\n      boundingBox: getMeshBoundingBox(attributes)\n    },\n    mode: 4,\n    indices: {\n      value: triangleIndices,\n      size: 1\n    },\n    attributes: attributes\n  };\n}\nexport default function loadQuantizedMesh(arrayBuffer, options) {\n  return getTileMesh(arrayBuffer, options['quantized-mesh']);\n}","map":{"version":3,"sources":["../../../src/lib/parse-quantized-mesh.js"],"names":["getMeshBoundingBox","decode","DECODING_STEPS","getMeshAttributes","vertexData","header","bounds","minHeight","maxHeight","minX","minY","maxX","maxY","xScale","yScale","zScale","nCoords","length","positions","Float32Array","texCoords","i","x","y","z","POSITION","value","size","TEXCOORD_0","getTileMesh","arrayBuffer","options","triangleIndices","attributes","loaderData","vertexCount","boundingBox","mode","indices","loadQuantizedMesh"],"mappings":"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","sourcesContent":["import {getMeshBoundingBox} from '@loaders.gl/loader-utils';\nimport decode, {DECODING_STEPS} from './decode-quantized-mesh';\n\nfunction getMeshAttributes(vertexData, header, bounds) {\n  const {minHeight, maxHeight} = header;\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];\n  const xScale = maxX - minX;\n  const yScale = maxY - minY;\n  const zScale = maxHeight - minHeight;\n\n  const nCoords = vertexData.length / 3;\n  // vec3. x, y defined by bounds, z in meters\n  const positions = new Float32Array(nCoords * 3);\n\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(nCoords * 2);\n\n  // Data is not interleaved; all u, then all v, then all heights\n  for (let i = 0; i < nCoords; i++) {\n    const x = vertexData[i] / 32767;\n    const y = vertexData[i + nCoords] / 32767;\n    const z = vertexData[i + nCoords * 2] / 32767;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = y * yScale + minY;\n    positions[3 * i + 2] = z * zScale + minHeight;\n\n    texCoords[2 * i + 0] = x;\n    texCoords[2 * i + 1] = y;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // TODO: Parse normals if they exist in the file\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\nfunction getTileMesh(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n  const {bounds} = options;\n  // Don't parse edge indices or format extensions\n  const {header, vertexData, triangleIndices} = decode(arrayBuffer, DECODING_STEPS.triangleIndices);\n  // TODO: use skirt information from file\n  const attributes = getMeshAttributes(vertexData, header, bounds);\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      // @ts-ignore\n      vertexCount: triangleIndices.length,\n      // TODO: Find bounding box from header, instead of doing extra pass over\n      // vertices.\n      boundingBox: getMeshBoundingBox(attributes)\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: triangleIndices, size: 1},\n    attributes\n  };\n}\n\nexport default function loadQuantizedMesh(arrayBuffer, options) {\n  return getTileMesh(arrayBuffer, options['quantized-mesh']);\n}\n"]},"metadata":{},"sourceType":"module"}