{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport ManagedArray from '../../utils/managed-array';\nimport { TILE_REFINEMENT } from '../../constants';\nimport { assert } from '@loaders.gl/loader-utils';\nexport var DEFAULT_OPTIONS = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2\n};\nvar TilesetTraverser = function () {\n  function TilesetTraverser(options) {\n    _classCallCheck(this, TilesetTraverser);\n    this.options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n    this._frameNumber = null;\n    this.root = null;\n    this.selectedTiles = {};\n    this.requestedTiles = {};\n    this.emptyTiles = {};\n  }\n  _createClass(TilesetTraverser, [{\n    key: \"traverse\",\n    value: function traverse(root, frameState, options) {\n      this.root = root;\n      this.options = _objectSpread(_objectSpread({}, this.options), options);\n      this.reset();\n      this.updateTile(root, frameState);\n      this._frameNumber = frameState.frameNumber;\n      this.executeTraversal(root, frameState);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.requestedTiles = {};\n      this.selectedTiles = {};\n      this.emptyTiles = {};\n      this._traversalStack.reset();\n      this._emptyTraversalStack.reset();\n    }\n  }, {\n    key: \"executeTraversal\",\n    value: function executeTraversal(root, frameState) {\n      var stack = this._traversalStack;\n      stack.push(root);\n      while (stack.length > 0) {\n        var tile = stack.pop();\n        var shouldRefine = false;\n        if (this.canTraverse(tile, frameState)) {\n          this.updateChildTiles(tile, frameState);\n          shouldRefine = this.updateAndPushChildren(tile, frameState, stack);\n        }\n        var parent = tile.parent;\n        var parentRefines = Boolean(!parent || parent._shouldRefine);\n        var stoppedRefining = !shouldRefine;\n        if (!tile.hasRenderContent) {\n          this.emptyTiles[tile.id] = tile;\n          this.loadTile(tile, frameState);\n          if (stoppedRefining) {\n            this.selectTile(tile, frameState);\n          }\n        } else if (tile.refine === TILE_REFINEMENT.ADD) {\n          this.loadTile(tile, frameState);\n          this.selectTile(tile, frameState);\n        } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n          this.loadTile(tile, frameState);\n          if (stoppedRefining) {\n            this.selectTile(tile, frameState);\n          }\n        }\n        this.touchTile(tile, frameState);\n        tile._shouldRefine = shouldRefine && parentRefines;\n      }\n      if (this.options.onTraversalEnd) {\n        this.options.onTraversalEnd(frameState);\n      }\n    }\n  }, {\n    key: \"updateChildTiles\",\n    value: function updateChildTiles(tile, frameState) {\n      var children = tile.children;\n      var _iterator = _createForOfIteratorHelper(children),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          this.updateTile(child, frameState);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    }\n  }, {\n    key: \"updateAndPushChildren\",\n    value: function updateAndPushChildren(tile, frameState, stack) {\n      var _this$options = this.options,\n        loadSiblings = _this$options.loadSiblings,\n        skipLevelOfDetail = _this$options.skipLevelOfDetail;\n      var children = tile.children;\n      children.sort(this.compareDistanceToCamera);\n      var checkRefines = !skipLevelOfDetail && tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent;\n      var hasVisibleChild = false;\n      var _iterator2 = _createForOfIteratorHelper(children),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var child = _step2.value;\n          if (child.isVisibleAndInRequestVolume) {\n            if (stack.find(child)) {\n              stack[\"delete\"](child);\n            }\n            stack.push(child);\n            hasVisibleChild = true;\n          } else if (checkRefines || loadSiblings) {\n            this.loadTile(child, frameState);\n            this.touchTile(child, frameState);\n          }\n          if (checkRefines) {\n            var childRefines = void 0;\n            if (!child._inRequestVolume) {\n              childRefines = false;\n            } else if (!child.hasRenderContent) {\n              childRefines = this.executeEmptyTraversal(child, frameState);\n            } else {\n              childRefines = child.contentAvailable;\n            }\n            if (!childRefines) {\n              return childRefines;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return hasVisibleChild;\n    }\n  }, {\n    key: \"updateTile\",\n    value: function updateTile(tile, frameState) {\n      this.updateTileVisibility(tile, frameState);\n    }\n  }, {\n    key: \"selectTile\",\n    value: function selectTile(tile, frameState) {\n      if (this.shouldSelectTile(tile, frameState)) {\n        tile._selectedFrame = frameState.frameNumber;\n        this.selectedTiles[tile.id] = tile;\n      }\n    }\n  }, {\n    key: \"loadTile\",\n    value: function loadTile(tile, frameState) {\n      if (this.shouldLoadTile(tile, frameState)) {\n        tile._requestedFrame = frameState.frameNumber;\n        tile._priority = this.getPriority(tile);\n        this.requestedTiles[tile.id] = tile;\n      }\n    }\n  }, {\n    key: \"touchTile\",\n    value: function touchTile(tile, frameState) {\n      tile.tileset._cache.touch(tile);\n      tile._touchedFrame = frameState.frameNumber;\n    }\n  }, {\n    key: \"canTraverse\",\n    value: function canTraverse(tile, frameState) {\n      var useParentMetric = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var ignoreVisibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n        return false;\n      }\n      if (!tile.hasChildren) {\n        return false;\n      }\n      if (tile.hasTilesetContent) {\n        return !tile.contentExpired;\n      }\n      return this.shouldRefine(tile, frameState, useParentMetric);\n    }\n  }, {\n    key: \"shouldLoadTile\",\n    value: function shouldLoadTile(tile, frameState) {\n      return tile.hasUnloadedContent || tile.contentExpired;\n    }\n  }, {\n    key: \"shouldSelectTile\",\n    value: function shouldSelectTile(tile, frameState) {\n      return tile.contentAvailable && !this.options.skipLevelOfDetail;\n    }\n  }, {\n    key: \"shouldRefine\",\n    value: function shouldRefine(tile, frameState, useParentMetric) {\n      var screenSpaceError = tile._screenSpaceError;\n      if (useParentMetric) {\n        screenSpaceError = tile.getScreenSpaceError(frameState, true);\n      }\n      return screenSpaceError > this.options.maximumScreenSpaceError;\n    }\n  }, {\n    key: \"updateTileVisibility\",\n    value: function updateTileVisibility(tile, frameState) {\n      tile.updateVisibility(frameState);\n    }\n  }, {\n    key: \"compareDistanceToCamera\",\n    value: function compareDistanceToCamera(b, a) {\n      return b._distanceToCamera - a._distanceToCamera;\n    }\n  }, {\n    key: \"getPriority\",\n    value: function getPriority(tile) {\n      var options = this.options;\n      switch (tile.refine) {\n        case TILE_REFINEMENT.ADD:\n          return tile._distanceToCamera;\n        case TILE_REFINEMENT.REPLACE:\n          var parent = tile.parent;\n          var useParentScreenSpaceError = parent && (!options.skipLevelOfDetail || tile._screenSpaceError === 0.0 || parent.hasTilesetContent);\n          var screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : tile._screenSpaceError;\n          var rootScreenSpaceError = this.root._screenSpaceError;\n          return rootScreenSpaceError - screenSpaceError;\n        default:\n          return assert(false);\n      }\n    }\n  }, {\n    key: \"anyChildrenVisible\",\n    value: function anyChildrenVisible(tile, frameState) {\n      var anyVisible = false;\n      var _iterator3 = _createForOfIteratorHelper(tile.children),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var child = _step3.value;\n          child.updateVisibility(frameState);\n          anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return anyVisible;\n    }\n  }, {\n    key: \"executeEmptyTraversal\",\n    value: function executeEmptyTraversal(root, frameState) {\n      var allDescendantsLoaded = true;\n      var stack = this._emptyTraversalStack;\n      while (stack.length > 0) {\n        var tile = stack.pop();\n        this.updateTile(tile, frameState);\n        if (!tile.isVisibleAndInRequestVolume) {\n          this.loadTile(tile, frameState);\n          this.touchTile(tile, frameState);\n        }\n        var traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n        if (!traverse && !tile.contentAvailable) {\n          allDescendantsLoaded = false;\n        }\n        if (traverse) {\n          var children = tile.children.filter(function (c) {\n            return c;\n          });\n          var _iterator4 = _createForOfIteratorHelper(children),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var child = _step4.value;\n              if (stack.find(child)) {\n                stack[\"delete\"](child);\n              }\n              stack.push(child);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      }\n      return allDescendantsLoaded;\n    }\n  }]);\n  return TilesetTraverser;\n}();\nexport { TilesetTraverser as default };","map":{"version":3,"sources":["../../../../src/tileset/traversers/tileset-traverser.js"],"names":["ManagedArray","TILE_REFINEMENT","assert","DEFAULT_OPTIONS","loadSiblings","skipLevelOfDetail","maximumScreenSpaceError","TilesetTraverser","options","_traversalStack","_emptyTraversalStack","_frameNumber","root","selectedTiles","requestedTiles","emptyTiles","frameState","reset","updateTile","frameNumber","executeTraversal","stack","push","length","tile","pop","shouldRefine","canTraverse","updateChildTiles","updateAndPushChildren","parent","parentRefines","Boolean","_shouldRefine","stoppedRefining","hasRenderContent","id","loadTile","selectTile","refine","ADD","REPLACE","touchTile","onTraversalEnd","children","child","sort","compareDistanceToCamera","checkRefines","hasVisibleChild","isVisibleAndInRequestVolume","find","childRefines","_inRequestVolume","executeEmptyTraversal","contentAvailable","updateTileVisibility","shouldSelectTile","_selectedFrame","shouldLoadTile","_requestedFrame","_priority","getPriority","tileset","_cache","touch","_touchedFrame","useParentMetric","ignoreVisibility","hasChildren","hasTilesetContent","contentExpired","hasUnloadedContent","screenSpaceError","_screenSpaceError","getScreenSpaceError","updateVisibility","b","a","_distanceToCamera","useParentScreenSpaceError","rootScreenSpaceError","anyVisible","allDescendantsLoaded","traverse","filter","c"],"mappings":"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","sourcesContent":["import ManagedArray from '../../utils/managed-array';\nimport {TILE_REFINEMENT} from '../../constants';\nimport {assert} from '@loaders.gl/loader-utils';\n\nexport const DEFAULT_OPTIONS = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2\n};\n\nexport default class TilesetTraverser {\n  // TODO nested props\n  constructor(options) {\n    this.options = {...DEFAULT_OPTIONS, ...options};\n    // TRAVERSAL\n    // temporary storage to hold the traversed tiles during a traversal\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n\n    // set in every traverse cycle\n    this._frameNumber = null;\n\n    // fulfill in traverse call\n    this.root = null;\n\n    // RESULT\n    // tiles should be rendered\n    this.selectedTiles = {};\n    // tiles should be loaded from server\n    this.requestedTiles = {};\n    // tiles does not have render content\n    this.emptyTiles = {};\n  }\n\n  // tiles should be visible\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = {...this.options, ...options};\n\n    // reset result\n    this.reset();\n\n    // update tile (visibility and expiration)\n    this.updateTile(root, frameState);\n\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n    this._traversalStack.reset();\n    this._emptyTraversalStack.reset();\n  }\n\n  // execute traverse\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(root, frameState) {\n    // stack to store traversed tiles, only visible tiles should be added to stack\n    // visible: visible in the current view frustum\n    const stack = this._traversalStack;\n\n    stack.push(root);\n    while (stack.length > 0) {\n      // 1. pop tile\n      const tile = stack.pop();\n\n      // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n      let shouldRefine = false;\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(tile, frameState, stack);\n      }\n\n      // 3. decide if should render (select) this tile\n      //   - tile does not have render content\n      //   - tile has render content and tile is `add` type (pointcloud)\n      //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n        // additive tiles\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n\n        // replace tiles\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n      this.touchTile(tile, frameState);\n\n      // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n\n    if (this.options.onTraversalEnd) {\n      this.options.onTraversalEnd(frameState);\n    }\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n    return true;\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAndPushChildren(tile, frameState, stack) {\n    const {loadSiblings, skipLevelOfDetail} = this.options;\n\n    const children = tile.children;\n\n    // sort children tiles\n    children.sort(this.compareDistanceToCamera);\n\n    // For traditional replacement refinement only refine if all children are loaded.\n    // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    const checkRefines =\n      !skipLevelOfDetail && tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent;\n\n    let hasVisibleChild = false;\n    for (const child of children) {\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        // Keep non-visible children loaded since they are still needed before the parent can refine.\n        // Or loadSiblings is true so always load tiles regardless of visibility.\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n\n        if (!childRefines) {\n          return childRefines;\n        }\n      }\n    }\n\n    return hasVisibleChild;\n  }\n  /* eslint-enable complexity, max-statements */\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n\n  // tile to render in the browser\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile, frameState)) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n\n  // tile to load from server\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile, frameState)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = this.getPriority(tile);\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  // cache tile\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    // cesium specific\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile, frameState) {\n    // if request tile is in current frame\n    // and has unexpired render content\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile, frameState) {\n    // if select tile is in current frame\n    // and content available\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  // Decide if tile LoD (level of detail) is not sufficient under current viewport\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    tile.updateVisibility(frameState);\n  }\n\n  // UTILITIES\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  // If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n  // Additive tiles are prioritized by distance because it subjectively looks better.\n  // Replacement tiles are prioritized by screen space error.\n  // A tileset that has both additive and replacement tiles may not prioritize tiles as effectively since SSE and distance\n  // are different types of values. Maybe all priorities need to be normalized to 0-1 range.\n  // TODO move to tile-3d-header\n  getPriority(tile) {\n    const {options} = this;\n    switch (tile.refine) {\n      case TILE_REFINEMENT.ADD:\n        return tile._distanceToCamera;\n\n      case TILE_REFINEMENT.REPLACE:\n        const {parent} = tile;\n        const useParentScreenSpaceError =\n          parent &&\n          (!options.skipLevelOfDetail ||\n            tile._screenSpaceError === 0.0 ||\n            parent.hasTilesetContent);\n        const screenSpaceError = useParentScreenSpaceError\n          ? parent._screenSpaceError\n          : tile._screenSpaceError;\n        const rootScreenSpaceError = this.root._screenSpaceError;\n        return rootScreenSpaceError - screenSpaceError; // Map higher SSE to lower values (e.g. root tile is highest priority)\n\n      default:\n        return assert(false);\n    }\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n    return anyVisible;\n  }\n\n  // TODO revisit this empty traversal logic\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n\n    while (stack.length > 0) {\n      const tile = stack.pop();\n\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        // Load tiles that aren't visible since they are still needed for the parent to refine\n        this.loadTile(tile, frameState);\n        this.touchTile(tile, frameState);\n      }\n\n      // Only traverse if the tile is empty - traversal stop at descendants with content\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      // Traversal stops but the tile does not have content yet.\n      // There will be holes if the parent tries to refine to its children, so don't refine.\n      if (!traverse && !tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n\n      if (traverse) {\n        const children = tile.children.filter(c => c);\n        for (const child of children) {\n          // eslint-disable-next-line max-depth\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n          stack.push(child);\n        }\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n}\n\n// TODO\n// enable expiration\n// enable optimization hint\n"]},"metadata":{},"sourceType":"module"}