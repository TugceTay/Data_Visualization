{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _asyncIterator from \"@babel/runtime/helpers/esm/asyncIterator\";\nimport log from '../utils/log';\nimport { isAsyncIterable } from '../utils/iterable-utils';\nimport { PROP_SYMBOLS } from './constants';\nvar ASYNC_ORIGINAL = PROP_SYMBOLS.ASYNC_ORIGINAL,\n  ASYNC_RESOLVED = PROP_SYMBOLS.ASYNC_RESOLVED,\n  ASYNC_DEFAULTS = PROP_SYMBOLS.ASYNC_DEFAULTS;\nvar EMPTY_PROPS = Object.freeze({});\nvar ComponentState = function () {\n  function ComponentState() {\n    var component = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    _classCallCheck(this, ComponentState);\n    this.component = component;\n    this.asyncProps = {};\n    this.onAsyncPropUpdated = function () {};\n    this.oldProps = EMPTY_PROPS;\n    this.oldAsyncProps = null;\n  }\n  _createClass(ComponentState, [{\n    key: \"getOldProps\",\n    value: function getOldProps() {\n      return this.oldAsyncProps || this.oldProps;\n    }\n  }, {\n    key: \"resetOldProps\",\n    value: function resetOldProps() {\n      this.oldAsyncProps = null;\n      this.oldProps = this.component.props;\n    }\n  }, {\n    key: \"freezeAsyncOldProps\",\n    value: function freezeAsyncOldProps() {\n      if (!this.oldAsyncProps) {\n        this.oldProps = this.oldProps || this.component.props;\n        this.oldAsyncProps = Object.create(this.oldProps);\n        for (var propName in this.asyncProps) {\n          Object.defineProperty(this.oldAsyncProps, propName, {\n            enumerable: true,\n            value: this.oldProps[propName]\n          });\n        }\n      }\n    }\n  }, {\n    key: \"hasAsyncProp\",\n    value: function hasAsyncProp(propName) {\n      return propName in this.asyncProps;\n    }\n  }, {\n    key: \"getAsyncProp\",\n    value: function getAsyncProp(propName) {\n      var asyncProp = this.asyncProps[propName];\n      return asyncProp && asyncProp.resolvedValue;\n    }\n  }, {\n    key: \"isAsyncPropLoading\",\n    value: function isAsyncPropLoading(propName) {\n      if (propName) {\n        var asyncProp = this.asyncProps[propName];\n        return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);\n      }\n      for (var key in this.asyncProps) {\n        if (this.isAsyncPropLoading(key)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"reloadAsyncProp\",\n    value: function reloadAsyncProp(propName, value) {\n      this._watchPromise(propName, Promise.resolve(value));\n    }\n  }, {\n    key: \"setAsyncProps\",\n    value: function setAsyncProps(props) {\n      var resolvedValues = props[ASYNC_RESOLVED] || {};\n      var originalValues = props[ASYNC_ORIGINAL] || props;\n      var defaultValues = props[ASYNC_DEFAULTS] || {};\n      for (var propName in resolvedValues) {\n        var value = resolvedValues[propName];\n        this._createAsyncPropData(propName, value, defaultValues[propName]);\n        this._updateAsyncProp(propName, value);\n      }\n      for (var _propName in originalValues) {\n        var _value2 = originalValues[_propName];\n        this._createAsyncPropData(_propName, _value2, defaultValues[_propName]);\n        this._updateAsyncProp(_propName, _value2);\n      }\n    }\n  }, {\n    key: \"_updateAsyncProp\",\n    value: function _updateAsyncProp(propName, value) {\n      if (!this._didAsyncInputValueChange(propName, value)) {\n        return;\n      }\n      if (typeof value === 'string') {\n        var fetch = this.layer && this.layer.props.fetch;\n        var url = value;\n        if (fetch) {\n          value = fetch(url, {\n            propName: propName,\n            layer: this.layer\n          });\n        }\n      }\n      if (value instanceof Promise) {\n        this._watchPromise(propName, value);\n        return;\n      }\n      if (isAsyncIterable(value)) {\n        this._resolveAsyncIterable(propName, value);\n        return;\n      }\n      this._setPropValue(propName, value);\n    }\n  }, {\n    key: \"_didAsyncInputValueChange\",\n    value: function _didAsyncInputValueChange(propName, value) {\n      var asyncProp = this.asyncProps[propName];\n      if (value === asyncProp.lastValue) {\n        return false;\n      }\n      asyncProp.lastValue = value;\n      return true;\n    }\n  }, {\n    key: \"_setPropValue\",\n    value: function _setPropValue(propName, value) {\n      var asyncProp = this.asyncProps[propName];\n      asyncProp.value = value;\n      asyncProp.resolvedValue = value;\n      asyncProp.pendingLoadCount++;\n      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n    }\n  }, {\n    key: \"_setAsyncPropValue\",\n    value: function _setAsyncPropValue(propName, value, loadCount) {\n      var asyncProp = this.asyncProps[propName];\n      if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n        this.freezeAsyncOldProps();\n        asyncProp.resolvedValue = value;\n        asyncProp.resolvedLoadCount = loadCount;\n        this.onAsyncPropUpdated(propName, value);\n      }\n    }\n  }, {\n    key: \"_watchPromise\",\n    value: function _watchPromise(propName, promise) {\n      var _this = this;\n      var asyncProp = this.asyncProps[propName];\n      asyncProp.pendingLoadCount++;\n      var loadCount = asyncProp.pendingLoadCount;\n      promise.then(function (data) {\n        data = _this._postProcessValue(propName, data);\n        _this._setAsyncPropValue(propName, data, loadCount);\n        var onDataLoad = _this.layer && _this.layer.props.onDataLoad;\n        if (propName === 'data' && onDataLoad) {\n          onDataLoad(data, {\n            propName: propName,\n            layer: _this.layer\n          });\n        }\n      })[\"catch\"](function (error) {\n        return log.error(error)();\n      });\n    }\n  }, {\n    key: \"_resolveAsyncIterable\",\n    value: function () {\n      var _resolveAsyncIterable2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(propName, iterable) {\n        var asyncProp, loadCount, data, count, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, onDataLoad;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (propName !== 'data') {\n                  this._setPropValue(propName, iterable);\n                }\n                asyncProp = this.asyncProps[propName];\n                asyncProp.pendingLoadCount++;\n                loadCount = asyncProp.pendingLoadCount;\n                data = [];\n                count = 0;\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context.prev = 8;\n                _iterator = _asyncIterator(iterable);\n              case 10:\n                _context.next = 12;\n                return _iterator.next();\n              case 12:\n                _step = _context.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context.next = 16;\n                return _step.value;\n              case 16:\n                _value = _context.sent;\n                if (_iteratorNormalCompletion) {\n                  _context.next = 26;\n                  break;\n                }\n                chunk = _value;\n                data = this._postProcessValue(propName, chunk, data);\n                Object.defineProperty(data, '__diff', {\n                  enumerable: false,\n                  value: [{\n                    startRow: count,\n                    endRow: data.length\n                  }]\n                });\n                count = data.length;\n                this._setAsyncPropValue(propName, data, loadCount);\n              case 23:\n                _iteratorNormalCompletion = true;\n                _context.next = 10;\n                break;\n              case 26:\n                _context.next = 32;\n                break;\n              case 28:\n                _context.prev = 28;\n                _context.t0 = _context[\"catch\"](8);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n              case 32:\n                _context.prev = 32;\n                _context.prev = 33;\n                if (!(!_iteratorNormalCompletion && _iterator[\"return\"] != null)) {\n                  _context.next = 37;\n                  break;\n                }\n                _context.next = 37;\n                return _iterator[\"return\"]();\n              case 37:\n                _context.prev = 37;\n                if (!_didIteratorError) {\n                  _context.next = 40;\n                  break;\n                }\n                throw _iteratorError;\n              case 40:\n                return _context.finish(37);\n              case 41:\n                return _context.finish(32);\n              case 42:\n                onDataLoad = this.layer && this.layer.props.onDataLoad;\n                if (onDataLoad) {\n                  onDataLoad(data, {\n                    propName: propName,\n                    layer: this.layer\n                  });\n                }\n              case 44:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[8, 28, 32, 42], [33,, 37, 41]]);\n      }));\n      function _resolveAsyncIterable(_x, _x2) {\n        return _resolveAsyncIterable2.apply(this, arguments);\n      }\n      return _resolveAsyncIterable;\n    }()\n  }, {\n    key: \"_postProcessValue\",\n    value: function _postProcessValue(propName, value, previousValue) {\n      var _ref = this.component ? this.component.props : {},\n        dataTransform = _ref.dataTransform;\n      if (propName !== 'data') {\n        return value;\n      }\n      if (dataTransform) {\n        return dataTransform(value, previousValue);\n      }\n      return previousValue ? previousValue.concat(value) : value;\n    }\n  }, {\n    key: \"_createAsyncPropData\",\n    value: function _createAsyncPropData(propName, value, defaultValue) {\n      var asyncProp = this.asyncProps[propName];\n      if (!asyncProp) {\n        this.asyncProps[propName] = {\n          lastValue: null,\n          resolvedValue: defaultValue,\n          pendingLoadCount: 0,\n          resolvedLoadCount: 0\n        };\n      }\n    }\n  }]);\n  return ComponentState;\n}();\nexport { ComponentState as default };","map":{"version":3,"sources":["../../../src/lifecycle/component-state.js"],"names":["log","isAsyncIterable","PROP_SYMBOLS","ASYNC_ORIGINAL","ASYNC_RESOLVED","ASYNC_DEFAULTS","EMPTY_PROPS","Object","freeze","ComponentState","component","asyncProps","onAsyncPropUpdated","oldProps","oldAsyncProps","props","create","propName","defineProperty","enumerable","value","asyncProp","resolvedValue","Boolean","pendingLoadCount","resolvedLoadCount","key","isAsyncPropLoading","_watchPromise","Promise","resolve","resolvedValues","originalValues","defaultValues","_createAsyncPropData","_updateAsyncProp","_didAsyncInputValueChange","fetch","layer","url","_resolveAsyncIterable","_setPropValue","lastValue","loadCount","undefined","freezeAsyncOldProps","promise","then","data","_postProcessValue","_setAsyncPropValue","onDataLoad","error","iterable","count","chunk","startRow","endRow","length","previousValue","dataTransform","concat","defaultValue"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../utils/log';\nimport {isAsyncIterable} from '../utils/iterable-utils';\nimport {PROP_SYMBOLS} from './constants';\nconst {ASYNC_ORIGINAL, ASYNC_RESOLVED, ASYNC_DEFAULTS} = PROP_SYMBOLS;\n\nconst EMPTY_PROPS = Object.freeze({});\n\nexport default class ComponentState {\n  constructor(component = null) {\n    this.component = component;\n    this.asyncProps = {}; // Prop values that the layer sees\n    this.onAsyncPropUpdated = () => {};\n    this.oldProps = EMPTY_PROPS; // Last props before update\n    this.oldAsyncProps = null; // Last props before update, with async values copied.\n  }\n\n  getOldProps() {\n    return this.oldAsyncProps || this.oldProps;\n  }\n\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component.props;\n  }\n\n  // Whenever async props are changing, we need to make a copy of oldProps\n  // otherwise the prop rewriting will affect the value both in props and oldProps.\n  // While the copy is relatively expensive, this only happens on load completion.\n  freezeAsyncOldProps() {\n    if (!this.oldAsyncProps) {\n      // Make sure oldProps is set\n      this.oldProps = this.oldProps || this.component.props;\n\n      // 1. inherit all synchronous props from oldProps\n      // 2. reconfigure the async prop descriptors to fixed values\n      this.oldAsyncProps = Object.create(this.oldProps);\n      for (const propName in this.asyncProps) {\n        Object.defineProperty(this.oldAsyncProps, propName, {\n          enumerable: true,\n          value: this.oldProps[propName]\n        });\n      }\n    }\n  }\n\n  // ASYNC PROP HANDLING\n  //\n\n  // Checks if a prop is overridden\n  hasAsyncProp(propName) {\n    return propName in this.asyncProps;\n  }\n\n  // Returns value of an overriden prop\n  getAsyncProp(propName) {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n\n  isAsyncPropLoading(propName) {\n    if (propName) {\n      const asyncProp = this.asyncProps[propName];\n      return Boolean(\n        asyncProp &&\n          asyncProp.pendingLoadCount > 0 &&\n          asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount\n      );\n    }\n    for (const key in this.asyncProps) {\n      if (this.isAsyncPropLoading(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Without changing the original prop value, swap out the data resolution under the hood\n  reloadAsyncProp(propName, value) {\n    this._watchPromise(propName, Promise.resolve(value));\n  }\n\n  // Updates all async/overridden props (when new props come in)\n  // Checks if urls have changed, starts loading, or removes override\n  setAsyncProps(props) {\n    // NOTE: prop param and default values are only support for testing\n    const resolvedValues = props[ASYNC_RESOLVED] || {};\n    const originalValues = props[ASYNC_ORIGINAL] || props;\n    const defaultValues = props[ASYNC_DEFAULTS] || {};\n\n    // TODO - use async props from the layer's prop types\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n      this._createAsyncPropData(propName, value, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n      // Makes sure a record exists for this prop\n      this._createAsyncPropData(propName, value, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n  }\n\n  // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n  _updateAsyncProp(propName, value) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n\n    // interpret value string as url and start a new load tracked by a promise\n    if (typeof value === 'string') {\n      const fetch = this.layer && this.layer.props.fetch;\n      const url = value;\n      if (fetch) {\n        value = fetch(url, {propName, layer: this.layer});\n      }\n    }\n\n    // interprets promise and track the \"loading\"\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n      return;\n    }\n\n    if (isAsyncIterable(value)) {\n      this._resolveAsyncIterable(propName, value);\n      return;\n    }\n\n    // else, normal, non-async value. Just store value for now\n    this._setPropValue(propName, value);\n  }\n\n  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n  _didAsyncInputValueChange(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n    if (value === asyncProp.lastValue) {\n      return false;\n    }\n    asyncProp.lastValue = value;\n    return true;\n  }\n\n  // Set normal, non-async value\n  _setPropValue(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.value = value;\n    asyncProp.resolvedValue = value;\n    asyncProp.pendingLoadCount++;\n    asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n  }\n\n  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n  _setAsyncPropValue(propName, value, loadCount) {\n    // Only update if loadCount is larger or equal to resolvedLoadCount\n    // otherwise a more recent load has already completed\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n      // A chance to copy old props before updating\n      this.freezeAsyncOldProps();\n\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n\n      // Call callback to inform listener\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n\n  // Tracks a promise, sets the prop when loaded, handles load count\n  _watchPromise(propName, promise) {\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    promise\n      .then(data => {\n        data = this._postProcessValue(propName, data);\n        this._setAsyncPropValue(propName, data, loadCount);\n\n        const onDataLoad = this.layer && this.layer.props.onDataLoad;\n        if (propName === 'data' && onDataLoad) {\n          onDataLoad(data, {propName, layer: this.layer});\n        }\n      })\n      .catch(error => log.error(error)());\n  }\n\n  async _resolveAsyncIterable(propName, iterable) {\n    if (propName !== 'data') {\n      // we only support data as async iterable\n      this._setPropValue(propName, iterable);\n    }\n\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    let data = [];\n    let count = 0;\n\n    for await (const chunk of iterable) {\n      data = this._postProcessValue(propName, chunk, data);\n\n      // Used by the default _dataDiff function\n      Object.defineProperty(data, '__diff', {\n        enumerable: false,\n        value: [{startRow: count, endRow: data.length}]\n      });\n\n      count = data.length;\n      this._setAsyncPropValue(propName, data, loadCount);\n    }\n\n    const onDataLoad = this.layer && this.layer.props.onDataLoad;\n    if (onDataLoad) {\n      onDataLoad(data, {propName, layer: this.layer});\n    }\n  }\n\n  // Give the app a chance to post process the loaded data\n  _postProcessValue(propName, value, previousValue) {\n    const {dataTransform} = this.component ? this.component.props : {};\n    if (propName !== 'data') {\n      return value;\n    }\n    if (dataTransform) {\n      return dataTransform(value, previousValue);\n    }\n    // previousValue is assigned if loaded with async iterator\n    return previousValue ? previousValue.concat(value) : value;\n  }\n\n  // Creating an asyncProp record if needed\n  _createAsyncPropData(propName, value, defaultValue) {\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      // assert(defaultValue !== undefined);\n      this.asyncProps[propName] = {\n        lastValue: null, // Supplied prop value (can be url/promise, not visible to layer)\n        resolvedValue: defaultValue, // Resolved prop value (valid data, can be \"shown\" to layer)\n        pendingLoadCount: 0, // How many loads have been issued\n        resolvedLoadCount: 0 // Latest resolved load, (earlier loads will be ignored)\n      };\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}