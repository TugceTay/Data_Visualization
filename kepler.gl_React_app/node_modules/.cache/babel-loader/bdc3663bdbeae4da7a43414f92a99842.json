{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Layer, project32, picking } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar defaultProps = {\n  iconAtlas: {\n    type: 'object',\n    value: null,\n    async: true\n  },\n  iconMapping: {\n    type: 'object',\n    value: {},\n    async: true\n  },\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  sizeMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  alphaCutoff: {\n    type: 'number',\n    value: 0.05,\n    min: 0,\n    max: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getIcon: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.icon;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 1\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  }\n};\nvar IconLayer = function (_Layer) {\n  _inherits(IconLayer, _Layer);\n  function IconLayer() {\n    _classCallCheck(this, IconLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(IconLayer).apply(this, arguments));\n  }\n  _createClass(IconLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return _get(_getPrototypeOf(IconLayer.prototype), \"getShaders\", this).call(this, {\n        vs: vs,\n        fs: fs,\n        modules: [project32, picking]\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n      this.state = {\n        iconManager: new IconManager(this.context.gl, {\n          onUpdate: function onUpdate() {\n            return _this._onUpdate();\n          }\n        })\n      };\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instancePositions: {\n          size: 3,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          transition: true,\n          accessor: 'getPosition'\n        },\n        instanceSizes: {\n          size: 1,\n          transition: true,\n          accessor: 'getSize',\n          defaultValue: 1\n        },\n        instanceOffsets: {\n          size: 2,\n          accessor: 'getIcon',\n          transform: this.getInstanceOffset\n        },\n        instanceIconFrames: {\n          size: 4,\n          accessor: 'getIcon',\n          transform: this.getInstanceIconFrame\n        },\n        instanceColorModes: {\n          size: 1,\n          type: 5121,\n          accessor: 'getIcon',\n          transform: this.getInstanceColorMode\n        },\n        instanceColors: {\n          size: this.props.colorFormat.length,\n          type: 5121,\n          normalized: true,\n          transition: true,\n          accessor: 'getColor',\n          defaultValue: DEFAULT_COLOR\n        },\n        instanceAngles: {\n          size: 1,\n          transition: true,\n          accessor: 'getAngle'\n        },\n        instancePixelOffset: {\n          size: 2,\n          transition: true,\n          accessor: 'getPixelOffset'\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n        props = _ref.props,\n        changeFlags = _ref.changeFlags;\n      _get(_getPrototypeOf(IconLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n      var attributeManager = this.getAttributeManager();\n      var iconAtlas = props.iconAtlas,\n        iconMapping = props.iconMapping,\n        data = props.data,\n        getIcon = props.getIcon;\n      var iconManager = this.state.iconManager;\n      iconManager.setProps({\n        loadOptions: props.loadOptions\n      });\n      var iconMappingChanged = false;\n      var prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n      if (prePacked) {\n        if (oldProps.iconAtlas !== props.iconAtlas) {\n          iconManager.setProps({\n            iconAtlas: iconAtlas,\n            autoPacking: false\n          });\n        }\n        if (oldProps.iconMapping !== props.iconMapping) {\n          iconManager.setProps({\n            iconMapping: iconMapping\n          });\n          iconMappingChanged = true;\n        }\n      } else {\n        iconManager.setProps({\n          autoPacking: true\n        });\n      }\n      if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {\n        iconManager.setProps({\n          data: data,\n          getIcon: getIcon\n        });\n        iconMappingChanged = true;\n      }\n      if (iconMappingChanged) {\n        attributeManager.invalidate('instanceOffsets');\n        attributeManager.invalidate('instanceIconFrames');\n        attributeManager.invalidate('instanceColorModes');\n      }\n      if (changeFlags.extensionsChanged) {\n        var gl = this.context.gl;\n        if (this.state.model) {\n          this.state.model[\"delete\"]();\n        }\n        this.setState({\n          model: this._getModel(gl)\n        });\n        attributeManager.invalidateAll();\n      }\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      _get(_getPrototypeOf(IconLayer.prototype), \"finalizeState\", this).call(this);\n      this.state.iconManager.finalize();\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var _this$props = this.props,\n        sizeScale = _this$props.sizeScale,\n        sizeMinPixels = _this$props.sizeMinPixels,\n        sizeMaxPixels = _this$props.sizeMaxPixels,\n        sizeUnits = _this$props.sizeUnits,\n        billboard = _this$props.billboard,\n        alphaCutoff = _this$props.alphaCutoff;\n      var iconManager = this.state.iconManager;\n      var viewport = this.context.viewport;\n      var iconsTexture = iconManager.getTexture();\n      if (iconsTexture && iconsTexture.loaded) {\n        this.state.model.setUniforms(Object.assign({}, uniforms, {\n          iconsTexture: iconsTexture,\n          iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n          sizeScale: sizeScale * (sizeUnits === 'pixels' ? viewport.metersPerPixel : 1),\n          sizeMinPixels: sizeMinPixels,\n          sizeMaxPixels: sizeMaxPixels,\n          billboard: billboard,\n          alphaCutoff: alphaCutoff\n        })).draw();\n      }\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      var positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 6,\n          attributes: {\n            positions: {\n              size: 2,\n              value: new Float32Array(positions)\n            }\n          }\n        }),\n        isInstanced: true\n      }));\n    }\n  }, {\n    key: \"_onUpdate\",\n    value: function _onUpdate() {\n      this.setNeedsRedraw();\n    }\n  }, {\n    key: \"getInstanceOffset\",\n    value: function getInstanceOffset(icon) {\n      var rect = this.state.iconManager.getIconMapping(icon);\n      return [rect.width / 2 - rect.anchorX || 0, rect.height / 2 - rect.anchorY || 0];\n    }\n  }, {\n    key: \"getInstanceColorMode\",\n    value: function getInstanceColorMode(icon) {\n      var mapping = this.state.iconManager.getIconMapping(icon);\n      return mapping.mask ? 1 : 0;\n    }\n  }, {\n    key: \"getInstanceIconFrame\",\n    value: function getInstanceIconFrame(icon) {\n      var rect = this.state.iconManager.getIconMapping(icon);\n      return [rect.x || 0, rect.y || 0, rect.width || 0, rect.height || 0];\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return _get(_getPrototypeOf(IconLayer.prototype), \"isLoaded\", this) && this.state.iconManager.isLoaded;\n    }\n  }]);\n  return IconLayer;\n}(Layer);\nexport { IconLayer as default };\nIconLayer.layerName = 'IconLayer';\nIconLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/icon-layer/icon-layer.js"],"names":["Layer","project32","picking","Model","Geometry","vs","fs","IconManager","DEFAULT_COLOR","defaultProps","iconAtlas","type","value","async","iconMapping","sizeScale","min","billboard","sizeUnits","sizeMinPixels","sizeMaxPixels","Number","MAX_SAFE_INTEGER","alphaCutoff","max","getPosition","x","position","getIcon","icon","getColor","getSize","getAngle","getPixelOffset","IconLayer","modules","state","iconManager","context","gl","onUpdate","_onUpdate","attributeManager","getAttributeManager","addInstanced","instancePositions","size","fp64","use64bitPositions","transition","accessor","instanceSizes","defaultValue","instanceOffsets","transform","getInstanceOffset","instanceIconFrames","getInstanceIconFrame","instanceColorModes","getInstanceColorMode","instanceColors","props","colorFormat","length","normalized","instanceAngles","instancePixelOffset","oldProps","changeFlags","data","setProps","loadOptions","iconMappingChanged","prePacked","internalState","isAsyncPropLoading","autoPacking","dataChanged","updateTriggersChanged","all","invalidate","extensionsChanged","model","setState","_getModel","invalidateAll","isLoaded","finalize","uniforms","viewport","iconsTexture","getTexture","loaded","setUniforms","assign","iconsTextureDim","width","height","metersPerPixel","draw","positions","getShaders","id","geometry","drawMode","attributes","Float32Array","isInstanced","setNeedsRedraw","rect","getIconMapping","anchorX","anchorY","mapping","mask","y","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {Layer, project32, picking} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n/*\n * @param {object} props\n * @param {Texture2D | string} props.iconAtlas - atlas image url or texture\n * @param {object} props.iconMapping - icon names mapped to icon definitions\n * @param {object} props.iconMapping[icon_name].x - x position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].y - y position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].width - width of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].height - height of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].anchorX - x anchor of icon on the atlas image,\n *   default to width / 2\n * @param {object} props.iconMapping[icon_name].anchorY - y anchor of icon on the atlas image,\n *   default to height / 2\n * @param {object} props.iconMapping[icon_name].mask - whether icon is treated as a transparency\n *   mask. If true, user defined color is applied. If false, original color from the image is\n *   applied. Default to false.\n * @param {number} props.size - icon size in pixels\n * @param {func} props.getPosition - returns anchor position of the icon, in [lng, lat, z]\n * @param {func} props.getIcon - returns icon name as a string\n * @param {func} props.getSize - returns icon size multiplier as a number\n * @param {func} props.getColor - returns color of the icon in [r, g, b, a]. Only works on icons\n *   with mask: true.\n * @param {func} props.getAngle - returns rotating angle (in degree) of the icon.\n */\nconst defaultProps = {\n  iconAtlas: {type: 'object', value: null, async: true},\n  iconMapping: {type: 'object', value: {}, async: true},\n  sizeScale: {type: 'number', value: 1, min: 0},\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {type: 'number', min: 0, value: 0}, //  min point radius in pixels\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max point radius in pixels\n  alphaCutoff: {type: 'number', value: 0.05, min: 0, max: 1},\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getIcon: {type: 'accessor', value: x => x.icon},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 1},\n  getAngle: {type: 'accessor', value: 0},\n  getPixelOffset: {type: 'accessor', value: [0, 0]}\n};\n\nexport default class IconLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {onUpdate: () => this._onUpdate()})\n    };\n\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {size: 2, accessor: 'getIcon', transform: this.getInstanceOffset},\n      instanceIconFrames: {size: 4, accessor: 'getIcon', transform: this.getInstanceIconFrame},\n      instanceColorModes: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        accessor: 'getIcon',\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  /* eslint-disable max-statements, complexity */\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n    const {iconAtlas, iconMapping, data, getIcon} = props;\n    const {iconManager} = this.state;\n\n    iconManager.setProps({loadOptions: props.loadOptions});\n\n    let iconMappingChanged = false;\n    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n\n    // prepacked iconAtlas from user\n    if (prePacked) {\n      if (oldProps.iconAtlas !== props.iconAtlas) {\n        iconManager.setProps({iconAtlas, autoPacking: false});\n      }\n\n      if (oldProps.iconMapping !== props.iconMapping) {\n        iconManager.setProps({iconMapping});\n        iconMappingChanged = true;\n      }\n    } else {\n      // otherwise, use autoPacking\n      iconManager.setProps({autoPacking: true});\n    }\n\n    if (\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon))\n    ) {\n      iconManager.setProps({data, getIcon});\n      iconMappingChanged = true;\n    }\n\n    if (iconMappingChanged) {\n      attributeManager.invalidate('instanceOffsets');\n      attributeManager.invalidate('instanceIconFrames');\n      attributeManager.invalidate('instanceColorModes');\n    }\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      attributeManager.invalidateAll();\n    }\n  }\n  /* eslint-enable max-statements, complexity */\n\n  get isLoaded() {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    // Release resources held by the icon manager\n    this.state.iconManager.finalize();\n  }\n\n  draw({uniforms}) {\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff} = this.props;\n    const {iconManager} = this.state;\n    const {viewport} = this.context;\n\n    const iconsTexture = iconManager.getTexture();\n    if (iconsTexture && iconsTexture.loaded) {\n      this.state.model\n        .setUniforms(\n          Object.assign({}, uniforms, {\n            iconsTexture,\n            iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n            sizeScale: sizeScale * (sizeUnits === 'pixels' ? viewport.metersPerPixel : 1),\n            sizeMinPixels,\n            sizeMaxPixels,\n            billboard,\n            alphaCutoff\n          })\n        )\n        .draw();\n    }\n  }\n\n  _getModel(gl) {\n    // The icon-layer vertex shader uses 2d positions\n    // specifed via: attribute vec2 positions;\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLE_FAN,\n          attributes: {\n            // The size must be explicitly passed here otherwise luma.gl\n            // will default to assuming that positions are 3D (x,y,z)\n            positions: {\n              size: 2,\n              value: new Float32Array(positions)\n            }\n          }\n        }),\n        isInstanced: true\n      })\n    );\n  }\n\n  _onUpdate() {\n    this.setNeedsRedraw();\n  }\n\n  getInstanceOffset(icon) {\n    const rect = this.state.iconManager.getIconMapping(icon);\n    return [rect.width / 2 - rect.anchorX || 0, rect.height / 2 - rect.anchorY || 0];\n  }\n\n  getInstanceColorMode(icon) {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n\n  getInstanceIconFrame(icon) {\n    const rect = this.state.iconManager.getIconMapping(icon);\n    return [rect.x || 0, rect.y || 0, rect.width || 0, rect.height || 0];\n  }\n}\n\nIconLayer.layerName = 'IconLayer';\nIconLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}