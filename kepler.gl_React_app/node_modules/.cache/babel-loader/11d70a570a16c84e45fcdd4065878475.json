{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Matrix4 } from 'math.gl';\nimport Viewport from './viewport';\nimport { PROJECTION_MODE } from '../lib/constants';\nimport * as vec3 from 'gl-matrix/vec3';\nimport * as vec4 from 'gl-matrix/vec4';\nvar DEGREES_TO_RADIANS = Math.PI / 180;\nvar RADIANS_TO_DEGREES = 180 / Math.PI;\nvar EARTH_RADIUS = 6370972;\nvar GLOBE_RADIUS = 256;\nfunction getDistanceScales() {\n  var unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n  var unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;\n  return {\n    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n    unitsPerMeter2: [0, 0, 0],\n    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n    unitsPerDegree2: [0, 0, 0],\n    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n  };\n}\nvar GlobeViewport = function (_Viewport) {\n  _inherits(GlobeViewport, _Viewport);\n  function GlobeViewport() {\n    var _this;\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, GlobeViewport);\n    var _opts$latitude = opts.latitude,\n      latitude = _opts$latitude === void 0 ? 0 : _opts$latitude,\n      _opts$longitude = opts.longitude,\n      longitude = _opts$longitude === void 0 ? 0 : _opts$longitude,\n      _opts$zoom = opts.zoom,\n      zoom = _opts$zoom === void 0 ? 11 : _opts$zoom,\n      _opts$nearZMultiplier = opts.nearZMultiplier,\n      nearZMultiplier = _opts$nearZMultiplier === void 0 ? 0.1 : _opts$nearZMultiplier,\n      _opts$farZMultiplier = opts.farZMultiplier,\n      farZMultiplier = _opts$farZMultiplier === void 0 ? 1 : _opts$farZMultiplier,\n      _opts$resolution = opts.resolution,\n      resolution = _opts$resolution === void 0 ? 10 : _opts$resolution;\n    var width = opts.width,\n      height = opts.height,\n      _opts$altitude = opts.altitude,\n      altitude = _opts$altitude === void 0 ? 1.5 : _opts$altitude;\n    width = width || 1;\n    height = height || 1;\n    altitude = Math.max(0.75, altitude);\n    var viewMatrix = new Matrix4().lookAt({\n      eye: [0, -altitude, 0],\n      up: [0, 0, 1]\n    });\n    var scale = Math.pow(2, zoom);\n    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n    viewMatrix.scale(scale / height);\n    var halfFov = Math.atan(0.5 / altitude);\n    var relativeScale = GLOBE_RADIUS * 2 * scale / height;\n    var viewportOpts = Object.assign({}, opts, {\n      width: width,\n      height: height,\n      viewMatrix: viewMatrix,\n      longitude: longitude,\n      latitude: latitude,\n      zoom: zoom,\n      fovyRadians: halfFov * 2,\n      aspect: width / height,\n      focalDistance: altitude,\n      near: nearZMultiplier,\n      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier\n    });\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GlobeViewport).call(this, viewportOpts));\n    _this.resolution = resolution;\n    _this.distanceScales = getDistanceScales();\n    return _this;\n  }\n  _createClass(GlobeViewport, [{\n    key: \"getDistanceScales\",\n    value: function getDistanceScales() {\n      return this.distanceScales;\n    }\n  }, {\n    key: \"unproject\",\n    value: function unproject(xyz) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$topLeft = _ref.topLeft,\n        topLeft = _ref$topLeft === void 0 ? true : _ref$topLeft,\n        targetZ = _ref.targetZ;\n      var _xyz = _slicedToArray(xyz, 3),\n        x = _xyz[0],\n        y = _xyz[1],\n        z = _xyz[2];\n      var y2 = topLeft ? y : this.height - y;\n      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;\n      var coord;\n      if (Number.isFinite(z)) {\n        coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n      } else {\n        var coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n        var coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n        var lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n        var lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n        var l0Sqr = vec3.sqrLen(coord0);\n        var l1Sqr = vec3.sqrLen(coord1);\n        var sSqr = (4 * l0Sqr * l1Sqr - Math.pow(lSqr - l0Sqr - l1Sqr, 2)) / 16;\n        var dSqr = 4 * sSqr / lSqr;\n        var r0 = Math.sqrt(l0Sqr - dSqr);\n        var dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n        var t = (r0 - dr) / Math.sqrt(lSqr);\n        coord = vec3.lerp([], coord0, coord1, t);\n      }\n      var _this$unprojectPositi = this.unprojectPosition(coord),\n        _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3),\n        X = _this$unprojectPositi2[0],\n        Y = _this$unprojectPositi2[1],\n        Z = _this$unprojectPositi2[2];\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    }\n  }, {\n    key: \"projectPosition\",\n    value: function projectPosition(xyz) {\n      var _xyz2 = _slicedToArray(xyz, 3),\n        lng = _xyz2[0],\n        lat = _xyz2[1],\n        _xyz2$ = _xyz2[2],\n        Z = _xyz2$ === void 0 ? 0 : _xyz2$;\n      var lambda = lng * DEGREES_TO_RADIANS;\n      var phi = lat * DEGREES_TO_RADIANS;\n      var cosPhi = Math.cos(phi);\n      var D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n      return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n    }\n  }, {\n    key: \"unprojectPosition\",\n    value: function unprojectPosition(xyz) {\n      var _xyz3 = _slicedToArray(xyz, 3),\n        x = _xyz3[0],\n        y = _xyz3[1],\n        z = _xyz3[2];\n      var D = vec3.len(xyz);\n      var phi = Math.asin(z / D);\n      var lambda = Math.atan2(x, -y);\n      var lng = lambda * RADIANS_TO_DEGREES;\n      var lat = phi * RADIANS_TO_DEGREES;\n      var Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n      return [lng, lat, Z];\n    }\n  }, {\n    key: \"projectFlat\",\n    value: function projectFlat(xyz) {\n      return xyz;\n    }\n  }, {\n    key: \"unprojectFlat\",\n    value: function unprojectFlat(xyz) {\n      return xyz;\n    }\n  }, {\n    key: \"getMapCenterByLngLatPosition\",\n    value: function getMapCenterByLngLatPosition(_ref2) {\n      var lngLat = _ref2.lngLat,\n        pos = _ref2.pos;\n      var fromPosition = this.unproject(pos);\n      return [lngLat[0] - fromPosition[0] + this.longitude, lngLat[1] - fromPosition[1] + this.latitude];\n    }\n  }, {\n    key: \"projectionMode\",\n    get: function get() {\n      return PROJECTION_MODE.GLOBE;\n    }\n  }]);\n  return GlobeViewport;\n}(Viewport);\nexport { GlobeViewport as default };\nfunction transformVector(matrix, vector) {\n  var result = vec4.transformMat4([], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}","map":{"version":3,"sources":["../../../src/viewports/globe-viewport.js"],"names":["Matrix4","Viewport","PROJECTION_MODE","vec3","vec4","DEGREES_TO_RADIANS","Math","PI","RADIANS_TO_DEGREES","EARTH_RADIUS","GLOBE_RADIUS","getDistanceScales","unitsPerMeter","unitsPerDegree","unitsPerMeter2","metersPerUnit","unitsPerDegree2","degreesPerUnit","GlobeViewport","opts","latitude","longitude","zoom","nearZMultiplier","farZMultiplier","resolution","width","height","altitude","max","viewMatrix","lookAt","eye","up","scale","pow","rotateX","rotateZ","halfFov","atan","relativeScale","viewportOpts","assign","fovyRadians","aspect","focalDistance","near","far","min","distanceScales","GLOBE","xyz","topLeft","targetZ","x","y","z","y2","pixelUnprojectionMatrix","coord","Number","isFinite","transformVector","coord0","coord1","lt","lSqr","sqrLen","sub","l0Sqr","l1Sqr","sSqr","dSqr","r0","sqrt","dr","t","lerp","X","Y","Z","unprojectPosition","lng","lat","lambda","phi","cosPhi","cos","D","sin","len","asin","atan2","lngLat","pos","fromPosition","unproject","matrix","vector","result","transformMat4"],"mappings":"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","sourcesContent":["import {Matrix4} from 'math.gl';\nimport Viewport from './viewport';\nimport {PROJECTION_MODE} from '../lib/constants';\n\nimport * as vec3 from 'gl-matrix/vec3';\nimport * as vec4 from 'gl-matrix/vec4';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst RADIANS_TO_DEGREES = 180 / Math.PI;\nconst EARTH_RADIUS = 6370972;\nconst GLOBE_RADIUS = 256;\n\nfunction getDistanceScales() {\n  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n  const unitsPerDegree = (Math.PI / 180) * GLOBE_RADIUS;\n\n  return {\n    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n    unitsPerMeter2: [0, 0, 0],\n    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n    unitsPerDegree2: [0, 0, 0],\n    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n  };\n}\n\nexport default class GlobeViewport extends Viewport {\n  constructor(opts = {}) {\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 11,\n      nearZMultiplier = 0.1,\n      farZMultiplier = 1,\n      resolution = 10\n    } = opts;\n\n    let {width, height, altitude = 1.5} = opts;\n\n    width = width || 1;\n    height = height || 1;\n    altitude = Math.max(0.75, altitude);\n\n    // Calculate view matrix\n    const viewMatrix = new Matrix4().lookAt({eye: [0, -altitude, 0], up: [0, 0, 1]});\n    const scale = Math.pow(2, zoom);\n    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n    viewMatrix.scale(scale / height);\n\n    const halfFov = Math.atan(0.5 / altitude);\n    const relativeScale = (GLOBE_RADIUS * 2 * scale) / height;\n\n    const viewportOpts = Object.assign({}, opts, {\n      // x, y,\n      width,\n      height,\n\n      // view matrix\n      viewMatrix,\n      longitude,\n      latitude,\n      zoom,\n\n      // projection matrix parameters\n      fovyRadians: halfFov * 2,\n      aspect: width / height,\n      focalDistance: altitude,\n      near: nearZMultiplier,\n      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier\n    });\n\n    super(viewportOpts);\n\n    this.resolution = resolution;\n    this.distanceScales = getDistanceScales();\n  }\n\n  get projectionMode() {\n    return PROJECTION_MODE.GLOBE;\n  }\n\n  getDistanceScales() {\n    return this.distanceScales;\n  }\n\n  unproject(xyz, {topLeft = true, targetZ} = {}) {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const {pixelUnprojectionMatrix} = this;\n\n    let coord;\n    if (Number.isFinite(z)) {\n      // Has depth component\n      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n    } else {\n      // since we don't know the correct projected z value for the point,\n      // unproject two points to get a line and then find the point on that line that intersects with the sphere\n      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n\n      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n      const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n      const l0Sqr = vec3.sqrLen(coord0);\n      const l1Sqr = vec3.sqrLen(coord1);\n      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;\n      const dSqr = (4 * sSqr) / lSqr;\n      const r0 = Math.sqrt(l0Sqr - dSqr);\n      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n      const t = (r0 - dr) / Math.sqrt(lSqr);\n\n      coord = vec3.lerp([], coord0, coord1, t);\n    }\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  projectPosition(xyz) {\n    const [lng, lat, Z = 0] = xyz;\n    const lambda = lng * DEGREES_TO_RADIANS;\n    const phi = lat * DEGREES_TO_RADIANS;\n    const cosPhi = Math.cos(phi);\n    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n\n    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n  }\n\n  unprojectPosition(xyz) {\n    const [x, y, z] = xyz;\n    const D = vec3.len(xyz);\n    const phi = Math.asin(z / D);\n    const lambda = Math.atan2(x, -y);\n\n    const lng = lambda * RADIANS_TO_DEGREES;\n    const lat = phi * RADIANS_TO_DEGREES;\n    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n    return [lng, lat, Z];\n  }\n\n  projectFlat(xyz) {\n    return xyz;\n  }\n\n  unprojectFlat(xyz) {\n    return xyz;\n  }\n\n  getMapCenterByLngLatPosition({lngLat, pos}) {\n    const fromPosition = this.unproject(pos);\n    return [\n      lngLat[0] - fromPosition[0] + this.longitude,\n      lngLat[1] - fromPosition[1] + this.latitude\n    ];\n  }\n}\n\nfunction transformVector(matrix, vector) {\n  const result = vec4.transformMat4([], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}