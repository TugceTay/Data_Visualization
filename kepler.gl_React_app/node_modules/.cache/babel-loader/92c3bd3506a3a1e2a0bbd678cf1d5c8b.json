{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.FILE_CONFLICT_MSG = void 0;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _icons = require(\"../components/common/icons\");\n\n// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nvar NAME = 'cloud-provider';\nvar DISPLAY_NAME = 'Cloud Provider';\nvar THUMBNAIL = {\n  width: 300,\n  height: 200\n};\nvar ICON = _icons.Upload;\nvar FILE_CONFLICT_MSG = 'file_conflict';\n/**\n * The default provider class\n * @param {object} props\n * @param {string} props.name\n * @param {string} props.displayName\n * @param {React.Component} props.icon - React element\n * @param {object} props.thumbnail - thumbnail size object\n * @param {number} props.thumbnail.width - thumbnail width in pixels\n * @param {number} props.thumbnail.height - thumbnail height in pixels\n * @public\n * @example\n *\n * const myProvider = new Provider({\n *  name: 'foo',\n *  displayName: 'Foo Storage'\n *  icon: Icon,\n *  thumbnail: {width: 300, height: 200}\n * })\n */\n\nexports.FILE_CONFLICT_MSG = FILE_CONFLICT_MSG;\nvar Provider = /*#__PURE__*/function () {\n  function Provider(props) {\n    (0, _classCallCheck2[\"default\"])(this, Provider);\n    this.name = props.name || NAME;\n    this.displayName = props.displayName || DISPLAY_NAME;\n    this.icon = props.icon || ICON;\n    this.thumbnail = props.thumbnail || THUMBNAIL;\n  }\n  /**\n   * Whether this provider support upload map to a private storage. If truthy, user will be displayed with the storage save icon on the top right of the side bar.\n   * @returns {boolean}\n   * @public\n   */\n\n  (0, _createClass2[\"default\"])(Provider, [{\n    key: \"hasPrivateStorage\",\n    value: function hasPrivateStorage() {\n      return true;\n    }\n    /**\n     * Whether this provider support share map via a public url, if truthy, user will be displayed with a share map via url under the export map option on the top right of the side bar\n     * @returns {boolean}\n     * @public\n     */\n  }, {\n    key: \"hasSharingUrl\",\n    value: function hasSharingUrl() {\n      return true;\n    }\n    /**\n     * This method is called after user share a map, to display the share url.\n     * @param {boolean} fullUrl - Whether to return the full url with domain, or just the location\n     * @returns {string} shareUrl\n     * @public\n     */\n  }, {\n    key: \"getShareUrl\",\n    value: function getShareUrl() {\n      var fullUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return '';\n    }\n    /**\n     * This method is called by kepler.gl demo app to pushes a new location to history, becoming the current location.\n     * @param {boolean} fullURL - Whether to return the full url with domain, or just the location\n     * @returns {string} mapUrl\n     * @public\n     */\n  }, {\n    key: \"getMapUrl\",\n    value: function getMapUrl() {\n      var fullURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return '';\n    }\n    /**\n     * This method is called to determine whether user already logged in to this provider\n     * @public\n     * @returns {boolean} true if a user already logged in\n     */\n  }, {\n    key: \"getAccessToken\",\n    value: function getAccessToken() {\n      return true;\n    }\n    /**\n     * This method is called to get the user name of the current user. It will be displayed in the cloud provider tile.\n     * @public\n     * @returns {string} true if a user already logged in\n     */\n  }, {\n    key: \"getUserName\",\n    value: function getUserName() {\n      return '';\n    }\n    /**\n     * This return a standard error that will trigger the overwrite map modal\n     */\n  }, {\n    key: \"getFileConflictError\",\n    value: function getFileConflictError() {\n      return new Error(FILE_CONFLICT_MSG);\n    }\n    /**\n     * This method will be called when user click the login button in the cloud provider tile.\n     * Upon login success, `onCloudLoginSuccess` has to be called to notify kepler.gl UI\n     * @param {function} onCloudLoginSuccess - callbacks to be called after login success\n     * @public\n     */\n  }, {\n    key: \"login\",\n    value: function () {\n      var _login = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(onCloudLoginSuccess) {\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                onCloudLoginSuccess();\n                return _context.abrupt(\"return\");\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      function login(_x) {\n        return _login.apply(this, arguments);\n      }\n      return login;\n    }()\n    /**\n     * This method will be called when user click the logout button under the cloud provider tile.\n     * Upon login success, `onCloudLoginSuccess` has to be called to notify kepler.gl UI\n     * @param {function} onCloudLogoutSuccess - callbacks to be called after logout success\n     * @public\n     */\n  }, {\n    key: \"logout\",\n    value: function () {\n      var _logout = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(onCloudLogoutSuccess) {\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                onCloudLogoutSuccess();\n                return _context2.abrupt(\"return\");\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      function logout(_x2) {\n        return _logout.apply(this, arguments);\n      }\n      return logout;\n    }()\n    /**\n     * This method will be called to upload map for saving and sharing. Kepler.gl will package map data, config, title, description and thumbnail for upload to storage.\n     * With the option to overwrite already saved map, and upload as private or public map.\n     *\n     * @param {Object} param\n     * @param {Object} param.mapData - the map object\n     * @param {Object} param.mapData.map - {datasets. config, info: {title, description}}\n     * @param {Blob} param.mapData.thumbnail - A thumbnail of current map. thumbnail size can be defined by provider by this.thumbnail\n     * @param {object} [param.options]\n     * @param {boolean} [param.options.overwrite] - whether user choose to overwrite already saved map under the same name\n     * @param {boolean} [param.options.isPublic] - whether user wish to share the map with others. if isPublic is truthy, kepler will call this.getShareUrl() to display an URL they can share with others\n     * @public\n     */\n  }, {\n    key: \"uploadMap\",\n    value: function () {\n      var _uploadMap = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(_ref) {\n        var mapData, _ref$options, options;\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                mapData = _ref.mapData, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options;\n                return _context3.abrupt(\"return\");\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function uploadMap(_x3) {\n        return _uploadMap.apply(this, arguments);\n      }\n      return uploadMap;\n    }()\n    /**\n     * This method is called to get a list of maps saved by the current logged in user.\n     * @returns visualizations an array of Viz objects\n     * @public\n     * @example\n     *  async listMaps() {\n     *    return [\n     *      {\n     *        id: 'a',\n     *        title: 'My map',\n     *        description: 'My first kepler map',\n     *        imageUrl: 'http://',\n     *        lastModification: 1582677787000,\n     *        privateMap: false,\n     *        loadParams: {}\n     *      }\n     *    ];\n     *  }\n     */\n  }, {\n    key: \"listMaps\",\n    value: function () {\n      var _listMaps = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4() {\n        return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", []);\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n      function listMaps() {\n        return _listMaps.apply(this, arguments);\n      }\n      return listMaps;\n    }()\n    /**\n     * This method will be called when user select a map to load from the storage map viewer\n     * @param {*} loadParams - the loadParams property of each visualization object\n     * @returns mapResponse - the map object containing dataset config info and format option\n     * @public\n     * @example\n     * async downloadMap(loadParams) {\n     *  const mockResponse = {\n     *    map: {\n     *      datasets: [],\n     *      config: {},\n     *      info: {\n     *        app: 'kepler.gl',\n     *        created_at: ''\n     *        title: 'test map',\n     *        description: 'Hello this is my test dropbox map'\n     *      }\n     *    },\n     *    // pass csv here if your provider currently only support save / load file as csv\n     *    format: 'keplergl'\n     *  };\n     *\n     *  return downloadMap;\n     * }\n     */\n  }, {\n    key: \"downloadMap\",\n    value: function () {\n      var _downloadMap = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee5(loadParams) {\n        return _regenerator[\"default\"].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\");\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n      function downloadMap(_x4) {\n        return _downloadMap.apply(this, arguments);\n      }\n      return downloadMap;\n    }()\n    /**\n     * @typedef {Object} Viz\n     * @property {string} id - An unique id\n     * @property {string} title - The title of the map\n     * @property {string} description - The description of the map\n     * @property {string} imageUrl - The imageUrl of the map\n     * @property {number} lastModification - An epoch timestamp in milliseconds\n     * @property {boolean} privateMap - Optional, whether if this map is private to the user, or can be accessed by others via URL\n     * @property {*} loadParams - A property to be passed to `downloadMap`\n     * @public\n     */\n\n    /**\n     * The returned object of `downloadMap`. The response object should contain: datasets: [], config: {}, and info: {}\n     * each dataset object should be {info: {id, label}, data: {...}}\n     * to inform how kepler should process your data object, pass in `format`\n     * @typedef {Object} MapResponse\n     * @property {Object} map\n     * @property {Array<Object>} map.datasets\n     * @property {Object} map.config\n     * @property {Object} map.info\n     * @property {string} format - one of 'csv': csv file string, 'geojson': geojson object, 'row': row object, 'keplergl': datasets array saved using KeplerGlSchema.save\n     * @public\n     */\n  }]);\n\n  return Provider;\n}();\nexports[\"default\"] = Provider;","map":{"version":3,"sources":["../../src/cloud-providers/provider.js"],"names":["NAME","DISPLAY_NAME","THUMBNAIL","width","height","ICON","Upload","FILE_CONFLICT_MSG","Provider","props","name","displayName","icon","thumbnail","fullUrl","fullURL","Error","onCloudLoginSuccess","onCloudLogoutSuccess","mapData","options","loadParams"],"mappings":";;;;;;;;;;;AAoBA,IAAA,MAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AApBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,IAAMA,IAAI,GAAG,gBAAb;AACA,IAAMC,YAAY,GAAG,gBAArB;AACA,IAAMC,SAAS,GAAG;EAACC,KAAK,EAAE,GAAR;EAAaC,MAAM,EAAE;AAArB,CAAlB;AACA,IAAMC,IAAI,GAAGC,MAAAA,CAAAA,MAAb;AACO,IAAMC,iBAAiB,GAAG,eAA1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACqBC,Q;EACnB,SAAA,QAAA,CAAYC,KAAZ,EAAmB;IAAA,CAAA,CAAA,EAAA,gBAAA,CAAA,SAAA,CAAA,EAAA,IAAA,EAAA,QAAA,CAAA;IACjB,IAAA,CAAKC,IAAL,GAAYD,KAAK,CAACC,IAAND,IAAcT,IAA1B;IACA,IAAA,CAAKW,WAAL,GAAmBF,KAAK,CAACE,WAANF,IAAqBR,YAAxC;IACA,IAAA,CAAKW,IAAL,GAAYH,KAAK,CAACG,IAANH,IAAcJ,IAA1B;IACA,IAAA,CAAKQ,SAAL,GAAiBJ,KAAK,CAACI,SAANJ,IAAmBP,SAApC;EACD;EAED;AACF;AACA;AACA;AACA;;;;WACE,SAAA,iBAAA,GAAoB;MAClB,OAAO,IAAP;IACD;IAED;AACF;AACA;AACA;AACA;;;WACE,SAAA,aAAA,GAAgB;MACd,OAAO,IAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;WACE,SAAA,WAAA,GAA6B;MAAA,IAAjBY,OAAiB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAP,KAAO;MAC3B,OAAO,EAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;WACE,SAAA,SAAA,GAA0B;MAAA,IAAhBC,OAAgB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAN,IAAM;MACxB,OAAO,EAAP;IACD;IAED;AACF;AACA;AACA;AACA;;;WACE,SAAA,cAAA,GAAiB;MACf,OAAO,IAAP;IACD;IAED;AACF;AACA;AACA;AACA;;;WACE,SAAA,WAAA,GAAc;MACZ,OAAO,EAAP;IACD;IAED;AACF;AACA;;;WACE,SAAA,oBAAA,GAAuB;MACrB,OAAO,IAAIC,KAAJ,CAAUT,iBAAV,CAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;;iGACE,SAAA,OAAA,CAAYU,mBAAZ,EAAA;QAAA,OAAA,YAAA,CAAA,SAAA,CAAA,CAAA,IAAA,CAAA,SAAA,QAAA,CAAA,QAAA,EAAA;UAAA,OAAA,CAAA,EAAA;YAAA,QAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;cAAA,KAAA,CAAA;gBACEA,mBAAmB,EAAA;gBADrB,OAAA,QAAA,CAAA,MAAA,CAAA,QAAA,CAAA;cAAA,KAAA,CAAA;cAAA,KAAA,KAAA;gBAAA,OAAA,QAAA,CAAA,IAAA,EAAA;YAAA;UAAA;QAAA,CAAA,EAAA,OAAA,CAAA;MAAA,C;;;;;;IAKA;AACF;AACA;AACA;AACA;AACA;;;;kGACE,SAAA,QAAA,CAAaC,oBAAb,EAAA;QAAA,OAAA,YAAA,CAAA,SAAA,CAAA,CAAA,IAAA,CAAA,SAAA,SAAA,CAAA,SAAA,EAAA;UAAA,OAAA,CAAA,EAAA;YAAA,QAAA,SAAA,CAAA,IAAA,GAAA,SAAA,CAAA,IAAA;cAAA,KAAA,CAAA;gBACEA,oBAAoB,EAAA;gBADtB,OAAA,SAAA,CAAA,MAAA,CAAA,QAAA,CAAA;cAAA,KAAA,CAAA;cAAA,KAAA,KAAA;gBAAA,OAAA,SAAA,CAAA,IAAA,EAAA;YAAA;UAAA;QAAA,CAAA,EAAA,QAAA,CAAA;MAAA,C;;;;;;IAKA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;qGACE,SAAA,QAAA,CAAA,IAAA,EAAA;QAAA,IAAA,OAAA,EAAA,YAAA,EAAA,OAAA;QAAA,OAAA,YAAA,CAAA,SAAA,CAAA,CAAA,IAAA,CAAA,SAAA,SAAA,CAAA,SAAA,EAAA;UAAA,OAAA,CAAA,EAAA;YAAA,QAAA,SAAA,CAAA,IAAA,GAAA,SAAA,CAAA,IAAA;cAAA,KAAA,CAAA;gBAAiBC,OAAjB,GAAA,IAAA,CAAiBA,OAAjB,EAAA,YAAA,GAAA,IAAA,CAA0BC,OAA1B,EAA0BA,OAA1B,GAAA,YAAA,KAAA,KAAA,CAAA,GAAoC,CAAA,CAApC,GAAA,YAAA;gBAAA,OAAA,SAAA,CAAA,MAAA,CAAA,QAAA,CAAA;cAAA,KAAA,CAAA;cAAA,KAAA,KAAA;gBAAA,OAAA,SAAA,CAAA,IAAA,EAAA;YAAA;UAAA;QAAA,CAAA,EAAA,QAAA,CAAA;MAAA,C;;;;;;IAIA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;oGACE,SAAA,QAAA,GAAA;QAAA,OAAA,YAAA,CAAA,SAAA,CAAA,CAAA,IAAA,CAAA,SAAA,SAAA,CAAA,SAAA,EAAA;UAAA,OAAA,CAAA,EAAA;YAAA,QAAA,SAAA,CAAA,IAAA,GAAA,SAAA,CAAA,IAAA;cAAA,KAAA,CAAA;gBAAA,OAAA,SAAA,CAAA,MAAA,CAAA,QAAA,EACS,EADT,CAAA;cAAA,KAAA,CAAA;cAAA,KAAA,KAAA;gBAAA,OAAA,SAAA,CAAA,IAAA,EAAA;YAAA;UAAA;QAAA,CAAA,EAAA,QAAA,CAAA;MAAA,C;;;;;;IAIA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;uGACE,SAAA,QAAA,CAAkBC,UAAlB,EAAA;QAAA,OAAA,YAAA,CAAA,SAAA,CAAA,CAAA,IAAA,CAAA,SAAA,SAAA,CAAA,SAAA,EAAA;UAAA,OAAA,CAAA,EAAA;YAAA,QAAA,SAAA,CAAA,IAAA,GAAA,SAAA,CAAA,IAAA;cAAA,KAAA,CAAA;gBAAA,OAAA,SAAA,CAAA,MAAA,CAAA,QAAA,CAAA;cAAA,KAAA,CAAA;cAAA,KAAA,KAAA;gBAAA,OAAA,SAAA,CAAA,IAAA,EAAA;YAAA;UAAA;QAAA,CAAA,EAAA,QAAA,CAAA;MAAA,C;;;;;;IAIA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Upload} from 'components/common/icons';\n\nconst NAME = 'cloud-provider';\nconst DISPLAY_NAME = 'Cloud Provider';\nconst THUMBNAIL = {width: 300, height: 200};\nconst ICON = Upload;\nexport const FILE_CONFLICT_MSG = 'file_conflict';\n/**\n * The default provider class\n * @param {object} props\n * @param {string} props.name\n * @param {string} props.displayName\n * @param {React.Component} props.icon - React element\n * @param {object} props.thumbnail - thumbnail size object\n * @param {number} props.thumbnail.width - thumbnail width in pixels\n * @param {number} props.thumbnail.height - thumbnail height in pixels\n * @public\n * @example\n *\n * const myProvider = new Provider({\n *  name: 'foo',\n *  displayName: 'Foo Storage'\n *  icon: Icon,\n *  thumbnail: {width: 300, height: 200}\n * })\n */\nexport default class Provider {\n  constructor(props) {\n    this.name = props.name || NAME;\n    this.displayName = props.displayName || DISPLAY_NAME;\n    this.icon = props.icon || ICON;\n    this.thumbnail = props.thumbnail || THUMBNAIL;\n  }\n\n  /**\n   * Whether this provider support upload map to a private storage. If truthy, user will be displayed with the storage save icon on the top right of the side bar.\n   * @returns {boolean}\n   * @public\n   */\n  hasPrivateStorage() {\n    return true;\n  }\n\n  /**\n   * Whether this provider support share map via a public url, if truthy, user will be displayed with a share map via url under the export map option on the top right of the side bar\n   * @returns {boolean}\n   * @public\n   */\n  hasSharingUrl() {\n    return true;\n  }\n\n  /**\n   * This method is called after user share a map, to display the share url.\n   * @param {boolean} fullUrl - Whether to return the full url with domain, or just the location\n   * @returns {string} shareUrl\n   * @public\n   */\n  getShareUrl(fullUrl = false) {\n    return '';\n  }\n\n  /**\n   * This method is called by kepler.gl demo app to pushes a new location to history, becoming the current location.\n   * @param {boolean} fullURL - Whether to return the full url with domain, or just the location\n   * @returns {string} mapUrl\n   * @public\n   */\n  getMapUrl(fullURL = true) {\n    return '';\n  }\n\n  /**\n   * This method is called to determine whether user already logged in to this provider\n   * @public\n   * @returns {boolean} true if a user already logged in\n   */\n  getAccessToken() {\n    return true;\n  }\n\n  /**\n   * This method is called to get the user name of the current user. It will be displayed in the cloud provider tile.\n   * @public\n   * @returns {string} true if a user already logged in\n   */\n  getUserName() {\n    return '';\n  }\n\n  /**\n   * This return a standard error that will trigger the overwrite map modal\n   */\n  getFileConflictError() {\n    return new Error(FILE_CONFLICT_MSG);\n  }\n\n  /**\n   * This method will be called when user click the login button in the cloud provider tile.\n   * Upon login success, `onCloudLoginSuccess` has to be called to notify kepler.gl UI\n   * @param {function} onCloudLoginSuccess - callbacks to be called after login success\n   * @public\n   */\n  async login(onCloudLoginSuccess) {\n    onCloudLoginSuccess();\n    return;\n  }\n\n  /**\n   * This method will be called when user click the logout button under the cloud provider tile.\n   * Upon login success, `onCloudLoginSuccess` has to be called to notify kepler.gl UI\n   * @param {function} onCloudLogoutSuccess - callbacks to be called after logout success\n   * @public\n   */\n  async logout(onCloudLogoutSuccess) {\n    onCloudLogoutSuccess();\n    return;\n  }\n\n  /**\n   * This method will be called to upload map for saving and sharing. Kepler.gl will package map data, config, title, description and thumbnail for upload to storage.\n   * With the option to overwrite already saved map, and upload as private or public map.\n   *\n   * @param {Object} param\n   * @param {Object} param.mapData - the map object\n   * @param {Object} param.mapData.map - {datasets. config, info: {title, description}}\n   * @param {Blob} param.mapData.thumbnail - A thumbnail of current map. thumbnail size can be defined by provider by this.thumbnail\n   * @param {object} [param.options]\n   * @param {boolean} [param.options.overwrite] - whether user choose to overwrite already saved map under the same name\n   * @param {boolean} [param.options.isPublic] - whether user wish to share the map with others. if isPublic is truthy, kepler will call this.getShareUrl() to display an URL they can share with others\n   * @public\n   */\n  async uploadMap({mapData, options = {}}) {\n    return;\n  }\n\n  /**\n   * This method is called to get a list of maps saved by the current logged in user.\n   * @returns visualizations an array of Viz objects\n   * @public\n   * @example\n   *  async listMaps() {\n   *    return [\n   *      {\n   *        id: 'a',\n   *        title: 'My map',\n   *        description: 'My first kepler map',\n   *        imageUrl: 'http://',\n   *        lastModification: 1582677787000,\n   *        privateMap: false,\n   *        loadParams: {}\n   *      }\n   *    ];\n   *  }\n   */\n  async listMaps() {\n    return [];\n  }\n\n  /**\n   * This method will be called when user select a map to load from the storage map viewer\n   * @param {*} loadParams - the loadParams property of each visualization object\n   * @returns mapResponse - the map object containing dataset config info and format option\n   * @public\n   * @example\n   * async downloadMap(loadParams) {\n   *  const mockResponse = {\n   *    map: {\n   *      datasets: [],\n   *      config: {},\n   *      info: {\n   *        app: 'kepler.gl',\n   *        created_at: ''\n   *        title: 'test map',\n   *        description: 'Hello this is my test dropbox map'\n   *      }\n   *    },\n   *    // pass csv here if your provider currently only support save / load file as csv\n   *    format: 'keplergl'\n   *  };\n   *\n   *  return downloadMap;\n   * }\n   */\n  async downloadMap(loadParams) {\n    return;\n  }\n\n  /**\n   * @typedef {Object} Viz\n   * @property {string} id - An unique id\n   * @property {string} title - The title of the map\n   * @property {string} description - The description of the map\n   * @property {string} imageUrl - The imageUrl of the map\n   * @property {number} lastModification - An epoch timestamp in milliseconds\n   * @property {boolean} privateMap - Optional, whether if this map is private to the user, or can be accessed by others via URL\n   * @property {*} loadParams - A property to be passed to `downloadMap`\n   * @public\n   */\n\n  /**\n   * The returned object of `downloadMap`. The response object should contain: datasets: [], config: {}, and info: {}\n   * each dataset object should be {info: {id, label}, data: {...}}\n   * to inform how kepler should process your data object, pass in `format`\n   * @typedef {Object} MapResponse\n   * @property {Object} map\n   * @property {Array<Object>} map.datasets\n   * @property {Object} map.config\n   * @property {Object} map.info\n   * @property {string} format - one of 'csv': csv file string, 'geojson': geojson object, 'row': row object, 'keplergl': datasets array saved using KeplerGlSchema.save\n   * @public\n   */\n}\n"]},"metadata":{},"sourceType":"script"}