{"ast":null,"code":"import Buffer from '../classes/buffer';\nimport { getKey } from '../webgl-utils/constants-to-keys';\nimport { getCompositeGLType } from '../webgl-utils/attribute-utils';\nimport { formatValue } from '../utils/format-value';\nexport function getDebugTableForVertexArray(_ref) {\n  let {\n    vertexArray,\n    header = 'Attributes'\n  } = _ref;\n  if (!vertexArray.configuration) {\n    return {};\n  }\n  const table = {};\n  if (vertexArray.elements) {\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n  const attributes = vertexArray.values;\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = \"\".concat(attributeLocation, \": \").concat(info.name);\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = \"\".concat(attributeLocation, \": \").concat(getGLSLDeclaration(info.name, accessor));\n      }\n      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);\n    }\n  }\n  return table;\n}\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  const {\n    gl\n  } = vertexArray;\n  if (!attribute) {\n    return {\n      [header]: 'null',\n      'Format ': 'N/A'\n    };\n  }\n  let type = 'NOT PROVIDED';\n  let size = 1;\n  let verts = 0;\n  let bytes = 0;\n  let isInteger;\n  let marker;\n  let value;\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n    type = String(type).replace('Array', '');\n    isInteger = type.indexOf('nt') !== -1;\n  }\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n    const {\n      data,\n      changed\n    } = buffer.getDebugData();\n    marker = changed ? '*' : '';\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n    let format;\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = \"\".concat(instanced ? 'I ' : 'P ', \" \").concat(verts, \" (x\").concat(size, \"=\").concat(bytes, \" bytes \").concat(getKey(gl, type), \")\");\n    } else {\n      isInteger = true;\n      format = \"\".concat(bytes, \" bytes\");\n    }\n    return {\n      [header]: \"\".concat(marker).concat(formatValue(value, {\n        size,\n        isInteger\n      })),\n      'Format ': format\n    };\n  }\n  value = attribute;\n  size = attribute.length;\n  type = String(attribute.constructor.name).replace('Array', '');\n  isInteger = type.indexOf('nt') !== -1;\n  return {\n    [header]: \"\".concat(formatValue(value, {\n      size,\n      isInteger\n    }), \" (constant)\"),\n    'Format ': \"\".concat(size, \"x\").concat(type, \" (constant)\")\n  };\n}\nfunction getGLSLDeclaration(name, accessor) {\n  const {\n    type,\n    size\n  } = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? \"\".concat(name, \" (\").concat(typeAndName.name, \")\") : name;\n}","map":{"version":3,"sources":["../../../src/debug/debug-vertex-array.js"],"names":["Buffer","getKey","getCompositeGLType","formatValue","getDebugTableForVertexArray","vertexArray","header","configuration","table","elements","ELEMENT_ARRAY_BUFFER","getDebugTableRow","attributes","values","attributeLocation","info","_getAttributeInfo","rowHeader","name","accessor","accessors","location","getGLSLDeclaration","attribute","gl","type","size","verts","bytes","isInteger","marker","value","String","replace","indexOf","buffer","data","changed","getDebugData","byteLength","BYTES_PER_ELEMENT","format","instanced","divisor","length","constructor","typeAndName"],"mappings":"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","sourcesContent":["import Buffer from '../classes/buffer';\nimport {getKey} from '../webgl-utils/constants-to-keys';\nimport {getCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {formatValue} from '../utils/format-value';\n\n// Creates object suitable as input for console.table\nexport function getDebugTableForVertexArray({vertexArray, header = 'Attributes'}) {\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {}; // {[header]: {}};\n\n  // Add index (elements) if available\n  if (vertexArray.elements) {\n    // const elements = Object.assign({size: 1}, vertexArray.elements);\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  // Add used attributes\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n      table[rowHeader] = getDebugTableRow(\n        vertexArray,\n        attributes[attributeLocation],\n        accessor,\n        header\n      );\n    }\n  }\n\n  return table;\n}\n\n/* eslint-disable max-statements */\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  const {gl} = vertexArray;\n\n  if (!attribute) {\n    return {\n      [header]: 'null',\n      'Format ': 'N/A'\n    };\n  }\n\n  let type = 'NOT PROVIDED';\n  let size = 1;\n  let verts = 0;\n  let bytes = 0;\n\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n\n    // Generate a type name by dropping Array from Float32Array etc.\n    type = String(type).replace('Array', '');\n\n    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n\n    const {data, changed} = buffer.getDebugData();\n    marker = changed ? '*' : '';\n\n    value = data;\n    // @ts-ignore\n    bytes = buffer.byteLength;\n    // @ts-ignore\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      // element buffer\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {size, isInteger})}`,\n      'Format ': format\n    };\n  }\n\n  // CONSTANT VALUE\n  value = attribute;\n  size = attribute.length;\n  // Generate a type name by dropping Array from Float32Array etc.\n  type = String(attribute.constructor.name).replace('Array', '');\n  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n  isInteger = type.indexOf('nt') !== -1;\n\n  return {\n    [header]: `${formatValue(value, {size, isInteger})} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n/* eslint-ensable max-statements */\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {type, size} = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? `${name} (${typeAndName.name})` : name;\n}\n"]},"metadata":{},"sourceType":"module"}