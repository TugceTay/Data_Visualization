{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNewDatasetColor = getNewDatasetColor;\nexports.createNewDataEntry = createNewDataEntry;\nexports.findDefaultColorField = findDefaultColorField;\nexports.datasetColorMaker = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _colorUtils = require(\"./color-utils\");\nvar _lodash = _interopRequireDefault(require(\"lodash.uniq\"));\nvar _defaultSettings = require(\"../constants/default-settings\");\nvar _dataProcessor = require(\"../processors/data-processor\");\nvar _keplerTable = _interopRequireDefault(require(\"./table-utils/kepler-table\"));\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar _marked = /*#__PURE__*/_regenerator[\"default\"].mark(generateColor);\n\n// apply a color for each dataset\n// to use as label colors\nvar datasetColors = ['#8F2FBF', '#005CFF', '#C06C84', '#F8B195', '#547A82', '#3EACA8', '#A2D4AB'].map(_colorUtils.hexToRgb);\n/**\n * Random color generator\n * @return {Generator<import('reducers/types').RGBColor>}\n */\n\nfunction generateColor() {\n  var index;\n  return _regenerator[\"default\"].wrap(function generateColor$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          index = 0;\n        case 1:\n          if (!(index < datasetColors.length + 1)) {\n            _context.next = 7;\n            break;\n          }\n          if (index === datasetColors.length) {\n            index = 0;\n          }\n          _context.next = 5;\n          return datasetColors[index++];\n        case 5:\n          _context.next = 1;\n          break;\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\nvar datasetColorMaker = generateColor();\n/** @type {typeof import('./dataset-utils').getNewDatasetColor} */\n\nexports.datasetColorMaker = datasetColorMaker;\nfunction getNewDatasetColor(datasets) {\n  var presetColors = datasetColors.map(String);\n  var usedColors = (0, _lodash[\"default\"])(Object.values(datasets).map(function (d) {\n    return String(d.color);\n  })).filter(function (c) {\n    return presetColors.includes(c);\n  });\n  if (usedColors.length === presetColors.length) {\n    // if we already depleted the pool of color\n    return datasetColorMaker.next().value;\n  }\n  var color = datasetColorMaker.next().value;\n  while (usedColors.includes(String(color))) {\n    color = datasetColorMaker.next().value;\n  }\n  return color;\n}\n/**\n * Take datasets payload from addDataToMap, create datasets entry save to visState\n * @type {typeof import('./dataset-utils').createNewDataEntry}\n */\n\nfunction createNewDataEntry(_ref) {\n  var info = _ref.info,\n    data = _ref.data,\n    opts = (0, _objectWithoutProperties2[\"default\"])(_ref, [\"info\", \"data\"]);\n  var datasets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var validatedData = (0, _dataProcessor.validateInputData)(data);\n  if (!validatedData) {\n    return {};\n  }\n  info = info || {};\n  var color = info.color || getNewDatasetColor(datasets);\n  var keplerTable = new _keplerTable[\"default\"](_objectSpread({\n    info: info,\n    data: validatedData,\n    color: color\n  }, opts));\n  return (0, _defineProperty2[\"default\"])({}, keplerTable.id, keplerTable);\n}\n/**\n * Field name prefixes and suffixes which should not be considered\n * as metrics. Fields will still be included if a 'metric word'\n * is found on the field name, however.\n */\n\nvar EXCLUDED_DEFAULT_FIELDS = [\n// Serial numbers and identification numbers\n'_id', 'id', 'index', 'uuid', 'guid', 'uid', 'gid', 'serial',\n// Geographic IDs are unlikely to be interesting to color\n'zip', 'code', 'post', 'region', 'fips', 'cbgs', 'h3', 's2',\n// Geographic coords (but not z/elevation/altitude\n// since that might be a metric)\n'lat', 'lon', 'lng', 'latitude', 'longitude', '_x', '_y'];\n/**\n * Prefixes and suffixes that indicate a field is a metric.\n *\n * Note that these are in order of preference, first being\n * most preferred.\n */\n\nvar METRIC_DEFAULT_FIELDS = ['metric', 'value', 'sum', 'count', 'unique', 'mean', 'mode', 'median', 'max', 'min', 'deviation', 'variance', 'p99', 'p95', 'p75', 'p50', 'p25', 'p05',\n// Abbreviations are less preferred\n'cnt', 'val'];\n/**\n * Choose a field to use as the default color field of a layer.\n *\n * The heuristic is:\n *\n * First, exclude fields that are on the exclusion list and don't\n * have names that suggest they contain metrics. Also exclude\n * field names that are blank.\n *\n * Next, look for a field that is of real type and contains one\n * of the preferred names (in order of the preferred names).\n *\n * Next, look for a field that is of integer type and contains\n * one of the preferred names (in order of the preferred names).\n *\n * Next, look for the first field that is of real type (in order\n * of field index).\n *\n * Next, look for the first field that is of integer type (in\n * order of field index).\n *\n * It's possible no field will be chosen (i.e. because all fields\n * are strings.)\n *\n * @param dataset\n */\n\nfunction findDefaultColorField(_ref3) {\n  var fields = _ref3.fields,\n    _ref3$fieldPairs = _ref3.fieldPairs,\n    fieldPairs = _ref3$fieldPairs === void 0 ? [] : _ref3$fieldPairs;\n  var fieldsWithoutExcluded = fields.filter(function (field) {\n    if (field.type !== _defaultSettings.ALL_FIELD_TYPES.real && field.type !== _defaultSettings.ALL_FIELD_TYPES.integer) {\n      // Only select numeric fields.\n      return false;\n    }\n    if (fieldPairs.find(function (pair) {\n      return pair.pair.lat.value === field.name || pair.pair.lng.value === field.name;\n    })) {\n      // Do not permit lat, lon fields\n      return false;\n    }\n    var normalizedFieldName = field.name.toLowerCase();\n    if (normalizedFieldName === '') {\n      // Special case excluded name when the name is blank.\n      return false;\n    }\n    var hasExcluded = EXCLUDED_DEFAULT_FIELDS.find(function (f) {\n      return normalizedFieldName.startsWith(f) || normalizedFieldName.endsWith(f);\n    });\n    var hasInclusion = METRIC_DEFAULT_FIELDS.find(function (f) {\n      return normalizedFieldName.startsWith(f) || normalizedFieldName.endsWith(f);\n    });\n    return !hasExcluded || hasInclusion;\n  });\n  var sortedFields = fieldsWithoutExcluded.sort(function (left, right) {\n    var normalizedLeft = left.name.toLowerCase();\n    var normalizedRight = right.name.toLowerCase();\n    var leftHasInclusion = METRIC_DEFAULT_FIELDS.findIndex(function (f) {\n      return normalizedLeft.startsWith(f) || normalizedLeft.endsWith(f);\n    });\n    var rightHasInclusion = METRIC_DEFAULT_FIELDS.findIndex(function (f) {\n      return normalizedRight.startsWith(f) || normalizedRight.endsWith(f);\n    });\n    if (leftHasInclusion !== rightHasInclusion) {\n      if (leftHasInclusion === -1) {\n        // Elements that do not have the inclusion list should go after those that do.\n        return 1;\n      } else if (rightHasInclusion === -1) {\n        // Elements that do have the inclusion list should go before those that don't.\n        return -1;\n      } // Compare based on order in the inclusion list\n\n      return leftHasInclusion - rightHasInclusion;\n    } // Compare based on type\n\n    if (left.type !== right.type) {\n      if (left.type === _defaultSettings.ALL_FIELD_TYPES.real) {\n        return -1;\n      } // left is an integer and right is not\n      // and reals come before integers\n\n      return 1;\n    } // Finally, order based on the order in the datasets columns\n\n    return left.index - right.index;\n  });\n  if (sortedFields.length) {\n    // There was a best match\n    return sortedFields[0];\n  } // No matches\n\n  return null;\n}","map":{"version":3,"sources":["../../src/utils/dataset-utils.js"],"names":["datasetColors","map","hexToRgb","generateColor","index","length","datasetColorMaker","getNewDatasetColor","datasets","presetColors","String","usedColors","values","d","color","filter","includes","c","next","value","createNewDataEntry","info","data","opts","validatedData","keplerTable","KeplerTable","id","EXCLUDED_DEFAULT_FIELDS","METRIC_DEFAULT_FIELDS","findDefaultColorField","fields","fieldPairs","fieldsWithoutExcluded","field","type","ALL_FIELD_TYPES","real","integer","find","pair","lat","name","lng","normalizedFieldName","toLowerCase","hasExcluded","startsWith","f","endsWith","hasInclusion","sortedFields","sort","left","right","normalizedLeft","normalizedRight","leftHasInclusion","findIndex","rightHasInclusion"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {hexToRgb} from './color-utils';\nimport uniq from 'lodash.uniq';\nimport {ALL_FIELD_TYPES} from 'constants/default-settings';\nimport {validateInputData} from 'processors/data-processor';\nimport KeplerTable from './table-utils/kepler-table';\n\n// apply a color for each dataset\n// to use as label colors\nconst datasetColors = [\n  '#8F2FBF',\n  '#005CFF',\n  '#C06C84',\n  '#F8B195',\n  '#547A82',\n  '#3EACA8',\n  '#A2D4AB'\n].map(hexToRgb);\n\n/**\n * Random color generator\n * @return {Generator<import('reducers/types').RGBColor>}\n */\nfunction* generateColor() {\n  let index = 0;\n  while (index < datasetColors.length + 1) {\n    if (index === datasetColors.length) {\n      index = 0;\n    }\n    yield datasetColors[index++];\n  }\n}\n\nexport const datasetColorMaker = generateColor();\n\n/** @type {typeof import('./dataset-utils').getNewDatasetColor} */\nexport function getNewDatasetColor(datasets) {\n  const presetColors = datasetColors.map(String);\n  const usedColors = uniq(Object.values(datasets).map(d => String(d.color))).filter(c =>\n    presetColors.includes(c)\n  );\n\n  if (usedColors.length === presetColors.length) {\n    // if we already depleted the pool of color\n    return datasetColorMaker.next().value;\n  }\n\n  let color = datasetColorMaker.next().value;\n  while (usedColors.includes(String(color))) {\n    color = datasetColorMaker.next().value;\n  }\n\n  return color;\n}\n\n/**\n * Take datasets payload from addDataToMap, create datasets entry save to visState\n * @type {typeof import('./dataset-utils').createNewDataEntry}\n */\nexport function createNewDataEntry({info, data, ...opts}, datasets = {}) {\n  const validatedData = validateInputData(data);\n  if (!validatedData) {\n    return {};\n  }\n\n  info = info || {};\n  const color = info.color || getNewDatasetColor(datasets);\n\n  const keplerTable = new KeplerTable({info, data: validatedData, color, ...opts});\n  return {\n    [keplerTable.id]: keplerTable\n  };\n}\n\n/**\n * Field name prefixes and suffixes which should not be considered\n * as metrics. Fields will still be included if a 'metric word'\n * is found on the field name, however.\n */\nconst EXCLUDED_DEFAULT_FIELDS = [\n  // Serial numbers and identification numbers\n  '_id',\n  'id',\n  'index',\n  'uuid',\n  'guid',\n  'uid',\n  'gid',\n  'serial',\n  // Geographic IDs are unlikely to be interesting to color\n  'zip',\n  'code',\n  'post',\n  'region',\n  'fips',\n  'cbgs',\n  'h3',\n  's2',\n  // Geographic coords (but not z/elevation/altitude\n  // since that might be a metric)\n  'lat',\n  'lon',\n  'lng',\n  'latitude',\n  'longitude',\n  '_x',\n  '_y'\n];\n\n/**\n * Prefixes and suffixes that indicate a field is a metric.\n *\n * Note that these are in order of preference, first being\n * most preferred.\n */\nconst METRIC_DEFAULT_FIELDS = [\n  'metric',\n  'value',\n  'sum',\n  'count',\n  'unique',\n  'mean',\n  'mode',\n  'median',\n  'max',\n  'min',\n  'deviation',\n  'variance',\n  'p99',\n  'p95',\n  'p75',\n  'p50',\n  'p25',\n  'p05',\n  // Abbreviations are less preferred\n  'cnt',\n  'val'\n];\n\n/**\n * Choose a field to use as the default color field of a layer.\n *\n * The heuristic is:\n *\n * First, exclude fields that are on the exclusion list and don't\n * have names that suggest they contain metrics. Also exclude\n * field names that are blank.\n *\n * Next, look for a field that is of real type and contains one\n * of the preferred names (in order of the preferred names).\n *\n * Next, look for a field that is of integer type and contains\n * one of the preferred names (in order of the preferred names).\n *\n * Next, look for the first field that is of real type (in order\n * of field index).\n *\n * Next, look for the first field that is of integer type (in\n * order of field index).\n *\n * It's possible no field will be chosen (i.e. because all fields\n * are strings.)\n *\n * @param dataset\n */\nexport function findDefaultColorField({fields, fieldPairs = []}) {\n  const fieldsWithoutExcluded = fields.filter(field => {\n    if (field.type !== ALL_FIELD_TYPES.real && field.type !== ALL_FIELD_TYPES.integer) {\n      // Only select numeric fields.\n      return false;\n    }\n    if (\n      fieldPairs.find(\n        pair => pair.pair.lat.value === field.name || pair.pair.lng.value === field.name\n      )\n    ) {\n      // Do not permit lat, lon fields\n      return false;\n    }\n\n    const normalizedFieldName = field.name.toLowerCase();\n    if (normalizedFieldName === '') {\n      // Special case excluded name when the name is blank.\n      return false;\n    }\n    const hasExcluded = EXCLUDED_DEFAULT_FIELDS.find(\n      f => normalizedFieldName.startsWith(f) || normalizedFieldName.endsWith(f)\n    );\n    const hasInclusion = METRIC_DEFAULT_FIELDS.find(\n      f => normalizedFieldName.startsWith(f) || normalizedFieldName.endsWith(f)\n    );\n    return !hasExcluded || hasInclusion;\n  });\n\n  const sortedFields = fieldsWithoutExcluded.sort((left, right) => {\n    const normalizedLeft = left.name.toLowerCase();\n    const normalizedRight = right.name.toLowerCase();\n    const leftHasInclusion = METRIC_DEFAULT_FIELDS.findIndex(\n      f => normalizedLeft.startsWith(f) || normalizedLeft.endsWith(f)\n    );\n    const rightHasInclusion = METRIC_DEFAULT_FIELDS.findIndex(\n      f => normalizedRight.startsWith(f) || normalizedRight.endsWith(f)\n    );\n    if (leftHasInclusion !== rightHasInclusion) {\n      if (leftHasInclusion === -1) {\n        // Elements that do not have the inclusion list should go after those that do.\n        return 1;\n      } else if (rightHasInclusion === -1) {\n        // Elements that do have the inclusion list should go before those that don't.\n        return -1;\n      }\n      // Compare based on order in the inclusion list\n      return leftHasInclusion - rightHasInclusion;\n    }\n\n    // Compare based on type\n    if (left.type !== right.type) {\n      if (left.type === ALL_FIELD_TYPES.real) {\n        return -1;\n      }\n      // left is an integer and right is not\n      // and reals come before integers\n      return 1;\n    }\n\n    // Finally, order based on the order in the datasets columns\n    return left.index - right.index;\n  });\n\n  if (sortedFields.length) {\n    // There was a best match\n    return sortedFields[0];\n  }\n  // No matches\n  return null;\n}\n"]},"metadata":{},"sourceType":"script"}