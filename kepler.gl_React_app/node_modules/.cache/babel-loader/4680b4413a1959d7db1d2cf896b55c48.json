{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport Attribute from './attribute';\nimport log from '../../utils/log';\nimport debug from '../../debug';\nimport AttributeTransitionManager from './attribute-transition-manager';\nvar TRACE_INVALIDATE = 'attributeManager.invalidate';\nvar TRACE_UPDATE_START = 'attributeManager.updateStart';\nvar TRACE_UPDATE_END = 'attributeManager.updateEnd';\nvar TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nvar TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nvar TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\nvar AttributeManager = function () {\n  function AttributeManager(gl) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$id = _ref.id,\n      id = _ref$id === void 0 ? 'attribute-manager' : _ref$id,\n      stats = _ref.stats,\n      timeline = _ref.timeline;\n    _classCallCheck(this, AttributeManager);\n    this.id = id;\n    this.gl = gl;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.accessors = {};\n    this.needsRedraw = true;\n    this.userData = {};\n    this.stats = stats;\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: \"\".concat(id, \"-transitions\"),\n      timeline: timeline\n    });\n    Object.seal(this);\n  }\n  _createClass(AttributeManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      for (var attributeName in this.attributes) {\n        this.attributes[attributeName][\"delete\"]();\n      }\n      this.attributeTransitionManager.finalize();\n    }\n  }, {\n    key: \"getNeedsRedraw\",\n    value: function getNeedsRedraw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearRedrawFlags: false\n      };\n      var redraw = this.needsRedraw;\n      this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n      return redraw && this.id;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.needsRedraw = true;\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(attributes, updaters) {\n      this._add(attributes, updaters);\n    }\n  }, {\n    key: \"addInstanced\",\n    value: function addInstanced(attributes, updaters) {\n      this._add(attributes, updaters, {\n        instanced: 1\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(attributeNameArray) {\n      for (var i = 0; i < attributeNameArray.length; i++) {\n        var name = attributeNameArray[i];\n        if (this.attributes[name] !== undefined) {\n          this.attributes[name][\"delete\"]();\n          delete this.attributes[name];\n        }\n      }\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(triggerName, dataRange) {\n      var invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n      debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n    }\n  }, {\n    key: \"invalidateAll\",\n    value: function invalidateAll(dataRange) {\n      for (var attributeName in this.attributes) {\n        this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n      }\n      debug(TRACE_INVALIDATE, this, 'all');\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        data = _ref2.data,\n        numInstances = _ref2.numInstances,\n        _ref2$startIndices = _ref2.startIndices,\n        startIndices = _ref2$startIndices === void 0 ? null : _ref2$startIndices,\n        transitions = _ref2.transitions,\n        _ref2$props = _ref2.props,\n        props = _ref2$props === void 0 ? {} : _ref2$props,\n        _ref2$buffers = _ref2.buffers,\n        buffers = _ref2$buffers === void 0 ? {} : _ref2$buffers,\n        _ref2$context = _ref2.context,\n        context = _ref2$context === void 0 ? {} : _ref2$context;\n      var updated = false;\n      debug(TRACE_UPDATE_START, this);\n      if (this.stats) {\n        this.stats.get('Update Attributes').timeStart();\n      }\n      for (var attributeName in this.attributes) {\n        var attribute = this.attributes[attributeName];\n        var accessorName = attribute.settings.accessor;\n        attribute.startIndices = startIndices;\n        if (props[attributeName]) {\n          log.removed(\"props.\".concat(attributeName), \"data.attributes.\".concat(attributeName))();\n        }\n        if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(buffers[accessorName], data.startIndices)) {} else if (!buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {} else if (attribute.needsUpdate()) {\n          updated = true;\n          this._updateAttribute({\n            attribute: attribute,\n            numInstances: numInstances,\n            data: data,\n            props: props,\n            context: context\n          });\n        }\n        this.needsRedraw |= attribute.needsRedraw();\n      }\n      if (updated) {\n        debug(TRACE_UPDATE_END, this, numInstances);\n      }\n      if (this.stats) {\n        this.stats.get('Update Attributes').timeEnd();\n      }\n      this.attributeTransitionManager.update({\n        attributes: this.attributes,\n        numInstances: numInstances,\n        transitions: transitions\n      });\n    }\n  }, {\n    key: \"updateTransition\",\n    value: function updateTransition() {\n      var attributeTransitionManager = this.attributeTransitionManager;\n      var transitionUpdated = attributeTransitionManager.run();\n      this.needsRedraw = this.needsRedraw || transitionUpdated;\n      return transitionUpdated;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getChangedAttributes\",\n    value: function getChangedAttributes() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearChangedFlags: false\n      };\n      var attributes = this.attributes,\n        attributeTransitionManager = this.attributeTransitionManager;\n      var changedAttributes = Object.assign({}, attributeTransitionManager.getAttributes());\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n          changedAttributes[attributeName] = attribute;\n        }\n      }\n      return changedAttributes;\n    }\n  }, {\n    key: \"getShaderAttributes\",\n    value: function getShaderAttributes(attributes) {\n      var excludeAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (!attributes) {\n        attributes = this.getAttributes();\n      }\n      var shaderAttributes = {};\n      for (var attributeName in attributes) {\n        if (!excludeAttributes[attributeName]) {\n          Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n        }\n      }\n      return shaderAttributes;\n    }\n  }, {\n    key: \"getAccessors\",\n    value: function getAccessors() {\n      return this.updateTriggers;\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(attributes, updaters) {\n      var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (updaters) {\n        log.warn('AttributeManager.add({updaters}) - updater map no longer supported')();\n      }\n      var newAttributes = {};\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        var newAttribute = this._createAttribute(attributeName, attribute, extraProps);\n        newAttributes[attributeName] = newAttribute;\n      }\n      Object.assign(this.attributes, newAttributes);\n      this._mapUpdateTriggersToAttributes();\n    }\n  }, {\n    key: \"_createAttribute\",\n    value: function _createAttribute(name, attribute, extraProps) {\n      var props = {\n        id: name,\n        constant: attribute.constant || false,\n        isIndexed: attribute.isIndexed || attribute.elements,\n        size: attribute.elements && 1 || attribute.size,\n        value: attribute.value || null,\n        divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor\n      };\n      return new Attribute(this.gl, Object.assign({}, attribute, props));\n    }\n  }, {\n    key: \"_mapUpdateTriggersToAttributes\",\n    value: function _mapUpdateTriggersToAttributes() {\n      var _this = this;\n      var triggers = {};\n      var _loop = function _loop(attributeName) {\n        var attribute = _this.attributes[attributeName];\n        attribute.getUpdateTriggers().forEach(function (triggerName) {\n          if (!triggers[triggerName]) {\n            triggers[triggerName] = [];\n          }\n          triggers[triggerName].push(attributeName);\n        });\n      };\n      for (var attributeName in this.attributes) {\n        _loop(attributeName);\n      }\n      this.updateTriggers = triggers;\n    }\n  }, {\n    key: \"_invalidateTrigger\",\n    value: function _invalidateTrigger(triggerName, dataRange) {\n      var attributes = this.attributes,\n        updateTriggers = this.updateTriggers;\n      var invalidatedAttributes = updateTriggers[triggerName];\n      if (invalidatedAttributes) {\n        invalidatedAttributes.forEach(function (name) {\n          var attribute = attributes[name];\n          if (attribute) {\n            attribute.setNeedsUpdate(attribute.id, dataRange);\n          }\n        });\n      }\n      return invalidatedAttributes;\n    }\n  }, {\n    key: \"_updateAttribute\",\n    value: function _updateAttribute(opts) {\n      var attribute = opts.attribute,\n        numInstances = opts.numInstances;\n      debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n      if (attribute.allocate(numInstances)) {\n        debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n      }\n      var updated = attribute.updateBuffer(opts);\n      if (updated) {\n        this.needsRedraw = true;\n        debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n      }\n    }\n  }]);\n  return AttributeManager;\n}();\nexport { AttributeManager as default };","map":{"version":3,"sources":["../../../../src/lib/attribute/attribute-manager.js"],"names":["Attribute","log","debug","AttributeTransitionManager","TRACE_INVALIDATE","TRACE_UPDATE_START","TRACE_UPDATE_END","TRACE_ATTRIBUTE_UPDATE_START","TRACE_ATTRIBUTE_ALLOCATE","TRACE_ATTRIBUTE_UPDATE_END","AttributeManager","gl","id","stats","timeline","attributes","updateTriggers","accessors","needsRedraw","userData","attributeTransitionManager","Object","seal","attributeName","finalize","opts","clearRedrawFlags","redraw","updaters","_add","instanced","attributeNameArray","i","length","name","undefined","triggerName","dataRange","invalidatedAttributes","_invalidateTrigger","setNeedsUpdate","data","numInstances","startIndices","transitions","props","buffers","context","updated","get","timeStart","attribute","accessorName","settings","accessor","removed","setExternalBuffer","setBinaryValue","setConstantValue","needsUpdate","_updateAttribute","timeEnd","update","transitionUpdated","run","clearChangedFlags","changedAttributes","assign","getAttributes","hasAttribute","excludeAttributes","shaderAttributes","getShaderAttributes","extraProps","warn","newAttributes","newAttribute","_createAttribute","_mapUpdateTriggersToAttributes","constant","isIndexed","elements","size","value","divisor","triggers","getUpdateTriggers","forEach","push","allocate","updateBuffer"],"mappings":";;AAqBA,OAAOA,SAAP,MAAsB,aAAtB;AACA,OAAOC,GAAP,MAAgB,iBAAhB;AACA,OAAOC,KAAP,MAAkB,aAAlB;AAEA,OAAOC,0BAAP,MAAuC,gCAAvC;AAEA,IAAMC,gBAAgB,GAAG,6BAAzB;AACA,IAAMC,kBAAkB,GAAG,8BAA3B;AACA,IAAMC,gBAAgB,GAAG,4BAAzB;AACA,IAAMC,4BAA4B,GAAG,uBAArC;AACA,IAAMC,wBAAwB,GAAG,oBAAjC;AACA,IAAMC,0BAA0B,GAAG,qBAAnC;IAEqBC,gB;EAwBnB,SAAA,gBAAA,CAAYC,EAAZ,EAAkE;IAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;MAAA,OAAA,GAAA,IAAA,CAAjDC,EAAiD;MAAjDA,EAAiD,GAAA,OAAA,KAAA,KAAA,CAAA,GAA5C,mBAA4C,GAAA,OAAA;MAAvBC,KAAuB,GAAA,IAAA,CAAvBA,KAAuB;MAAhBC,QAAgB,GAAA,IAAA,CAAhBA,QAAgB;IAAA,eAAA,CAAA,IAAA,EAAA,gBAAA,CAAA;IAChE,IAAA,CAAKF,EAAL,GAAUA,EAAV;IACA,IAAA,CAAKD,EAAL,GAAUA,EAAV;IAEA,IAAA,CAAKI,UAAL,GAAkB,CAAA,CAAlB;IAEA,IAAA,CAAKC,cAAL,GAAsB,CAAA,CAAtB;IACA,IAAA,CAAKC,SAAL,GAAiB,CAAA,CAAjB;IACA,IAAA,CAAKC,WAAL,GAAmB,IAAnB;IAEA,IAAA,CAAKC,QAAL,GAAgB,CAAA,CAAhB;IACA,IAAA,CAAKN,KAAL,GAAaA,KAAb;IAEA,IAAA,CAAKO,0BAAL,GAAkC,IAAIjB,0BAAJ,CAA+BQ,EAA/B,EAAmC;MACnEC,EAAE,EAAA,EAAA,CAAA,MAAA,CAAKA,EAAL,EAAA,cAAA,CADiE;MAEnEE,QAAQ,EAARA;IAFmE,CAAnC,CAAlC;IAMAO,MAAM,CAACC,IAAPD,CAAY,IAAZA,CAAAA;EACD;;;+BAEU;MACT,KAAK,IAAME,aAAX,IAA4B,IAAA,CAAKR,UAAjC,EAA6C;QAC3C,IAAA,CAAKA,UAAL,CAAgBQ,aAAhB,CAAA,CAAA,QAAA,CAAA,EAAA;MACD;MACD,IAAA,CAAKH,0BAAL,CAAgCI,QAAhC,EAAA;IACD;;;qCAQgD;MAAA,IAAlCC,IAAkC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAA3B;QAACC,gBAAgB,EAAE;MAAnB,CAA2B;MAC/C,IAAMC,MAAM,GAAG,IAAA,CAAKT,WAApB;MACA,IAAA,CAAKA,WAAL,GAAmB,IAAA,CAAKA,WAAL,IAAoB,CAACO,IAAI,CAACC,gBAA7C;MACA,OAAOC,MAAM,IAAI,IAAA,CAAKf,EAAtB;IACD;;;qCAK6B;MAAA,IAAfe,MAAe,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAN,IAAM;MAC5B,IAAA,CAAKT,WAAL,GAAmB,IAAnB;MACA,OAAO,IAAP;IACD;;;wBAGGH,U,EAAYa,Q,EAAU;MACxB,IAAA,CAAKC,IAAL,CAAUd,UAAV,EAAsBa,QAAtB,CAAA;IACD;;;iCAGYb,U,EAAYa,Q,EAAU;MACjC,IAAA,CAAKC,IAAL,CAAUd,UAAV,EAAsBa,QAAtB,EAAgC;QAACE,SAAS,EAAE;MAAZ,CAAhC,CAAA;IACD;;;2BAYMC,kB,EAAoB;MACzB,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,kBAAkB,CAACE,MAAvC,EAA+CD,CAAC,EAAhD,EAAoD;QAClD,IAAME,IAAI,GAAGH,kBAAkB,CAACC,CAAD,CAA/B;QACA,IAAI,IAAA,CAAKjB,UAAL,CAAgBmB,IAAhB,CAAA,KAA0BC,SAA9B,EAAyC;UACvC,IAAA,CAAKpB,UAAL,CAAgBmB,IAAhB,CAAA,CAAA,QAAA,CAAA,EAAA;UACA,OAAO,IAAA,CAAKnB,UAAL,CAAgBmB,IAAhB,CAAP;QACD;MACF;IACF;;;+BAGUE,W,EAAaC,S,EAAW;MACjC,IAAMC,qBAAqB,GAAG,IAAA,CAAKC,kBAAL,CAAwBH,WAAxB,EAAqCC,SAArC,CAA9B;MAEAnC,KAAK,CAACE,gBAAD,EAAmB,IAAnB,EAAyBgC,WAAzB,EAAsCE,qBAAtC,CAALpC;IACD;;;kCAEamC,S,EAAW;MACvB,KAAK,IAAMd,aAAX,IAA4B,IAAA,CAAKR,UAAjC,EAA6C;QAC3C,IAAA,CAAKA,UAAL,CAAgBQ,aAAhB,CAAA,CAA+BiB,cAA/B,CAA8CjB,aAA9C,EAA6Dc,SAA7D,CAAA;MACD;MAEDnC,KAAK,CAACE,gBAAD,EAAmB,IAAnB,EAAyB,KAAzB,CAALF;IACD;;;6BAWO;MAAA,IAAA,KAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;QAPNuC,IAOM,GAAA,KAAA,CAPNA,IAOM;QANNC,YAMM,GAAA,KAAA,CANNA,YAMM;QAAA,kBAAA,GAAA,KAAA,CALNC,YAKM;QALNA,YAKM,GAAA,kBAAA,KAAA,KAAA,CAAA,GALS,IAKT,GAAA,kBAAA;QAJNC,WAIM,GAAA,KAAA,CAJNA,WAIM;QAAA,WAAA,GAAA,KAAA,CAHNC,KAGM;QAHNA,KAGM,GAAA,WAAA,KAAA,KAAA,CAAA,GAHE,CAAA,CAGF,GAAA,WAAA;QAAA,aAAA,GAAA,KAAA,CAFNC,OAEM;QAFNA,OAEM,GAAA,aAAA,KAAA,KAAA,CAAA,GAFI,CAAA,CAEJ,GAAA,aAAA;QAAA,aAAA,GAAA,KAAA,CADNC,OACM;QADNA,OACM,GAAA,aAAA,KAAA,KAAA,CAAA,GADI,CAAA,CACJ,GAAA,aAAA;MAEN,IAAIC,OAAO,GAAG,KAAd;MAEA9C,KAAK,CAACG,kBAAD,EAAqB,IAArB,CAALH;MACA,IAAI,IAAA,CAAKW,KAAT,EAAgB;QACd,IAAA,CAAKA,KAAL,CAAWoC,GAAX,CAAe,mBAAf,CAAA,CAAoCC,SAApC,EAAA;MACD;MAED,KAAK,IAAM3B,aAAX,IAA4B,IAAA,CAAKR,UAAjC,EAA6C;QAC3C,IAAMoC,SAAS,GAAG,IAAA,CAAKpC,UAAL,CAAgBQ,aAAhB,CAAlB;QACA,IAAM6B,YAAY,GAAGD,SAAS,CAACE,QAAVF,CAAmBG,QAAxC;QACAH,SAAS,CAACR,YAAVQ,GAAyBR,YAAzBQ;QAEA,IAAIN,KAAK,CAACtB,aAAD,CAAT,EAA0B;UACxBtB,GAAG,CAACsD,OAAJtD,CAAAA,QAAAA,CAAAA,MAAAA,CAAqBsB,aAArBtB,CAAAA,EAAAA,kBAAAA,CAAAA,MAAAA,CAAyDsB,aAAzDtB,CAAAA,CAAAA,EAAAA;QACD;QAED,IAAIkD,SAAS,CAACK,iBAAVL,CAA4BL,OAAO,CAACvB,aAAD,CAAnC4B,CAAJ,EAAyD,CAExD,CAFD,MAEO,IAAIA,SAAS,CAACM,cAAVN,CAAyBL,OAAO,CAACM,YAAD,CAAhCD,EAAgDV,IAAI,CAACE,YAArDQ,CAAJ,EAAwE,CAE9E,CAFM,MAEA,IAAI,CAACL,OAAO,CAACM,YAAD,CAAR,IAA0BD,SAAS,CAACO,gBAAVP,CAA2BN,KAAK,CAACO,YAAD,CAAhCD,CAA9B,EAA+E,CAIrF,CAJM,MAIA,IAAIA,SAAS,CAACQ,WAAVR,EAAJ,EAA6B;UAElCH,OAAO,GAAG,IAAVA;UACA,IAAA,CAAKY,gBAAL,CAAsB;YACpBT,SAAS,EAATA,SADoB;YAEpBT,YAAY,EAAZA,YAFoB;YAGpBD,IAAI,EAAJA,IAHoB;YAIpBI,KAAK,EAALA,KAJoB;YAKpBE,OAAO,EAAPA;UALoB,CAAtB,CAAA;QAOD;QAED,IAAA,CAAK7B,WAAL,IAAoBiC,SAAS,CAACjC,WAAViC,EAApB;MACD;MAED,IAAIH,OAAJ,EAAa;QAEX9C,KAAK,CAACI,gBAAD,EAAmB,IAAnB,EAAyBoC,YAAzB,CAALxC;MACD;MAED,IAAI,IAAA,CAAKW,KAAT,EAAgB;QACd,IAAA,CAAKA,KAAL,CAAWoC,GAAX,CAAe,mBAAf,CAAA,CAAoCY,OAApC,EAAA;MACD;MAED,IAAA,CAAKzC,0BAAL,CAAgC0C,MAAhC,CAAuC;QACrC/C,UAAU,EAAE,IAAA,CAAKA,UADoB;QAErC2B,YAAY,EAAZA,YAFqC;QAGrCE,WAAW,EAAXA;MAHqC,CAAvC,CAAA;IAKD;;;uCAIkB;MAAA,IACVxB,0BADU,GACoB,IADpB,CACVA,0BADU;MAEjB,IAAM2C,iBAAiB,GAAG3C,0BAA0B,CAAC4C,GAA3B5C,EAA1B;MACA,IAAA,CAAKF,WAAL,GAAmB,IAAA,CAAKA,WAAL,IAAoB6C,iBAAvC;MACA,OAAOA,iBAAP;IACD;;;oCAOe;MACd,OAAO,IAAA,CAAKhD,UAAZ;IACD;;;2CAOuD;MAAA,IAAnCU,IAAmC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAA5B;QAACwC,iBAAiB,EAAE;MAApB,CAA4B;MAAA,IAC/ClD,UAD+C,GACL,IADK,CAC/CA,UAD+C;QACnCK,0BADmC,GACL,IADK,CACnCA,0BADmC;MAGtD,IAAM8C,iBAAiB,GAAG7C,MAAM,CAAC8C,MAAP9C,CAAc,CAAA,CAAdA,EAAkBD,0BAA0B,CAACgD,aAA3BhD,EAAlBC,CAA1B;MAEA,KAAK,IAAME,aAAX,IAA4BR,UAA5B,EAAwC;QACtC,IAAMoC,SAAS,GAAGpC,UAAU,CAACQ,aAAD,CAA5B;QACA,IAAI4B,SAAS,CAACjC,WAAViC,CAAsB1B,IAAtB0B,CAAAA,IAA+B,CAAC/B,0BAA0B,CAACiD,YAA3BjD,CAAwCG,aAAxCH,CAApC,EAA4F;UAC1F8C,iBAAiB,CAAC3C,aAAD,CAAjB2C,GAAmCf,SAAnCe;QACD;MACF;MAED,OAAOA,iBAAP;IACD;;;wCAGmBnD,U,EAAoC;MAAA,IAAxBuD,iBAAwB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;MACtD,IAAI,CAACvD,UAAL,EAAiB;QACfA,UAAU,GAAG,IAAA,CAAKqD,aAAL,EAAbrD;MACD;MACD,IAAMwD,gBAAgB,GAAG,CAAA,CAAzB;MACA,KAAK,IAAMhD,aAAX,IAA4BR,UAA5B,EAAwC;QACtC,IAAI,CAACuD,iBAAiB,CAAC/C,aAAD,CAAtB,EAAuC;UACrCF,MAAM,CAAC8C,MAAP9C,CAAckD,gBAAdlD,EAAgCN,UAAU,CAACQ,aAAD,CAAVR,CAA0ByD,mBAA1BzD,EAAhCM,CAAAA;QACD;MACF;MACD,OAAOkD,gBAAP;IACD;;;mCAMc;MACb,OAAO,IAAA,CAAKvD,cAAZ;IACD;;;yBAKID,U,EAAYa,Q,EAA2B;MAAA,IAAjB6C,UAAiB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;MAC1C,IAAI7C,QAAJ,EAAc;QACZ3B,GAAG,CAACyE,IAAJzE,CAAS,oEAATA,CAAAA,EAAAA;MACD;MAED,IAAM0E,aAAa,GAAG,CAAA,CAAtB;MAEA,KAAK,IAAMpD,aAAX,IAA4BR,UAA5B,EAAwC;QACtC,IAAMoC,SAAS,GAAGpC,UAAU,CAACQ,aAAD,CAA5B;QAGA,IAAMqD,YAAY,GAAG,IAAA,CAAKC,gBAAL,CAAsBtD,aAAtB,EAAqC4B,SAArC,EAAgDsB,UAAhD,CAArB;QAEAE,aAAa,CAACpD,aAAD,CAAboD,GAA+BC,YAA/BD;MACD;MAEDtD,MAAM,CAAC8C,MAAP9C,CAAc,IAAA,CAAKN,UAAnBM,EAA+BsD,aAA/BtD,CAAAA;MAEA,IAAA,CAAKyD,8BAAL,EAAA;IACD;;;qCAGgB5C,I,EAAMiB,S,EAAWsB,U,EAAY;MAC5C,IAAM5B,KAAK,GAAG;QACZjC,EAAE,EAAEsB,IADQ;QAGZ6C,QAAQ,EAAE5B,SAAS,CAAC4B,QAAV5B,IAAsB,KAHpB;QAIZ6B,SAAS,EAAE7B,SAAS,CAAC6B,SAAV7B,IAAuBA,SAAS,CAAC8B,QAJhC;QAKZC,IAAI,EAAG/B,SAAS,CAAC8B,QAAV9B,IAAsB,CAAvB,IAA6BA,SAAS,CAAC+B,IALjC;QAMZC,KAAK,EAAEhC,SAAS,CAACgC,KAAVhC,IAAmB,IANd;QAOZiC,OAAO,EAAEjC,SAAS,CAACrB,SAAVqB,IAAuBsB,UAAU,CAAC3C,SAAlCqB,GAA8C,CAA9CA,GAAkDA,SAAS,CAACiC;MAPzD,CAAd;MAUA,OAAO,IAAIpF,SAAJ,CAAc,IAAA,CAAKW,EAAnB,EAAuBU,MAAM,CAAC8C,MAAP9C,CAAc,CAAA,CAAdA,EAAkB8B,SAAlB9B,EAA6BwB,KAA7BxB,CAAvB,CAAP;IACD;;;qDAGgC;MAAA,IAAA,KAAA,GAAA,IAAA;MAC/B,IAAMgE,QAAQ,GAAG,CAAA,CAAjB;MAD+B,IAAA,KAAA,GAAA,SAAA,KAAA,CAGpB9D,aAHoB,EAAA;QAI7B,IAAM4B,SAAS,GAAG,KAAI,CAACpC,UAAL,CAAgBQ,aAAhB,CAAlB;QACA4B,SAAS,CAACmC,iBAAVnC,EAAAA,CAA8BoC,OAA9BpC,CAAsC,UAAA,WAAW,EAAI;UACnD,IAAI,CAACkC,QAAQ,CAACjD,WAAD,CAAb,EAA4B;YAC1BiD,QAAQ,CAACjD,WAAD,CAARiD,GAAwB,EAAxBA;UACD;UACDA,QAAQ,CAACjD,WAAD,CAARiD,CAAsBG,IAAtBH,CAA2B9D,aAA3B8D,CAAAA;QACD,CALDlC,CAAAA;MAL6B,CAAA;MAG/B,KAAK,IAAM5B,aAAX,IAA4B,IAAA,CAAKR,UAAjC,EAA6C;QAAA,KAAA,CAAlCQ,aAAkC,CAAA;MAQ5C;MAED,IAAA,CAAKP,cAAL,GAAsBqE,QAAtB;IACD;;;uCAEkBjD,W,EAAaC,S,EAAW;MAAA,IAClCtB,UADkC,GACJ,IADI,CAClCA,UADkC;QACtBC,cADsB,GACJ,IADI,CACtBA,cADsB;MAEzC,IAAMsB,qBAAqB,GAAGtB,cAAc,CAACoB,WAAD,CAA5C;MAEA,IAAIE,qBAAJ,EAA2B;QACzBA,qBAAqB,CAACiD,OAAtBjD,CAA8B,UAAA,IAAI,EAAI;UACpC,IAAMa,SAAS,GAAGpC,UAAU,CAACmB,IAAD,CAA5B;UACA,IAAIiB,SAAJ,EAAe;YACbA,SAAS,CAACX,cAAVW,CAAyBA,SAAS,CAACvC,EAAnCuC,EAAuCd,SAAvCc,CAAAA;UACD;QACF,CALDb,CAAAA;MAMD;MACD,OAAOA,qBAAP;IACD;;;qCAEgBb,I,EAAM;MAAA,IACd0B,SADc,GACa1B,IADb,CACd0B,SADc;QACHT,YADG,GACajB,IADb,CACHiB,YADG;MAErBxC,KAAK,CAACK,4BAAD,EAA+B4C,SAA/B,CAALjD;MAEA,IAAIiD,SAAS,CAACsC,QAAVtC,CAAmBT,YAAnBS,CAAJ,EAAsC;QACpCjD,KAAK,CAACM,wBAAD,EAA2B2C,SAA3B,EAAsCT,YAAtC,CAALxC;MACD;MAGD,IAAM8C,OAAO,GAAGG,SAAS,CAACuC,YAAVvC,CAAuB1B,IAAvB0B,CAAhB;MACA,IAAIH,OAAJ,EAAa;QACX,IAAA,CAAK9B,WAAL,GAAmB,IAAnB;QACAhB,KAAK,CAACO,0BAAD,EAA6B0C,SAA7B,EAAwCT,YAAxC,CAALxC;MACD;IACF;;;;SAzUkBQ,gB","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\nimport Attribute from './attribute';\nimport log from '../../utils/log';\nimport debug from '../../debug';\n\nimport AttributeTransitionManager from './attribute-transition-manager';\n\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\n\nexport default class AttributeManager {\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   */\n  constructor(gl, {id = 'attribute-manager', stats, timeline} = {}) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributes = {};\n\n    this.updateTriggers = {};\n    this.accessors = {};\n    this.needsRedraw = true;\n\n    this.userData = {};\n    this.stats = stats;\n\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: `${id}-transitions`,\n      timeline\n    });\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw(opts = {clearRedrawFlags: false}) {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  // @return {AttributeManager} - for chaining\n  setNeedsRedraw(redraw = true) {\n    this.needsRedraw = true;\n    return this;\n  }\n\n  // Adds attributes\n  add(attributes, updaters) {\n    this._add(attributes, updaters);\n  }\n\n  // Adds attributes\n  addInstanced(attributes, updaters) {\n    this._add(attributes, updaters, {instanced: 1});\n  }\n\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray) {\n    for (let i = 0; i < attributeNameArray.length; i++) {\n      const name = attributeNameArray[i];\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  // Marks an attribute for update\n  invalidate(triggerName, dataRange) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n\n  invalidateAll(dataRange) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n\n  // Ensure all attribute buffers are updated from props or data.\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  } = {}) {\n    // keep track of whether some attributes are updated\n    let updated = false;\n\n    debug(TRACE_UPDATE_START, this);\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n\n      if (props[attributeName]) {\n        log.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();\n      }\n\n      if (attribute.setExternalBuffer(buffers[attributeName])) {\n        // Step 1: try update attribute directly from external buffers\n      } else if (attribute.setBinaryValue(buffers[accessorName], data.startIndices)) {\n        // Step 2: try set packed value from external typed array\n      } else if (!buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {\n        // Step 3: try set constant value from props\n        // Note: if buffers[accessorName] is supplied, ignore props[accessorName]\n        // This may happen when setBinaryValue falls through to use the auto updater\n      } else if (attribute.needsUpdate()) {\n        // Step 4: update via updater callback\n        updated = true;\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n\n      this.needsRedraw |= attribute.needsRedraw();\n    }\n\n    if (updated) {\n      // Only initiate alloc/update (and logging) if actually needed\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition() {\n    const {attributeTransitionManager} = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes() {\n    return this.attributes;\n  }\n\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuffers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes(opts = {clearChangedFlags: false}) {\n    const {attributes, attributeTransitionManager} = this;\n\n    const changedAttributes = Object.assign({}, attributeTransitionManager.getAttributes());\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n\n    return changedAttributes;\n  }\n\n  // Returns shader attributes\n  getShaderAttributes(attributes, excludeAttributes = {}) {\n    if (!attributes) {\n      attributes = this.getAttributes();\n    }\n    const shaderAttributes = {};\n    for (const attributeName in attributes) {\n      if (!excludeAttributes[attributeName]) {\n        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n      }\n    }\n    return shaderAttributes;\n  }\n\n  // PROTECTED METHODS - Only to be used by collaborating classes, not by apps\n\n  // Returns object containing all accessors as keys, with non-null values\n  // @return {Object} - accessors object\n  getAccessors() {\n    return this.updateTriggers;\n  }\n\n  // PRIVATE METHODS\n\n  // Used to register an attribute\n  _add(attributes, updaters, extraProps = {}) {\n    if (updaters) {\n      log.warn('AttributeManager.add({updaters}) - updater map no longer supported')();\n    }\n\n    const newAttributes = {};\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      const newAttribute = this._createAttribute(attributeName, attribute, extraProps);\n\n      newAttributes[attributeName] = newAttribute;\n    }\n\n    Object.assign(this.attributes, newAttributes);\n\n    this._mapUpdateTriggersToAttributes();\n  }\n  /* eslint-enable max-statements */\n\n  _createAttribute(name, attribute, extraProps) {\n    const props = {\n      id: name,\n      // Luma fields\n      constant: attribute.constant || false,\n      isIndexed: attribute.isIndexed || attribute.elements,\n      size: (attribute.elements && 1) || attribute.size,\n      value: attribute.value || null,\n      divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor\n    };\n\n    return new Attribute(this.gl, Object.assign({}, attribute, props));\n  }\n\n  // build updateTrigger name to attribute name mapping\n  _mapUpdateTriggersToAttributes() {\n    const triggers = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  _invalidateTrigger(triggerName, dataRange) {\n    const {attributes, updateTriggers} = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n\n  _updateAttribute(opts) {\n    const {attribute, numInstances} = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n\n    // Calls update on any buffers that need update\n    const updated = attribute.updateBuffer(opts);\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}