{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport Martini from '@mapbox/martini';\nimport { getMeshBoundingBox } from '@loaders.gl/loader-utils';\nfunction getTerrain(imageData, tileSize, elevationDecoder) {\n  var rScaler = elevationDecoder.rScaler,\n    bScaler = elevationDecoder.bScaler,\n    gScaler = elevationDecoder.gScaler,\n    offset = elevationDecoder.offset;\n  var gridSize = tileSize + 1;\n  var terrain = new Float32Array(gridSize * gridSize);\n  for (var i = 0, y = 0; y < tileSize; y++) {\n    for (var x = 0; x < tileSize; x++, i++) {\n      var k = i * 4;\n      var r = imageData[k + 0];\n      var g = imageData[k + 1];\n      var b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n  for (var _i = gridSize * (gridSize - 1), _x = 0; _x < gridSize - 1; _x++, _i++) {\n    terrain[_i] = terrain[_i - gridSize];\n  }\n  for (var _i2 = gridSize - 1, _y = 0; _y < gridSize; _y++, _i2 += gridSize) {\n    terrain[_i2] = terrain[_i2 - 1];\n  }\n  return terrain;\n}\nfunction getMeshAttributes(vertices, terrain, tileSize, bounds) {\n  var gridSize = tileSize + 1;\n  var numOfVerticies = vertices.length / 2;\n  var positions = new Float32Array(numOfVerticies * 3);\n  var texCoords = new Float32Array(numOfVerticies * 2);\n  var _ref = bounds || [0, 0, tileSize, tileSize],\n    _ref2 = _slicedToArray(_ref, 4),\n    minX = _ref2[0],\n    minY = _ref2[1],\n    maxX = _ref2[2],\n    maxY = _ref2[3];\n  var xScale = (maxX - minX) / tileSize;\n  var yScale = (maxY - minY) / tileSize;\n  for (var i = 0; i < numOfVerticies; i++) {\n    var x = vertices[i * 2];\n    var y = vertices[i * 2 + 1];\n    var pixelIdx = y * gridSize + x;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n    texCoords[2 * i + 0] = x / tileSize;\n    texCoords[2 * i + 1] = y / tileSize;\n  }\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n  };\n}\nfunction getMartiniTileMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n  var meshMaxError = terrainOptions.meshMaxError,\n    bounds = terrainOptions.bounds,\n    elevationDecoder = terrainOptions.elevationDecoder;\n  var data = terrainImage.data;\n  var tileSize = terrainImage.width;\n  var gridSize = tileSize + 1;\n  var terrain = getTerrain(data, tileSize, elevationDecoder);\n  var martini = new Martini(gridSize);\n  var tile = martini.createTile(terrain);\n  var _tile$getMesh = tile.getMesh(meshMaxError),\n    vertices = _tile$getMesh.vertices,\n    triangles = _tile$getMesh.triangles;\n  var attributes = getMeshAttributes(vertices, terrain, tileSize, bounds);\n  return {\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox: getMeshBoundingBox(attributes)\n    },\n    mode: 4,\n    indices: {\n      value: triangles,\n      size: 1\n    },\n    attributes: attributes\n  };\n}\nexport default function loadTerrain(_x2, _x3, _x4) {\n  return _loadTerrain.apply(this, arguments);\n}\nfunction _loadTerrain() {\n  _loadTerrain = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(arrayBuffer, options, context) {\n    var image;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options.image = options.image || {};\n            options.image.type = 'data';\n            _context.next = 4;\n            return context.parse(arrayBuffer, options, options.baseUri);\n          case 4:\n            image = _context.sent;\n            return _context.abrupt(\"return\", getMartiniTileMesh(image, options.terrain));\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _loadTerrain.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/lib/parse-terrain.js"],"names":["Martini","getMeshBoundingBox","getTerrain","imageData","tileSize","elevationDecoder","rScaler","bScaler","gScaler","offset","gridSize","terrain","Float32Array","i","y","x","k","r","g","b","getMeshAttributes","vertices","bounds","numOfVerticies","length","positions","texCoords","minX","minY","maxX","maxY","xScale","yScale","pixelIdx","POSITION","value","size","TEXCOORD_0","getMartiniTileMesh","terrainImage","terrainOptions","meshMaxError","data","width","martini","tile","createTile","triangles","getMesh","attributes","loaderData","header","vertexCount","boundingBox","mode","indices","loadTerrain","arrayBuffer","options","context","image","type","parse","baseUri"],"mappings":"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","sourcesContent":["import Martini from '@mapbox/martini';\nimport {getMeshBoundingBox} from '@loaders.gl/loader-utils';\n\nfunction getTerrain(imageData, tileSize, elevationDecoder) {\n  const {rScaler, bScaler, gScaler, offset} = elevationDecoder;\n\n  const gridSize = tileSize + 1;\n  // From Martini demo\n  // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n  const terrain = new Float32Array(gridSize * gridSize);\n  // decode terrain values\n  for (let i = 0, y = 0; y < tileSize; y++) {\n    for (let x = 0; x < tileSize; x++, i++) {\n      const k = i * 4;\n      const r = imageData[k + 0];\n      const g = imageData[k + 1];\n      const b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n  // backfill bottom border\n  for (let i = gridSize * (gridSize - 1), x = 0; x < gridSize - 1; x++, i++) {\n    terrain[i] = terrain[i - gridSize];\n  }\n  // backfill right border\n  for (let i = gridSize - 1, y = 0; y < gridSize; y++, i += gridSize) {\n    terrain[i] = terrain[i - 1];\n  }\n  return terrain;\n}\n\nfunction getMeshAttributes(vertices, terrain, tileSize, bounds) {\n  const gridSize = tileSize + 1;\n  const numOfVerticies = vertices.length / 2;\n  // vec3. x, y in pixels, z in meters\n  const positions = new Float32Array(numOfVerticies * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(numOfVerticies * 2);\n\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, tileSize, tileSize];\n  const xScale = (maxX - minX) / tileSize;\n  const yScale = (maxY - minY) / tileSize;\n\n  for (let i = 0; i < numOfVerticies; i++) {\n    const x = vertices[i * 2];\n    const y = vertices[i * 2 + 1];\n    const pixelIdx = y * gridSize + x;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n\n    texCoords[2 * i + 0] = x / tileSize;\n    texCoords[2 * i + 1] = y / tileSize;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\nfunction getMartiniTileMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n  const {meshMaxError, bounds, elevationDecoder} = terrainOptions;\n\n  const data = terrainImage.data;\n  const tileSize = terrainImage.width;\n  const gridSize = tileSize + 1;\n\n  const terrain = getTerrain(data, tileSize, elevationDecoder);\n\n  const martini = new Martini(gridSize);\n  const tile = martini.createTile(terrain);\n  const {vertices, triangles} = tile.getMesh(meshMaxError);\n\n  const attributes = getMeshAttributes(vertices, terrain, tileSize, bounds);\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox: getMeshBoundingBox(attributes)\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: triangles, size: 1},\n    attributes\n  };\n}\n\nexport default async function loadTerrain(arrayBuffer, options, context) {\n  options.image = options.image || {};\n  options.image.type = 'data';\n  const image = await context.parse(arrayBuffer, options, options.baseUri);\n  // Extend function to support additional mesh generation options (square grid or delatin)\n  return getMartiniTileMesh(image, options.terrain);\n}\n"]},"metadata":{},"sourceType":"module"}