{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nexport var TypedArrayManager = function () {\n  function TypedArrayManager() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$overAlloc = _ref.overAlloc,\n      overAlloc = _ref$overAlloc === void 0 ? 2 : _ref$overAlloc,\n      _ref$poolSize = _ref.poolSize,\n      poolSize = _ref$poolSize === void 0 ? 100 : _ref$poolSize;\n    _classCallCheck(this, TypedArrayManager);\n    this.overAlloc = overAlloc;\n    this.poolSize = poolSize;\n    this._pool = [];\n  }\n  _createClass(TypedArrayManager, [{\n    key: \"allocate\",\n    value: function allocate(typedArray, count, _ref2) {\n      var _ref2$size = _ref2.size,\n        size = _ref2$size === void 0 ? 1 : _ref2$size,\n        type = _ref2.type,\n        _ref2$padding = _ref2.padding,\n        padding = _ref2$padding === void 0 ? 0 : _ref2$padding,\n        _ref2$copy = _ref2.copy,\n        copy = _ref2$copy === void 0 ? false : _ref2$copy,\n        _ref2$initialize = _ref2.initialize,\n        initialize = _ref2$initialize === void 0 ? false : _ref2$initialize;\n      var Type = type || typedArray && typedArray.constructor || Float32Array;\n      var newSize = count * size + padding;\n      if (ArrayBuffer.isView(typedArray)) {\n        if (newSize <= typedArray.length) {\n          return typedArray;\n        }\n        if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n          return new Type(typedArray.buffer, 0, newSize);\n        }\n      }\n      var newArray = this._allocate(Type, newSize, initialize);\n      if (typedArray && copy) {\n        newArray.set(typedArray);\n      } else if (!initialize) {\n        newArray.fill(0, 0, 4);\n      }\n      this._release(typedArray);\n      return newArray;\n    }\n  }, {\n    key: \"release\",\n    value: function release(typedArray) {\n      this._release(typedArray);\n    }\n  }, {\n    key: \"_allocate\",\n    value: function _allocate(Type, size, initialize) {\n      size = Math.max(Math.ceil(size * this.overAlloc), 1);\n      var pool = this._pool;\n      var byteLength = Type.BYTES_PER_ELEMENT * size;\n      var i = pool.findIndex(function (b) {\n        return b.byteLength >= byteLength;\n      });\n      if (i >= 0) {\n        var array = new Type(pool.splice(i, 1)[0], 0, size);\n        if (initialize) {\n          array.fill(0);\n        }\n        return array;\n      }\n      return new Type(size);\n    }\n  }, {\n    key: \"_release\",\n    value: function _release(typedArray) {\n      if (!ArrayBuffer.isView(typedArray)) {\n        return;\n      }\n      var pool = this._pool;\n      var buffer = typedArray.buffer;\n      var byteLength = buffer.byteLength;\n      var i = pool.findIndex(function (b) {\n        return b.byteLength >= byteLength;\n      });\n      if (i < 0) {\n        pool.push(buffer);\n      } else if (i > 0 || pool.length < this.poolSize) {\n        pool.splice(i, 0, buffer);\n      }\n      if (pool.length > this.poolSize) {\n        pool.shift();\n      }\n    }\n  }]);\n  return TypedArrayManager;\n}();\nexport default new TypedArrayManager();","map":{"version":3,"sources":["../../../src/utils/typed-array-manager.js"],"names":["TypedArrayManager","overAlloc","poolSize","_pool","typedArray","count","size","type","padding","copy","initialize","Type","constructor","Float32Array","newSize","ArrayBuffer","isView","length","BYTES_PER_ELEMENT","buffer","byteLength","newArray","_allocate","set","fill","_release","Math","max","ceil","pool","i","findIndex","b","array","splice","push","shift"],"mappings":"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","sourcesContent":["export class TypedArrayManager {\n  constructor({overAlloc = 2, poolSize = 100} = {}) {\n    this.overAlloc = overAlloc;\n    this.poolSize = poolSize;\n\n    this._pool = [];\n  }\n\n  allocate(typedArray, count, {size = 1, type, padding = 0, copy = false, initialize = false}) {\n    const Type = type || (typedArray && typedArray.constructor) || Float32Array;\n\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize);\n      }\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      // Hack - always initialize the first 4 elements. NaNs crashe the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n    return newArray;\n  }\n\n  release(typedArray) {\n    this._release(typedArray);\n  }\n\n  _allocate(Type, size, initialize) {\n    // Allocate at least one element to ensure a valid buffer\n    size = Math.max(Math.ceil(size * this.overAlloc), 1);\n\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * size;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      const array = new Type(pool.splice(i, 1)[0], 0, size);\n      if (initialize) {\n        // Viewing a buffer with a different type may create NaNs\n        array.fill(0);\n      }\n      return array;\n    }\n    return new Type(size);\n  }\n\n  _release(typedArray) {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {buffer} = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {byteLength} = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\n\nexport default new TypedArrayManager();\n"]},"metadata":{},"sourceType":"module"}