{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { CullingVolume, Plane, AxisAlignedBoundingBox } from '@math.gl/culling';\nvar TILE_SIZE = 512;\nvar MAX_MAPS = 3;\nvar OSMNode = function () {\n  function OSMNode(x, y, z) {\n    _classCallCheck(this, OSMNode);\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  _createClass(OSMNode, [{\n    key: \"update\",\n    value: function update(params) {\n      var viewport = params.viewport,\n        cullingVolume = params.cullingVolume,\n        elevationBounds = params.elevationBounds,\n        minZ = params.minZ,\n        maxZ = params.maxZ,\n        offset = params.offset;\n      var boundingVolume = this.getBoundingVolume(elevationBounds, offset);\n      var isInside = cullingVolume.computeVisibility(boundingVolume);\n      if (isInside < 0) {\n        return false;\n      }\n      if (!this.childVisible) {\n        var z = this.z;\n        if (z < maxZ && z >= minZ) {\n          var distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;\n          z += Math.floor(Math.log2(distance));\n        }\n        if (z >= maxZ) {\n          this.selected = true;\n          return true;\n        }\n      }\n      this.selected = false;\n      this.childVisible = true;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var child = _step.value;\n          child.update(params);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"getSelected\",\n    value: function getSelected() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      if (this.selected) {\n        result.push(this);\n      }\n      if (this._children) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n        try {\n          for (var _iterator2 = this._children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var node = _step2.value;\n            node.getSelected(result);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"getBoundingVolume\",\n    value: function getBoundingVolume(zRange, worldOffset) {\n      var scale = Math.pow(2, this.z);\n      var extent = TILE_SIZE / scale;\n      var originX = this.x * extent + worldOffset * TILE_SIZE;\n      var originY = TILE_SIZE - (this.y + 1) * extent;\n      return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      if (!this._children) {\n        var x = this.x * 2;\n        var y = this.y * 2;\n        var z = this.z + 1;\n        this._children = [new OSMNode(x, y, z), new OSMNode(x, y + 1, z), new OSMNode(x + 1, y, z), new OSMNode(x + 1, y + 1, z)];\n      }\n      return this._children;\n    }\n  }]);\n  return OSMNode;\n}();\nexport function getOSMTileIndices(viewport, maxZ, zRange) {\n  var planes = Object.values(viewport.getFrustumPlanes()).map(function (_ref) {\n    var normal = _ref.normal,\n      distance = _ref.distance;\n    return new Plane(normal.clone().negate(), distance);\n  });\n  var cullingVolume = new CullingVolume(planes);\n  var unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  var elevationMin = zRange && zRange[0] * unitsPerMeter || 0;\n  var elevationMax = zRange && zRange[1] * unitsPerMeter || 0;\n  var minZ = viewport.pitch <= 60 ? maxZ : 0;\n  var root = new OSMNode(0, 0, 0);\n  var traversalParams = {\n    viewport: viewport,\n    cullingVolume: cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ: minZ,\n    maxZ: maxZ,\n    offset: 0\n  };\n  root.update(traversalParams);\n  if (viewport.subViewports && viewport.subViewports.length > 1) {\n    traversalParams.offset = -1;\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n    traversalParams.offset = 1;\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n  return root.getSelected();\n}","map":{"version":3,"sources":["../../../src/tile-layer/tile-2d-traversal.js"],"names":["CullingVolume","Plane","AxisAlignedBoundingBox","TILE_SIZE","MAX_MAPS","OSMNode","x","y","z","_children","params","viewport","cullingVolume","elevationBounds","minZ","maxZ","offset","boundingVolume","getBoundingVolume","isInside","computeVisibility","childVisible","distance","distanceTo","cameraPosition","scale","height","Math","floor","log2","selected","child","children","update","result","push","node","getSelected","zRange","worldOffset","pow","extent","originX","originY","getOSMTileIndices","planes","values","getFrustumPlanes","map","normal","clone","negate","unitsPerMeter","distanceScales","elevationMin","elevationMax","pitch","root","traversalParams","subViewports","length"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport {CullingVolume, Plane, AxisAlignedBoundingBox} from '@math.gl/culling';\n\nconst TILE_SIZE = 512;\n// number of world copies to check\nconst MAX_MAPS = 3;\n\nclass OSMNode {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  get children() {\n    if (!this._children) {\n      const x = this.x * 2;\n      const y = this.y * 2;\n      const z = this.z + 1;\n      this._children = [\n        new OSMNode(x, y, z),\n        new OSMNode(x, y + 1, z),\n        new OSMNode(x + 1, y, z),\n        new OSMNode(x + 1, y + 1, z)\n      ];\n    }\n    return this._children;\n  }\n\n  update(params) {\n    const {viewport, cullingVolume, elevationBounds, minZ, maxZ, offset} = params;\n    const boundingVolume = this.getBoundingVolume(elevationBounds, offset);\n\n    // First, check if this tile is visible\n    const isInside = cullingVolume.computeVisibility(boundingVolume);\n    if (isInside < 0) {\n      return false;\n    }\n\n    // Avoid loading overlapping tiles - if a descendant is requested, do not request the ancester\n    if (!this.childVisible) {\n      let {z} = this;\n      if (z < maxZ && z >= minZ) {\n        // Adjust LOD\n        // If the tile is far enough from the camera, accept a lower zoom level\n        const distance =\n          (boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale) / viewport.height;\n        z += Math.floor(Math.log2(distance));\n      }\n      if (z >= maxZ) {\n        // LOD is acceptable\n        this.selected = true;\n        return true;\n      }\n    }\n\n    // LOD is not enough, recursively test child tiles\n    this.selected = false;\n    this.childVisible = true;\n    for (const child of this.children) {\n      child.update(params);\n    }\n    return true;\n  }\n\n  getSelected(result = []) {\n    if (this.selected) {\n      result.push(this);\n    }\n    if (this._children) {\n      for (const node of this._children) {\n        node.getSelected(result);\n      }\n    }\n    return result;\n  }\n\n  getBoundingVolume(zRange, worldOffset) {\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    const originX = this.x * extent + worldOffset * TILE_SIZE;\n    // deck's common space is y-flipped\n    const originY = TILE_SIZE - (this.y + 1) * extent;\n\n    return new AxisAlignedBoundingBox(\n      [originX, originY, zRange[0]],\n      [originX + extent, originY + extent, zRange[1]]\n    );\n  }\n}\n\nexport function getOSMTileIndices(viewport, maxZ, zRange) {\n  // Get the culling volume of the current camera\n  const planes = Object.values(viewport.getFrustumPlanes()).map(\n    ({normal, distance}) => new Plane(normal.clone().negate(), distance)\n  );\n  const cullingVolume = new CullingVolume(planes);\n\n  // Project zRange from meters to common space\n  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  const elevationMin = (zRange && zRange[0] * unitsPerMeter) || 0;\n  const elevationMax = (zRange && zRange[1] * unitsPerMeter) || 0;\n\n  // Always load at the current zoom level if pitch is small\n  const minZ = viewport.pitch <= 60 ? maxZ : 0;\n\n  const root = new OSMNode(0, 0, 0);\n  const traversalParams = {\n    viewport,\n    cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ,\n    maxZ,\n    // num. of worlds from the center. For repeated maps\n    offset: 0\n  };\n\n  root.update(traversalParams);\n\n  if (viewport.subViewports && viewport.subViewports.length > 1) {\n    // Check worlds in repeated maps\n    traversalParams.offset = -1;\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n    traversalParams.offset = 1;\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n\n  return root.getSelected();\n}\n"]},"metadata":{},"sourceType":"module"}