{"ast":null,"code":"import { log, assertWebGLContext } from '@luma.gl/gltools';\nimport Texture from './texture';\nconst FACES = [34069, 34070, 34071, 34072, 34073, 34074];\nexport default class TextureCube extends Texture {\n  get [Symbol.toStringTag]() {\n    return 'TextureCube';\n  }\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assertWebGLContext(gl);\n    super(gl, Object.assign({}, props, {\n      target: 34067\n    }));\n    this.initialize(props);\n    Object.seal(this);\n  }\n  initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      mipmaps = true,\n      parameters = {}\n    } = props;\n    this.opts = props;\n    this.setCubeMapImageData(props).then(() => {\n      this.loaded = true;\n      if (mipmaps) {\n        this.generateMipmap(props);\n      }\n      this.setParameters(parameters);\n    });\n    return this;\n  }\n  subImage(_ref) {\n    let {\n      face,\n      data,\n      x = 0,\n      y = 0,\n      mipmapLevel = 0\n    } = _ref;\n    return this._subImage({\n      target: face,\n      data,\n      x,\n      y,\n      mipmapLevel\n    });\n  }\n  async setCubeMapImageData(_ref2) {\n    let {\n      width,\n      height,\n      pixels,\n      data,\n      border = 0,\n      format = 6408,\n      type = 5121\n    } = _ref2;\n    const {\n      gl\n    } = this;\n    const imageDataMap = pixels || data;\n    const resolvedFaces = await Promise.all(FACES.map(face => {\n      const facePixels = imageDataMap[face];\n      return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);\n    }));\n    this.bind();\n    FACES.forEach((face, index) => {\n      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {\n        log.warn(\"\".concat(this.id, \" has mipmap and multiple LODs.\"))();\n      }\n      resolvedFaces[index].forEach((image, lodLevel) => {\n        if (width && height) {\n          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);\n        } else {\n          gl.texImage2D(face, lodLevel, format, format, type, image);\n        }\n      });\n    });\n    this.unbind();\n  }\n  setImageDataForFace(options) {\n    const {\n      face,\n      width,\n      height,\n      pixels,\n      data,\n      border = 0,\n      format = 6408,\n      type = 5121\n    } = options;\n    const {\n      gl\n    } = this;\n    const imageData = pixels || data;\n    this.bind();\n    if (imageData instanceof Promise) {\n      imageData.then(resolvedImageData => this.setImageDataForFace(Object.assign({}, options, {\n        face,\n        data: resolvedImageData,\n        pixels: resolvedImageData\n      })));\n    } else if (this.width || this.height) {\n      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);\n    } else {\n      gl.texImage2D(face, 0, format, format, type, imageData);\n    }\n    return this;\n  }\n}\nTextureCube.FACES = FACES;","map":{"version":3,"sources":["../../../src/classes/texture-cube.js"],"names":["log","assertWebGLContext","Texture","FACES","TextureCube","Symbol","toStringTag","constructor","gl","props","assign","target","initialize","Object","seal","mipmaps","parameters","opts","setCubeMapImageData","then","loaded","generateMipmap","setParameters","subImage","face","data","x","y","mipmapLevel","_subImage","width","height","pixels","border","format","type","imageDataMap","resolvedFaces","all","map","facePixels","Promise","Array","isArray","bind","forEach","index","length","warn","id","image","lodLevel","texImage2D","unbind","setImageDataForFace","options","imageData","resolvedImageData"],"mappings":"AACA,SAAQA,GAAR,EAAaC,kBAAb,QAAsC,kBAAtC;AACA,OAAOC,OAAP,MAAoB,WAApB;AAEA,MAAMC,KAAK,GAAG,CAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,CAAd;AASA,eAAe,MAAMC,WAAN,SAA0BF,OAA1B,CAAkC;EAExB,KAAlBG,MAAM,CAACC,WAAW,IAAI;IACzB,OAAO,aAAP;EACD;EAEDC,WAAW,CAACC,EAAD,EAAiB;IAAA,IAAZC,KAAY,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;IAC1BR,kBAAkB,CAACO,EAAD,CAAlBP;IAEA,KAAA,CAAMO,EAAN,EAAU,MAAM,CAACE,MAAP,CAAc,CAAA,CAAd,EAAkBD,KAAlB,EAAyB;MAACE,MAAM,EAAA;IAAP,CAAzB,CAAV,CAAA;IAEA,IAAA,CAAKC,UAAL,CAAgBH,KAAhB,CAAA;IAEAI,MAAM,CAACC,IAAPD,CAAY,IAAZA,CAAAA;EACD;EAEDD,UAAU,GAAa;IAAA,IAAZH,KAAY,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;IACrB,MAAM;MAACM,OAAO,GAAG,IAAX;MAAiBC,UAAU,GAAG,CAAA;IAA9B,CAAA,GAAoCP,KAA1C;IAGA,IAAA,CAAKQ,IAAL,GAAYR,KAAZ;IAGA,IAAA,CAAKS,mBAAL,CAAyBT,KAAzB,CAAA,CAAgCU,IAAhC,CAAqC,MAAM;MACzC,IAAA,CAAKC,MAAL,GAAc,IAAd;MAIA,IAAIL,OAAJ,EAAa;QACX,IAAA,CAAKM,cAAL,CAAoBZ,KAApB,CAAA;MACD;MAED,IAAA,CAAKa,aAAL,CAAmBN,UAAnB,CAAA;IACD,CAVD,CAAA;IAWA,OAAO,IAAP;EACD;EAEDO,QAAQ,CAAA,IAAA,EAA8C;IAAA,IAA7C;MAACC,IAAD;MAAOC,IAAP;MAAaC,CAAC,GAAG,CAAjB;MAAoBC,CAAC,GAAG,CAAxB;MAA2BC,WAAW,GAAG;IAAzC,CAA6C,GAAA,IAAA;IAEpD,OAAO,IAAA,CAAKC,SAAL,CAAe;MAAClB,MAAM,EAAEa,IAAT;MAAeC,IAAf;MAAqBC,CAArB;MAAwBC,CAAxB;MAA2BC;IAA3B,CAAf,CAAP;EACD;EAGwB,MAAnBV,mBAAmB,CAAA,KAAA,EAQtB;IAAA,IARuB;MACxBY,KADwB;MAExBC,MAFwB;MAGxBC,MAHwB;MAIxBP,IAJwB;MAKxBQ,MAAM,GAAG,CALe;MAMxBC,MAAM,GAAA,IANkB;MAOxBC,IAAI,GAAA;IAPoB,CAQvB,GAAA,KAAA;IACD,MAAM;MAAC3B;IAAD,CAAA,GAAO,IAAb;IACA,MAAM4B,YAAY,GAAGJ,MAAM,IAAIP,IAA/B;IAeA,MAAMY,aAAa,GAAG,MAAM,OAAO,CAACC,GAAR,CAC1B,KAAK,CAACC,GAAN,CAAUf,IAAI,IAAI;MAChB,MAAMgB,UAAU,GAAGJ,YAAY,CAACZ,IAAD,CAA/B;MACA,OAAOiB,OAAO,CAACH,GAARG,CAAYC,KAAK,CAACC,OAAND,CAAcF,UAAdE,CAAAA,GAA4BF,UAA5BE,GAAyC,CAACF,UAAD,CAArDC,CAAP;IACD,CAHD,CAD0B,CAA5B;IAOA,IAAA,CAAKG,IAAL,EAAA;IAEAzC,KAAK,CAAC0C,OAAN1C,CAAc,CAACqB,IAAD,EAAOsB,KAAP,KAAiB;MAC7B,IAAIT,aAAa,CAACS,KAAD,CAAbT,CAAqBU,MAArBV,GAA8B,CAA9BA,IAAmC,IAAA,CAAKpB,IAAL,CAAUF,OAAV,KAAsB,KAA7D,EAAoE;QAGlEf,GAAG,CAACgD,IAAJhD,CAAAA,EAAAA,CAAAA,MAAAA,CAAY,IAAA,CAAKiD,EAAjBjD,EAAAA,gCAAAA,CAAAA,CAAAA,EAAAA;MACD;MACDqC,aAAa,CAACS,KAAD,CAAbT,CAAqBQ,OAArBR,CAA6B,CAACa,KAAD,EAAQC,QAAR,KAAqB;QAEhD,IAAIrB,KAAK,IAAIC,MAAb,EAAqB;UACnBvB,EAAE,CAAC4C,UAAH5C,CAAcgB,IAAdhB,EAAoB2C,QAApB3C,EAA8B0B,MAA9B1B,EAAsCsB,KAAtCtB,EAA6CuB,MAA7CvB,EAAqDyB,MAArDzB,EAA6D0B,MAA7D1B,EAAqE2B,IAArE3B,EAA2E0C,KAA3E1C,CAAAA;QACD,CAFD,MAEO;UACLA,EAAE,CAAC4C,UAAH5C,CAAcgB,IAAdhB,EAAoB2C,QAApB3C,EAA8B0B,MAA9B1B,EAAsC0B,MAAtC1B,EAA8C2B,IAA9C3B,EAAoD0C,KAApD1C,CAAAA;QACD;MACF,CAPD6B,CAAAA;IAQD,CAdDlC,CAAAA;IAgBA,IAAA,CAAKkD,MAAL,EAAA;EACD;EAGDC,mBAAmB,CAACC,OAAD,EAAU;IAC3B,MAAM;MACJ/B,IADI;MAEJM,KAFI;MAGJC,MAHI;MAIJC,MAJI;MAKJP,IALI;MAMJQ,MAAM,GAAG,CANL;MAOJC,MAAM,GAAA,IAPF;MAQJC,IAAI,GAAA;IARA,CAAA,GAUFoB,OAVJ;IAYA,MAAM;MAAC/C;IAAD,CAAA,GAAO,IAAb;IAEA,MAAMgD,SAAS,GAAGxB,MAAM,IAAIP,IAA5B;IAEA,IAAA,CAAKmB,IAAL,EAAA;IACA,IAAIY,SAAS,YAAYf,OAAzB,EAAkC;MAChCe,SAAS,CAACrC,IAAVqC,CAAeC,iBAAiB,IAC9B,IAAA,CAAKH,mBAAL,CACE,MAAM,CAAC5C,MAAP,CAAc,CAAA,CAAd,EAAkB6C,OAAlB,EAA2B;QACzB/B,IADyB;QAEzBC,IAAI,EAAEgC,iBAFmB;QAGzBzB,MAAM,EAAEyB;MAHiB,CAA3B,CADF,CADFD,CAAAA;IASD,CAVD,MAUO,IAAI,IAAA,CAAK1B,KAAL,IAAc,IAAA,CAAKC,MAAvB,EAA+B;MACpCvB,EAAE,CAAC4C,UAAH5C,CAAcgB,IAAdhB,EAAoB,CAApBA,EAAuB0B,MAAvB1B,EAA+BsB,KAA/BtB,EAAsCuB,MAAtCvB,EAA8CyB,MAA9CzB,EAAsD0B,MAAtD1B,EAA8D2B,IAA9D3B,EAAoEgD,SAApEhD,CAAAA;IACD,CAFM,MAEA;MACLA,EAAE,CAAC4C,UAAH5C,CAAcgB,IAAdhB,EAAoB,CAApBA,EAAuB0B,MAAvB1B,EAA+B0B,MAA/B1B,EAAuC2B,IAAvC3B,EAA6CgD,SAA7ChD,CAAAA;IACD;IAED,OAAO,IAAP;EACD;AApI8C;AAuIjDJ,WAAW,CAACD,KAAZC,GAAoBD,KAApBC","sourcesContent":["import GL from '@luma.gl/constants';\nimport {log, assertWebGLContext} from '@luma.gl/gltools';\nimport Texture from './texture';\n\nconst FACES = [\n  GL.TEXTURE_CUBE_MAP_POSITIVE_X,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_X,\n  GL.TEXTURE_CUBE_MAP_POSITIVE_Y,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n  GL.TEXTURE_CUBE_MAP_POSITIVE_Z,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_Z\n];\n\nexport default class TextureCube extends Texture {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'TextureCube';\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGLContext(gl);\n\n    super(gl, Object.assign({}, props, {target: GL.TEXTURE_CUBE_MAP}));\n\n    this.initialize(props);\n\n    Object.seal(this);\n  }\n\n  initialize(props = {}) {\n    const {mipmaps = true, parameters = {}} = props;\n\n    // Store props for accessors\n    this.opts = props;\n\n    // @ts-ignore\n    this.setCubeMapImageData(props).then(() => {\n      this.loaded = true;\n\n      // TODO - should genMipmap() be called on the cubemap or on the faces?\n      // TODO - without generateMipmap() cube textures do not work at all!!! Why?\n      if (mipmaps) {\n        this.generateMipmap(props);\n      }\n\n      this.setParameters(parameters);\n    });\n    return this;\n  }\n\n  subImage({face, data, x = 0, y = 0, mipmapLevel = 0}) {\n    // @ts-ignore TODO - is this a bug?\n    return this._subImage({target: face, data, x, y, mipmapLevel});\n  }\n\n  /* eslint-disable max-statements, max-len */\n  async setCubeMapImageData({\n    width,\n    height,\n    pixels,\n    data,\n    border = 0,\n    format = GL.RGBA,\n    type = GL.UNSIGNED_BYTE\n  }) {\n    const {gl} = this;\n    const imageDataMap = pixels || data;\n\n    // pixel data (imageDataMap) is an Object from Face to Image or Promise.\n    // For example:\n    // {\n    // GL.TEXTURE_CUBE_MAP_POSITIVE_X : Image-or-Promise,\n    // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : Image-or-Promise,\n    // ... }\n    // To provide multiple level-of-details (LODs) this can be Face to Array\n    // of Image or Promise, like this\n    // {\n    // GL.TEXTURE_CUBE_MAP_POSITIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n    // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n    // ... }\n\n    const resolvedFaces = await Promise.all(\n      FACES.map(face => {\n        const facePixels = imageDataMap[face];\n        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);\n      })\n    );\n\n    this.bind();\n\n    FACES.forEach((face, index) => {\n      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {\n        // If the user provides multiple LODs, then automatic mipmap\n        // generation generateMipmap() should be disabled to avoid overwritting them.\n        log.warn(`${this.id} has mipmap and multiple LODs.`)();\n      }\n      resolvedFaces[index].forEach((image, lodLevel) => {\n        // TODO: adjust width & height for LOD!\n        if (width && height) {\n          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);\n        } else {\n          gl.texImage2D(face, lodLevel, format, format, type, image);\n        }\n      });\n    });\n\n    this.unbind();\n  }\n\n  // TODO: update this method to accept LODs\n  setImageDataForFace(options) {\n    const {\n      face,\n      width,\n      height,\n      pixels,\n      data,\n      border = 0,\n      format = GL.RGBA,\n      type = GL.UNSIGNED_BYTE\n      // generateMipmap = false // TODO\n    } = options;\n\n    const {gl} = this;\n\n    const imageData = pixels || data;\n\n    this.bind();\n    if (imageData instanceof Promise) {\n      imageData.then(resolvedImageData =>\n        this.setImageDataForFace(\n          Object.assign({}, options, {\n            face,\n            data: resolvedImageData,\n            pixels: resolvedImageData\n          })\n        )\n      );\n    } else if (this.width || this.height) {\n      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);\n    } else {\n      gl.texImage2D(face, 0, format, format, type, imageData);\n    }\n\n    return this;\n  }\n}\n\nTextureCube.FACES = FACES;\n"]},"metadata":{},"sourceType":"module"}