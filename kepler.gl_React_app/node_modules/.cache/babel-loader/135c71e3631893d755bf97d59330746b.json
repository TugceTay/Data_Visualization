{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { Buffer, Transform } from '@luma.gl/core';\nimport Attribute from '../lib/attribute/attribute';\nimport { padBuffer, getAttributeTypeFromSize, getSourceBufferAttribute, getAttributeBufferLength, cycleBuffers } from '../lib/attribute/attribute-transition-utils';\nimport Transition from './transition';\nvar GPUInterpolationTransition = function () {\n  function GPUInterpolationTransition(_ref) {\n    var gl = _ref.gl,\n      attribute = _ref.attribute,\n      timeline = _ref.timeline;\n    _classCallCheck(this, GPUInterpolationTransition);\n    this.gl = gl;\n    this.type = 'interpolation';\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    this.attributeInTransition = new Attribute(gl, attribute.settings);\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = 0;\n    this.transform = getTransform(gl, attribute);\n    var bufferOpts = {\n      byteLength: 0,\n      usage: 35050\n    };\n    this.buffers = [new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts)];\n  }\n  _createClass(GPUInterpolationTransition, [{\n    key: \"start\",\n    value: function start(transitionSettings, numInstances) {\n      if (transitionSettings.duration <= 0) {\n        this.transition.cancel();\n        return;\n      }\n      var gl = this.gl,\n        buffers = this.buffers,\n        attribute = this.attribute;\n      cycleBuffers(buffers);\n      var padBufferOpts = {\n        numInstances: numInstances,\n        attribute: attribute,\n        fromLength: this.currentLength,\n        fromStartIndices: this.currentStartIndices,\n        getData: transitionSettings.enter\n      };\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = buffers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var buffer = _step.value;\n          padBuffer(_objectSpread({\n            buffer: buffer\n          }, padBufferOpts));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      this.currentStartIndices = attribute.startIndices;\n      this.currentLength = getAttributeBufferLength(attribute, numInstances);\n      this.attributeInTransition.update({\n        buffer: buffers[1],\n        value: attribute.value\n      });\n      this.transition.start(transitionSettings);\n      this.transform.update({\n        elementCount: Math.floor(this.currentLength / attribute.size),\n        sourceBuffers: {\n          aFrom: buffers[0],\n          aTo: getSourceBufferAttribute(gl, attribute)\n        },\n        feedbackBuffers: {\n          vCurrent: buffers[1]\n        }\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var updated = this.transition.update();\n      if (updated) {\n        var _this$transition = this.transition,\n          time = _this$transition.time,\n          _this$transition$sett = _this$transition.settings,\n          duration = _this$transition$sett.duration,\n          easing = _this$transition$sett.easing;\n        var t = easing(time / duration);\n        this.transform.run({\n          uniforms: {\n            time: t\n          }\n        });\n      }\n      return updated;\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.transition.cancel();\n      this.transform[\"delete\"]();\n      while (this.buffers.length) {\n        this.buffers.pop()[\"delete\"]();\n      }\n    }\n  }, {\n    key: \"inProgress\",\n    get: function get() {\n      return this.transition.inProgress;\n    }\n  }]);\n  return GPUInterpolationTransition;\n}();\nexport { GPUInterpolationTransition as default };\nvar vs = \"\\n#define SHADER_NAME interpolation-transition-vertex-shader\\n\\nuniform float time;\\nattribute ATTRIBUTE_TYPE aFrom;\\nattribute ATTRIBUTE_TYPE aTo;\\nvarying ATTRIBUTE_TYPE vCurrent;\\n\\nvoid main(void) {\\n  vCurrent = mix(aFrom, aTo, time);\\n  gl_Position = vec4(0.0);\\n}\\n\";\nfunction getTransform(gl, attribute) {\n  var attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    vs: vs,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent']\n  });\n}","map":{"version":3,"sources":["../../../src/transitions/gpu-interpolation-transition.js"],"names":["Buffer","Transform","Attribute","padBuffer","getAttributeTypeFromSize","getSourceBufferAttribute","getAttributeBufferLength","cycleBuffers","Transition","GPUInterpolationTransition","gl","attribute","timeline","type","transition","attributeInTransition","settings","currentStartIndices","startIndices","currentLength","transform","getTransform","bufferOpts","byteLength","usage","buffers","inProgress","transitionSettings","numInstances","duration","cancel","padBufferOpts","fromLength","fromStartIndices","getData","enter","buffer","update","value","start","elementCount","Math","floor","size","sourceBuffers","aFrom","aTo","feedbackBuffers","vCurrent","updated","time","easing","t","run","uniforms","length","pop","vs","attributeType","defines","ATTRIBUTE_TYPE","varyings"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer, Transform} from '@luma.gl/core';\nimport Attribute from '../lib/attribute/attribute';\nimport {\n  padBuffer,\n  getAttributeTypeFromSize,\n  getSourceBufferAttribute,\n  getAttributeBufferLength,\n  cycleBuffers\n} from '../lib/attribute/attribute-transition-utils';\nimport Transition from './transition';\n\nexport default class GPUInterpolationTransition {\n  constructor({gl, attribute, timeline}) {\n    this.gl = gl;\n    this.type = 'interpolation';\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    // this is the attribute we return during the transition - note: if it is a constant\n    // attribute, it will be converted and returned as a regular attribute\n    // `attribute.userData` is the original options passed when constructing the attribute.\n    // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n    this.attributeInTransition = new Attribute(gl, attribute.settings);\n    this.currentStartIndices = attribute.startIndices;\n    // storing currentLength because this.buffer may be larger than the actual length we want to use\n    // this is because we only reallocate buffers when they grow, not when they shrink,\n    // due to performance costs\n    this.currentLength = 0;\n    this.transform = getTransform(gl, attribute);\n    const bufferOpts = {\n      byteLength: 0,\n      usage: GL.DYNAMIC_COPY\n    };\n    this.buffers = [\n      new Buffer(gl, bufferOpts), // from\n      new Buffer(gl, bufferOpts) // current\n    ];\n  }\n\n  get inProgress() {\n    return this.transition.inProgress;\n  }\n\n  // this is called when an attribute's values have changed and\n  // we need to start animating towards the new values\n  // this also correctly resizes / pads the transform's buffers\n  // in case the attribute's buffer has changed in length or in\n  // startIndices\n  start(transitionSettings, numInstances) {\n    if (transitionSettings.duration <= 0) {\n      this.transition.cancel();\n      return;\n    }\n\n    const {gl, buffers, attribute} = this;\n    // Alternate between two buffers when new transitions start.\n    // Last destination buffer is used as an attribute (from state),\n    // And the other buffer is now the current buffer.\n    cycleBuffers(buffers);\n\n    const padBufferOpts = {\n      numInstances,\n      attribute,\n      fromLength: this.currentLength,\n      fromStartIndices: this.currentStartIndices,\n      getData: transitionSettings.enter\n    };\n\n    for (const buffer of buffers) {\n      padBuffer({buffer, ...padBufferOpts});\n    }\n\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = getAttributeBufferLength(attribute, numInstances);\n    this.attributeInTransition.update({\n      buffer: buffers[1],\n      // Hack: Float64Array is required for double-precision attributes\n      // to generate correct shader attributes\n      value: attribute.value\n    });\n\n    this.transition.start(transitionSettings);\n\n    this.transform.update({\n      elementCount: Math.floor(this.currentLength / attribute.size),\n      sourceBuffers: {\n        aFrom: buffers[0],\n        aTo: getSourceBufferAttribute(gl, attribute)\n      },\n      feedbackBuffers: {\n        vCurrent: buffers[1]\n      }\n    });\n  }\n\n  update() {\n    const updated = this.transition.update();\n    if (updated) {\n      const {\n        time,\n        settings: {duration, easing}\n      } = this.transition;\n      const t = easing(time / duration);\n      this.transform.run({\n        uniforms: {time: t}\n      });\n    }\n    return updated;\n  }\n\n  cancel() {\n    this.transition.cancel();\n    this.transform.delete();\n    while (this.buffers.length) {\n      this.buffers.pop().delete();\n    }\n  }\n}\n\nconst vs = `\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n`;\n\nfunction getTransform(gl, attribute) {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    vs,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent']\n  });\n}\n"]},"metadata":{},"sourceType":"module"}