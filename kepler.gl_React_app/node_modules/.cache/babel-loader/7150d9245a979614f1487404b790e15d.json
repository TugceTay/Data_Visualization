{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Vector3, Matrix4, assert, equals, _MathUtils } from '@math.gl/core';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z } from '../constants';\nimport { fromCartographicToRadians, toCartographicFromRadians } from '../type-utils';\nimport scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';\nimport localFrameToFixedFrame from './helpers/ellipsoid-transform';\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\nlet wgs84;\nexport default class Ellipsoid {\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n    let z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0;\n    _defineProperty(this, \"radii\", void 0);\n    _defineProperty(this, \"radiiSquared\", void 0);\n    _defineProperty(this, \"radiiToTheFourth\", void 0);\n    _defineProperty(this, \"oneOverRadii\", void 0);\n    _defineProperty(this, \"oneOverRadiiSquared\", void 0);\n    _defineProperty(this, \"minimumRadius\", void 0);\n    _defineProperty(this, \"maximumRadius\", void 0);\n    _defineProperty(this, \"centerToleranceSquared\", _MathUtils.EPSILON1);\n    _defineProperty(this, \"squaredXOverSquaredZ\", void 0);\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n    this.radii = new Vector3(x, y, z);\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n    this.oneOverRadii = new Vector3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);\n    this.oneOverRadiiSquared = new Vector3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));\n    this.minimumRadius = Math.min(x, y, z);\n    this.maximumRadius = Math.max(x, y, z);\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n    Object.freeze(this);\n  }\n  equals(right) {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n  toString() {\n    return this.radii.toString();\n  }\n  cartographicToCartesian(cartographic) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    const normal = scratchNormal;\n    const k = scratchK;\n    const [,, height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n    normal.scale(height);\n    k.add(normal);\n    return k.to(result);\n  }\n  cartesianToCartographic(cartesian) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n    if (!point) {\n      return undefined;\n    }\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n  eastNorthUpToFixedFrame(origin) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Matrix4();\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin) {\n    let result = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Matrix4();\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n  geocentricSurfaceNormal(cartesian) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    return scratchVector.from(cartesian).normalize().to(result);\n  }\n  geodeticSurfaceNormalCartographic(cartographic) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n    const cosLatitude = Math.cos(latitude);\n    scratchVector.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();\n    return scratchVector.to(result);\n  }\n  geodeticSurfaceNormal(cartesian) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n  }\n  scaleToGeodeticSurface(cartesian, result) {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n  scaleToGeocentricSurface(cartesian) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    scratchPosition.from(cartesian);\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n    const beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n  transformPositionToScaledSpace(position) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n  }\n  transformPositionFromScaledSpace(position) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    return scratchPosition.from(position).scale(this.radii).to(result);\n  }\n  getSurfaceNormalIntersectionWithZAxis(position) {\n    let buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 0];\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n_defineProperty(Ellipsoid, \"WGS84\", new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z));","map":{"version":3,"sources":["../../../src/ellipsoid/ellipsoid.ts"],"names":["Vector3","Matrix4","assert","equals","_MathUtils","vec3","WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z","fromCartographicToRadians","toCartographicFromRadians","scaleToGeodeticSurface","localFrameToFixedFrame","scratchVector","scratchNormal","scratchK","scratchPosition","scratchHeight","scratchCartesian","wgs84","Ellipsoid","EPSILON1","constructor","x","y","z","radii","radiiSquared","radiiToTheFourth","oneOverRadii","oneOverRadiiSquared","minimumRadius","Math","min","maximumRadius","max","squaredXOverSquaredZ","Object","freeze","right","Boolean","toString","cartographicToCartesian","cartographic","result","normal","k","height","geodeticSurfaceNormalCartographic","copy","scale","gamma","sqrt","dot","add","to","cartesianToCartographic","cartesian","from","point","undefined","geodeticSurfaceNormal","h","subtract","longitude","atan2","latitude","asin","sign","length","eastNorthUpToFixedFrame","origin","firstAxis","secondAxis","thirdAxis","geocentricSurfaceNormal","normalize","cartographicVectorRadians","cosLatitude","cos","set","sin","scaleToGeocentricSurface","positionX","positionY","positionZ","beta","multiplyScalar","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","abs"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {\n  Vector3,\n  Matrix4,\n  toRadians,\n  toDegrees,\n  assert,\n  equals,\n  _MathUtils,\n  NumericArray\n} from '@math.gl/core';\nimport * as vec3 from 'gl-matrix/vec3';\n\nimport {WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z} from '../constants';\nimport {fromCartographicToRadians, toCartographicFromRadians} from '../type-utils';\n\nimport scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';\nimport localFrameToFixedFrame from './helpers/ellipsoid-transform';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n\nlet wgs84;\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * `(x / a)^2 + (y / b)^2 + (z / c)^2 = 1`.  Primarily used\n * to represent the shape of planetary bodies.\n */\nexport default class Ellipsoid {\n  /** An Ellipsoid instance initialized to the WGS84 standard. */\n  static readonly WGS84: Ellipsoid = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n\n  readonly radii: Vector3;\n  readonly radiiSquared: Vector3;\n  readonly radiiToTheFourth: Vector3;\n  readonly oneOverRadii: Vector3;\n  readonly oneOverRadiiSquared: Vector3;\n  readonly minimumRadius: number;\n  readonly maximumRadius: number;\n  readonly centerToleranceSquared: number = _MathUtils.EPSILON1;\n  readonly squaredXOverSquaredZ: number;\n\n  /** Creates an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions. */\n  constructor(x: number, y: number, z: number);\n  constructor();\n\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n\n    this.radii = new Vector3(x, y, z);\n\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n\n    this.oneOverRadii = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / x,\n      y === 0.0 ? 0.0 : 1.0 / y,\n      z === 0.0 ? 0.0 : 1.0 / z\n    );\n\n    this.oneOverRadiiSquared = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / (x * x),\n      y === 0.0 ? 0.0 : 1.0 / (y * y),\n      z === 0.0 ? 0.0 : 1.0 / (z * z)\n    );\n\n    this.minimumRadius = Math.min(x, y, z);\n\n    this.maximumRadius = Math.max(x, y, z);\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */\n  equals(right: Ellipsoid): boolean {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n\n  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */\n  toString(): string {\n    return this.radii.toString();\n  }\n\n  /** Converts the provided cartographic to Cartesian representation. */\n  cartographicToCartesian(cartographic: number[], result: Vector3): Vector3;\n  cartographicToCartesian(cartographic: number[], result?: number[]): number[];\n\n  cartographicToCartesian(cartographic, result = [0, 0, 0]) {\n    const normal = scratchNormal;\n    const k = scratchK;\n\n    const [, , height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n\n    normal.scale(height);\n\n    k.add(normal);\n\n    return k.to(result);\n  }\n\n  /** Converts the provided cartesian to cartographic (lng/lat/z) representation.\n   * The cartesian is undefined at the center of the ellipsoid. */\n  cartesianToCartographic(cartesian: number[], result: Vector3): Vector3;\n  cartesianToCartographic(cartesian: number[], result?: number[]): number[];\n\n  cartesianToCartographic(cartesian, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n\n    if (!point) {\n      return undefined;\n    }\n\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame. */\n  eastNorthUpToFixedFrame(origin: number[], result?: Matrix4): Matrix4;\n  eastNorthUpToFixedFrame(origin: number[], result: number[]): number[];\n\n  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame centered at\n   * the provided origin to the ellipsoid's fixed reference frame.\n   */\n  localFrameToFixedFrame(\n    firstAxis: string,\n    secondAxis: string,\n    thirdAxis: string,\n    origin: Readonly<NumericArray>,\n    result?: Matrix4\n  ): Matrix4;\n  localFrameToFixedFrame<Matrix4T>(\n    firstAxis: string,\n    secondAxis: string,\n    thirdAxis: string,\n    origin: Readonly<NumericArray>,\n    result: number[]\n  ): number[];\n\n  // Computes a 4x4 transformation matrix from a reference frame centered at\n  // the provided origin to the ellipsoid's fixed reference frame.\n  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n\n  /** Computes the unit vector directed from the center of this ellipsoid toward\n   * the provided Cartesian position. */\n  geocentricSurfaceNormal(cartesian: number[], result?: number[]): number[];\n  geocentricSurfaceNormal<NumArray>(cartesian: number[], result: NumArray): NumArray;\n  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).normalize().to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at provided position. */\n  geodeticSurfaceNormalCartographic<NumArray>(cartographic: number[], result: NumArray): NumArray;\n  geodeticSurfaceNormalCartographic(cartographic: number[]): number[];\n  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n\n    const cosLatitude = Math.cos(latitude);\n\n    scratchVector\n      .set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude))\n      .normalize();\n\n    return scratchVector.to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position. */\n  geodeticSurfaceNormal<NumArrayT>(cartesian: number[], result: NumArrayT): NumArrayT;\n  geodeticSurfaceNormal(cartesian: number[]): number[];\n  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n  }\n\n  /** Scales the provided Cartesian position along the geodetic surface normal\n   * so that it is on the surface of this ellipsoid.  If the position is\n   * at the center of the ellipsoid, this function returns undefined. */\n  scaleToGeodeticSurface(cartesian: number[], result?: number[]): number[] {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n\n  /** Scales the provided Cartesian position along the geocentric surface normal\n   * so that it is on the surface of this ellipsoid. */\n  scaleToGeocentricSurface(cartesian: number[], result: number[] = [0, 0, 0]): number[] {\n    scratchPosition.from(cartesian);\n\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n\n    const beta =\n      1.0 /\n      Math.sqrt(\n        positionX * positionX * oneOverRadiiSquared.x +\n          positionY * positionY * oneOverRadiiSquared.y +\n          positionZ * positionZ * oneOverRadiiSquared.z\n      );\n\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#oneOverRadii` */\n  transformPositionToScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#radii`. */\n  transformPositionFromScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.radii).to(result);\n  }\n\n  /** Computes a point which is the intersection of the surface normal with the z-axis. */\n  getSurfaceNormalIntersectionWithZAxis(\n    position: number[],\n    buffer: number = 0,\n    result: number[] = [0, 0, 0]\n  ): number[] {\n    // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}