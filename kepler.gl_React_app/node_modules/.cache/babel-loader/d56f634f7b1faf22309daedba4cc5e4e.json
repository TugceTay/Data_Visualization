{"ast":null,"code":"import typedArrayManager from './typed-array-manager';\nimport { Vector3 } from 'math.gl';\nexport function createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nexport function mod(value, divisor) {\n  var modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nexport function extractCameraVectors(_ref) {\n  var viewMatrix = _ref.viewMatrix,\n    viewMatrixInverse = _ref.viewMatrixInverse;\n  return {\n    eye: [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]],\n    direction: [-viewMatrix[2], -viewMatrix[6], -viewMatrix[10]],\n    up: [viewMatrix[1], viewMatrix[5], viewMatrix[9]],\n    right: [viewMatrix[0], viewMatrix[4], viewMatrix[8]]\n  };\n}\nvar cameraPosition = new Vector3();\nvar cameraDirection = new Vector3();\nvar cameraUp = new Vector3();\nvar cameraRight = new Vector3();\nvar nearCenter = new Vector3();\nvar farCenter = new Vector3();\nvar a = new Vector3();\nexport function getFrustumPlanes(_ref2) {\n  var aspect = _ref2.aspect,\n    near = _ref2.near,\n    far = _ref2.far,\n    fovyRadians = _ref2.fovyRadians,\n    position = _ref2.position,\n    direction = _ref2.direction,\n    up = _ref2.up,\n    right = _ref2.right;\n  cameraDirection.copy(direction);\n  var nearFarScale = 1 / cameraDirection.len();\n  cameraDirection.normalize();\n  cameraPosition.copy(position);\n  cameraUp.copy(up);\n  var widthScale = 1 / cameraUp.len();\n  cameraUp.normalize();\n  cameraRight.copy(right).normalize();\n  var nearHeight = 2 * Math.tan(fovyRadians / 2) * near * widthScale;\n  var nearWidth = nearHeight * aspect;\n  nearCenter.copy(cameraDirection).scale(near * nearFarScale).add(cameraPosition);\n  farCenter.copy(cameraDirection).scale(far * nearFarScale).add(cameraPosition);\n  var normal = cameraDirection.clone().negate();\n  var distance = normal.dot(nearCenter);\n  var planes = {\n    near: {\n      distance: distance,\n      normal: normal\n    },\n    far: {\n      distance: cameraDirection.dot(farCenter),\n      normal: cameraDirection.clone()\n    }\n  };\n  a.copy(cameraRight).scale(nearWidth * 0.5).add(nearCenter).subtract(cameraPosition).normalize();\n  normal = new Vector3(a).cross(cameraUp);\n  distance = cameraPosition.dot(normal);\n  planes.right = {\n    normal: normal,\n    distance: distance\n  };\n  a.copy(cameraRight).scale(-nearWidth * 0.5).add(nearCenter).subtract(cameraPosition).normalize();\n  normal = new Vector3(cameraUp).cross(a);\n  distance = cameraPosition.dot(normal);\n  planes.left = {\n    normal: normal,\n    distance: distance\n  };\n  a.copy(cameraUp).scale(nearHeight * 0.5).add(nearCenter).subtract(cameraPosition).normalize();\n  normal = new Vector3(cameraRight).cross(a);\n  distance = cameraPosition.dot(normal);\n  planes.top = {\n    normal: normal,\n    distance: distance\n  };\n  a.copy(cameraUp).scale(-nearHeight * 0.5).add(nearCenter).subtract(cameraPosition).normalize();\n  normal = new Vector3(a).cross(cameraRight);\n  distance = cameraPosition.dot(normal);\n  planes.bottom = {\n    normal: normal,\n    distance: distance\n  };\n  return planes;\n}\nexport function fp64LowPart(x) {\n  return x - Math.fround(x);\n}\nvar scratchArray;\nexport function toDoublePrecisionArray(typedArray, _ref3) {\n  var _ref3$size = _ref3.size,\n    size = _ref3$size === void 0 ? 1 : _ref3$size,\n    _ref3$startIndex = _ref3.startIndex,\n    startIndex = _ref3$startIndex === void 0 ? 0 : _ref3$startIndex,\n    endIndex = _ref3.endIndex;\n  if (!Number.isFinite(endIndex)) {\n    endIndex = typedArray.length;\n  }\n  var count = (endIndex - startIndex) / size;\n  scratchArray = typedArrayManager.allocate(scratchArray, count, {\n    type: Float32Array,\n    size: size * 2\n  });\n  var sourceIndex = startIndex;\n  var targetIndex = 0;\n  while (sourceIndex < endIndex) {\n    for (var j = 0; j < size; j++) {\n      var value = typedArray[sourceIndex++];\n      scratchArray[targetIndex + j] = value;\n      scratchArray[targetIndex + j + size] = fp64LowPart(value);\n    }\n    targetIndex += size * 2;\n  }\n  return scratchArray.subarray(0, count * size * 2);\n}","map":{"version":3,"sources":["../../../src/utils/math-utils.js"],"names":["typedArrayManager","Vector3","createMat4","mod","value","divisor","modulus","extractCameraVectors","viewMatrix","viewMatrixInverse","eye","direction","up","right","cameraPosition","cameraDirection","cameraUp","cameraRight","nearCenter","farCenter","a","getFrustumPlanes","aspect","near","far","fovyRadians","position","copy","nearFarScale","len","normalize","widthScale","nearHeight","Math","tan","nearWidth","scale","add","normal","clone","negate","distance","dot","planes","subtract","cross","left","top","bottom","fp64LowPart","x","fround","scratchArray","toDoublePrecisionArray","typedArray","size","startIndex","endIndex","Number","isFinite","length","count","allocate","type","Float32Array","sourceIndex","targetIndex","j","subarray"],"mappings":"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","sourcesContent":["// Extensions to math.gl library. Intended to be folded back.\nimport typedArrayManager from './typed-array-manager';\nimport {Vector3} from 'math.gl';\n\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nexport function createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\nexport function mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\n\n// Extract camera vectors (move to math library?)\nexport function extractCameraVectors({viewMatrix, viewMatrixInverse}) {\n  // Read the translation from the inverse view matrix\n  return {\n    eye: [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]],\n    direction: [-viewMatrix[2], -viewMatrix[6], -viewMatrix[10]],\n    up: [viewMatrix[1], viewMatrix[5], viewMatrix[9]],\n    right: [viewMatrix[0], viewMatrix[4], viewMatrix[8]]\n  };\n}\n\nconst cameraPosition = new Vector3();\nconst cameraDirection = new Vector3();\nconst cameraUp = new Vector3();\nconst cameraRight = new Vector3();\nconst nearCenter = new Vector3();\nconst farCenter = new Vector3();\nconst a = new Vector3();\n\n/* eslint-disable max-statements */\n\n// Extract frustum planes in common space.\n// Note that common space is left-handed\n// (with y pointing down)\nexport function getFrustumPlanes({aspect, near, far, fovyRadians, position, direction, up, right}) {\n  cameraDirection.copy(direction);\n\n  // Account for any scaling of the z axis (e.g. in\n  // mercator view matrix)\n  const nearFarScale = 1 / cameraDirection.len();\n  cameraDirection.normalize();\n\n  cameraPosition.copy(position);\n\n  cameraUp.copy(up);\n  // Account for scaling of the xy axis\n  const widthScale = 1 / cameraUp.len();\n  cameraUp.normalize();\n  cameraRight.copy(right).normalize();\n\n  const nearHeight = 2 * Math.tan(fovyRadians / 2) * near * widthScale;\n  const nearWidth = nearHeight * aspect;\n\n  nearCenter\n    .copy(cameraDirection)\n    .scale(near * nearFarScale)\n    .add(cameraPosition);\n  farCenter\n    .copy(cameraDirection)\n    .scale(far * nearFarScale)\n    .add(cameraPosition);\n\n  let normal = cameraDirection.clone().negate();\n  let distance = normal.dot(nearCenter);\n\n  const planes = {\n    near: {\n      distance,\n      normal\n    },\n    far: {\n      distance: cameraDirection.dot(farCenter),\n      normal: cameraDirection.clone()\n    }\n  };\n\n  a.copy(cameraRight)\n    .scale(nearWidth * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(a).cross(cameraUp);\n  distance = cameraPosition.dot(normal);\n  planes.right = {normal, distance};\n\n  a.copy(cameraRight)\n    .scale(-nearWidth * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(cameraUp).cross(a);\n  distance = cameraPosition.dot(normal);\n  planes.left = {normal, distance};\n\n  a.copy(cameraUp)\n    .scale(nearHeight * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(cameraRight).cross(a);\n  distance = cameraPosition.dot(normal);\n  planes.top = {normal, distance};\n\n  a.copy(cameraUp)\n    .scale(-nearHeight * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(a).cross(cameraRight);\n  distance = cameraPosition.dot(normal);\n  planes.bottom = {normal, distance};\n\n  return planes;\n}\n\n/**\n * Calculate the low part of a WebGL 64 bit float\n * @param x {number} - the input float number\n * @returns {number} - the lower 32 bit of the number\n */\nexport function fp64LowPart(x) {\n  return x - Math.fround(x);\n}\n\nlet scratchArray;\n\n/**\n * Split a Float64Array into a double-length Float32Array\n * @param typedArray {Float64Array}\n * @param size {Number} - per attribute size\n * @param [startIndex] {Number} - start index in the source array\n * @param [endIndex] {Number} - end index in the source array\n * @returns {Float32Array} - high part, low part for each attribute:\n    [1xHi, 1yHi, 1zHi, 1xLow, 1yLow, 1zLow, 2xHi, ...]\n */\nexport function toDoublePrecisionArray(typedArray, {size = 1, startIndex = 0, endIndex}) {\n  if (!Number.isFinite(endIndex)) {\n    endIndex = typedArray.length;\n  }\n  const count = (endIndex - startIndex) / size;\n  scratchArray = typedArrayManager.allocate(scratchArray, count, {\n    type: Float32Array,\n    size: size * 2\n  });\n\n  let sourceIndex = startIndex;\n  let targetIndex = 0;\n  while (sourceIndex < endIndex) {\n    for (let j = 0; j < size; j++) {\n      const value = typedArray[sourceIndex++];\n      scratchArray[targetIndex + j] = value;\n      scratchArray[targetIndex + j + size] = fp64LowPart(value);\n    }\n    targetIndex += size * 2;\n  }\n\n  return scratchArray.subarray(0, count * size * 2);\n}\n"]},"metadata":{},"sourceType":"module"}