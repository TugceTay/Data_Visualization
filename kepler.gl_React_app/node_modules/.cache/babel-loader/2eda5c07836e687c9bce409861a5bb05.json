{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Pass from './pass';\nimport { clear, setParameters, withParameters, cssToDeviceRatio } from '@luma.gl/core';\nimport log from '../utils/log';\nvar LayersPass = function (_Pass) {\n  _inherits(LayersPass, _Pass);\n  function LayersPass() {\n    _classCallCheck(this, LayersPass);\n    return _possibleConstructorReturn(this, _getPrototypeOf(LayersPass).apply(this, arguments));\n  }\n  _createClass(LayersPass, [{\n    key: \"render\",\n    value: function render(props) {\n      var gl = this.gl;\n      setParameters(gl, {\n        framebuffer: props.target\n      });\n      return this._drawLayers(props);\n    }\n  }, {\n    key: \"_drawLayers\",\n    value: function _drawLayers(props) {\n      var viewports = props.viewports,\n        views = props.views,\n        onViewportActive = props.onViewportActive,\n        _props$clearCanvas = props.clearCanvas,\n        clearCanvas = _props$clearCanvas === void 0 ? true : _props$clearCanvas;\n      var gl = this.gl;\n      if (clearCanvas) {\n        clearGLCanvas(gl);\n      }\n      var renderStats = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = viewports[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var viewportOrDescriptor = _step.value;\n          var viewport = viewportOrDescriptor.viewport || viewportOrDescriptor;\n          var view = views && views[viewport.id];\n          onViewportActive(viewport);\n          props.view = view;\n          var subViewports = viewport.subViewports || [viewport];\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n          try {\n            for (var _iterator2 = subViewports[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var subViewport = _step2.value;\n              props.viewport = subViewport;\n              var stats = this._drawLayersInViewport(gl, props);\n              renderStats.push(stats);\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                _iterator2[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return renderStats;\n    }\n  }, {\n    key: \"_drawLayersInViewport\",\n    value: function _drawLayersInViewport(gl, _ref) {\n      var layers = _ref.layers,\n        layerFilter = _ref.layerFilter,\n        onError = _ref.onError,\n        viewport = _ref.viewport,\n        view = _ref.view,\n        _ref$pass = _ref.pass,\n        pass = _ref$pass === void 0 ? 'unknown' : _ref$pass,\n        effects = _ref.effects,\n        moduleParameters = _ref.moduleParameters;\n      var glViewport = getGLViewport(gl, {\n        viewport: viewport\n      });\n      if (view && view.props.clear) {\n        var clearOpts = view.props.clear === true ? {\n          color: true,\n          depth: true\n        } : view.props.clear;\n        withParameters(gl, {\n          scissorTest: true,\n          scissor: glViewport\n        }, function () {\n          return clear(gl, clearOpts);\n        });\n      }\n      var renderStatus = {\n        totalCount: layers.length,\n        visibleCount: 0,\n        compositeCount: 0,\n        pickableCount: 0\n      };\n      setParameters(gl, {\n        viewport: glViewport\n      });\n      var indexResolver = layerIndexResolver();\n      for (var layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n        var layer = layers[layerIndex];\n        var shouldDrawLayer = this._shouldDrawLayer(layer, viewport, pass, layerFilter);\n        var layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n        if (shouldDrawLayer && layer.props.pickable) {\n          renderStatus.pickableCount++;\n        }\n        if (layer.isComposite) {\n          renderStatus.compositeCount++;\n        } else if (shouldDrawLayer) {\n          renderStatus.visibleCount++;\n          var _moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);\n          var layerParameters = this.getLayerParameters(layer, layerIndex);\n          _moduleParameters.viewport = viewport;\n          try {\n            layer.drawLayer({\n              moduleParameters: _moduleParameters,\n              uniforms: {\n                layerIndex: layerRenderIndex\n              },\n              parameters: layerParameters\n            });\n          } catch (err) {\n            if (onError) {\n              onError(err, layer);\n            } else {\n              log.error(\"error during drawing of \".concat(layer), err)();\n            }\n          }\n        }\n      }\n      return renderStatus;\n    }\n  }, {\n    key: \"shouldDrawLayer\",\n    value: function shouldDrawLayer(layer) {\n      return true;\n    }\n  }, {\n    key: \"getModuleParameters\",\n    value: function getModuleParameters(layer, effects) {\n      return null;\n    }\n  }, {\n    key: \"getLayerParameters\",\n    value: function getLayerParameters(layer, layerIndex) {\n      return layer.props.parameters;\n    }\n  }, {\n    key: \"_shouldDrawLayer\",\n    value: function _shouldDrawLayer(layer, viewport, pass, layerFilter) {\n      var shouldDrawLayer = this.shouldDrawLayer(layer) && layer.props.visible;\n      if (shouldDrawLayer && layerFilter) {\n        shouldDrawLayer = layerFilter({\n          layer: layer,\n          viewport: viewport,\n          isPicking: pass.startsWith('picking'),\n          renderPass: pass\n        });\n      }\n      if (shouldDrawLayer) {\n        layer.activateViewport(viewport);\n      }\n      return shouldDrawLayer;\n    }\n  }, {\n    key: \"_getModuleParameters\",\n    value: function _getModuleParameters(layer, effects, pass, overrides) {\n      var moduleParameters = Object.assign(Object.create(layer.props), {\n        autoWrapLongitude: layer.wrapLongitude,\n        viewport: layer.context.viewport,\n        mousePosition: layer.context.mousePosition,\n        pickingActive: 0,\n        devicePixelRatio: cssToDeviceRatio(this.gl)\n      });\n      if (effects) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n        try {\n          for (var _iterator3 = effects[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var effect = _step3.value;\n            Object.assign(moduleParameters, effect.getModuleParameters(layer));\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n      return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);\n    }\n  }]);\n  return LayersPass;\n}(Pass);\nexport { LayersPass as default };\nexport function layerIndexResolver() {\n  var startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var layerIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var resolvers = {};\n  return function (layer, isDrawn) {\n    var indexOverride = layer.props._offset;\n    var layerId = layer.id;\n    var parentId = layer.parent && layer.parent.id;\n    var index;\n    if (parentId in resolvers) {\n      var resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n    layerIndices[layerId] = index;\n    return index;\n  };\n}\nfunction getGLViewport(gl, _ref2) {\n  var viewport = _ref2.viewport;\n  var height = gl.canvas ? gl.canvas.clientHeight || gl.canvas.height : 100;\n  var dimensions = viewport;\n  var pixelRatio = cssToDeviceRatio(gl);\n  return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];\n}\nfunction clearGLCanvas(gl) {\n  var width = gl.drawingBufferWidth;\n  var height = gl.drawingBufferHeight;\n  setParameters(gl, {\n    viewport: [0, 0, width, height]\n  });\n  gl.clear(16384 | 256);\n}","map":{"version":3,"sources":["../../../src/passes/layers-pass.js"],"names":["Pass","clear","setParameters","withParameters","cssToDeviceRatio","log","LayersPass","props","gl","framebuffer","target","_drawLayers","viewports","views","onViewportActive","clearCanvas","clearGLCanvas","renderStats","viewportOrDescriptor","viewport","view","id","subViewports","subViewport","stats","_drawLayersInViewport","push","layers","layerFilter","onError","pass","effects","moduleParameters","glViewport","getGLViewport","clearOpts","color","depth","scissorTest","scissor","renderStatus","totalCount","length","visibleCount","compositeCount","pickableCount","indexResolver","layerIndexResolver","layerIndex","layer","shouldDrawLayer","_shouldDrawLayer","layerRenderIndex","pickable","isComposite","_moduleParameters","_getModuleParameters","layerParameters","getLayerParameters","drawLayer","uniforms","parameters","err","error","visible","isPicking","startsWith","renderPass","activateViewport","overrides","assign","Object","create","autoWrapLongitude","wrapLongitude","context","mousePosition","pickingActive","devicePixelRatio","effect","getModuleParameters","startIndex","layerIndices","resolvers","isDrawn","indexOverride","_offset","layerId","parentId","parent","index","resolver","Number","isFinite","height","canvas","clientHeight","dimensions","pixelRatio","x","y","width","drawingBufferWidth","drawingBufferHeight"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport Pass from './pass';\nimport {clear, setParameters, withParameters, cssToDeviceRatio} from '@luma.gl/core';\nimport log from '../utils/log';\n\nexport default class LayersPass extends Pass {\n  render(props) {\n    const gl = this.gl;\n\n    setParameters(gl, {framebuffer: props.target});\n    return this._drawLayers(props);\n  }\n\n  // PRIVATE\n  // Draw a list of layers in a list of viewports\n  _drawLayers(props) {\n    const {viewports, views, onViewportActive, clearCanvas = true} = props;\n\n    const gl = this.gl;\n    if (clearCanvas) {\n      clearGLCanvas(gl);\n    }\n\n    const renderStats = [];\n\n    for (const viewportOrDescriptor of viewports) {\n      // Get a viewport from a viewport descriptor (which can be a plain viewport)\n      const viewport = viewportOrDescriptor.viewport || viewportOrDescriptor;\n      const view = views && views[viewport.id];\n\n      // Update context to point to this viewport\n      onViewportActive(viewport);\n\n      props.view = view;\n\n      // render this viewport\n      const subViewports = viewport.subViewports || [viewport];\n      for (const subViewport of subViewports) {\n        props.viewport = subViewport;\n\n        const stats = this._drawLayersInViewport(gl, props);\n        renderStats.push(stats);\n      }\n    }\n    return renderStats;\n  }\n\n  // Draws a list of layers in one viewport\n  // TODO - when picking we could completely skip rendering viewports that dont\n  // intersect with the picking rect\n  /* eslint-disable max-depth, max-statements */\n  _drawLayersInViewport(\n    gl,\n    {layers, layerFilter, onError, viewport, view, pass = 'unknown', effects, moduleParameters}\n  ) {\n    const glViewport = getGLViewport(gl, {viewport});\n\n    if (view && view.props.clear) {\n      const clearOpts = view.props.clear === true ? {color: true, depth: true} : view.props.clear;\n      withParameters(\n        gl,\n        {\n          scissorTest: true,\n          scissor: glViewport\n        },\n        () => clear(gl, clearOpts)\n      );\n    }\n\n    // render layers in normal colors\n    const renderStatus = {\n      totalCount: layers.length,\n      visibleCount: 0,\n      compositeCount: 0,\n      pickableCount: 0\n    };\n\n    setParameters(gl, {viewport: glViewport});\n\n    const indexResolver = layerIndexResolver();\n    // render layers in normal colors\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      // Check if we should draw layer\n      const shouldDrawLayer = this._shouldDrawLayer(layer, viewport, pass, layerFilter);\n\n      // This is the \"logical\" index for ordering this layer in the stack\n      // used to calculate polygon offsets\n      // It can be the same as another layer\n      const layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n\n      // Calculate stats\n      if (shouldDrawLayer && layer.props.pickable) {\n        renderStatus.pickableCount++;\n      }\n      if (layer.isComposite) {\n        renderStatus.compositeCount++;\n      } else if (shouldDrawLayer) {\n        // Draw the layer\n        renderStatus.visibleCount++;\n\n        const _moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);\n        const layerParameters = this.getLayerParameters(layer, layerIndex);\n        // overwrite layer.context.viewport with the sub viewport\n        _moduleParameters.viewport = viewport;\n\n        try {\n          layer.drawLayer({\n            moduleParameters: _moduleParameters,\n            uniforms: {layerIndex: layerRenderIndex},\n            parameters: layerParameters\n          });\n        } catch (err) {\n          if (onError) {\n            onError(err, layer);\n          } else {\n            log.error(`error during drawing of ${layer}`, err)();\n          }\n        }\n      }\n    }\n\n    return renderStatus;\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  /* Methods for subclass overrides */\n  shouldDrawLayer(layer) {\n    return true;\n  }\n\n  getModuleParameters(layer, effects) {\n    return null;\n  }\n\n  getLayerParameters(layer, layerIndex) {\n    return layer.props.parameters;\n  }\n\n  /* Private */\n  _shouldDrawLayer(layer, viewport, pass, layerFilter) {\n    let shouldDrawLayer = this.shouldDrawLayer(layer) && layer.props.visible;\n\n    if (shouldDrawLayer && layerFilter) {\n      shouldDrawLayer = layerFilter({\n        layer,\n        viewport,\n        isPicking: pass.startsWith('picking'),\n        renderPass: pass\n      });\n    }\n    if (shouldDrawLayer) {\n      // If a layer is drawn, update its viewportChanged flag\n      layer.activateViewport(viewport);\n    }\n\n    return shouldDrawLayer;\n  }\n\n  _getModuleParameters(layer, effects, pass, overrides) {\n    const moduleParameters = Object.assign(Object.create(layer.props), {\n      autoWrapLongitude: layer.wrapLongitude,\n      viewport: layer.context.viewport,\n      mousePosition: layer.context.mousePosition,\n      pickingActive: 0,\n      devicePixelRatio: cssToDeviceRatio(this.gl)\n    });\n\n    if (effects) {\n      for (const effect of effects) {\n        Object.assign(moduleParameters, effect.getModuleParameters(layer));\n      }\n    }\n\n    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);\n  }\n}\n\n// If the _index prop is defined, return a layer index that's relative to its parent\n// Otherwise return the index of the layer among all rendered layers\n// This is done recursively, i.e. if the user overrides a layer's default index,\n// all its descendants will be resolved relative to that index.\n// This implementation assumes that parent layers always appear before its children\n// which is true if the layer array comes from the LayerManager\nexport function layerIndexResolver(startIndex = 0, layerIndices = {}) {\n  const resolvers = {};\n\n  return (layer, isDrawn) => {\n    const indexOverride = layer.props._offset;\n    const layerId = layer.id;\n    const parentId = layer.parent && layer.parent.id;\n\n    let index;\n\n    if (parentId in resolvers) {\n      const resolver = (resolvers[parentId] =\n        resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices));\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      // Mark layer as needing its own resolver\n      // We don't actually create it until it's used for the first time\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n\n    layerIndices[layerId] = index;\n    return index;\n  };\n}\n\n// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\nfunction getGLViewport(gl, {viewport}) {\n  // TODO - dummy default for node\n  // Fallback to width/height when clientWidth/clientHeight are 0 or undefined.\n  const height = gl.canvas ? gl.canvas.clientHeight || gl.canvas.height : 100;\n  // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n  const dimensions = viewport;\n  const pixelRatio = cssToDeviceRatio(gl);\n  return [\n    dimensions.x * pixelRatio,\n    (height - dimensions.y - dimensions.height) * pixelRatio,\n    dimensions.width * pixelRatio,\n    dimensions.height * pixelRatio\n  ];\n}\n\nfunction clearGLCanvas(gl) {\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  // clear depth and color buffers, restoring transparency\n  setParameters(gl, {viewport: [0, 0, width, height]});\n  gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n}\n"]},"metadata":{},"sourceType":"module"}