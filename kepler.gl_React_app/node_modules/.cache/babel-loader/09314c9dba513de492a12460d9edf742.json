{"ast":null,"code":"import { assertWebGLContext, log } from '@luma.gl/gltools';\nimport { parseGLSLCompilerError, getShaderName } from '../glsl-utils';\nimport { assert } from '../utils/assert';\nimport { uid } from '../utils/utils';\nimport Resource from './resource';\nconst ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';\nexport class Shader extends Resource {\n  get [Symbol.toStringTag]() {\n    return 'Shader';\n  }\n  static getTypeName(shaderType) {\n    switch (shaderType) {\n      case 35633:\n        return 'vertex-shader';\n      case 35632:\n        return 'fragment-shader';\n      default:\n        assert(false);\n        return 'unknown';\n    }\n  }\n  constructor(gl, props) {\n    assertWebGLContext(gl);\n    assert(typeof props.source === 'string', ERR_SOURCE);\n    const id = getShaderName(props.source, null) || props.id || uid(\"unnamed \".concat(Shader.getTypeName(props.shaderType)));\n    super(gl, {\n      id\n    });\n    this.shaderType = props.shaderType;\n    this.source = props.source;\n    this.initialize(props);\n  }\n  initialize(_ref) {\n    let {\n      source\n    } = _ref;\n    const shaderName = getShaderName(source, null);\n    if (shaderName) {\n      this.id = uid(shaderName);\n    }\n    this._compile(source);\n  }\n  getParameter(pname) {\n    return this.gl.getShaderParameter(this.handle, pname);\n  }\n  toString() {\n    return \"\".concat(Shader.getTypeName(this.shaderType), \":\").concat(this.id);\n  }\n  getName() {\n    return getShaderName(this.source) || 'unnamed-shader';\n  }\n  getSource() {\n    return this.gl.getShaderSource(this.handle);\n  }\n  getTranslatedSource() {\n    const extension = this.gl.getExtension('WEBGL_debug_shaders');\n    return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL_debug_shaders not implemented';\n  }\n  _compile() {\n    let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.source;\n    if (!source.startsWith('#version ')) {\n      source = \"#version 100\\n\".concat(source);\n    }\n    this.source = source;\n    this.gl.shaderSource(this.handle, this.source);\n    this.gl.compileShader(this.handle);\n    const compileStatus = this.getParameter(35713);\n    if (!compileStatus) {\n      const infoLog = this.gl.getShaderInfoLog(this.handle);\n      const {\n        shaderName,\n        errors,\n        warnings\n      } = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id);\n      log.error(\"GLSL compilation errors in \".concat(shaderName, \"\\n\").concat(errors))();\n      log.warn(\"GLSL compilation warnings in \".concat(shaderName, \"\\n\").concat(warnings))();\n      throw new Error(\"GLSL compilation errors in \".concat(shaderName));\n    }\n  }\n  _deleteHandle() {\n    this.gl.deleteShader(this.handle);\n  }\n  _getOptsFromHandle() {\n    return {\n      type: this.getParameter(35663),\n      source: this.getSource()\n    };\n  }\n}\nexport class VertexShader extends Shader {\n  get [Symbol.toStringTag]() {\n    return 'VertexShader';\n  }\n  constructor(gl, props) {\n    if (typeof props === 'string') {\n      props = {\n        source: props\n      };\n    }\n    super(gl, Object.assign({}, props, {\n      shaderType: 35633\n    }));\n  }\n  _createHandle() {\n    return this.gl.createShader(35633);\n  }\n}\nexport class FragmentShader extends Shader {\n  get [Symbol.toStringTag]() {\n    return 'FragmentShader';\n  }\n  constructor(gl, props) {\n    if (typeof props === 'string') {\n      props = {\n        source: props\n      };\n    }\n    super(gl, Object.assign({}, props, {\n      shaderType: 35632\n    }));\n  }\n  _createHandle() {\n    return this.gl.createShader(35632);\n  }\n}","map":{"version":3,"sources":["../../../src/classes/shader.js"],"names":["assertWebGLContext","log","parseGLSLCompilerError","getShaderName","assert","uid","Resource","ERR_SOURCE","Shader","Symbol","toStringTag","getTypeName","shaderType","constructor","gl","props","source","id","initialize","shaderName","_compile","getParameter","pname","getShaderParameter","handle","toString","getName","getSource","getShaderSource","getTranslatedSource","extension","getExtension","getTranslatedShaderSource","startsWith","shaderSource","compileShader","compileStatus","infoLog","getShaderInfoLog","errors","warnings","error","warn","Error","_deleteHandle","deleteShader","_getOptsFromHandle","type","VertexShader","assign","_createHandle","createShader","FragmentShader"],"mappings":"AACA,SAAQA,kBAAR,EAA4BC,GAA5B,QAAsC,kBAAtC;AACA,SAAQC,sBAAR,EAAgCC,aAAhC,QAAoD,eAApD;AACA,SAAQC,MAAR,QAAqB,iBAArB;AACA,SAAQC,GAAR,QAAkB,gBAAlB;AACA,OAAOC,QAAP,MAAqB,YAArB;AAEA,MAAMC,UAAU,GAAG,sDAAnB;AAGA,OAAO,MAAMC,MAAN,SAAqBF,QAArB,CAA8B;EAEZ,KAAlBG,MAAM,CAACC,WAAW,IAAI;IACzB,OAAO,QAAP;EACD;EAEiB,OAAXC,WAAW,CAACC,UAAD,EAAa;IAC7B,QAAQA,UAAR;MACE,KAAA,KAAA;QACE,OAAO,eAAP;MACF,KAAA,KAAA;QACE,OAAO,iBAAP;MACF;QACER,MAAM,CAAC,KAAD,CAANA;QACA,OAAO,SAAP;IAAA;EAEL;EAGDS,WAAW,CAACC,EAAD,EAAKC,KAAL,EAAY;IACrBf,kBAAkB,CAACc,EAAD,CAAlBd;IAGAI,MAAM,CAAC,OAAOW,KAAK,CAACC,MAAb,KAAwB,QAAzB,EAAmCT,UAAnC,CAANH;IAGA,MAAMa,EAAE,GACNd,aAAa,CAACY,KAAK,CAACC,MAAP,EAAe,IAAf,CAAbb,IACAY,KAAK,CAACE,EADNd,IAEAE,GAAG,CAAA,UAAA,CAAA,MAAA,CAAYG,MAAM,CAACG,WAAPH,CAAmBO,KAAK,CAACH,UAAzBJ,CAAZ,CAAA,CAHL;IAKA,KAAA,CAAMM,EAAN,EAAU;MAACG;IAAD,CAAV,CAAA;IAEA,IAAA,CAAKL,UAAL,GAAkBG,KAAK,CAACH,UAAxB;IACA,IAAA,CAAKI,MAAL,GAAcD,KAAK,CAACC,MAApB;IAEA,IAAA,CAAKE,UAAL,CAAgBH,KAAhB,CAAA;EACD;EAEDG,UAAU,CAAA,IAAA,EAAW;IAAA,IAAV;MAACF;IAAD,CAAU,GAAA,IAAA;IACnB,MAAMG,UAAU,GAAGhB,aAAa,CAACa,MAAD,EAAS,IAAT,CAAhC;IACA,IAAIG,UAAJ,EAAgB;MACd,IAAA,CAAKF,EAAL,GAAUZ,GAAG,CAACc,UAAD,CAAb;IACD;IACD,IAAA,CAAKC,QAAL,CAAcJ,MAAd,CAAA;EACD;EAIDK,YAAY,CAACC,KAAD,EAAQ;IAClB,OAAO,IAAA,CAAKR,EAAL,CAAQS,kBAAR,CAA2B,IAAA,CAAKC,MAAhC,EAAwCF,KAAxC,CAAP;EACD;EAEDG,QAAQ,GAAG;IACT,OAAA,EAAA,CAAA,MAAA,CAAUjB,MAAM,CAACG,WAAPH,CAAmB,IAAA,CAAKI,UAAxBJ,CAAV,EAAA,GAAA,CAAA,CAAA,MAAA,CAAiD,IAAA,CAAKS,EAAtD,CAAA;EACD;EAEDS,OAAO,GAAG;IACR,OAAOvB,aAAa,CAAC,IAAA,CAAKa,MAAN,CAAbb,IAA8B,gBAArC;EACD;EAEDwB,SAAS,GAAG;IACV,OAAO,IAAA,CAAKb,EAAL,CAAQc,eAAR,CAAwB,IAAA,CAAKJ,MAA7B,CAAP;EACD;EAGDK,mBAAmB,GAAG;IACpB,MAAMC,SAAS,GAAG,IAAA,CAAKhB,EAAL,CAAQiB,YAAR,CAAqB,qBAArB,CAAlB;IACA,OAAOD,SAAS,GACZA,SAAS,CAACE,yBAAVF,CAAoC,IAAA,CAAKN,MAAzCM,CADY,GAEZ,qEAFJ;EAGD;EAGDV,QAAQ,GAAuB;IAAA,IAAtBJ,MAAsB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAb,IAAA,CAAKA,MAAQ;IAC7B,IAAI,CAACA,MAAM,CAACiB,UAAPjB,CAAkB,WAAlBA,CAAL,EAAqC;MACnCA,MAAM,GAAA,gBAAA,CAAA,MAAA,CAAoBA,MAApB,CAANA;IACD;IACD,IAAA,CAAKA,MAAL,GAAcA,MAAd;IACA,IAAA,CAAKF,EAAL,CAAQoB,YAAR,CAAqB,IAAA,CAAKV,MAA1B,EAAkC,IAAA,CAAKR,MAAvC,CAAA;IACA,IAAA,CAAKF,EAAL,CAAQqB,aAAR,CAAsB,IAAA,CAAKX,MAA3B,CAAA;IAKA,MAAMY,aAAa,GAAG,IAAA,CAAKf,YAAL,CAAA,KAAA,CAAtB;IACA,IAAI,CAACe,aAAL,EAAoB;MAClB,MAAMC,OAAO,GAAG,IAAA,CAAKvB,EAAL,CAAQwB,gBAAR,CAAyB,IAAA,CAAKd,MAA9B,CAAhB;MACA,MAAM;QAACL,UAAD;QAAaoB,MAAb;QAAqBC;MAArB,CAAA,GAAiCtC,sBAAsB,CAC3DmC,OAD2D,EAE3D,IAAA,CAAKrB,MAFsD,EAG3D,IAAA,CAAKJ,UAHsD,EAI3D,IAAA,CAAKK,EAJsD,CAA7D;MAMAhB,GAAG,CAACwC,KAAJxC,CAAAA,6BAAAA,CAAAA,MAAAA,CAAwCkB,UAAxClB,EAAAA,IAAAA,CAAAA,CAAAA,MAAAA,CAAuDsC,MAAvDtC,CAAAA,CAAAA,EAAAA;MACAA,GAAG,CAACyC,IAAJzC,CAAAA,+BAAAA,CAAAA,MAAAA,CAAyCkB,UAAzClB,EAAAA,IAAAA,CAAAA,CAAAA,MAAAA,CAAwDuC,QAAxDvC,CAAAA,CAAAA,EAAAA;MACA,MAAM,IAAI0C,KAAJ,CAAA,6BAAA,CAAA,MAAA,CAAwCxB,UAAxC,CAAA,CAAN;IACD;EACF;EAEDyB,aAAa,GAAG;IACd,IAAA,CAAK9B,EAAL,CAAQ+B,YAAR,CAAqB,IAAA,CAAKrB,MAA1B,CAAA;EACD;EAEDsB,kBAAkB,GAAG;IACnB,OAAO;MACLC,IAAI,EAAE,IAAA,CAAK1B,YAAL,CAAA,KAAA,CADD;MAELL,MAAM,EAAE,IAAA,CAAKW,SAAL;IAFH,CAAP;EAID;AA7GkC;AAgHrC,OAAO,MAAMqB,YAAN,SAA2BxC,MAA3B,CAAkC;EAEhB,KAAlBC,MAAM,CAACC,WAAW,IAAI;IACzB,OAAO,cAAP;EACD;EAEDG,WAAW,CAACC,EAAD,EAAKC,KAAL,EAAY;IAErB,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;MAC7BA,KAAK,GAAG;QAACC,MAAM,EAAED;MAAT,CAARA;IACD;IACD,KAAA,CAAMD,EAAN,EAAU,MAAM,CAACmC,MAAP,CAAc,CAAA,CAAd,EAAkBlC,KAAlB,EAAyB;MAACH,UAAU,EAAA;IAAX,CAAzB,CAAV,CAAA;EACD;EAGDsC,aAAa,GAAG;IACd,OAAO,IAAA,CAAKpC,EAAL,CAAQqC,YAAR,CAAA,KAAA,CAAP;EACD;AAjBsC;AAoBzC,OAAO,MAAMC,cAAN,SAA6B5C,MAA7B,CAAoC;EAElB,KAAlBC,MAAM,CAACC,WAAW,IAAI;IACzB,OAAO,gBAAP;EACD;EACDG,WAAW,CAACC,EAAD,EAAKC,KAAL,EAAY;IAErB,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;MAC7BA,KAAK,GAAG;QAACC,MAAM,EAAED;MAAT,CAARA;IACD;IAED,KAAA,CAAMD,EAAN,EAAU,MAAM,CAACmC,MAAP,CAAc,CAAA,CAAd,EAAkBlC,KAAlB,EAAyB;MAACH,UAAU,EAAA;IAAX,CAAzB,CAAV,CAAA;EACD;EAGDsC,aAAa,GAAG;IACd,OAAO,IAAA,CAAKpC,EAAL,CAAQqC,YAAR,CAAA,KAAA,CAAP;EACD;AAjBwC","sourcesContent":["import GL from '@luma.gl/constants';\nimport {assertWebGLContext, log} from '@luma.gl/gltools';\nimport {parseGLSLCompilerError, getShaderName} from '../glsl-utils';\nimport {assert} from '../utils/assert';\nimport {uid} from '../utils/utils';\nimport Resource from './resource';\n\nconst ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';\n\n// For now this is an internal class\nexport class Shader extends Resource {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'Shader';\n  }\n\n  static getTypeName(shaderType) {\n    switch (shaderType) {\n      case GL.VERTEX_SHADER:\n        return 'vertex-shader';\n      case GL.FRAGMENT_SHADER:\n        return 'fragment-shader';\n      default:\n        assert(false);\n        return 'unknown';\n    }\n  }\n\n  /* eslint-disable max-statements */\n  constructor(gl, props) {\n    assertWebGLContext(gl);\n\n    // Validate arguments\n    assert(typeof props.source === 'string', ERR_SOURCE);\n\n    // Deduce an id, from shader source, or supplied id, or shader type\n    const id =\n      getShaderName(props.source, null) ||\n      props.id ||\n      uid(`unnamed ${Shader.getTypeName(props.shaderType)}`);\n\n    super(gl, {id});\n\n    this.shaderType = props.shaderType;\n    this.source = props.source;\n\n    this.initialize(props);\n  }\n\n  initialize({source}) {\n    const shaderName = getShaderName(source, null);\n    if (shaderName) {\n      this.id = uid(shaderName);\n    }\n    this._compile(source);\n  }\n\n  // Accessors\n\n  getParameter(pname) {\n    return this.gl.getShaderParameter(this.handle, pname);\n  }\n\n  toString() {\n    return `${Shader.getTypeName(this.shaderType)}:${this.id}`;\n  }\n\n  getName() {\n    return getShaderName(this.source) || 'unnamed-shader';\n  }\n\n  getSource() {\n    return this.gl.getShaderSource(this.handle);\n  }\n\n  // Debug method - Returns translated source if available\n  getTranslatedSource() {\n    const extension = this.gl.getExtension('WEBGL_debug_shaders');\n    return extension\n      ? extension.getTranslatedShaderSource(this.handle)\n      : 'No translated source available. WEBGL_debug_shaders not implemented';\n  }\n\n  // PRIVATE METHODS\n  _compile(source = this.source) {\n    if (!source.startsWith('#version ')) {\n      source = `#version 100\\n${source}`;\n    }\n    this.source = source;\n    this.gl.shaderSource(this.handle, this.source);\n    this.gl.compileShader(this.handle);\n\n    // TODO - For performance reasons, avoid checking shader compilation errors on production?\n    // TODO - Load log even when no error reported, to catch warnings?\n    // https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings\n    const compileStatus = this.getParameter(GL.COMPILE_STATUS);\n    if (!compileStatus) {\n      const infoLog = this.gl.getShaderInfoLog(this.handle);\n      const {shaderName, errors, warnings} = parseGLSLCompilerError(\n        infoLog,\n        this.source,\n        this.shaderType,\n        this.id\n      );\n      log.error(`GLSL compilation errors in ${shaderName}\\n${errors}`)();\n      log.warn(`GLSL compilation warnings in ${shaderName}\\n${warnings}`)();\n      throw new Error(`GLSL compilation errors in ${shaderName}`);\n    }\n  }\n\n  _deleteHandle() {\n    this.gl.deleteShader(this.handle);\n  }\n\n  _getOptsFromHandle() {\n    return {\n      type: this.getParameter(GL.SHADER_TYPE),\n      source: this.getSource()\n    };\n  }\n}\n\nexport class VertexShader extends Shader {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'VertexShader';\n  }\n\n  constructor(gl, props) {\n    // Signature: new VertexShader(gl, source)\n    if (typeof props === 'string') {\n      props = {source: props};\n    }\n    super(gl, Object.assign({}, props, {shaderType: GL.VERTEX_SHADER}));\n  }\n\n  // PRIVATE METHODS\n  _createHandle() {\n    return this.gl.createShader(GL.VERTEX_SHADER);\n  }\n}\n\nexport class FragmentShader extends Shader {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'FragmentShader';\n  }\n  constructor(gl, props) {\n    // Signature: new FragmentShader(gl, source)\n    if (typeof props === 'string') {\n      props = {source: props};\n    }\n\n    super(gl, Object.assign({}, props, {shaderType: GL.FRAGMENT_SHADER}));\n  }\n\n  // PRIVATE METHODS\n  _createHandle() {\n    return this.gl.createShader(GL.FRAGMENT_SHADER);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}