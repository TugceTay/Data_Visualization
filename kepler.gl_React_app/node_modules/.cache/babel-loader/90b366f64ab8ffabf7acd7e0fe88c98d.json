{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isGeoJson = isGeoJson;\nexports.isFeature = isFeature;\nexports.isFeatureCollection = isFeatureCollection;\nexports.isRowObject = isRowObject;\nexports.isKeplerGlMap = isKeplerGlMap;\nexports.makeProgressIterator = makeProgressIterator;\nexports.readBatch = readBatch;\nexports.readFileInBatches = readFileInBatches;\nexports.processFileData = processFileData;\nexports.filesToDataPayload = filesToDataPayload;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _awaitAsyncGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/awaitAsyncGenerator\"));\nvar _wrapAsyncGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/wrapAsyncGenerator\"));\nvar _asyncIterator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncIterator\"));\nrequire(\"@loaders.gl/polyfills\");\nvar _core = require(\"@loaders.gl/core\");\nvar _json = require(\"@loaders.gl/json\");\nvar _csv = require(\"@loaders.gl/csv\");\nvar _dataProcessor = require(\"./data-processor\");\nvar _utils = require(\"../utils/utils\");\nvar _defaultSettings = require(\"../constants/default-settings\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar BATCH_TYPE = {\n  METADATA: 'metadata',\n  PARTIAL_RESULT: 'partial-result',\n  FINAL_RESULT: 'final-result'\n};\nvar CSV_LOADER_OPTIONS = {\n  batchSize: 4000,\n  // Auto de tect number of rows per batch (network batch size)\n  rowFormat: 'object',\n  dynamicTyping: false // not working for now\n};\n\nvar JSON_LOADER_OPTIONS = {\n  // instruct loaders.gl on what json paths to stream\n  jsonpaths: ['$',\n  // JSON Row array\n  '$.features',\n  // GeoJSON\n  '$.datasets' // KeplerGL JSON\n  ]\n};\n\nfunction isGeoJson(json) {\n  // json can be feature collection\n  // or single feature\n  return (0, _utils.isPlainObject)(json) && (isFeature(json) || isFeatureCollection(json));\n}\nfunction isFeature(json) {\n  return json.type === 'Feature' && json.geometry;\n}\nfunction isFeatureCollection(json) {\n  return json.type === 'FeatureCollection' && json.features;\n}\nfunction isRowObject(json) {\n  return Array.isArray(json) && (0, _utils.isPlainObject)(json[0]);\n}\nfunction isKeplerGlMap(json) {\n  return Boolean((0, _utils.isPlainObject)(json) && json.datasets && json.config && json.info && json.info.app === 'kepler.gl');\n}\nfunction makeProgressIterator(_x, _x2) {\n  return _makeProgressIterator.apply(this, arguments);\n} // eslint-disable-next-line complexity\n\nfunction _makeProgressIterator() {\n  _makeProgressIterator = (0, _wrapAsyncGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(asyncIterator, info) {\n    var rowCount, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, rowCountInBatch, percent, progress;\n    return _regenerator[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            rowCount = 0;\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context.prev = 3;\n            _iterator = (0, _asyncIterator2[\"default\"])(asyncIterator);\n          case 5:\n            _context.next = 7;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_iterator.next());\n          case 7:\n            _step = _context.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context.next = 11;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_step.value);\n          case 11:\n            _value = _context.sent;\n            if (_iteratorNormalCompletion) {\n              _context.next = 23;\n              break;\n            }\n            batch = _value;\n            rowCountInBatch = batch.data && batch.data.length || 0;\n            rowCount += rowCountInBatch;\n            percent = Number.isFinite(batch.bytesUsed) ? batch.bytesUsed / info.size : null; // Update progress object\n\n            progress = _objectSpread({\n              rowCount: rowCount,\n              rowCountInBatch: rowCountInBatch\n            }, Number.isFinite(percent) ? {\n              percent: percent\n            } : {});\n            _context.next = 20;\n            return _objectSpread(_objectSpread({}, batch), {}, {\n              progress: progress\n            });\n          case 20:\n            _iteratorNormalCompletion = true;\n            _context.next = 5;\n            break;\n          case 23:\n            _context.next = 29;\n            break;\n          case 25:\n            _context.prev = 25;\n            _context.t0 = _context[\"catch\"](3);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n          case 29:\n            _context.prev = 29;\n            _context.prev = 30;\n            if (!(!_iteratorNormalCompletion && _iterator[\"return\"] != null)) {\n              _context.next = 34;\n              break;\n            }\n            _context.next = 34;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_iterator[\"return\"]());\n          case 34:\n            _context.prev = 34;\n            if (!_didIteratorError) {\n              _context.next = 37;\n              break;\n            }\n            throw _iteratorError;\n          case 37:\n            return _context.finish(34);\n          case 38:\n            return _context.finish(29);\n          case 39:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3, 25, 29, 39], [30,, 34, 38]]);\n  }));\n  return _makeProgressIterator.apply(this, arguments);\n}\nfunction readBatch(_x3, _x4) {\n  return _readBatch.apply(this, arguments);\n}\nfunction _readBatch() {\n  _readBatch = (0, _wrapAsyncGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(asyncIterator, fileName) {\n    var result, batches, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, batch, streamingPath, i;\n    return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            result = null;\n            batches = [];\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context2.prev = 4;\n            _iterator2 = (0, _asyncIterator2[\"default\"])(asyncIterator);\n          case 6:\n            _context2.next = 8;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_iterator2.next());\n          case 8:\n            _step2 = _context2.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context2.next = 12;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_step2.value);\n          case 12:\n            _value2 = _context2.sent;\n            if (_iteratorNormalCompletion2) {\n              _context2.next = 21;\n              break;\n            }\n            batch = _value2;\n\n            // Last batch will have this special type and will provide all the root\n            // properties of the parsed document.\n            // Only json parse will have `FINAL_RESULT`\n            if (batch.batchType === BATCH_TYPE.FINAL_RESULT) {\n              if (batch.container) {\n                result = _objectSpread({}, batch.container);\n              } // Set the streamed data correctly is Batch json path is set\n              // and the path streamed is not the top level object (jsonpath = '$')\n\n              if (batch.jsonpath && batch.jsonpath.length > 1) {\n                streamingPath = new _json._JSONPath(batch.jsonpath);\n                streamingPath.setFieldAtPath(result, batches);\n              } else if (batch.jsonpath && batch.jsonpath.length === 1) {\n                // The streamed object is a ROW JSON-batch (jsonpath = '$')\n                // row objects\n                result = batches;\n              }\n            } else {\n              for (i = 0; i < batch.data.length; i++) {\n                batches.push(batch.data[i]);\n              }\n            }\n            _context2.next = 18;\n            return _objectSpread(_objectSpread(_objectSpread({}, batch), batch.schema ? {\n              headers: Object.keys(batch.schema)\n            } : {}), {}, {\n              fileName: fileName,\n              // if dataset is CSV, data is set to the raw batches\n              data: result ? result : batches\n            });\n          case 18:\n            _iteratorNormalCompletion2 = true;\n            _context2.next = 6;\n            break;\n          case 21:\n            _context2.next = 27;\n            break;\n          case 23:\n            _context2.prev = 23;\n            _context2.t0 = _context2[\"catch\"](4);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context2.t0;\n          case 27:\n            _context2.prev = 27;\n            _context2.prev = 28;\n            if (!(!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null)) {\n              _context2.next = 32;\n              break;\n            }\n            _context2.next = 32;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_iterator2[\"return\"]());\n          case 32:\n            _context2.prev = 32;\n            if (!_didIteratorError2) {\n              _context2.next = 35;\n              break;\n            }\n            throw _iteratorError2;\n          case 35:\n            return _context2.finish(32);\n          case 36:\n            return _context2.finish(27);\n          case 37:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[4, 23, 27, 37], [28,, 32, 36]]);\n  }));\n  return _readBatch.apply(this, arguments);\n}\nfunction readFileInBatches(_x5) {\n  return _readFileInBatches.apply(this, arguments);\n}\nfunction _readFileInBatches() {\n  _readFileInBatches = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(_ref) {\n    var file, _ref$fileCache, fileCache, _ref$loaders, loaders, _ref$loadOptions, loadOptions, batchIterator, progressIterator;\n    return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            file = _ref.file, _ref$fileCache = _ref.fileCache, fileCache = _ref$fileCache === void 0 ? [] : _ref$fileCache, _ref$loaders = _ref.loaders, loaders = _ref$loaders === void 0 ? [] : _ref$loaders, _ref$loadOptions = _ref.loadOptions, loadOptions = _ref$loadOptions === void 0 ? {} : _ref$loadOptions;\n            loaders = [_json.JSONLoader, _csv.CSVLoader].concat((0, _toConsumableArray2[\"default\"])(loaders));\n            loadOptions = _objectSpread({\n              csv: CSV_LOADER_OPTIONS,\n              json: JSON_LOADER_OPTIONS,\n              metadata: true\n            }, loadOptions);\n            _context3.next = 5;\n            return (0, _core.parseInBatches)(file, loaders, loadOptions);\n          case 5:\n            batchIterator = _context3.sent;\n            progressIterator = makeProgressIterator(batchIterator, {\n              size: file.size\n            });\n            return _context3.abrupt(\"return\", readBatch(progressIterator, file.name));\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _readFileInBatches.apply(this, arguments);\n}\nfunction processFileData(_ref2) {\n  var content = _ref2.content,\n    fileCache = _ref2.fileCache;\n  return new Promise(function (resolve, reject) {\n    var data = content.data;\n    var format;\n    var processor;\n    if (isKeplerGlMap(data)) {\n      format = _defaultSettings.DATASET_FORMATS.keplergl;\n      processor = _dataProcessor.processKeplerglJSON;\n    } else if (isRowObject(data)) {\n      format = _defaultSettings.DATASET_FORMATS.row;\n      processor = _dataProcessor.processRowObject;\n    } else if (isGeoJson(data)) {\n      format = _defaultSettings.DATASET_FORMATS.geojson;\n      processor = _dataProcessor.processGeojson;\n    }\n    if (format && processor) {\n      var result = processor(data);\n      resolve([].concat((0, _toConsumableArray2[\"default\"])(fileCache), [{\n        data: result,\n        info: {\n          label: content.fileName,\n          format: format\n        }\n      }]));\n    }\n    reject('Unknow File Format');\n  });\n}\nfunction filesToDataPayload(fileCache) {\n  // seperate out files which could be a single datasets. or a keplergl map json\n  var collection = fileCache.reduce(function (accu, file) {\n    var data = file.data,\n      _file$info = file.info,\n      info = _file$info === void 0 ? {} : _file$info;\n    var format = info.format;\n    if (format === _defaultSettings.DATASET_FORMATS.keplergl) {\n      // if file contains a single kepler map dataset & config\n      accu.keplerMaps.push(_objectSpread(_objectSpread({}, data), {}, {\n        options: {\n          centerMap: !(data.config && data.config.mapState)\n        }\n      }));\n    } else if (_defaultSettings.DATASET_FORMATS[format]) {\n      // if file contains only data\n      var newDataset = {\n        data: data,\n        info: _objectSpread({\n          id: info.id || (0, _utils.generateHashId)(4)\n        }, info)\n      };\n      accu.datasets.push(newDataset);\n    }\n    return accu;\n  }, {\n    datasets: [],\n    keplerMaps: []\n  }); // add kepler map first with config\n  // add datasets later in one add data call\n\n  return collection.keplerMaps.concat({\n    datasets: collection.datasets\n  });\n}","map":{"version":3,"sources":["../../src/processors/file-handler.js"],"names":["BATCH_TYPE","METADATA","PARTIAL_RESULT","FINAL_RESULT","CSV_LOADER_OPTIONS","batchSize","rowFormat","dynamicTyping","JSON_LOADER_OPTIONS","jsonpaths","isGeoJson","json","isFeature","isFeatureCollection","type","geometry","features","isRowObject","Array","isArray","isKeplerGlMap","Boolean","datasets","config","info","app","makeProgressIterator","asyncIterator","rowCount","batch","rowCountInBatch","data","length","percent","Number","isFinite","bytesUsed","size","progress","readBatch","fileName","result","batches","batchType","container","jsonpath","streamingPath","_JSONPath","setFieldAtPath","i","push","schema","headers","Object","keys","readFileInBatches","file","fileCache","loaders","loadOptions","JSONLoader","CSVLoader","csv","metadata","batchIterator","progressIterator","name","processFileData","content","Promise","resolve","reject","format","processor","DATASET_FORMATS","keplergl","processKeplerglJSON","row","processRowObject","geojson","processGeojson","label","filesToDataPayload","collection","reduce","accu","keplerMaps","options","centerMap","mapState","newDataset","id","concat"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport '@loaders.gl/polyfills';\nimport {parseInBatches} from '@loaders.gl/core';\nimport {JSONLoader, _JSONPath} from '@loaders.gl/json';\nimport {CSVLoader} from '@loaders.gl/csv';\nimport {processGeojson, processKeplerglJSON, processRowObject} from './data-processor';\nimport {isPlainObject, generateHashId} from 'utils/utils';\nimport {DATASET_FORMATS} from 'constants/default-settings';\n\nconst BATCH_TYPE = {\n  METADATA: 'metadata',\n  PARTIAL_RESULT: 'partial-result',\n  FINAL_RESULT: 'final-result'\n};\n\nconst CSV_LOADER_OPTIONS = {\n  batchSize: 4000, // Auto de tect number of rows per batch (network batch size)\n  rowFormat: 'object',\n  dynamicTyping: false // not working for now\n};\n\nconst JSON_LOADER_OPTIONS = {\n  // instruct loaders.gl on what json paths to stream\n  jsonpaths: [\n    '$', // JSON Row array\n    '$.features', // GeoJSON\n    '$.datasets' // KeplerGL JSON\n  ]\n};\n\nexport function isGeoJson(json) {\n  // json can be feature collection\n  // or single feature\n  return isPlainObject(json) && (isFeature(json) || isFeatureCollection(json));\n}\n\nexport function isFeature(json) {\n  return json.type === 'Feature' && json.geometry;\n}\n\nexport function isFeatureCollection(json) {\n  return json.type === 'FeatureCollection' && json.features;\n}\n\nexport function isRowObject(json) {\n  return Array.isArray(json) && isPlainObject(json[0]);\n}\n\nexport function isKeplerGlMap(json) {\n  return Boolean(\n    isPlainObject(json) &&\n      json.datasets &&\n      json.config &&\n      json.info &&\n      json.info.app === 'kepler.gl'\n  );\n}\n\nexport async function* makeProgressIterator(asyncIterator, info) {\n  let rowCount = 0;\n\n  for await (const batch of asyncIterator) {\n    const rowCountInBatch = (batch.data && batch.data.length) || 0;\n    rowCount += rowCountInBatch;\n    const percent = Number.isFinite(batch.bytesUsed) ? batch.bytesUsed / info.size : null;\n\n    // Update progress object\n    const progress = {\n      rowCount,\n      rowCountInBatch,\n      // @ts-ignore\n      ...(Number.isFinite(percent) ? {percent} : {})\n    };\n\n    yield {...batch, progress};\n  }\n}\n\n// eslint-disable-next-line complexity\nexport async function* readBatch(asyncIterator, fileName) {\n  let result = null;\n  const batches = [];\n\n  for await (const batch of asyncIterator) {\n    // Last batch will have this special type and will provide all the root\n    // properties of the parsed document.\n    // Only json parse will have `FINAL_RESULT`\n    if (batch.batchType === BATCH_TYPE.FINAL_RESULT) {\n      if (batch.container) {\n        result = {...batch.container};\n      }\n      // Set the streamed data correctly is Batch json path is set\n      // and the path streamed is not the top level object (jsonpath = '$')\n      if (batch.jsonpath && batch.jsonpath.length > 1) {\n        const streamingPath = new _JSONPath(batch.jsonpath);\n        streamingPath.setFieldAtPath(result, batches);\n      } else if (batch.jsonpath && batch.jsonpath.length === 1) {\n        // The streamed object is a ROW JSON-batch (jsonpath = '$')\n        // row objects\n        result = batches;\n      }\n    } else {\n      for (let i = 0; i < batch.data.length; i++) {\n        batches.push(batch.data[i]);\n      }\n    }\n\n    yield {\n      ...batch,\n      ...(batch.schema ? {headers: Object.keys(batch.schema)} : {}),\n      fileName,\n      // if dataset is CSV, data is set to the raw batches\n      data: result ? result : batches\n    };\n  }\n}\n\nexport async function readFileInBatches({file, fileCache = [], loaders = [], loadOptions = {}}) {\n  loaders = [JSONLoader, CSVLoader, ...loaders];\n  loadOptions = {\n    csv: CSV_LOADER_OPTIONS,\n    json: JSON_LOADER_OPTIONS,\n    metadata: true,\n    ...loadOptions\n  };\n\n  const batchIterator = await parseInBatches(file, loaders, loadOptions);\n  const progressIterator = makeProgressIterator(batchIterator, {size: file.size});\n\n  return readBatch(progressIterator, file.name);\n}\n\nexport function processFileData({content, fileCache}) {\n  return new Promise((resolve, reject) => {\n    const {data} = content;\n\n    let format;\n    let processor;\n    if (isKeplerGlMap(data)) {\n      format = DATASET_FORMATS.keplergl;\n      processor = processKeplerglJSON;\n    } else if (isRowObject(data)) {\n      format = DATASET_FORMATS.row;\n      processor = processRowObject;\n    } else if (isGeoJson(data)) {\n      format = DATASET_FORMATS.geojson;\n      processor = processGeojson;\n    }\n\n    if (format && processor) {\n      const result = processor(data);\n\n      resolve([\n        ...fileCache,\n        {\n          data: result,\n          info: {\n            label: content.fileName,\n            format\n          }\n        }\n      ]);\n    }\n\n    reject('Unknow File Format');\n  });\n}\n\nexport function filesToDataPayload(fileCache) {\n  // seperate out files which could be a single datasets. or a keplergl map json\n  const collection = fileCache.reduce(\n    (accu, file) => {\n      const {data, info = {}} = file;\n      const {format} = info;\n      if (format === DATASET_FORMATS.keplergl) {\n        // if file contains a single kepler map dataset & config\n        accu.keplerMaps.push({\n          ...data,\n          options: {\n            centerMap: !(data.config && data.config.mapState)\n          }\n        });\n      } else if (DATASET_FORMATS[format]) {\n        // if file contains only data\n        const newDataset = {\n          data,\n          info: {\n            id: info.id || generateHashId(4),\n            ...info\n          }\n        };\n        accu.datasets.push(newDataset);\n      }\n      return accu;\n    },\n    {datasets: [], keplerMaps: []}\n  );\n\n  // add kepler map first with config\n  // add datasets later in one add data call\n  return collection.keplerMaps.concat({datasets: collection.datasets});\n}\n"]},"metadata":{},"sourceType":"script"}