{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { COORDINATE_SYSTEM } from '../../lib/constants';\nimport { getOffsetOrigin } from './viewport-uniforms';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\nimport * as vec4 from 'gl-matrix/vec4';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { addMetersToLngLat } from '@math.gl/web-mercator';\nfunction lngLatZToWorldPosition(lngLatZ, viewport) {\n  var offsetMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var p = viewport.projectPosition(lngLatZ);\n  if (offsetMode && viewport instanceof WebMercatorViewport) {\n    var _lngLatZ = _slicedToArray(lngLatZ, 3),\n      longitude = _lngLatZ[0],\n      latitude = _lngLatZ[1],\n      _lngLatZ$ = _lngLatZ[2],\n      z = _lngLatZ$ === void 0 ? 0 : _lngLatZ$;\n    var distanceScales = viewport.getDistanceScales([longitude, latitude]);\n    p[2] = z * distanceScales.unitsPerMeter[2];\n  }\n  return p;\n}\nfunction normalizeParameters(opts) {\n  var normalizedParams = Object.assign({}, opts);\n  var coordinateSystem = opts.coordinateSystem;\n  var viewport = opts.viewport,\n    coordinateOrigin = opts.coordinateOrigin,\n    fromCoordinateSystem = opts.fromCoordinateSystem,\n    fromCoordinateOrigin = opts.fromCoordinateOrigin;\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;\n  }\n  if (fromCoordinateSystem === undefined) {\n    normalizedParams.fromCoordinateSystem = coordinateSystem;\n  }\n  if (fromCoordinateOrigin === undefined) {\n    normalizedParams.fromCoordinateOrigin = coordinateOrigin;\n  }\n  normalizedParams.coordinateSystem = coordinateSystem;\n  return normalizedParams;\n}\nexport function getWorldPosition(position, _ref) {\n  var viewport = _ref.viewport,\n    modelMatrix = _ref.modelMatrix,\n    coordinateSystem = _ref.coordinateSystem,\n    coordinateOrigin = _ref.coordinateOrigin,\n    offsetMode = _ref.offsetMode;\n  var _position = _slicedToArray(position, 3),\n    x = _position[0],\n    y = _position[1],\n    z = _position[2];\n  if (modelMatrix) {\n    var _vec4$transformMat = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);\n    var _vec4$transformMat2 = _slicedToArray(_vec4$transformMat, 3);\n    x = _vec4$transformMat2[0];\n    y = _vec4$transformMat2[1];\n    z = _vec4$transformMat2[2];\n  }\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x, y, z]), viewport, offsetMode);\n    case COORDINATE_SYSTEM.CARTESIAN:\n    default:\n      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);\n  }\n}\nexport function projectPosition(position, params) {\n  var _normalizeParameters = normalizeParameters(params),\n    viewport = _normalizeParameters.viewport,\n    coordinateSystem = _normalizeParameters.coordinateSystem,\n    coordinateOrigin = _normalizeParameters.coordinateOrigin,\n    modelMatrix = _normalizeParameters.modelMatrix,\n    fromCoordinateSystem = _normalizeParameters.fromCoordinateSystem,\n    fromCoordinateOrigin = _normalizeParameters.fromCoordinateOrigin;\n  var _getOffsetOrigin = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin),\n    geospatialOrigin = _getOffsetOrigin.geospatialOrigin,\n    shaderCoordinateOrigin = _getOffsetOrigin.shaderCoordinateOrigin,\n    offsetMode = _getOffsetOrigin.offsetMode;\n  var worldPosition = getWorldPosition(position, {\n    viewport: viewport,\n    modelMatrix: modelMatrix,\n    coordinateSystem: fromCoordinateSystem,\n    coordinateOrigin: fromCoordinateOrigin,\n    offsetMode: offsetMode\n  });\n  if (offsetMode) {\n    var positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n    vec3.sub(worldPosition, worldPosition, positionCommonSpace);\n  }\n  return worldPosition;\n}","map":{"version":3,"sources":["../../../../src/shaderlib/project/project-functions.js"],"names":["COORDINATE_SYSTEM","getOffsetOrigin","WebMercatorViewport","vec4","vec3","addMetersToLngLat","lngLatZToWorldPosition","lngLatZ","viewport","offsetMode","p","projectPosition","longitude","latitude","z","distanceScales","getDistanceScales","unitsPerMeter","normalizeParameters","opts","normalizedParams","Object","assign","coordinateSystem","coordinateOrigin","fromCoordinateSystem","fromCoordinateOrigin","DEFAULT","isGeospatial","LNGLAT","CARTESIAN","undefined","getWorldPosition","position","modelMatrix","x","y","transformMat4","LNGLAT_OFFSETS","METER_OFFSETS","params","geospatialOrigin","shaderCoordinateOrigin","worldPosition","positionCommonSpace","sub"],"mappings":"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","sourcesContent":["/**\n * Projection utils\n * TODO: move to Viewport class?\n */\nimport {COORDINATE_SYSTEM} from '../../lib/constants';\nimport {getOffsetOrigin} from './viewport-uniforms';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\n\nimport * as vec4 from 'gl-matrix/vec4';\nimport * as vec3 from 'gl-matrix/vec3';\nimport {addMetersToLngLat} from '@math.gl/web-mercator';\n\n// In project.glsl, offset modes calculate z differently from LNG_LAT mode.\n// offset modes apply the y adjustment (unitsPerMeter2) when projecting z\n// LNG_LAT mode only use the linear scale.\nfunction lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {\n  const p = viewport.projectPosition(lngLatZ);\n\n  // TODO - avoid using instanceof\n  if (offsetMode && viewport instanceof WebMercatorViewport) {\n    const [longitude, latitude, z = 0] = lngLatZ;\n    const distanceScales = viewport.getDistanceScales([longitude, latitude]);\n    p[2] = z * distanceScales.unitsPerMeter[2];\n  }\n  return p;\n}\n\nfunction normalizeParameters(opts) {\n  const normalizedParams = Object.assign({}, opts);\n\n  let {coordinateSystem} = opts;\n  const {viewport, coordinateOrigin, fromCoordinateSystem, fromCoordinateOrigin} = opts;\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial\n      ? COORDINATE_SYSTEM.LNGLAT\n      : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  if (fromCoordinateSystem === undefined) {\n    normalizedParams.fromCoordinateSystem = coordinateSystem;\n  }\n  if (fromCoordinateOrigin === undefined) {\n    normalizedParams.fromCoordinateOrigin = coordinateOrigin;\n  }\n\n  normalizedParams.coordinateSystem = coordinateSystem;\n\n  return normalizedParams;\n}\n\nexport function getWorldPosition(\n  position,\n  {viewport, modelMatrix, coordinateSystem, coordinateOrigin, offsetMode}\n) {\n  let [x, y, z] = position;\n\n  if (modelMatrix) {\n    [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);\n  }\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      return lngLatZToWorldPosition(\n        [x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)],\n        viewport,\n        offsetMode\n      );\n\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      return lngLatZToWorldPosition(\n        addMetersToLngLat(coordinateOrigin, [x, y, z]),\n        viewport,\n        offsetMode\n      );\n\n    case COORDINATE_SYSTEM.CARTESIAN:\n    default:\n      return viewport.isGeospatial\n        ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]]\n        : viewport.projectPosition([x, y, z]);\n  }\n}\n\n/**\n * Equivalent to project_position in project.glsl\n * projects a user supplied position to world position directly with or without\n * a reference coordinate system\n * @param {array} position - [x, y, z]\n * @param {object} params\n * @param {Viewport} params.viewport - the current viewport\n * @param {number} params.coordinateSystem - the reference coordinate system used\n *   align world position\n * @param {array} params.coordinateOrigin - the reference coordinate origin used\n *   to align world position\n * @param {Matrix4} [params.modelMatrix] - the model matrix of the supplied position\n * @param {number} [params.fromCoordinateSystem] - the coordinate system that the\n *   supplied position is in. Default to the same as `coordinateSystem`.\n * @param {array} [params.fromCoordinateOrigin] - the coordinate origin that the\n *   supplied position is in. Default to the same as `coordinateOrigin`.\n */\nexport function projectPosition(position, params) {\n  const {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    // optional\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  } = normalizeParameters(params);\n\n  const {geospatialOrigin, shaderCoordinateOrigin, offsetMode} = getOffsetOrigin(\n    viewport,\n    coordinateSystem,\n    coordinateOrigin\n  );\n\n  const worldPosition = getWorldPosition(position, {\n    viewport,\n    modelMatrix,\n    coordinateSystem: fromCoordinateSystem,\n    coordinateOrigin: fromCoordinateOrigin,\n    offsetMode\n  });\n\n  if (offsetMode) {\n    const positionCommonSpace = viewport.projectPosition(\n      geospatialOrigin || shaderCoordinateOrigin\n    );\n    vec3.sub(worldPosition, worldPosition, positionCommonSpace);\n  }\n\n  return worldPosition;\n}\n"]},"metadata":{},"sourceType":"module"}