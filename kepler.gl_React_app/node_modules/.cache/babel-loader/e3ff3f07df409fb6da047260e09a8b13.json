{"ast":null,"code":"import { Vector3, assert, equals as equalsEpsilon } from '@math.gl/core';\nconst EPSILON14 = 1e-14;\nconst scratchOrigin = new Vector3();\nconst VECTOR_PRODUCT_LOCAL_FRAME = {\n  up: {\n    south: 'east',\n    north: 'west',\n    west: 'south',\n    east: 'north'\n  },\n  down: {\n    south: 'west',\n    north: 'east',\n    west: 'north',\n    east: 'south'\n  },\n  south: {\n    up: 'west',\n    down: 'east',\n    west: 'down',\n    east: 'up'\n  },\n  north: {\n    up: 'east',\n    down: 'west',\n    west: 'up',\n    east: 'down'\n  },\n  west: {\n    up: 'north',\n    down: 'south',\n    north: 'down',\n    south: 'up'\n  },\n  east: {\n    up: 'south',\n    down: 'north',\n    north: 'up',\n    south: 'down'\n  }\n};\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n};\nconst scratchAxisVectors = {\n  east: new Vector3(),\n  north: new Vector3(),\n  up: new Vector3(),\n  west: new Vector3(),\n  south: new Vector3(),\n  down: new Vector3()\n};\nconst scratchVector1 = new Vector3();\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\nexport default function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {\n  const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];\n  assert(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));\n  let firstAxisVector;\n  let secondAxisVector;\n  let thirdAxisVector;\n  const origin = scratchOrigin.copy(cartesianOrigin);\n  const atPole = equalsEpsilon(origin.x, 0.0, EPSILON14) && equalsEpsilon(origin.y, 0.0, EPSILON14);\n  if (atPole) {\n    const sign = Math.sign(origin.z);\n    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);\n    if (firstAxis !== 'east' && firstAxis !== 'west') {\n      firstAxisVector.scale(sign);\n    }\n    secondAxisVector = scratchVector2.fromArray(degeneratePositionLocalFrame[secondAxis]);\n    if (secondAxis !== 'east' && secondAxis !== 'west') {\n      secondAxisVector.scale(sign);\n    }\n    thirdAxisVector = scratchVector3.fromArray(degeneratePositionLocalFrame[thirdAxis]);\n    if (thirdAxis !== 'east' && thirdAxis !== 'west') {\n      thirdAxisVector.scale(sign);\n    }\n  } else {\n    const {\n      up,\n      east,\n      north\n    } = scratchAxisVectors;\n    east.set(-origin.y, origin.x, 0.0).normalize();\n    ellipsoid.geodeticSurfaceNormal(origin, up);\n    north.copy(up).cross(east);\n    const {\n      down,\n      west,\n      south\n    } = scratchAxisVectors;\n    down.copy(up).scale(-1);\n    west.copy(east).scale(-1);\n    south.copy(north).scale(-1);\n    firstAxisVector = scratchAxisVectors[firstAxis];\n    secondAxisVector = scratchAxisVectors[secondAxis];\n    thirdAxisVector = scratchAxisVectors[thirdAxis];\n  }\n  result[0] = firstAxisVector.x;\n  result[1] = firstAxisVector.y;\n  result[2] = firstAxisVector.z;\n  result[3] = 0.0;\n  result[4] = secondAxisVector.x;\n  result[5] = secondAxisVector.y;\n  result[6] = secondAxisVector.z;\n  result[7] = 0.0;\n  result[8] = thirdAxisVector.x;\n  result[9] = thirdAxisVector.y;\n  result[10] = thirdAxisVector.z;\n  result[11] = 0.0;\n  result[12] = origin.x;\n  result[13] = origin.y;\n  result[14] = origin.z;\n  result[15] = 1.0;\n  return result;\n}","map":{"version":3,"sources":["../../../../src/ellipsoid/helpers/ellipsoid-transform.ts"],"names":["Vector3","assert","equals","equalsEpsilon","EPSILON14","scratchOrigin","VECTOR_PRODUCT_LOCAL_FRAME","up","south","north","west","east","down","degeneratePositionLocalFrame","scratchAxisVectors","scratchVector1","scratchVector2","scratchVector3","localFrameToFixedFrame","ellipsoid","firstAxis","secondAxis","thirdAxis","cartesianOrigin","result","thirdAxisInferred","firstAxisVector","secondAxisVector","thirdAxisVector","origin","copy","atPole","x","y","sign","Math","z","fromArray","scale","set","normalize","geodeticSurfaceNormal","cross"],"mappings":"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","sourcesContent":["import {Vector3, assert, equals as equalsEpsilon} from '@math.gl/core';\n\nimport type Ellipsoid from '../ellipsoid';\n\nconst EPSILON14 = 1e-14;\n\nconst scratchOrigin = new Vector3();\n\n// Caclulate third axis from given two axii\nconst VECTOR_PRODUCT_LOCAL_FRAME = {\n  up: {\n    south: 'east',\n    north: 'west',\n    west: 'south',\n    east: 'north'\n  },\n  down: {\n    south: 'west',\n    north: 'east',\n    west: 'north',\n    east: 'south'\n  },\n  south: {\n    up: 'west',\n    down: 'east',\n    west: 'down',\n    east: 'up'\n  },\n  north: {\n    up: 'east',\n    down: 'west',\n    west: 'up',\n    east: 'down'\n  },\n  west: {\n    up: 'north',\n    down: 'south',\n    north: 'down',\n    south: 'up'\n  },\n  east: {\n    up: 'south',\n    down: 'north',\n    north: 'up',\n    south: 'down'\n  }\n} as const;\n\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n} as const;\n\nconst scratchAxisVectors = {\n  east: new Vector3(),\n  north: new Vector3(),\n  up: new Vector3(),\n  west: new Vector3(),\n  south: new Vector3(),\n  down: new Vector3()\n};\n\nconst scratchVector1 = new Vector3();\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\n\ntype Axis = 'up' | 'down' | 'north' | 'east' | 'south' | 'west';\n\n// Computes a 4x4 transformation matrix from a reference frame\n// centered at the provided origin to the provided ellipsoid's fixed reference frame.\n// eslint-disable-next-line max-statements, max-params, complexity\nexport default function localFrameToFixedFrame(\n  ellipsoid: Ellipsoid,\n  firstAxis: Axis,\n  secondAxis: Axis,\n  thirdAxis: Axis,\n  cartesianOrigin: number[],\n  result: number[]\n): number[] {\n  const thirdAxisInferred =\n    VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] &&\n    (VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis] as Axis);\n  // firstAxis and secondAxis must be east, north, up, west, south or down.');\n  assert(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));\n\n  let firstAxisVector: Vector3;\n  let secondAxisVector: Vector3;\n  let thirdAxisVector: Vector3;\n\n  const origin = scratchOrigin.copy(cartesianOrigin);\n\n  // If x and y are zero, assume origin is at a pole, which is a special case.\n  const atPole = equalsEpsilon(origin.x, 0.0, EPSILON14) && equalsEpsilon(origin.y, 0.0, EPSILON14);\n\n  if (atPole) {\n    // Look up axis value and adjust\n    const sign = Math.sign(origin.z);\n\n    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);\n    if (firstAxis !== 'east' && firstAxis !== 'west') {\n      firstAxisVector.scale(sign);\n    }\n\n    secondAxisVector = scratchVector2.fromArray(degeneratePositionLocalFrame[secondAxis]);\n    if (secondAxis !== 'east' && secondAxis !== 'west') {\n      secondAxisVector.scale(sign);\n    }\n\n    thirdAxisVector = scratchVector3.fromArray(degeneratePositionLocalFrame[thirdAxis]);\n    if (thirdAxis !== 'east' && thirdAxis !== 'west') {\n      thirdAxisVector.scale(sign);\n    }\n  } else {\n    // Calculate all axis\n    const {up, east, north} = scratchAxisVectors;\n\n    east.set(-origin.y, origin.x, 0.0).normalize();\n    ellipsoid.geodeticSurfaceNormal(origin, up);\n    north.copy(up).cross(east);\n\n    const {down, west, south} = scratchAxisVectors;\n\n    down.copy(up).scale(-1);\n    west.copy(east).scale(-1);\n    south.copy(north).scale(-1);\n\n    // Pick three axis based on desired orientation\n    firstAxisVector = scratchAxisVectors[firstAxis];\n    secondAxisVector = scratchAxisVectors[secondAxis];\n    thirdAxisVector = scratchAxisVectors[thirdAxis];\n  }\n\n  // TODO - assuming the result is column-major\n  result[0] = firstAxisVector.x;\n  result[1] = firstAxisVector.y;\n  result[2] = firstAxisVector.z;\n  result[3] = 0.0;\n  result[4] = secondAxisVector.x;\n  result[5] = secondAxisVector.y;\n  result[6] = secondAxisVector.z;\n  result[7] = 0.0;\n  result[8] = thirdAxisVector.x;\n  result[9] = thirdAxisVector.y;\n  result[10] = thirdAxisVector.z;\n  result[11] = 0.0;\n  result[12] = origin.x;\n  result[13] = origin.y;\n  result[14] = origin.z;\n  result[15] = 1.0;\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}