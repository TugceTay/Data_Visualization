{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _DEFAULT_TEXTURE_PARA;\nimport { Texture2D, copyToTexture, cloneTextureFrom } from '@luma.gl/core';\nimport { ImageLoader } from '@loaders.gl/images';\nimport { load } from '@loaders.gl/core';\nimport { createIterable, log } from '@deck.gl/core';\nvar DEFAULT_CANVAS_WIDTH = 1024;\nvar DEFAULT_BUFFER = 4;\nvar noop = function noop() {};\nvar DEFAULT_TEXTURE_PARAMETERS = (_DEFAULT_TEXTURE_PARA = {}, _defineProperty(_DEFAULT_TEXTURE_PARA, 10241, 9987), _defineProperty(_DEFAULT_TEXTURE_PARA, 10240, 9729), _defineProperty(_DEFAULT_TEXTURE_PARA, 10242, 33071), _defineProperty(_DEFAULT_TEXTURE_PARA, 10243, 33071), _DEFAULT_TEXTURE_PARA);\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\nfunction resizeImage(ctx, imageData, width, height) {\n  if (width === imageData.width && height === imageData.height) {\n    return imageData;\n  }\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n  return ctx.canvas;\n}\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\nfunction resizeTexture(gl, texture, width, height) {\n  var oldWidth = texture.width;\n  var oldHeight = texture.height;\n  var newTexture = cloneTextureFrom(texture, {\n    width: width,\n    height: height\n  });\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n  texture[\"delete\"]();\n  return newTexture;\n}\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (var i = 0; i < columns.length; i++) {\n    var _columns$i = columns[i],\n      icon = _columns$i.icon,\n      xOffset = _columns$i.xOffset;\n    var id = getIconId(icon);\n    mapping[id] = Object.assign({}, icon, {\n      x: xOffset,\n      y: yOffset\n    });\n  }\n}\nexport function buildMapping(_ref) {\n  var icons = _ref.icons,\n    buffer = _ref.buffer,\n    _ref$mapping = _ref.mapping,\n    mapping = _ref$mapping === void 0 ? {} : _ref$mapping,\n    _ref$xOffset = _ref.xOffset,\n    xOffset = _ref$xOffset === void 0 ? 0 : _ref$xOffset,\n    _ref$yOffset = _ref.yOffset,\n    yOffset = _ref$yOffset === void 0 ? 0 : _ref$yOffset,\n    _ref$rowHeight = _ref.rowHeight,\n    rowHeight = _ref$rowHeight === void 0 ? 0 : _ref$rowHeight,\n    canvasWidth = _ref.canvasWidth;\n  var columns = [];\n  for (var i = 0; i < icons.length; i++) {\n    var icon = icons[i];\n    var id = getIconId(icon);\n    if (!mapping[id]) {\n      var height = icon.height,\n        width = icon.width;\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n      columns.push({\n        icon: icon,\n        xOffset: xOffset\n      });\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n  return {\n    mapping: mapping,\n    rowHeight: rowHeight,\n    xOffset: xOffset,\n    yOffset: yOffset,\n    canvasWidth: canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\nexport function getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n  cachedIcons = cachedIcons || {};\n  var icons = {};\n  var _createIterable = createIterable(data),\n    iterable = _createIterable.iterable,\n    objectInfo = _createIterable.objectInfo;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n  try {\n    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var object = _step.value;\n      objectInfo.index++;\n      var icon = getIcon(object, objectInfo);\n      var id = getIconId(icon);\n      if (!icon) {\n        throw new Error('Icon is missing.');\n      }\n      if (!icon.url) {\n        throw new Error('Icon url is missing.');\n      }\n      if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n        icons[id] = icon;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n  return icons;\n}\nvar IconManager = function () {\n  function IconManager(gl, _ref2) {\n    var _ref2$onUpdate = _ref2.onUpdate,\n      onUpdate = _ref2$onUpdate === void 0 ? noop : _ref2$onUpdate;\n    _classCallCheck(this, IconManager);\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n    this._loadOptions = null;\n    this._getIcon = null;\n    this._texture = null;\n    this._externalTexture = null;\n    this._mapping = {};\n    this._pendingCount = 0;\n    this._autoPacking = false;\n    this._xOffset = 0;\n    this._yOffset = 0;\n    this._rowHeight = 0;\n    this._buffer = DEFAULT_BUFFER;\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH;\n    this._canvasHeight = 0;\n    this._canvas = null;\n  }\n  _createClass(IconManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      if (this._texture) {\n        this._texture[\"delete\"]();\n      }\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      return this._texture || this._externalTexture;\n    }\n  }, {\n    key: \"getIconMapping\",\n    value: function getIconMapping(icon) {\n      var id = this._autoPacking ? getIconId(icon) : icon;\n      return this._mapping[id] || {};\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(_ref3) {\n      var loadOptions = _ref3.loadOptions,\n        autoPacking = _ref3.autoPacking,\n        iconAtlas = _ref3.iconAtlas,\n        iconMapping = _ref3.iconMapping,\n        data = _ref3.data,\n        getIcon = _ref3.getIcon;\n      if (loadOptions) {\n        this._loadOptions = loadOptions;\n      }\n      if (autoPacking !== undefined) {\n        this._autoPacking = autoPacking;\n      }\n      if (getIcon) {\n        this._getIcon = getIcon;\n      }\n      if (iconMapping) {\n        this._mapping = iconMapping;\n      }\n      if (iconAtlas) {\n        this._updateIconAtlas(iconAtlas);\n      }\n      if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {\n        this._canvas = this._canvas || document.createElement('canvas');\n        this._updateAutoPacking(data);\n      }\n    }\n  }, {\n    key: \"_updateIconAtlas\",\n    value: function _updateIconAtlas(iconAtlas) {\n      if (this._texture) {\n        this._texture[\"delete\"]();\n        this._texture = null;\n      }\n      if (iconAtlas instanceof Texture2D) {\n        iconAtlas.setParameters(DEFAULT_TEXTURE_PARAMETERS);\n        this._externalTexture = iconAtlas;\n        this.onUpdate();\n      } else if (iconAtlas) {\n        this._texture = new Texture2D(this.gl, {\n          data: iconAtlas,\n          parameters: DEFAULT_TEXTURE_PARAMETERS\n        });\n        this.onUpdate();\n      }\n    }\n  }, {\n    key: \"_updateAutoPacking\",\n    value: function _updateAutoPacking(data) {\n      var icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {});\n      if (icons.length > 0) {\n        var _buildMapping = buildMapping({\n            icons: icons,\n            buffer: this._buffer,\n            canvasWidth: this._canvasWidth,\n            mapping: this._mapping,\n            rowHeight: this._rowHeight,\n            xOffset: this._xOffset,\n            yOffset: this._yOffset\n          }),\n          mapping = _buildMapping.mapping,\n          xOffset = _buildMapping.xOffset,\n          yOffset = _buildMapping.yOffset,\n          rowHeight = _buildMapping.rowHeight,\n          canvasHeight = _buildMapping.canvasHeight;\n        this._rowHeight = rowHeight;\n        this._mapping = mapping;\n        this._xOffset = xOffset;\n        this._yOffset = yOffset;\n        this._canvasHeight = canvasHeight;\n        if (!this._texture) {\n          this._texture = new Texture2D(this.gl, {\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            parameters: DEFAULT_TEXTURE_PARAMETERS\n          });\n        }\n        if (this._texture.height !== this._canvasHeight) {\n          this._texture = resizeTexture(this.gl, this._texture, this._canvasWidth, this._canvasHeight);\n        }\n        this.onUpdate();\n        this._loadIcons(icons);\n      }\n    }\n  }, {\n    key: \"_loadIcons\",\n    value: function _loadIcons(icons) {\n      var _this = this;\n      var ctx = this._canvas.getContext('2d');\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        var _loop = function _loop() {\n          var icon = _step2.value;\n          _this._pendingCount++;\n          load(icon.url, ImageLoader, _this._loadOptions).then(function (imageData) {\n            var id = getIconId(icon);\n            var _this$_mapping$id = _this._mapping[id],\n              x = _this$_mapping$id.x,\n              y = _this$_mapping$id.y,\n              width = _this$_mapping$id.width,\n              height = _this$_mapping$id.height;\n            var data = resizeImage(ctx, imageData, width, height);\n            _this._texture.setSubImageData({\n              data: data,\n              x: x,\n              y: y,\n              width: width,\n              height: height\n            });\n            _this._texture.generateMipmap();\n            _this.onUpdate();\n          })[\"catch\"](function (error) {\n            log.error(error)();\n          })[\"finally\"](function () {\n            _this._pendingCount--;\n          });\n        };\n        for (var _iterator2 = icons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          _loop();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return this._pendingCount === 0;\n    }\n  }]);\n  return IconManager;\n}();\nexport { IconManager as default };","map":{"version":3,"sources":["../../../src/icon-layer/icon-manager.js"],"names":["Texture2D","copyToTexture","cloneTextureFrom","ImageLoader","load","createIterable","log","DEFAULT_CANVAS_WIDTH","DEFAULT_BUFFER","noop","DEFAULT_TEXTURE_PARAMETERS","nextPowOfTwo","number","Math","pow","ceil","log2","resizeImage","ctx","imageData","width","height","canvas","clearRect","drawImage","getIconId","icon","id","url","resizeTexture","gl","texture","oldWidth","oldHeight","newTexture","targetY","buildRowMapping","mapping","columns","yOffset","i","length","xOffset","assign","x","y","buildMapping","icons","buffer","rowHeight","canvasWidth","push","max","canvasHeight","getDiffIcons","data","getIcon","cachedIcons","iterable","objectInfo","object","index","Error","IconManager","onUpdate","_loadOptions","_getIcon","_texture","_externalTexture","_mapping","_pendingCount","_autoPacking","_xOffset","_yOffset","_rowHeight","_buffer","_canvasWidth","_canvasHeight","_canvas","loadOptions","autoPacking","iconAtlas","iconMapping","undefined","_updateIconAtlas","document","createElement","_updateAutoPacking","setParameters","parameters","Object","values","_loadIcons","getContext","then","setSubImageData","generateMipmap","error"],"mappings":"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","sourcesContent":["/* global document */\nimport GL from '@luma.gl/constants';\nimport {Texture2D, copyToTexture, cloneTextureFrom} from '@luma.gl/core';\nimport {ImageLoader} from '@loaders.gl/images';\nimport {load} from '@loaders.gl/core';\nimport {createIterable, log} from '@deck.gl/core';\n\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\n\nconst noop = () => {};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n  // GL.LINEAR is the default value but explicitly set it here\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  // for texture boundary artifact\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\n\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n// update comment to create a new texture and copy original data.\nfunction resizeImage(ctx, imageData, width, height) {\n  if (width === imageData.width && height === imageData.height) {\n    return imageData;\n  }\n\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n\n  return ctx.canvas;\n}\n\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\n\n// resize texture without losing original data\nfunction resizeTexture(gl, texture, width, height) {\n  const oldWidth = texture.width;\n  const oldHeight = texture.height;\n\n  const newTexture = cloneTextureFrom(texture, {width, height});\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n\n  texture.delete();\n  return newTexture;\n}\n\n// traverse icons in a row of icon atlas\n// extend each icon with left-top coordinates\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {icon, xOffset} = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = Object.assign({}, icon, {\n      x: xOffset,\n      y: yOffset\n    });\n  }\n}\n\n/**\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\n * @param icons {Array<Object>} list of icons, each icon requires url, width, height\n * @param buffer {Number} add buffer to the right and bottom side of the image\n * @param xOffset {Number} right position of last icon in old mapping\n * @param yOffset {Number} top position in last icon in old mapping\n * @param rowHeight {Number} rowHeight of the last icon's row\n * @param canvasWidth {Number} max width of canvas\n * @param mapping {object} old mapping\n * @returns {{mapping: {'/icon/1': {url, width, height, ...}},, canvasHeight: {Number}}}\n */\nexport function buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth\n}) {\n  let columns = [];\n  // Strategy to layout all the icons into a texture:\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\n  // when the sum of the icons width is equal or larger than canvasWidth,\n  // move to next row starting from total height so far plus max height of the icons in previous row\n  // row width is equal to canvasWidth\n  // row height is decided by the max height of the icons in that row\n  // mapping coordinates of each icon is its left-top position in the texture\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n\n    if (!mapping[id]) {\n      const {height, width} = icon;\n\n      // fill one row\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset\n      });\n\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\n\n// extract icons from data\n// return icons should be unique, and not cached or cached but url changed\nexport function getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {iterable, objectInfo} = createIterable(data);\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = icon;\n    }\n  }\n  return icons;\n}\n\nexport default class IconManager {\n  constructor(\n    gl,\n    {\n      onUpdate = noop // notify IconLayer when icon texture update\n    }\n  ) {\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n\n    // load options used for loading images\n    this._loadOptions = null;\n    this._getIcon = null;\n\n    this._texture = null;\n    this._externalTexture = null;\n    this._mapping = {};\n    // count of pending requests to fetch icons\n    this._pendingCount = 0;\n\n    this._autoPacking = false;\n\n    // internal props used when autoPacking applied\n    // right position of last icon\n    this._xOffset = 0;\n    // top position of last icon\n    this._yOffset = 0;\n    this._rowHeight = 0;\n    this._buffer = DEFAULT_BUFFER;\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH;\n    this._canvasHeight = 0;\n    this._canvas = null;\n  }\n\n  finalize() {\n    if (this._texture) {\n      this._texture.delete();\n    }\n  }\n\n  getTexture() {\n    return this._texture || this._externalTexture;\n  }\n\n  getIconMapping(icon) {\n    const id = this._autoPacking ? getIconId(icon) : icon;\n    return this._mapping[id] || {};\n  }\n\n  setProps({loadOptions, autoPacking, iconAtlas, iconMapping, data, getIcon}) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n\n    if (getIcon) {\n      this._getIcon = getIcon;\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n\n    if (iconAtlas) {\n      this._updateIconAtlas(iconAtlas);\n    }\n\n    if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {\n      this._canvas = this._canvas || document.createElement('canvas');\n\n      this._updateAutoPacking(data);\n    }\n  }\n\n  get isLoaded() {\n    return this._pendingCount === 0;\n  }\n\n  _updateIconAtlas(iconAtlas) {\n    if (this._texture) {\n      this._texture.delete();\n      this._texture = null;\n    }\n    if (iconAtlas instanceof Texture2D) {\n      iconAtlas.setParameters(DEFAULT_TEXTURE_PARAMETERS);\n\n      this._externalTexture = iconAtlas;\n      this.onUpdate();\n    } else if (iconAtlas) {\n      // Browser object: Image, ImageData, HTMLCanvasElement, ImageBitmap\n      this._texture = new Texture2D(this.gl, {\n        data: iconAtlas,\n        parameters: DEFAULT_TEXTURE_PARAMETERS\n      });\n      this.onUpdate();\n    }\n  }\n\n  _updateAutoPacking(data) {\n    const icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {});\n\n    if (icons.length > 0) {\n      // generate icon mapping\n      const {mapping, xOffset, yOffset, rowHeight, canvasHeight} = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n\n      // create new texture\n      if (!this._texture) {\n        this._texture = new Texture2D(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: DEFAULT_TEXTURE_PARAMETERS\n        });\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(\n          this.gl,\n          this._texture,\n          this._canvasWidth,\n          this._canvasHeight\n        );\n      }\n\n      this.onUpdate();\n\n      // load images\n      this._loadIcons(icons);\n    }\n  }\n\n  _loadIcons(icons) {\n    const ctx = this._canvas.getContext('2d');\n\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, ImageLoader, this._loadOptions)\n        .then(imageData => {\n          const id = getIconId(icon);\n          const {x, y, width, height} = this._mapping[id];\n\n          const data = resizeImage(ctx, imageData, width, height);\n\n          this._texture.setSubImageData({\n            data,\n            x,\n            y,\n            width,\n            height\n          });\n\n          // Call to regenerate mipmaps after modifying texture(s)\n          this._texture.generateMipmap();\n\n          this.onUpdate();\n        })\n        .catch(error => {\n          log.error(error)();\n        })\n        .finally(() => {\n          this._pendingCount--;\n        });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}