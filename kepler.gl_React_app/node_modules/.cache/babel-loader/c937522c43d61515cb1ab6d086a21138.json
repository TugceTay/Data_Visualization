{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _awaitAsyncGenerator from \"@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _asyncIterator from \"@babel/runtime/helpers/esm/asyncIterator\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport { makeTextDecoderIterator } from '@loaders.gl/loader-utils';\nimport { TableBatchBuilder } from '@loaders.gl/tables';\nimport StreamingJSONParser from './parser/streaming-json-parser';\nexport default function parseJSONInBatches(_x, _x2) {\n  return _parseJSONInBatches.apply(this, arguments);\n}\nfunction _parseJSONInBatches() {\n  _parseJSONInBatches = _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee(asyncIterator, options) {\n    var metadata, _options$json, batchSize, _rootObjectBatches, jsonpaths, TableBatchType, isFirstChunk, tableBatchBuilder, schema, parser, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, rows, _jsonpath, initialBatch, _initialBatch, _iterator2, _step2, row, jsonpath, batch, finalBatch, _finalBatch;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            asyncIterator = makeTextDecoderIterator(asyncIterator);\n            metadata = options.metadata;\n            _options$json = options.json, batchSize = _options$json.batchSize, _rootObjectBatches = _options$json._rootObjectBatches, jsonpaths = _options$json.jsonpaths;\n            TableBatchType = options.json.TableBatch;\n            isFirstChunk = true;\n            tableBatchBuilder = null;\n            schema = null;\n            parser = new StreamingJSONParser({\n              jsonpaths: jsonpaths\n            });\n            tableBatchBuilder = tableBatchBuilder || new TableBatchBuilder(TableBatchType, schema, {\n              batchSize: batchSize\n            });\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context.prev = 11;\n            _iterator = _asyncIterator(asyncIterator);\n          case 13:\n            _context.next = 15;\n            return _awaitAsyncGenerator(_iterator.next());\n          case 15:\n            _step = _context.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context.next = 19;\n            return _awaitAsyncGenerator(_step.value);\n          case 19:\n            _value = _context.sent;\n            if (_iteratorNormalCompletion) {\n              _context.next = 61;\n              break;\n            }\n            chunk = _value;\n            rows = parser.write(chunk);\n            _jsonpath = rows.length > 0 && parser.getStreamingJsonPathAsString();\n            if (!(rows.length > 0 && isFirstChunk)) {\n              _context.next = 35;\n              break;\n            }\n            if (!metadata) {\n              _context.next = 29;\n              break;\n            }\n            initialBatch = {\n              batchType: 'partial-result',\n              container: parser.getPartialResult(),\n              data: [],\n              bytesUsed: 0,\n              schema: null,\n              jsonpath: _jsonpath\n            };\n            _context.next = 29;\n            return initialBatch;\n          case 29:\n            if (!_rootObjectBatches) {\n              _context.next = 33;\n              break;\n            }\n            _initialBatch = {\n              batchType: 'root-object-batch-partial',\n              container: parser.getPartialResult(),\n              data: [],\n              schema: null\n            };\n            _context.next = 33;\n            return _initialBatch;\n          case 33:\n            isFirstChunk = false;\n            schema = deduceSchema(rows);\n          case 35:\n            _iterator2 = _createForOfIteratorHelper(rows);\n            _context.prev = 36;\n            _iterator2.s();\n          case 38:\n            if ((_step2 = _iterator2.n()).done) {\n              _context.next = 46;\n              break;\n            }\n            row = _step2.value;\n            tableBatchBuilder.addRow(row);\n            if (!tableBatchBuilder.isFull()) {\n              _context.next = 44;\n              break;\n            }\n            _context.next = 44;\n            return tableBatchBuilder.getBatch({\n              jsonpath: _jsonpath\n            });\n          case 44:\n            _context.next = 38;\n            break;\n          case 46:\n            _context.next = 51;\n            break;\n          case 48:\n            _context.prev = 48;\n            _context.t0 = _context[\"catch\"](36);\n            _iterator2.e(_context.t0);\n          case 51:\n            _context.prev = 51;\n            _iterator2.f();\n            return _context.finish(51);\n          case 54:\n            tableBatchBuilder.chunkComplete(chunk);\n            if (!tableBatchBuilder.isFull()) {\n              _context.next = 58;\n              break;\n            }\n            _context.next = 58;\n            return tableBatchBuilder.getBatch({\n              jsonpath: _jsonpath\n            });\n          case 58:\n            _iteratorNormalCompletion = true;\n            _context.next = 13;\n            break;\n          case 61:\n            _context.next = 67;\n            break;\n          case 63:\n            _context.prev = 63;\n            _context.t1 = _context[\"catch\"](11);\n            _didIteratorError = true;\n            _iteratorError = _context.t1;\n          case 67:\n            _context.prev = 67;\n            _context.prev = 68;\n            if (!(!_iteratorNormalCompletion && _iterator[\"return\"] != null)) {\n              _context.next = 72;\n              break;\n            }\n            _context.next = 72;\n            return _awaitAsyncGenerator(_iterator[\"return\"]());\n          case 72:\n            _context.prev = 72;\n            if (!_didIteratorError) {\n              _context.next = 75;\n              break;\n            }\n            throw _iteratorError;\n          case 75:\n            return _context.finish(72);\n          case 76:\n            return _context.finish(67);\n          case 77:\n            jsonpath = parser.getStreamingJsonPathAsString();\n            batch = tableBatchBuilder.getBatch({\n              jsonpath: jsonpath\n            });\n            if (!batch) {\n              _context.next = 82;\n              break;\n            }\n            _context.next = 82;\n            return batch;\n          case 82:\n            if (!metadata) {\n              _context.next = 86;\n              break;\n            }\n            finalBatch = {\n              batchType: 'final-result',\n              container: parser.getPartialResult(),\n              jsonpath: parser.getStreamingJsonPathAsString(),\n              data: [],\n              schema: null\n            };\n            _context.next = 86;\n            return finalBatch;\n          case 86:\n            if (!_rootObjectBatches) {\n              _context.next = 90;\n              break;\n            }\n            _finalBatch = {\n              batchType: 'root-object-batch-complete',\n              container: parser.getPartialResult(),\n              data: [],\n              schema: null\n            };\n            _context.next = 90;\n            return _finalBatch;\n          case 90:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[11, 63, 67, 77], [36, 48, 51, 54], [68,, 72, 76]]);\n  }));\n  return _parseJSONInBatches.apply(this, arguments);\n}\nfunction deduceSchema(rows) {\n  var row = rows[0];\n  var schema = {};\n  var i = 0;\n  for (var columnName in row) {\n    var value = row[columnName];\n    switch (_typeof(value)) {\n      case 'number':\n      case 'boolean':\n        schema[columnName] = {\n          name: String(columnName),\n          index: i,\n          type: Float32Array\n        };\n        break;\n      case 'object':\n        schema[columnName] = {\n          name: String(columnName),\n          index: i,\n          type: Array\n        };\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {\n          name: String(columnName),\n          index: i,\n          type: Array\n        };\n    }\n    i++;\n  }\n  return schema;\n}","map":{"version":3,"sources":["../../../src/lib/parse-json-in-batches.js"],"names":["makeTextDecoderIterator","TableBatchBuilder","StreamingJSONParser","parseJSONInBatches","asyncIterator","options","metadata","batchSize","_rootObjectBatches","jsonpaths","json","TableBatchType","TableBatch","isFirstChunk","tableBatchBuilder","schema","parser","chunk","rows","write","jsonpath","length","getStreamingJsonPathAsString","initialBatch","batchType","container","getPartialResult","data","bytesUsed","deduceSchema","row","addRow","isFull","getBatch","chunkComplete","batch","finalBatch","i","columnName","value","name","String","index","type","Float32Array","Array"],"mappings":"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","sourcesContent":["import {makeTextDecoderIterator} from '@loaders.gl/loader-utils';\nimport {TableBatchBuilder} from '@loaders.gl/tables';\nimport StreamingJSONParser from './parser/streaming-json-parser';\n\n// TODO - support batch size 0 = no batching/single batch?\n// eslint-disable-next-line max-statements, complexity\nexport default async function* parseJSONInBatches(asyncIterator, options) {\n  asyncIterator = makeTextDecoderIterator(asyncIterator);\n\n  const {metadata} = options;\n  const {batchSize, _rootObjectBatches, jsonpaths} = options.json;\n  const TableBatchType = options.json.TableBatch;\n\n  let isFirstChunk = true;\n  let tableBatchBuilder = null;\n  let schema = null;\n\n  const parser = new StreamingJSONParser({jsonpaths});\n  tableBatchBuilder =\n    // @ts-ignore\n    tableBatchBuilder || new TableBatchBuilder(TableBatchType, schema, {batchSize});\n\n  for await (const chunk of asyncIterator) {\n    const rows = parser.write(chunk);\n\n    const jsonpath = rows.length > 0 && parser.getStreamingJsonPathAsString();\n\n    if (rows.length > 0 && isFirstChunk) {\n      if (metadata) {\n        const initialBatch = {\n          batchType: 'partial-result',\n          container: parser.getPartialResult(),\n          data: [],\n          bytesUsed: 0,\n          schema: null,\n          jsonpath\n        };\n        yield initialBatch;\n      }\n      // Backwards compabitility\n      if (_rootObjectBatches) {\n        const initialBatch = {\n          batchType: 'root-object-batch-partial',\n          container: parser.getPartialResult(),\n          data: [],\n          schema: null\n        };\n        yield initialBatch;\n      }\n      isFirstChunk = false;\n      schema = deduceSchema(rows);\n    }\n\n    // Add the row\n    for (const row of rows) {\n      tableBatchBuilder.addRow(row);\n      // If a batch has been completed, emit it\n      if (tableBatchBuilder.isFull()) {\n        yield tableBatchBuilder.getBatch({jsonpath});\n      }\n    }\n\n    tableBatchBuilder.chunkComplete(chunk);\n    if (tableBatchBuilder.isFull()) {\n      yield tableBatchBuilder.getBatch({jsonpath});\n    }\n  }\n\n  // yield final batch\n  const jsonpath = parser.getStreamingJsonPathAsString();\n  const batch = tableBatchBuilder.getBatch({jsonpath});\n  if (batch) {\n    yield batch;\n  }\n\n  if (metadata) {\n    const finalBatch = {\n      batchType: 'final-result',\n      container: parser.getPartialResult(),\n      jsonpath: parser.getStreamingJsonPathAsString(),\n      data: [],\n      schema: null\n    };\n    yield finalBatch;\n  }\n  if (_rootObjectBatches) {\n    const finalBatch = {\n      batchType: 'root-object-batch-complete',\n      container: parser.getPartialResult(),\n      data: [],\n      schema: null\n    };\n    yield finalBatch;\n  }\n}\n\nfunction deduceSchema(rows) {\n  const row = rows[0];\n\n  const schema = {};\n  let i = 0;\n  for (const columnName in row) {\n    const value = row[columnName];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n\n      case 'object':\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n        break;\n\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n    i++;\n  }\n  return schema;\n}\n"]},"metadata":{},"sourceType":"module"}