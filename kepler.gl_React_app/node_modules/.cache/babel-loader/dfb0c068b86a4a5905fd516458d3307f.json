{"ast":null,"code":"export function processPickInfo(_ref) {\n  var pickInfo = _ref.pickInfo,\n    lastPickedInfo = _ref.lastPickedInfo,\n    mode = _ref.mode,\n    layers = _ref.layers,\n    viewports = _ref.viewports,\n    x = _ref.x,\n    y = _ref.y,\n    z = _ref.z,\n    pixelRatio = _ref.pixelRatio;\n  var pickedColor = pickInfo.pickedColor,\n    pickedLayer = pickInfo.pickedLayer,\n    pickedObjectIndex = pickInfo.pickedObjectIndex;\n  var affectedLayers = pickedLayer ? [pickedLayer] : [];\n  if (mode === 'hover') {\n    var lastPickedObjectIndex = lastPickedInfo.index;\n    var lastPickedLayerId = lastPickedInfo.layerId;\n    var pickedLayerId = pickedLayer && pickedLayer.props.id;\n    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {\n      if (pickedLayerId !== lastPickedLayerId) {\n        var lastPickedLayer = layers.find(function (layer) {\n          return layer.props.id === lastPickedLayerId;\n        });\n        if (lastPickedLayer) {\n          affectedLayers.unshift(lastPickedLayer);\n        }\n      }\n      lastPickedInfo.layerId = pickedLayerId;\n      lastPickedInfo.index = pickedObjectIndex;\n      lastPickedInfo.info = null;\n    }\n  }\n  var viewport = getViewportFromCoordinates({\n    viewports: viewports\n  });\n  var coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y], {\n    targetZ: z\n  });\n  var baseInfo = {\n    color: null,\n    layer: null,\n    index: -1,\n    picked: false,\n    x: x,\n    y: y,\n    pixel: [x, y],\n    coordinate: coordinate,\n    lngLat: coordinate,\n    devicePixel: [pickInfo.pickedX, pickInfo.pickedY],\n    pixelRatio: pixelRatio\n  };\n  var infos = new Map();\n  infos.set(null, baseInfo);\n  affectedLayers.forEach(function (layer) {\n    var info = Object.assign({}, baseInfo);\n    if (layer === pickedLayer) {\n      info.color = pickedColor;\n      info.index = pickedObjectIndex;\n      info.picked = true;\n    }\n    info = getLayerPickingInfo({\n      layer: layer,\n      info: info,\n      mode: mode\n    });\n    if (layer === pickedLayer && mode === 'hover') {\n      lastPickedInfo.info = info;\n    }\n    if (info) {\n      infos.set(info.layer.id, info);\n    }\n    if (mode === 'hover' && layer.props.autoHighlight) {\n      var pickingModuleParameters = {\n        pickingSelectedColor: pickedLayer === layer ? pickedColor : null\n      };\n      var highlightColor = layer.props.highlightColor;\n      if (pickedLayer === layer && typeof highlightColor === 'function') {\n        pickingModuleParameters.pickingHighlightColor = highlightColor(info);\n      }\n      layer.setModuleParameters(pickingModuleParameters);\n      layer.setNeedsRedraw();\n    }\n  });\n  return infos;\n}\nexport function getLayerPickingInfo(_ref2) {\n  var layer = _ref2.layer,\n    info = _ref2.info,\n    mode = _ref2.mode;\n  while (layer && info) {\n    var sourceLayer = info.layer || layer;\n    info.layer = layer;\n    info = layer.getPickingInfo({\n      info: info,\n      mode: mode,\n      sourceLayer: sourceLayer\n    });\n    layer = layer.parent;\n  }\n  return info;\n}\nfunction getViewportFromCoordinates(_ref3) {\n  var viewports = _ref3.viewports;\n  var viewport = viewports[0];\n  return viewport;\n}","map":{"version":3,"sources":["../../../../src/lib/picking/pick-info.js"],"names":["processPickInfo","pickInfo","lastPickedInfo","mode","layers","viewports","x","y","z","pixelRatio","pickedColor","pickedLayer","pickedObjectIndex","affectedLayers","lastPickedObjectIndex","index","lastPickedLayerId","layerId","pickedLayerId","props","id","lastPickedLayer","find","layer","unshift","info","viewport","getViewportFromCoordinates","coordinate","unproject","targetZ","baseInfo","color","picked","pixel","lngLat","devicePixel","pickedX","pickedY","infos","Map","set","forEach","Object","assign","getLayerPickingInfo","autoHighlight","pickingModuleParameters","pickingSelectedColor","highlightColor","pickingHighlightColor","setModuleParameters","setNeedsRedraw","sourceLayer","getPickingInfo","parent"],"mappings":"AAuBA,OAAO,SAASA,eAAT,CAAA,IAAA,EAUJ;EAAA,IATDC,QASC,GAAA,IAAA,CATDA,QASC;IARDC,cAQC,GAAA,IAAA,CARDA,cAQC;IAPDC,IAOC,GAAA,IAAA,CAPDA,IAOC;IANDC,MAMC,GAAA,IAAA,CANDA,MAMC;IALDC,SAKC,GAAA,IAAA,CALDA,SAKC;IAJDC,CAIC,GAAA,IAAA,CAJDA,CAIC;IAHDC,CAGC,GAAA,IAAA,CAHDA,CAGC;IAFDC,CAEC,GAAA,IAAA,CAFDA,CAEC;IADDC,UACC,GAAA,IAAA,CADDA,UACC;EAAA,IACMC,WADN,GACqDT,QADrD,CACMS,WADN;IACmBC,WADnB,GACqDV,QADrD,CACmBU,WADnB;IACgCC,iBADhC,GACqDX,QADrD,CACgCW,iBADhC;EAGD,IAAMC,cAAc,GAAGF,WAAW,GAAG,CAACA,WAAD,CAAH,GAAmB,EAArD;EAEA,IAAIR,IAAI,KAAK,OAAb,EAAsB;IAEpB,IAAMW,qBAAqB,GAAGZ,cAAc,CAACa,KAA7C;IACA,IAAMC,iBAAiB,GAAGd,cAAc,CAACe,OAAzC;IACA,IAAMC,aAAa,GAAGP,WAAW,IAAIA,WAAW,CAACQ,KAAZR,CAAkBS,EAAvD;IAGA,IAAIF,aAAa,KAAKF,iBAAlBE,IAAuCN,iBAAiB,KAAKE,qBAAjE,EAAwF;MACtF,IAAII,aAAa,KAAKF,iBAAtB,EAAyC;QAIvC,IAAMK,eAAe,GAAG,MAAM,CAACC,IAAP,CAAY,UAAA,KAAK,EAAA;UAAA,OAAIC,KAAK,CAACJ,KAANI,CAAYH,EAAZG,KAAmBP,iBAAvB;QAAA,CAAjB,CAAxB;QACA,IAAIK,eAAJ,EAAqB;UAEnBR,cAAc,CAACW,OAAfX,CAAuBQ,eAAvBR,CAAAA;QACD;MACF;MAGDX,cAAc,CAACe,OAAff,GAAyBgB,aAAzBhB;MACAA,cAAc,CAACa,KAAfb,GAAuBU,iBAAvBV;MACAA,cAAc,CAACuB,IAAfvB,GAAsB,IAAtBA;IACD;EACF;EAED,IAAMwB,QAAQ,GAAGC,0BAA0B,CAAC;IAACtB,SAAS,EAATA;EAAD,CAAD,CAA3C;EACA,IAAMuB,UAAU,GAAGF,QAAQ,IAAI,QAAQ,CAACG,SAAT,CAAmB,CAACvB,CAAC,GAAGoB,QAAQ,CAACpB,CAAd,EAAiBC,CAAC,GAAGmB,QAAQ,CAACnB,CAA9B,CAAnB,EAAqD;IAACuB,OAAO,EAAEtB;EAAV,CAArD,CAA/B;EAEA,IAAMuB,QAAQ,GAAG;IACfC,KAAK,EAAE,IADQ;IAEfT,KAAK,EAAE,IAFQ;IAGfR,KAAK,EAAE,CAAC,CAHO;IAIfkB,MAAM,EAAE,KAJO;IAKf3B,CAAC,EAADA,CALe;IAMfC,CAAC,EAADA,CANe;IAOf2B,KAAK,EAAE,CAAC5B,CAAD,EAAIC,CAAJ,CAPQ;IAQfqB,UAAU,EAAVA,UARe;IAUfO,MAAM,EAAEP,UAVO;IAWfQ,WAAW,EAAE,CAACnC,QAAQ,CAACoC,OAAV,EAAmBpC,QAAQ,CAACqC,OAA5B,CAXE;IAYf7B,UAAU,EAAVA;EAZe,CAAjB;EAmBA,IAAM8B,KAAK,GAAG,IAAIC,GAAJ,EAAd;EAGAD,KAAK,CAACE,GAANF,CAAU,IAAVA,EAAgBR,QAAhBQ,CAAAA;EAEA1B,cAAc,CAAC6B,OAAf7B,CAAuB,UAAA,KAAK,EAAI;IAC9B,IAAIY,IAAI,GAAGkB,MAAM,CAACC,MAAPD,CAAc,CAAA,CAAdA,EAAkBZ,QAAlBY,CAAX;IAEA,IAAIpB,KAAK,KAAKZ,WAAd,EAA2B;MACzBc,IAAI,CAACO,KAALP,GAAaf,WAAbe;MACAA,IAAI,CAACV,KAALU,GAAab,iBAAba;MACAA,IAAI,CAACQ,MAALR,GAAc,IAAdA;IACD;IAEDA,IAAI,GAAGoB,mBAAmB,CAAC;MAACtB,KAAK,EAALA,KAAD;MAAQE,IAAI,EAAJA,IAAR;MAActB,IAAI,EAAJA;IAAd,CAAD,CAA1BsB;IAEA,IAAIF,KAAK,KAAKZ,WAAVY,IAAyBpB,IAAI,KAAK,OAAtC,EAA+C;MAC7CD,cAAc,CAACuB,IAAfvB,GAAsBuB,IAAtBvB;IACD;IAID,IAAIuB,IAAJ,EAAU;MACRc,KAAK,CAACE,GAANF,CAAUd,IAAI,CAACF,KAALE,CAAWL,EAArBmB,EAAyBd,IAAzBc,CAAAA;IACD;IAED,IAAIpC,IAAI,KAAK,OAATA,IAAoBoB,KAAK,CAACJ,KAANI,CAAYuB,aAApC,EAAmD;MACjD,IAAMC,uBAAuB,GAAG;QAC9BC,oBAAoB,EAAErC,WAAW,KAAKY,KAAhBZ,GAAwBD,WAAxBC,GAAsC;MAD9B,CAAhC;MADiD,IAI1CsC,cAJ0C,GAIxB1B,KAAK,CAACJ,KAJkB,CAI1C8B,cAJ0C;MAKjD,IAAItC,WAAW,KAAKY,KAAhBZ,IAAyB,OAAOsC,cAAP,KAA0B,UAAvD,EAAmE;QACjEF,uBAAuB,CAACG,qBAAxBH,GAAgDE,cAAc,CAACxB,IAAD,CAA9DsB;MACD;MACDxB,KAAK,CAAC4B,mBAAN5B,CAA0BwB,uBAA1BxB,CAAAA;MAEAA,KAAK,CAAC6B,cAAN7B,EAAAA;IACD;EACF,CAjCDV,CAAAA;EAmCA,OAAO0B,KAAP;AACD;AAGD,OAAO,SAASM,mBAAT,CAAA,KAAA,EAAkD;EAAA,IAApBtB,KAAoB,GAAA,KAAA,CAApBA,KAAoB;IAAbE,IAAa,GAAA,KAAA,CAAbA,IAAa;IAAPtB,IAAO,GAAA,KAAA,CAAPA,IAAO;EACvD,OAAOoB,KAAK,IAAIE,IAAhB,EAAsB;IAKpB,IAAM4B,WAAW,GAAG5B,IAAI,CAACF,KAALE,IAAcF,KAAlC;IACAE,IAAI,CAACF,KAALE,GAAaF,KAAbE;IAIAA,IAAI,GAAG,KAAK,CAAC6B,cAAN,CAAqB;MAAC7B,IAAI,EAAJA,IAAD;MAAOtB,IAAI,EAAJA,IAAP;MAAakD,WAAW,EAAXA;IAAb,CAArB,CAAP5B;IACAF,KAAK,GAAGA,KAAK,CAACgC,MAAdhC;EACD;EACD,OAAOE,IAAP;AACD;AAOD,SAASE,0BAAT,CAAA,KAAA,EAAiD;EAAA,IAAZtB,SAAY,GAAA,KAAA,CAAZA,SAAY;EAC/C,IAAMqB,QAAQ,GAAGrB,SAAS,CAAC,CAAD,CAA1B;EACA,OAAOqB,QAAP;AACD","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// TODO - break this monster function into 3+ parts\n/* eslint-disable max-depth, max-statements */\n\nexport function processPickInfo({\n  pickInfo,\n  lastPickedInfo,\n  mode,\n  layers,\n  viewports,\n  x,\n  y,\n  z,\n  pixelRatio\n}) {\n  const {pickedColor, pickedLayer, pickedObjectIndex} = pickInfo;\n\n  const affectedLayers = pickedLayer ? [pickedLayer] : [];\n\n  if (mode === 'hover') {\n    // only invoke onHover events if picked object has changed\n    const lastPickedObjectIndex = lastPickedInfo.index;\n    const lastPickedLayerId = lastPickedInfo.layerId;\n    const pickedLayerId = pickedLayer && pickedLayer.props.id;\n\n    // proceed only if picked object changed\n    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {\n      if (pickedLayerId !== lastPickedLayerId) {\n        // We cannot store a ref to lastPickedLayer in the context because\n        // the state of an outdated layer is no longer valid\n        // and the props may have changed\n        const lastPickedLayer = layers.find(layer => layer.props.id === lastPickedLayerId);\n        if (lastPickedLayer) {\n          // Let leave event fire before enter event\n          affectedLayers.unshift(lastPickedLayer);\n        }\n      }\n\n      // Update layer manager context\n      lastPickedInfo.layerId = pickedLayerId;\n      lastPickedInfo.index = pickedObjectIndex;\n      lastPickedInfo.info = null;\n    }\n  }\n\n  const viewport = getViewportFromCoordinates({viewports}); // TODO - add coords\n  const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y], {targetZ: z});\n\n  const baseInfo = {\n    color: null,\n    layer: null,\n    index: -1,\n    picked: false,\n    x,\n    y,\n    pixel: [x, y],\n    coordinate,\n    // TODO remove the lngLat prop after compatibility check\n    lngLat: coordinate,\n    devicePixel: [pickInfo.pickedX, pickInfo.pickedY],\n    pixelRatio\n  };\n\n  // Use a Map to store all picking infos.\n  // The following two forEach loops are the result of\n  // https://github.com/visgl/deck.gl/issues/443\n  // Please be very careful when changing this pattern\n  const infos = new Map();\n\n  // Make sure infos always contain something even if no layer is affected\n  infos.set(null, baseInfo);\n\n  affectedLayers.forEach(layer => {\n    let info = Object.assign({}, baseInfo);\n\n    if (layer === pickedLayer) {\n      info.color = pickedColor;\n      info.index = pickedObjectIndex;\n      info.picked = true;\n    }\n\n    info = getLayerPickingInfo({layer, info, mode});\n\n    if (layer === pickedLayer && mode === 'hover') {\n      lastPickedInfo.info = info;\n    }\n\n    // This guarantees that there will be only one copy of info for\n    // one composite layer\n    if (info) {\n      infos.set(info.layer.id, info);\n    }\n\n    if (mode === 'hover' && layer.props.autoHighlight) {\n      const pickingModuleParameters = {\n        pickingSelectedColor: pickedLayer === layer ? pickedColor : null\n      };\n      const {highlightColor} = layer.props;\n      if (pickedLayer === layer && typeof highlightColor === 'function') {\n        pickingModuleParameters.pickingHighlightColor = highlightColor(info);\n      }\n      layer.setModuleParameters(pickingModuleParameters);\n      // setModuleParameters does not trigger redraw\n      layer.setNeedsRedraw();\n    }\n  });\n\n  return infos;\n}\n\n// Walk up the layer composite chain to populate the info object\nexport function getLayerPickingInfo({layer, info, mode}) {\n  while (layer && info) {\n    // For a composite layer, sourceLayer will point to the sublayer\n    // where the event originates from.\n    // It provides additional context for the composite layer's\n    // getPickingInfo() method to populate the info object\n    const sourceLayer = info.layer || layer;\n    info.layer = layer;\n    // layer.pickLayer() function requires a non-null ```layer.state```\n    // object to function properly. So the layer referenced here\n    // must be the \"current\" layer, not an \"out-dated\" / \"invalidated\" layer\n    info = layer.getPickingInfo({info, mode, sourceLayer});\n    layer = layer.parent;\n  }\n  return info;\n}\n\n// Indentifies which viewport, if any corresponds to x and y\n// Returns first viewport if no match\n// TODO - need to determine which viewport we are in\n// TODO - document concept of \"primary viewport\" that matches all coords?\n// TODO - static method on Viewport class?\nfunction getViewportFromCoordinates({viewports}) {\n  const viewport = viewports[0];\n  return viewport;\n}\n"]},"metadata":{},"sourceType":"module"}