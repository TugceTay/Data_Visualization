{"ast":null,"code":"import { padTo4Bytes, assert } from '@loaders.gl/loader-utils';\nvar MAGIC_glTF = 0x676c5446;\nvar GLB_FILE_HEADER_SIZE = 12;\nvar GLB_CHUNK_HEADER_SIZE = 8;\nvar GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nvar GLB_CHUNK_TYPE_BIN = 0x004e4942;\nvar GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;\nvar GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;\nvar GLB_V1_CONTENT_FORMAT_JSON = 0x0;\nvar LE = true;\nfunction getMagicString(dataView) {\n  var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return \"\".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));\n}\nexport function isGLB(arrayBuffer) {\n  var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var dataView = new DataView(arrayBuffer);\n  var _options$magic = options.magic,\n    magic = _options$magic === void 0 ? MAGIC_glTF : _options$magic;\n  var magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\nexport default function parseGLBSync(glb, arrayBuffer) {\n  var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var dataView = new DataView(arrayBuffer);\n  glb.type = getMagicString(dataView, byteOffset + 0);\n  glb.version = dataView.getUint32(byteOffset + 4, LE);\n  var byteLength = dataView.getUint32(byteOffset + 8, LE);\n  glb.header = {\n    byteOffset: byteOffset,\n    byteLength: byteLength\n  };\n  glb.json = {};\n  glb.binChunks = [];\n  byteOffset += GLB_FILE_HEADER_SIZE;\n  switch (glb.version) {\n    case 1:\n      return parseGLBV1(glb, dataView, byteOffset, options = {});\n    case 2:\n      return parseGLBV2(glb, dataView, byteOffset, options = {});\n    default:\n      throw new Error(\"Invalid GLB version \".concat(glb.version, \". Only supports v1 and v2.\"));\n  }\n}\nfunction parseGLBV1(glb, dataView, byteOffset, options) {\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  var contentLength = dataView.getUint32(byteOffset + 0, LE);\n  var contentFormat = dataView.getUint32(byteOffset + 4, LE);\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n  parseJSONChunk(glb, dataView, byteOffset, contentLength, options);\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength, options);\n  return byteOffset;\n}\nfunction parseGLBV2(glb, dataView, byteOffset, options) {\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n  return byteOffset + glb.header.byteLength;\n}\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    var chunkLength = dataView.getUint32(byteOffset + 0, LE);\n    var chunkFormat = dataView.getUint32(byteOffset + 4, LE);\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength, options);\n        break;\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.glb.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.glb.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength, options);\n        }\n        break;\n      default:\n        break;\n    }\n    byteOffset += padTo4Bytes(chunkLength);\n  }\n  return byteOffset;\n}\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength, options) {\n  var jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n  var textDecoder = new TextDecoder('utf8');\n  var jsonText = textDecoder.decode(jsonChunk);\n  glb.json = JSON.parse(jsonText);\n  return padTo4Bytes(chunkLength);\n}\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength, options) {\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset: byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n  });\n  return padTo4Bytes(chunkLength);\n}","map":{"version":3,"sources":["../../../src/lib/parse-glb.js"],"names":["padTo4Bytes","assert","MAGIC_glTF","GLB_FILE_HEADER_SIZE","GLB_CHUNK_HEADER_SIZE","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED","GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED","GLB_V1_CONTENT_FORMAT_JSON","LE","getMagicString","dataView","byteOffset","String","fromCharCode","getUint8","isGLB","arrayBuffer","options","DataView","magic","magic1","getUint32","parseGLBSync","glb","type","version","byteLength","header","json","binChunks","parseGLBV1","parseGLBV2","Error","contentLength","contentFormat","parseJSONChunk","parseBINChunk","parseGLBChunksSync","chunkLength","chunkFormat","strict","jsonChunk","Uint8Array","buffer","textDecoder","TextDecoder","jsonText","decode","JSON","parse","hasBinChunk","push"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements */\n/* global TextDecoder */\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\nimport {padTo4Bytes, assert} from '@loaders.gl/loader-utils';\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0; // DEPRECATED - Backward compatibility for old xviz files\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1; // DEPRECATED - Backward compatibility for old xviz files\n\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n\nconst LE = true; // Binary GLTF is little endian.\n\nfunction getMagicString(dataView, byteOffset = 0) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n\n// Check if a data view is a GLB\nexport function isGLB(arrayBuffer, byteOffset = 0, options = {}) {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {magic = MAGIC_glTF} = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n\nexport default function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  // Compare format with GLBLoader documentation\n  glb.type = getMagicString(dataView, byteOffset + 0);\n  glb.version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  const byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of binary file\n\n  // Put less important stuff in a header, to avoid clutter\n  glb.header = {\n    byteOffset, // Byte offset into the initial arrayBuffer\n    byteLength\n  };\n\n  // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n  glb.json = {};\n  glb.binChunks = [];\n\n  byteOffset += GLB_FILE_HEADER_SIZE;\n\n  switch (glb.version) {\n    case 1:\n      // eslint-disable-next-line\n      return parseGLBV1(glb, dataView, byteOffset, (options = {}));\n    case 2:\n      return parseGLBV2(glb, dataView, byteOffset, (options = {}));\n    default:\n      throw new Error(`Invalid GLB version ${glb.version}. Only supports v1 and v2.`);\n  }\n}\n\nfunction parseGLBV1(glb, dataView, byteOffset, options) {\n  // Sanity: ensure file is big enough to hold at least the headers\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  // Explanation of GLB structure:\n  // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n  const contentLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n  const contentFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n  // GLB v1 only supports a single chunk type\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n\n  parseJSONChunk(glb, dataView, byteOffset, contentLength, options);\n  // No need to call the function padTo4Bytes() from parseJSONChunk()\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength, options);\n\n  return byteOffset;\n}\n\nfunction parseGLBV2(glb, dataView, byteOffset, options) {\n  // Sanity: ensure file is big enough to hold at least the first chunk header\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n  // Iterate as long as there is space left for another chunk header\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength, options);\n        break;\n\n      // Backward compatibility for very old xviz files\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.glb.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.glb.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength, options);\n        }\n        break;\n\n      default:\n        // Ignore, per spec\n        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n        break;\n    }\n\n    byteOffset += padTo4Bytes(chunkLength);\n  }\n\n  return byteOffset;\n}\n\n// Parse a GLB JSON chunk\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength, options) {\n  // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n\n  // 2. Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // 3. Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n\n  return padTo4Bytes(chunkLength);\n}\n\n// Parse a GLB BIN chunk\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength, options) {\n  // Note: BIN chunk can be optional\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n    // TODO - copy, or create typed array view?\n  });\n\n  return padTo4Bytes(chunkLength);\n}\n"]},"metadata":{},"sourceType":"module"}