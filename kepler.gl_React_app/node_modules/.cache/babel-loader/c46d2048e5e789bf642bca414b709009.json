{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Model, Geometry, FEATURES, hasFeatures } from '@luma.gl/core';\nimport { Layer, log, picking } from '@deck.gl/core';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\nvar DEFAULT_MINCOLOR = [0, 0, 0, 0];\nvar DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nvar COLOR_PROPS = [\"minColor\", \"maxColor\", \"colorRange\", \"colorDomain\"];\nvar defaultProps = {\n  cellSizePixels: {\n    value: 100,\n    min: 1\n  },\n  cellMarginPixels: {\n    value: 2,\n    min: 0,\n    max: 5\n  },\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\nvar ScreenGridCellLayer = function (_Layer) {\n  _inherits(ScreenGridCellLayer, _Layer);\n  function ScreenGridCellLayer() {\n    _classCallCheck(this, ScreenGridCellLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScreenGridCellLayer).apply(this, arguments));\n  }\n  _createClass(ScreenGridCellLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return {\n        vs: vs,\n        fs: fs,\n        modules: [picking]\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var gl = this.context.gl;\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instancePositions: {\n          size: 3,\n          update: this.calculateInstancePositions\n        },\n        instanceCounts: {\n          size: 4,\n          noAlloc: true\n        }\n      });\n      this.setState({\n        model: this._getModel(gl)\n      });\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var oldProps = _ref2.oldProps,\n        props = _ref2.props,\n        changeFlags = _ref2.changeFlags;\n      _get(_getPrototypeOf(ScreenGridCellLayer.prototype), \"updateState\", this).call(this, {\n        oldProps: oldProps,\n        props: props,\n        changeFlags: changeFlags\n      });\n      var attributeManager = this.getAttributeManager();\n      if (props.numInstances !== oldProps.numInstances) {\n        attributeManager.invalidateAll();\n      } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n        attributeManager.invalidate('instancePositions');\n      }\n      this._updateUniforms(oldProps, props, changeFlags);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref3) {\n      var uniforms = _ref3.uniforms;\n      var _this$props = this.props,\n        parameters = _this$props.parameters,\n        maxTexture = _this$props.maxTexture;\n      var minColor = this.props.minColor || DEFAULT_MINCOLOR;\n      var maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n      var colorDomain = this.props.colorDomain || [1, 0];\n      var model = this.state.model;\n      var layerUniforms = {\n        minColor: minColor,\n        maxColor: maxColor,\n        maxTexture: maxTexture,\n        colorDomain: colorDomain\n      };\n      uniforms = Object.assign(layerUniforms, uniforms);\n      model.draw({\n        uniforms: uniforms,\n        parameters: Object.assign({\n          depthTest: false,\n          depthMask: false\n        }, parameters)\n      });\n    }\n  }, {\n    key: \"calculateInstancePositions\",\n    value: function calculateInstancePositions(attribute, _ref4) {\n      var numInstances = _ref4.numInstances;\n      var _this$context$viewpor = this.context.viewport,\n        width = _this$context$viewpor.width,\n        height = _this$context$viewpor.height;\n      var cellSizePixels = this.props.cellSizePixels;\n      var numCol = Math.ceil(width / cellSizePixels);\n      var value = attribute.value,\n        size = attribute.size;\n      for (var i = 0; i < numInstances; i++) {\n        var x = i % numCol;\n        var y = Math.floor(i / numCol);\n        value[i * size + 0] = x * cellSizePixels / width * 2 - 1;\n        value[i * size + 1] = 1 - y * cellSizePixels / height * 2;\n        value[i * size + 2] = 0;\n      }\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 6,\n          attributes: {\n            positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n          }\n        }),\n        isInstanced: true\n      }));\n    }\n  }, {\n    key: \"_shouldUseMinMax\",\n    value: function _shouldUseMinMax() {\n      var _this$props2 = this.props,\n        minColor = _this$props2.minColor,\n        maxColor = _this$props2.maxColor,\n        colorDomain = _this$props2.colorDomain,\n        colorRange = _this$props2.colorRange;\n      if (minColor || maxColor) {\n        log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n        return true;\n      }\n      if (colorDomain || colorRange) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"_updateUniforms\",\n    value: function _updateUniforms(oldProps, props, changeFlags) {\n      var model = this.state.model;\n      if (COLOR_PROPS.some(function (key) {\n        return oldProps[key] !== props[key];\n      })) {\n        model.setUniforms({\n          shouldUseMinMax: this._shouldUseMinMax()\n        });\n      }\n      if (oldProps.colorRange !== props.colorRange) {\n        model.setUniforms({\n          colorRange: colorRangeToFlatArray(props.colorRange)\n        });\n      }\n      if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {\n        var _this$context$viewpor2 = this.context.viewport,\n          width = _this$context$viewpor2.width,\n          height = _this$context$viewpor2.height;\n        var _this$props3 = this.props,\n          cellSizePixels = _this$props3.cellSizePixels,\n          cellMarginPixels = _this$props3.cellMarginPixels;\n        var margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n        var cellScale = new Float32Array([(cellSizePixels - margin) / width * 2, -(cellSizePixels - margin) / height * 2, 1]);\n        model.setUniforms({\n          cellScale: cellScale\n        });\n      }\n    }\n  }], [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n    }\n  }]);\n  return ScreenGridCellLayer;\n}(Layer);\nexport { ScreenGridCellLayer as default };\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/screen-grid-layer/screen-grid-cell-layer.js"],"names":["Model","Geometry","FEATURES","hasFeatures","Layer","log","picking","defaultColorRange","colorRangeToFlatArray","vs","fs","DEFAULT_MINCOLOR","DEFAULT_MAXCOLOR","COLOR_PROPS","defaultProps","cellSizePixels","value","min","cellMarginPixels","max","colorDomain","colorRange","ScreenGridCellLayer","gl","TEXTURE_FLOAT","modules","context","attributeManager","getAttributeManager","addInstanced","instancePositions","size","update","calculateInstancePositions","instanceCounts","noAlloc","setState","model","_getModel","changeFlags","somethingChanged","oldProps","props","numInstances","invalidateAll","invalidate","_updateUniforms","uniforms","parameters","maxTexture","minColor","maxColor","state","layerUniforms","Object","assign","draw","depthTest","depthMask","attribute","width","height","viewport","numCol","Math","ceil","i","x","y","floor","getShaders","id","geometry","drawMode","attributes","positions","Float32Array","isInstanced","deprecated","some","key","setUniforms","shouldUseMinMax","_shouldUseMinMax","viewportChanged","margin","cellScale","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, FEATURES, hasFeatures} from '@luma.gl/core';\nimport {Layer, log, picking} from '@deck.gl/core';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\n\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = [`minColor`, `maxColor`, `colorRange`, `colorDomain`];\n\nconst defaultProps = {\n  cellSizePixels: {value: 100, min: 1},\n  cellMarginPixels: {value: 2, min: 0, max: 5},\n\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\n\nexport default class ScreenGridCellLayer extends Layer {\n  static isSupported(gl) {\n    return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n  }\n\n  getShaders() {\n    return {vs, fs, modules: [picking]};\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {size: 3, update: this.calculateInstancePositions},\n      instanceCounts: {size: 4, noAlloc: true}\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    // 'instanceCounts' buffer contetns change on viewport change.\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({oldProps, props, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n    if (props.numInstances !== oldProps.numInstances) {\n      attributeManager.invalidateAll();\n    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n      attributeManager.invalidate('instancePositions');\n    }\n\n    this._updateUniforms(oldProps, props, changeFlags);\n  }\n\n  draw({uniforms}) {\n    const {parameters, maxTexture} = this.props;\n    const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n\n    // If colorDomain not specified we use default domain [1, maxCount]\n    // maxCount value will be sampled form maxTexture in vertex shader.\n    const colorDomain = this.props.colorDomain || [1, 0];\n    const {model} = this.state;\n    const layerUniforms = {\n      minColor,\n      maxColor,\n      maxTexture,\n      colorDomain\n    };\n\n    uniforms = Object.assign(layerUniforms, uniforms);\n    model.draw({\n      uniforms,\n      parameters: Object.assign(\n        {\n          depthTest: false,\n          depthMask: false\n        },\n        parameters\n      )\n    });\n  }\n\n  calculateInstancePositions(attribute, {numInstances}) {\n    const {width, height} = this.context.viewport;\n    const {cellSizePixels} = this.props;\n    const numCol = Math.ceil(width / cellSizePixels);\n\n    const {value, size} = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = ((x * cellSizePixels) / width) * 2 - 1;\n      value[i * size + 1] = 1 - ((y * cellSizePixels) / height) * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  // Private Methods\n\n  _getModel(gl) {\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLE_FAN,\n          attributes: {\n            positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n          }\n        }),\n        isInstanced: true\n      })\n    );\n  }\n\n  _shouldUseMinMax() {\n    const {minColor, maxColor, colorDomain, colorRange} = this.props;\n    if (minColor || maxColor) {\n      log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n      return true;\n    }\n    // minColor and maxColor not supplied, check if colorRange or colorDomain supplied.\n    // NOTE: colorDomain and colorRange are experimental features, use them only when supplied.\n    if (colorDomain || colorRange) {\n      return false;\n    }\n    // None specified, use default minColor and maxColor\n    return true;\n  }\n\n  _updateUniforms(oldProps, props, changeFlags) {\n    const {model} = this.state;\n    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n      model.setUniforms({shouldUseMinMax: this._shouldUseMinMax()});\n    }\n\n    if (oldProps.colorRange !== props.colorRange) {\n      model.setUniforms({colorRange: colorRangeToFlatArray(props.colorRange)});\n    }\n\n    if (\n      oldProps.cellMarginPixels !== props.cellMarginPixels ||\n      oldProps.cellSizePixels !== props.cellSizePixels ||\n      changeFlags.viewportChanged\n    ) {\n      const {width, height} = this.context.viewport;\n      const {cellSizePixels, cellMarginPixels} = this.props;\n      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n\n      const cellScale = new Float32Array([\n        ((cellSizePixels - margin) / width) * 2,\n        (-(cellSizePixels - margin) / height) * 2,\n        1\n      ]);\n      model.setUniforms({cellScale});\n    }\n  }\n}\n\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}