{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setFilterGpuMode = setFilterGpuMode;\nexports.assignGpuChannels = assignGpuChannels;\nexports.assignGpuChannel = assignGpuChannel;\nexports.resetFilterGpuMode = resetFilterGpuMode;\nexports.getGpuFilterProps = getGpuFilterProps;\nexports.getDatasetFieldIndexForFilter = getDatasetFieldIndexForFilter;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _utils = require(\"./utils\");\nvar _defaultSettings = require(\"../constants/default-settings\");\nvar _dataUtils = require(\"./data-utils\");\nvar _moment = _interopRequireDefault(require(\"moment\"));\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n/**\n * Set gpu mode based on current number of gpu filters exists\n * @type {typeof import('./gpu-filter-utils').setFilterGpuMode}\n */\nfunction setFilterGpuMode(filter, filters) {\n  // filter can be applied to multiple datasets, hence gpu filter mode should also be\n  // an array, however, to keep us sane, for now, we only check if there is available channel for every dataId,\n  // if all of them has, we set gpu mode to true\n  // TODO: refactor filter so we don't keep an array of everything\n  filter.dataId.forEach(function (dataId, datasetIdx) {\n    var gpuFilters = filters.filter(function (f) {\n      return f.dataId.includes(dataId) && f.gpu;\n    });\n    if (filter.gpu && gpuFilters.length === _defaultSettings.MAX_GPU_FILTERS) {\n      return (0, _utils.set)(['gpu'], false, filter);\n    }\n  });\n  return filter;\n}\n/**\n * Scan though all filters and assign gpu chanel to gpu filter\n * @type {typeof import('./gpu-filter-utils').assignGpuChannels}\n */\n\nfunction assignGpuChannels(allFilters) {\n  return allFilters.reduce(function (accu, f, index) {\n    var filters = accu; // if gpu is true assign and validate gpu Channel\n\n    if (f.gpu) {\n      f = assignGpuChannel(f, accu);\n      filters = (0, _utils.set)([index], f, accu);\n    }\n    return filters;\n  }, allFilters);\n}\n/**\n * Assign a new gpu filter a channel based on first availability\n * @type {typeof import('./gpu-filter-utils').assignGpuChannel}\n */\n\nfunction assignGpuChannel(filter, filters) {\n  // find first available channel\n  if (!filter.gpu) {\n    return filter;\n  }\n  var gpuChannel = filter.gpuChannel || [];\n  filter.dataId.forEach(function (dataId, datasetIdx) {\n    var findGpuChannel = function findGpuChannel(channel) {\n      return function (f) {\n        var dataIdx = (0, _utils.toArray)(f.dataId).indexOf(dataId);\n        return f.id !== filter.id && dataIdx > -1 && f.gpu && (0, _utils.toArray)(f.gpuChannel)[dataIdx] === channel;\n      };\n    };\n    if (Number.isFinite(gpuChannel[datasetIdx]) && !filters.find(findGpuChannel(gpuChannel[datasetIdx]))) {\n      // if value is already assigned and valid\n      return;\n    }\n    var i = 0;\n    while (i < _defaultSettings.MAX_GPU_FILTERS) {\n      if (!filters.find(findGpuChannel(i))) {\n        gpuChannel[datasetIdx] = i;\n        return;\n      }\n      i++;\n    }\n  }); // if cannot find channel for all dataid, set gpu back to false\n  // TODO: refactor filter to handle same filter different gpu mode\n\n  if (!gpuChannel.length || !gpuChannel.every(Number.isFinite)) {\n    return _objectSpread(_objectSpread({}, filter), {}, {\n      gpu: false\n    });\n  }\n  return _objectSpread(_objectSpread({}, filter), {}, {\n    gpuChannel: gpuChannel\n  });\n}\n/**\n * Edit filter.gpu to ensure that only\n * X number of gpu filers can coexist.\n * @type {typeof import('./gpu-filter-utils').resetFilterGpuMode}\n */\n\nfunction resetFilterGpuMode(filters) {\n  var gpuPerDataset = {};\n  return filters.map(function (f, i) {\n    if (f.gpu) {\n      var gpu = true;\n      (0, _utils.toArray)(f.dataId).forEach(function (dataId) {\n        var count = gpuPerDataset[dataId];\n        if (count === _defaultSettings.MAX_GPU_FILTERS) {\n          gpu = false;\n        } else {\n          gpuPerDataset[dataId] = count ? count + 1 : 1;\n        }\n      });\n      if (!gpu) {\n        return (0, _utils.set)(['gpu'], false, f);\n      }\n    }\n    return f;\n  });\n}\n/**\n * Initial filter uniform\n * @returns {Array<Array<Number>>}\n */\n\nfunction getEmptyFilterRange() {\n  return new Array(_defaultSettings.MAX_GPU_FILTERS).fill(0).map(function (d) {\n    return [0, 0];\n  });\n}\n/**\n * Returns index of the data element.\n * @param {any} d Data element with row index info.\n * @returns number\n */\n\nvar defaultGetIndex = function defaultGetIndex(d) {\n  return d.index;\n};\n/**\n * Returns value at the specified row from the data container.\n * @param {import('./table-utils/data-container-interface').DataContainerInterface} dc Data container.\n * @param {any} d Data element with row index info.\n * @param {number} fieldIndex Column index in the data container.\n * @returns\n */\n\nvar defaultGetData = function defaultGetData(dc, d, fieldIndex) {\n  return dc.valueAt(d.index, fieldIndex);\n};\n/**\n * @param {Array<Object>} channels\n * @param {string} dataId\n * @param {Array<Object>} fields\n * @return {Function} getFilterValue\n */\n\nvar getFilterValueAccessor = function getFilterValueAccessor(channels, dataId, fields) {\n  return function (dc) {\n    return function () {\n      var getIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetIndex;\n      var getData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetData;\n      return function (d) {\n        return (\n          // for empty channel, value is 0 and min max would be [0, 0]\n          channels.map(function (filter) {\n            if (!filter) {\n              return 0;\n            }\n            var fieldIndex = getDatasetFieldIndexForFilter(dataId, filter);\n            var field = fields[fieldIndex];\n            var value = filter.type === _defaultSettings.FILTER_TYPES.timeRange ? field.filterProps && Array.isArray(field.filterProps.mappedValue) ? field.filterProps.mappedValue[getIndex(d)] : _moment[\"default\"].utc(getData(dc, d, fieldIndex)).valueOf() : getData(dc, d, fieldIndex);\n            return (0, _dataUtils.notNullorUndefined)(value) ? value - filter.domain[0] : Number.MIN_SAFE_INTEGER;\n          })\n        );\n      };\n    };\n  };\n};\n/**\n * Get filter properties for gpu filtering\n * @type {typeof import('./gpu-filter-utils').getGpuFilterProps}\n */\n\nfunction getGpuFilterProps(filters, dataId, fields) {\n  var filterRange = getEmptyFilterRange();\n  var triggers = {}; // array of filter for each channel, undefined, if no filter is assigned to that channel\n\n  var channels = [];\n  var _loop = function _loop(i) {\n    var filter = filters.find(function (f) {\n      return f.gpu && f.dataId.includes(dataId) && f.gpuChannel && f.gpuChannel[f.dataId.indexOf(dataId)] === i;\n    }); // @ts-ignore\n\n    filterRange[i][0] = filter ? filter.value[0] - filter.domain[0] : 0; // @ts-ignore\n\n    filterRange[i][1] = filter ? filter.value[1] - filter.domain[0] : 0;\n    triggers[\"gpuFilter_\".concat(i)] = filter ? filter.name[filter.dataId.indexOf(dataId)] : null;\n    channels.push(filter);\n  };\n  for (var i = 0; i < _defaultSettings.MAX_GPU_FILTERS; i++) {\n    _loop(i);\n  }\n  var filterValueAccessor = getFilterValueAccessor(channels, dataId, fields);\n  return {\n    filterRange: filterRange,\n    filterValueUpdateTriggers: triggers,\n    filterValueAccessor: filterValueAccessor\n  };\n}\n/**\n * Return dataset field index from filter.fieldIdx\n * The index matches the same dataset index for filter.dataId\n * @type {typeof import('./gpu-filter-utils').getDatasetFieldIndexForFilter}\n */\n\nfunction getDatasetFieldIndexForFilter(dataId, filter) {\n  var datasetIndex = (0, _utils.toArray)(filter.dataId).indexOf(dataId);\n  if (datasetIndex < 0) {\n    return -1;\n  }\n  var fieldIndex = filter.fieldIdx[datasetIndex];\n  return (0, _dataUtils.notNullorUndefined)(fieldIndex) ? fieldIndex : -1;\n}","map":{"version":3,"sources":["../../src/utils/gpu-filter-utils.js"],"names":["setFilterGpuMode","filter","filters","dataId","forEach","datasetIdx","gpuFilters","f","includes","gpu","length","MAX_GPU_FILTERS","assignGpuChannels","allFilters","reduce","accu","index","assignGpuChannel","gpuChannel","findGpuChannel","dataIdx","indexOf","id","channel","Number","isFinite","find","i","every","resetFilterGpuMode","gpuPerDataset","map","count","getEmptyFilterRange","Array","fill","defaultGetIndex","d","defaultGetData","dc","fieldIndex","valueAt","getFilterValueAccessor","channels","fields","getIndex","getData","getDatasetFieldIndexForFilter","field","value","type","FILTER_TYPES","timeRange","filterProps","isArray","mappedValue","moment","utc","valueOf","domain","MIN_SAFE_INTEGER","getGpuFilterProps","filterRange","triggers","name","push","filterValueAccessor","filterValueUpdateTriggers","datasetIndex","fieldIdx"],"mappings":";;;;;;;;;;;;;AAoBA,IAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AACA,IAAA,gBAAA,GAAA,OAAA,CAAA,+BAAA,CAAA;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AACA,IAAA,OAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACO,SAASA,gBAAT,CAA0BC,MAA1B,EAAkCC,OAAlC,EAA2C;EAChD;EACA;EACA;EACA;EAEAD,MAAM,CAACE,MAAPF,CAAcG,OAAdH,CAAsB,UAACE,MAAD,EAASE,UAAT,EAAwB;IAC5C,IAAMC,UAAU,GAAG,OAAO,CAACL,MAAR,CAAe,UAAA,CAAC,EAAA;MAAA,OAAIM,CAAC,CAACJ,MAAFI,CAASC,QAATD,CAAkBJ,MAAlBI,CAAAA,IAA6BA,CAAC,CAACE,GAAnC;IAAA,CAAhB,CAAnB;IAEA,IAAIR,MAAM,CAACQ,GAAPR,IAAcK,UAAU,CAACI,MAAXJ,KAAsBK,gBAAAA,CAAAA,eAAxC,EAAyD;MACvD,OAAO,CAAA,CAAA,EAAA,MAAA,CAAA,GAAA,EAAI,CAAC,KAAD,CAAJ,EAAa,KAAb,EAAoBV,MAApB,CAAP;IACD;EACF,CANDA,CAAAA;EAQA,OAAOA,MAAP;AACD;AAED;AACA;AACA;AACA;;AACO,SAASW,iBAAT,CAA2BC,UAA3B,EAAuC;EAC5C,OAAO,UAAU,CAACC,MAAX,CAAkB,UAACC,IAAD,EAAOR,CAAP,EAAUS,KAAV,EAAoB;IAC3C,IAAId,OAAO,GAAGa,IAAd,CAD2C,CAG3C;;IACA,IAAIR,CAAC,CAACE,GAAN,EAAW;MACTF,CAAC,GAAGU,gBAAgB,CAACV,CAAD,EAAIQ,IAAJ,CAApBR;MACAL,OAAO,GAAG,CAAA,CAAA,EAAA,MAAA,CAAA,GAAA,EAAI,CAACc,KAAD,CAAJ,EAAaT,CAAb,EAAgBQ,IAAhB,CAAVb;IACD;IAED,OAAOA,OAAP;EACD,CAVM,EAUJW,UAVI,CAAP;AAWD;AACD;AACA;AACA;AACA;;AACO,SAASI,gBAAT,CAA0BhB,MAA1B,EAAkCC,OAAlC,EAA2C;EAChD;EACA,IAAI,CAACD,MAAM,CAACQ,GAAZ,EAAiB;IACf,OAAOR,MAAP;EACD;EAED,IAAMiB,UAAU,GAAGjB,MAAM,CAACiB,UAAPjB,IAAqB,EAAxC;EAEAA,MAAM,CAACE,MAAPF,CAAcG,OAAdH,CAAsB,UAACE,MAAD,EAASE,UAAT,EAAwB;IAC5C,IAAMc,cAAc,GAAG,SAAjBA,cAAiB,CAAA,OAAO,EAAA;MAAA,OAAI,UAAA,CAAC,EAAI;QACrC,IAAMC,OAAO,GAAG,CAAA,CAAA,EAAA,MAAA,CAAA,OAAA,EAAQb,CAAC,CAACJ,MAAV,CAAA,CAAkBkB,OAAlB,CAA0BlB,MAA1B,CAAhB;QACA,OACEI,CAAC,CAACe,EAAFf,KAASN,MAAM,CAACqB,EAAhBf,IAAsBa,OAAO,GAAG,CAAC,CAAjCb,IAAsCA,CAAC,CAACE,GAAxCF,IAA+C,CAAA,CAAA,EAAA,MAAA,CAAA,OAAA,EAAQA,CAAC,CAACW,UAAV,CAAA,CAAsBE,OAAtB,CAAA,KAAmCG,OADpF;MAGD,CAL6B;IAAA,CAA9B;IAOA,IACEC,MAAM,CAACC,QAAPD,CAAgBN,UAAU,CAACb,UAAD,CAA1BmB,CAAAA,IACA,CAACtB,OAAO,CAACwB,IAARxB,CAAaiB,cAAc,CAACD,UAAU,CAACb,UAAD,CAAX,CAA3BH,CAFH,EAGE;MACA;MACA;IACD;IAED,IAAIyB,CAAC,GAAG,CAAR;IAEA,OAAOA,CAAC,GAAGhB,gBAAAA,CAAAA,eAAX,EAA4B;MAC1B,IAAI,CAACT,OAAO,CAACwB,IAARxB,CAAaiB,cAAc,CAACQ,CAAD,CAA3BzB,CAAL,EAAsC;QACpCgB,UAAU,CAACb,UAAD,CAAVa,GAAyBS,CAAzBT;QACA;MACD;MACDS,CAAC,EAAA;IACF;EACF,CAzBD1B,CAAAA,CARgD,CAmChD;EACA;;EACA,IAAI,CAACiB,UAAU,CAACR,MAAZ,IAAsB,CAACQ,UAAU,CAACU,KAAXV,CAAiBM,MAAM,CAACC,QAAxBP,CAA3B,EAA8D;IAC5D,OAAA,aAAA,CAAA,aAAA,CAAA,CAAA,CAAA,EACKjB,MADL,CAAA,EAAA,CAAA,CAAA,EAAA;MAEEQ,GAAG,EAAE;IAFP,CAAA,CAAA;EAID;EAED,OAAA,aAAA,CAAA,aAAA,CAAA,CAAA,CAAA,EACKR,MADL,CAAA,EAAA,CAAA,CAAA,EAAA;IAEEiB,UAAU,EAAVA;EAFF,CAAA,CAAA;AAID;AACD;AACA;AACA;AACA;AACA;;AACO,SAASW,kBAAT,CAA4B3B,OAA5B,EAAqC;EAC1C,IAAM4B,aAAa,GAAG,CAAA,CAAtB;EAEA,OAAO,OAAO,CAACC,GAAR,CAAY,UAACxB,CAAD,EAAIoB,CAAJ,EAAU;IAC3B,IAAIpB,CAAC,CAACE,GAAN,EAAW;MACT,IAAIA,GAAG,GAAG,IAAV;MACA,CAAA,CAAA,EAAA,MAAA,CAAA,OAAA,EAAQF,CAAC,CAACJ,MAAV,CAAA,CAAkBC,OAAlB,CAA0B,UAAA,MAAM,EAAI;QAClC,IAAM4B,KAAK,GAAGF,aAAa,CAAC3B,MAAD,CAA3B;QAEA,IAAI6B,KAAK,KAAKrB,gBAAAA,CAAAA,eAAd,EAA+B;UAC7BF,GAAG,GAAG,KAANA;QACD,CAFD,MAEO;UACLqB,aAAa,CAAC3B,MAAD,CAAb2B,GAAwBE,KAAK,GAAGA,KAAK,GAAG,CAAX,GAAe,CAA5CF;QACD;MACF,CARD,CAAA;MAUA,IAAI,CAACrB,GAAL,EAAU;QACR,OAAO,CAAA,CAAA,EAAA,MAAA,CAAA,GAAA,EAAI,CAAC,KAAD,CAAJ,EAAa,KAAb,EAAoBF,CAApB,CAAP;MACD;IACF;IAED,OAAOA,CAAP;EACD,CAnBM,CAAP;AAoBD;AAED;AACA;AACA;AACA;;AACA,SAAS0B,mBAAT,GAA+B;EAC7B,OAAO,IAAIC,KAAJ,CAAUvB,gBAAAA,CAAAA,eAAV,CAAA,CAA2BwB,IAA3B,CAAgC,CAAhC,CAAA,CAAmCJ,GAAnC,CAAuC,UAAA,CAAC,EAAA;IAAA,OAAI,CAAC,CAAD,EAAI,CAAJ,CAAJ;EAAA,CAAxC,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;AACA,IAAMK,eAAe,GAAG,SAAlBA,eAAkB,CAAA,CAAC,EAAA;EAAA,OAAIC,CAAC,CAACrB,KAAN;AAAA,CAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMsB,cAAc,GAAG,SAAjBA,cAAiB,CAACC,EAAD,EAAKF,CAAL,EAAQG,UAAR,EAAuB;EAC5C,OAAOD,EAAE,CAACE,OAAHF,CAAWF,CAAC,CAACrB,KAAbuB,EAAoBC,UAApBD,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMG,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACC,QAAD,EAAWxC,MAAX,EAAmByC,MAAnB,EAAA;EAAA,OAA8B,UAAA,EAAE,EAAA;IAAA,OAAI,YAAA;MAAA,IACjEC,QADiE,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GACtDT,eADsD;MAAA,IAEjEU,OAFiE,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAEvDR,cAFuD;MAAA,OAG9D,UAAA,CAAC,EAAA;QAAA;UACJ;UACAK,QAAQ,CAACZ,GAATY,CAAa,UAAA,MAAM,EAAI;YACrB,IAAI,CAAC1C,MAAL,EAAa;cACX,OAAO,CAAP;YACD;YACD,IAAMuC,UAAU,GAAGO,6BAA6B,CAAC5C,MAAD,EAASF,MAAT,CAAhD;YACA,IAAM+C,KAAK,GAAGJ,MAAM,CAACJ,UAAD,CAApB;YAEA,IAAMS,KAAK,GACThD,MAAM,CAACiD,IAAPjD,KAAgBkD,gBAAAA,CAAAA,YAAAA,CAAaC,SAA7BnD,GACI+C,KAAK,CAACK,WAANL,IAAqBd,KAAK,CAACoB,OAANpB,CAAcc,KAAK,CAACK,WAANL,CAAkBO,WAAhCrB,CAArBc,GACEA,KAAK,CAACK,WAANL,CAAkBO,WAAlBP,CAA8BH,QAAQ,CAACR,CAAD,CAAtCW,CADFA,GAEEQ,OAAAA,CAAAA,SAAAA,CAAAA,CAAOC,GAAPD,CAAWV,OAAO,CAACP,EAAD,EAAKF,CAAL,EAAQG,UAAR,CAAlBgB,CAAAA,CAAuCE,OAAvCF,EAHNvD,GAII6C,OAAO,CAACP,EAAD,EAAKF,CAAL,EAAQG,UAAR,CALb;YAOA,OAAO,CAAA,CAAA,EAAA,UAAA,CAAA,kBAAA,EAAmBS,KAAnB,CAAA,GAA4BA,KAAK,GAAGhD,MAAM,CAAC0D,MAAP1D,CAAc,CAAdA,CAApC,GAAuDuB,MAAM,CAACoC,gBAArE;UACD,CAfDjB;QAAAA;MAFI,CAH6D;IAAA,CAAJ;EAAA,CAAhC;AAAA,CAA/B;AAsBA;AACA;AACA;AACA;;AACO,SAASkB,iBAAT,CAA2B3D,OAA3B,EAAoCC,MAApC,EAA4CyC,MAA5C,EAAoD;EACzD,IAAMkB,WAAW,GAAG7B,mBAAmB,EAAvC;EACA,IAAM8B,QAAQ,GAAG,CAAA,CAAjB,CAFyD,CAIzD;;EACA,IAAMpB,QAAQ,GAAG,EAAjB;EALyD,IAAA,KAAA,GAAA,SAAA,KAAA,CAOhDhB,CAPgD,EAAA;IAQvD,IAAM1B,MAAM,GAAG,OAAO,CAACyB,IAAR,CACb,UAAA,CAAC,EAAA;MAAA,OACCnB,CAAC,CAACE,GAAFF,IACAA,CAAC,CAACJ,MAAFI,CAASC,QAATD,CAAkBJ,MAAlBI,CADAA,IAEAA,CAAC,CAACW,UAFFX,IAGAA,CAAC,CAACW,UAAFX,CAAaA,CAAC,CAACJ,MAAFI,CAASc,OAATd,CAAiBJ,MAAjBI,CAAbA,CAAAA,KAA2CoB,CAJ5C;IAAA,CADY,CAAf,CARuD,CAgBvD;;IACAmC,WAAW,CAACnC,CAAD,CAAXmC,CAAe,CAAfA,CAAAA,GAAoB7D,MAAM,GAAGA,MAAM,CAACgD,KAAPhD,CAAa,CAAbA,CAAAA,GAAkBA,MAAM,CAAC0D,MAAP1D,CAAc,CAAdA,CAArB,GAAwC,CAAlE6D,CAjBuD,CAkBvD;;IACAA,WAAW,CAACnC,CAAD,CAAXmC,CAAe,CAAfA,CAAAA,GAAoB7D,MAAM,GAAGA,MAAM,CAACgD,KAAPhD,CAAa,CAAbA,CAAAA,GAAkBA,MAAM,CAAC0D,MAAP1D,CAAc,CAAdA,CAArB,GAAwC,CAAlE6D;IAEAC,QAAQ,CAAA,YAAA,CAAA,MAAA,CAAcpC,CAAd,CAAA,CAARoC,GAA6B9D,MAAM,GAAGA,MAAM,CAAC+D,IAAP/D,CAAYA,MAAM,CAACE,MAAPF,CAAcoB,OAAdpB,CAAsBE,MAAtBF,CAAZA,CAAH,GAAgD,IAAnF8D;IACApB,QAAQ,CAACsB,IAATtB,CAAc1C,MAAd0C,CAAAA;EAtBuD,CAAA;EAOzD,KAAK,IAAIhB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,gBAAAA,CAAAA,eAApB,EAAqCgB,CAAC,EAAtC,EAA0C;IAAA,KAAA,CAAjCA,CAAiC,CAAA;EAgBzC;EAED,IAAMuC,mBAAmB,GAAGxB,sBAAsB,CAACC,QAAD,EAAWxC,MAAX,EAAmByC,MAAnB,CAAlD;EAEA,OAAO;IACLkB,WAAW,EAAXA,WADK;IAELK,yBAAyB,EAAEJ,QAFtB;IAGLG,mBAAmB,EAAnBA;EAHK,CAAP;AAKD;AAED;AACA;AACA;AACA;AACA;;AACO,SAASnB,6BAAT,CAAuC5C,MAAvC,EAA+CF,MAA/C,EAAuD;EAC5D,IAAMmE,YAAY,GAAG,CAAA,CAAA,EAAA,MAAA,CAAA,OAAA,EAAQnE,MAAM,CAACE,MAAf,CAAA,CAAuBkB,OAAvB,CAA+BlB,MAA/B,CAArB;EACA,IAAIiE,YAAY,GAAG,CAAnB,EAAsB;IACpB,OAAO,CAAC,CAAR;EACD;EAED,IAAM5B,UAAU,GAAGvC,MAAM,CAACoE,QAAPpE,CAAgBmE,YAAhBnE,CAAnB;EAEA,OAAO,CAAA,CAAA,EAAA,UAAA,CAAA,kBAAA,EAAmBuC,UAAnB,CAAA,GAAiCA,UAAjC,GAA8C,CAAC,CAAtD;AACD","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {set, toArray} from './utils';\nimport {MAX_GPU_FILTERS, FILTER_TYPES} from 'constants/default-settings';\nimport {notNullorUndefined} from './data-utils';\nimport moment from 'moment';\n\n/**\n * Set gpu mode based on current number of gpu filters exists\n * @type {typeof import('./gpu-filter-utils').setFilterGpuMode}\n */\nexport function setFilterGpuMode(filter, filters) {\n  // filter can be applied to multiple datasets, hence gpu filter mode should also be\n  // an array, however, to keep us sane, for now, we only check if there is available channel for every dataId,\n  // if all of them has, we set gpu mode to true\n  // TODO: refactor filter so we don't keep an array of everything\n\n  filter.dataId.forEach((dataId, datasetIdx) => {\n    const gpuFilters = filters.filter(f => f.dataId.includes(dataId) && f.gpu);\n\n    if (filter.gpu && gpuFilters.length === MAX_GPU_FILTERS) {\n      return set(['gpu'], false, filter);\n    }\n  });\n\n  return filter;\n}\n\n/**\n * Scan though all filters and assign gpu chanel to gpu filter\n * @type {typeof import('./gpu-filter-utils').assignGpuChannels}\n */\nexport function assignGpuChannels(allFilters) {\n  return allFilters.reduce((accu, f, index) => {\n    let filters = accu;\n\n    // if gpu is true assign and validate gpu Channel\n    if (f.gpu) {\n      f = assignGpuChannel(f, accu);\n      filters = set([index], f, accu);\n    }\n\n    return filters;\n  }, allFilters);\n}\n/**\n * Assign a new gpu filter a channel based on first availability\n * @type {typeof import('./gpu-filter-utils').assignGpuChannel}\n */\nexport function assignGpuChannel(filter, filters) {\n  // find first available channel\n  if (!filter.gpu) {\n    return filter;\n  }\n\n  const gpuChannel = filter.gpuChannel || [];\n\n  filter.dataId.forEach((dataId, datasetIdx) => {\n    const findGpuChannel = channel => f => {\n      const dataIdx = toArray(f.dataId).indexOf(dataId);\n      return (\n        f.id !== filter.id && dataIdx > -1 && f.gpu && toArray(f.gpuChannel)[dataIdx] === channel\n      );\n    };\n\n    if (\n      Number.isFinite(gpuChannel[datasetIdx]) &&\n      !filters.find(findGpuChannel(gpuChannel[datasetIdx]))\n    ) {\n      // if value is already assigned and valid\n      return;\n    }\n\n    let i = 0;\n\n    while (i < MAX_GPU_FILTERS) {\n      if (!filters.find(findGpuChannel(i))) {\n        gpuChannel[datasetIdx] = i;\n        return;\n      }\n      i++;\n    }\n  });\n\n  // if cannot find channel for all dataid, set gpu back to false\n  // TODO: refactor filter to handle same filter different gpu mode\n  if (!gpuChannel.length || !gpuChannel.every(Number.isFinite)) {\n    return {\n      ...filter,\n      gpu: false\n    };\n  }\n\n  return {\n    ...filter,\n    gpuChannel\n  };\n}\n/**\n * Edit filter.gpu to ensure that only\n * X number of gpu filers can coexist.\n * @type {typeof import('./gpu-filter-utils').resetFilterGpuMode}\n */\nexport function resetFilterGpuMode(filters) {\n  const gpuPerDataset = {};\n\n  return filters.map((f, i) => {\n    if (f.gpu) {\n      let gpu = true;\n      toArray(f.dataId).forEach(dataId => {\n        const count = gpuPerDataset[dataId];\n\n        if (count === MAX_GPU_FILTERS) {\n          gpu = false;\n        } else {\n          gpuPerDataset[dataId] = count ? count + 1 : 1;\n        }\n      });\n\n      if (!gpu) {\n        return set(['gpu'], false, f);\n      }\n    }\n\n    return f;\n  });\n}\n\n/**\n * Initial filter uniform\n * @returns {Array<Array<Number>>}\n */\nfunction getEmptyFilterRange() {\n  return new Array(MAX_GPU_FILTERS).fill(0).map(d => [0, 0]);\n}\n\n/**\n * Returns index of the data element.\n * @param {any} d Data element with row index info.\n * @returns number\n */\nconst defaultGetIndex = d => d.index;\n\n/**\n * Returns value at the specified row from the data container.\n * @param {import('./table-utils/data-container-interface').DataContainerInterface} dc Data container.\n * @param {any} d Data element with row index info.\n * @param {number} fieldIndex Column index in the data container.\n * @returns\n */\nconst defaultGetData = (dc, d, fieldIndex) => {\n  return dc.valueAt(d.index, fieldIndex);\n};\n\n/**\n * @param {Array<Object>} channels\n * @param {string} dataId\n * @param {Array<Object>} fields\n * @return {Function} getFilterValue\n */\nconst getFilterValueAccessor = (channels, dataId, fields) => dc => (\n  getIndex = defaultGetIndex,\n  getData = defaultGetData\n) => d =>\n  // for empty channel, value is 0 and min max would be [0, 0]\n  channels.map(filter => {\n    if (!filter) {\n      return 0;\n    }\n    const fieldIndex = getDatasetFieldIndexForFilter(dataId, filter);\n    const field = fields[fieldIndex];\n\n    const value =\n      filter.type === FILTER_TYPES.timeRange\n        ? field.filterProps && Array.isArray(field.filterProps.mappedValue)\n          ? field.filterProps.mappedValue[getIndex(d)]\n          : moment.utc(getData(dc, d, fieldIndex)).valueOf()\n        : getData(dc, d, fieldIndex);\n\n    return notNullorUndefined(value) ? value - filter.domain[0] : Number.MIN_SAFE_INTEGER;\n  });\n\n/**\n * Get filter properties for gpu filtering\n * @type {typeof import('./gpu-filter-utils').getGpuFilterProps}\n */\nexport function getGpuFilterProps(filters, dataId, fields) {\n  const filterRange = getEmptyFilterRange();\n  const triggers = {};\n\n  // array of filter for each channel, undefined, if no filter is assigned to that channel\n  const channels = [];\n\n  for (let i = 0; i < MAX_GPU_FILTERS; i++) {\n    const filter = filters.find(\n      f =>\n        f.gpu &&\n        f.dataId.includes(dataId) &&\n        f.gpuChannel &&\n        f.gpuChannel[f.dataId.indexOf(dataId)] === i\n    );\n\n    // @ts-ignore\n    filterRange[i][0] = filter ? filter.value[0] - filter.domain[0] : 0;\n    // @ts-ignore\n    filterRange[i][1] = filter ? filter.value[1] - filter.domain[0] : 0;\n\n    triggers[`gpuFilter_${i}`] = filter ? filter.name[filter.dataId.indexOf(dataId)] : null;\n    channels.push(filter);\n  }\n\n  const filterValueAccessor = getFilterValueAccessor(channels, dataId, fields);\n\n  return {\n    filterRange,\n    filterValueUpdateTriggers: triggers,\n    filterValueAccessor\n  };\n}\n\n/**\n * Return dataset field index from filter.fieldIdx\n * The index matches the same dataset index for filter.dataId\n * @type {typeof import('./gpu-filter-utils').getDatasetFieldIndexForFilter}\n */\nexport function getDatasetFieldIndexForFilter(dataId, filter) {\n  const datasetIndex = toArray(filter.dataId).indexOf(dataId);\n  if (datasetIndex < 0) {\n    return -1;\n  }\n\n  const fieldIndex = filter.fieldIdx[datasetIndex];\n\n  return notNullorUndefined(fieldIndex) ? fieldIndex : -1;\n}\n"]},"metadata":{},"sourceType":"script"}