{"ast":null,"code":"import { assert } from '../utils/assert';\nimport { formatValue } from '../utils/format-value';\nexport function getDebugTableForUniforms(_ref) {\n  let {\n    header = 'Uniforms',\n    program,\n    uniforms,\n    undefinedOnly = false\n  } = _ref;\n  assert(program);\n  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';\n  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix';\n  const uniformLocations = program._uniformSetters;\n  const table = {};\n  const uniformNames = Object.keys(uniformLocations).sort();\n  let count = 0;\n  for (const uniformName of uniformNames) {\n    if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n      if (addUniformToTable({\n        table,\n        header,\n        uniforms,\n        uniformName,\n        undefinedOnly\n      })) {\n        count++;\n      }\n    }\n  }\n  for (const uniformName of uniformNames) {\n    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n      if (addUniformToTable({\n        table,\n        header,\n        uniforms,\n        uniformName,\n        undefinedOnly\n      })) {\n        count++;\n      }\n    }\n  }\n  for (const uniformName of uniformNames) {\n    if (!table[uniformName]) {\n      if (addUniformToTable({\n        table,\n        header,\n        uniforms,\n        uniformName,\n        undefinedOnly\n      })) {\n        count++;\n      }\n    }\n  }\n  let unusedCount = 0;\n  const unusedTable = {};\n  if (!undefinedOnly) {\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      if (!table[uniformName]) {\n        unusedCount++;\n        unusedTable[uniformName] = {\n          Type: \"NOT USED: \".concat(uniform),\n          [header]: formatValue(uniform)\n        };\n      }\n    }\n  }\n  return {\n    table,\n    count,\n    unusedTable,\n    unusedCount\n  };\n}\nfunction addUniformToTable(_ref2) {\n  let {\n    table,\n    header,\n    uniforms,\n    uniformName,\n    undefinedOnly\n  } = _ref2;\n  const value = uniforms[uniformName];\n  const isDefined = isUniformDefined(value);\n  if (!undefinedOnly || !isDefined) {\n    table[uniformName] = {\n      [header]: isDefined ? formatValue(value) : 'N/A',\n      'Uniform Type': isDefined ? value : 'NOT PROVIDED'\n    };\n    return true;\n  }\n  return false;\n}\nfunction isUniformDefined(value) {\n  return value !== undefined && value !== null;\n}","map":{"version":3,"sources":["../../../src/debug/debug-uniforms.js"],"names":["assert","formatValue","getDebugTableForUniforms","header","program","uniforms","undefinedOnly","SHADER_MODULE_UNIFORM_REGEXP","PROJECT_MODULE_UNIFORM_REGEXP","uniformLocations","_uniformSetters","table","uniformNames","Object","keys","sort","count","uniformName","match","addUniformToTable","unusedCount","unusedTable","uniform","Type","value","isDefined","isUniformDefined","undefined"],"mappings":"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","sourcesContent":["import {assert} from '../utils/assert';\nimport {formatValue} from '../utils/format-value';\n\n// Prepares a table suitable for console.table\n/* eslint-disable max-statements, complexity */\nexport function getDebugTableForUniforms({\n  header = 'Uniforms',\n  program,\n  uniforms,\n  undefinedOnly = false\n}) {\n  assert(program);\n\n  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';\n  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix'; // TODO - Use explicit list\n\n  const uniformLocations = program._uniformSetters;\n  const table = {}; // {[header]: {}};\n\n  // Add program's provided uniforms (in alphabetical order)\n  const uniformNames = Object.keys(uniformLocations).sort();\n\n  let count = 0;\n\n  // First add non-underscored uniforms (assumed not coming from shader modules)\n  for (const uniformName of uniformNames) {\n    if (\n      !uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) &&\n      !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)\n    ) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // add underscored uniforms (assumed from shader modules)\n  for (const uniformName of uniformNames) {\n    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  for (const uniformName of uniformNames) {\n    if (!table[uniformName]) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // Create a table of unused uniforms\n  let unusedCount = 0;\n  const unusedTable = {};\n  if (!undefinedOnly) {\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      if (!table[uniformName]) {\n        unusedCount++;\n        unusedTable[uniformName] = {\n          Type: `NOT USED: ${uniform}`,\n          [header]: formatValue(uniform)\n        };\n      }\n    }\n  }\n\n  return {table, count, unusedTable, unusedCount};\n}\n\n// Helper\nfunction addUniformToTable({table, header, uniforms, uniformName, undefinedOnly}) {\n  const value = uniforms[uniformName];\n  const isDefined = isUniformDefined(value);\n  if (!undefinedOnly || !isDefined) {\n    table[uniformName] = {\n      // Add program's unprovided uniforms\n      [header]: isDefined ? formatValue(value) : 'N/A',\n      'Uniform Type': isDefined ? value : 'NOT PROVIDED'\n    };\n    return true;\n  }\n  return false;\n}\n\nfunction isUniformDefined(value) {\n  return value !== undefined && value !== null;\n}\n"]},"metadata":{},"sourceType":"module"}