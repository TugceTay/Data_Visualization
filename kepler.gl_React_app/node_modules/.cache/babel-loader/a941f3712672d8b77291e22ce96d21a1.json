{"ast":null,"code":"import Resource from './resource';\nimport { FEATURES, hasFeatures } from '../features';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { assert } from '../utils/assert';\nconst GL_QUERY_RESULT = 0x8866;\nconst GL_QUERY_RESULT_AVAILABLE = 0x8867;\nconst GL_TIME_ELAPSED_EXT = 0x88bf;\nconst GL_GPU_DISJOINT_EXT = 0x8fbb;\nconst GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;\nconst GL_ANY_SAMPLES_PASSED = 0x8c2f;\nconst GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;\nexport default class Query extends Resource {\n  get [Symbol.toStringTag]() {\n    return 'Query';\n  }\n  static isSupported(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const webgl2 = isWebGL2(gl);\n    const hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);\n    let supported = webgl2 || hasTimerQuery;\n    for (const key of opts) {\n      switch (key) {\n        case 'queries':\n          supported = supported && webgl2;\n          break;\n        case 'timers':\n          supported = supported && hasTimerQuery;\n          break;\n        default:\n          assert(false);\n      }\n    }\n    return supported;\n  }\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, opts);\n    this.target = null;\n    this._queryPending = false;\n    this._pollingPromise = null;\n    Object.seal(this);\n  }\n  beginTimeElapsedQuery() {\n    return this.begin(GL_TIME_ELAPSED_EXT);\n  }\n  beginOcclusionQuery() {\n    let {\n      conservative = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);\n  }\n  beginTransformFeedbackQuery() {\n    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);\n  }\n  begin(target) {\n    if (this._queryPending) {\n      return this;\n    }\n    this.target = target;\n    this.gl2.beginQuery(this.target, this.handle);\n    return this;\n  }\n  end() {\n    if (this._queryPending) {\n      return this;\n    }\n    if (this.target) {\n      this.gl2.endQuery(this.target);\n      this.target = null;\n      this._queryPending = true;\n    }\n    return this;\n  }\n  isResultAvailable() {\n    if (!this._queryPending) {\n      return false;\n    }\n    const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);\n    if (resultAvailable) {\n      this._queryPending = false;\n    }\n    return resultAvailable;\n  }\n  isTimerDisjoint() {\n    return this.gl2.getParameter(GL_GPU_DISJOINT_EXT);\n  }\n  getResult() {\n    return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);\n  }\n  getTimerMilliseconds() {\n    return this.getResult() / 1e6;\n  }\n  createPoll() {\n    let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;\n    if (this._pollingPromise) {\n      return this._pollingPromise;\n    }\n    let counter = 0;\n    this._pollingPromise = new Promise((resolve, reject) => {\n      const poll = () => {\n        if (this.isResultAvailable()) {\n          resolve(this.getResult());\n          this._pollingPromise = null;\n        } else if (counter++ > limit) {\n          reject('Timed out');\n          this._pollingPromise = null;\n        } else {\n          requestAnimationFrame(poll);\n        }\n      };\n      requestAnimationFrame(poll);\n    });\n    return this._pollingPromise;\n  }\n  _createHandle() {\n    return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;\n  }\n  _deleteHandle() {\n    this.gl2.deleteQuery(this.handle);\n  }\n}","map":{"version":3,"sources":["../../../src/classes/query.js"],"names":["Resource","FEATURES","hasFeatures","isWebGL2","assert","GL_QUERY_RESULT","GL_QUERY_RESULT_AVAILABLE","GL_TIME_ELAPSED_EXT","GL_GPU_DISJOINT_EXT","GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN","GL_ANY_SAMPLES_PASSED","GL_ANY_SAMPLES_PASSED_CONSERVATIVE","Query","Symbol","toStringTag","isSupported","gl","opts","webgl2","hasTimerQuery","TIMER_QUERY","supported","key","constructor","target","_queryPending","_pollingPromise","Object","seal","beginTimeElapsedQuery","begin","beginOcclusionQuery","conservative","beginTransformFeedbackQuery","gl2","beginQuery","handle","end","endQuery","isResultAvailable","resultAvailable","getQueryParameter","isTimerDisjoint","getParameter","getResult","getTimerMilliseconds","createPoll","limit","Number","POSITIVE_INFINITY","counter","Promise","resolve","reject","poll","requestAnimationFrame","_createHandle","createQuery","_deleteHandle","deleteQuery"],"mappings":"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","sourcesContent":["// WebGL2 Query (also handles disjoint timer extensions)\nimport Resource from './resource';\nimport {FEATURES, hasFeatures} from '../features';\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {assert} from '../utils/assert';\n\nconst GL_QUERY_RESULT = 0x8866; // Returns a GLuint containing the query result.\nconst GL_QUERY_RESULT_AVAILABLE = 0x8867; // whether query result is available.\n\nconst GL_TIME_ELAPSED_EXT = 0x88bf; // Elapsed time (in nanoseconds).\nconst GL_GPU_DISJOINT_EXT = 0x8fbb; // Whether GPU performed any disjoint operation.\n\nconst GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88; // #primitives written to feedback buffers\nconst GL_ANY_SAMPLES_PASSED = 0x8c2f; // Occlusion query (if drawing passed depth test)\nconst GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a; // Occlusion query less accurate/faster version\n\nexport default class Query extends Resource {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'Query';\n  }\n  // Returns true if Query is supported by the WebGL implementation\n  // Can also check whether timestamp queries are available.\n  static isSupported(gl, opts = []) {\n    const webgl2 = isWebGL2(gl);\n\n    // Initial value\n    const hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);\n    let supported = webgl2 || hasTimerQuery;\n\n    for (const key of opts) {\n      switch (key) {\n        case 'queries':\n          supported = supported && webgl2;\n          break;\n        case 'timers':\n          supported = supported && hasTimerQuery;\n          break;\n        default:\n          assert(false);\n      }\n    }\n\n    return supported;\n  }\n\n  // Create a query class\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    this.target = null;\n    this._queryPending = false;\n    this._pollingPromise = null;\n\n    Object.seal(this);\n  }\n\n  // Shortcut for timer query (dependent on extension in both WebGL1 and 2)\n  // Measures GPU time delta between this call and a matching `end` call in the\n  // GPU instruction stream.\n  beginTimeElapsedQuery() {\n    return this.begin(GL_TIME_ELAPSED_EXT);\n  }\n\n  // Shortcut for occlusion queries\n  beginOcclusionQuery({conservative = false} = {}) {\n    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);\n  }\n\n  // Shortcut for transformFeedbackQuery\n  beginTransformFeedbackQuery() {\n    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);\n  }\n\n  // Due to OpenGL API limitations, after calling `begin()` on one Query\n  // instance, `end()` must be called on that same instance before\n  // calling `begin()` on another query. While there can be multiple\n  // outstanding queries representing disjoint `begin()`/`end()` intervals.\n  // It is not possible to interleave or overlap `begin` and `end` calls.\n  begin(target) {\n    // Don't start a new query if one is already active.\n    if (this._queryPending) {\n      return this;\n    }\n\n    this.target = target;\n    this.gl2.beginQuery(this.target, this.handle);\n\n    return this;\n  }\n\n  // ends the current query\n  end() {\n    // Can't end a new query if the last one hasn't been resolved.\n    if (this._queryPending) {\n      return this;\n    }\n\n    if (this.target) {\n      this.gl2.endQuery(this.target);\n      this.target = null;\n      this._queryPending = true;\n    }\n    return this;\n  }\n\n  // Returns true if the query result is available\n  isResultAvailable() {\n    if (!this._queryPending) {\n      return false;\n    }\n\n    const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);\n    if (resultAvailable) {\n      this._queryPending = false;\n    }\n    return resultAvailable;\n  }\n\n  // Timing query is disjoint, i.e. results are invalid\n  isTimerDisjoint() {\n    return this.gl2.getParameter(GL_GPU_DISJOINT_EXT);\n  }\n\n  // Returns query result.\n  getResult() {\n    return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);\n  }\n\n  // Returns the query result, converted to milliseconds to match JavaScript conventions.\n  getTimerMilliseconds() {\n    return this.getResult() / 1e6;\n  }\n\n  // Polls the query\n  createPoll(limit = Number.POSITIVE_INFINITY) {\n    if (this._pollingPromise) {\n      return this._pollingPromise;\n    }\n\n    let counter = 0;\n\n    this._pollingPromise = new Promise((resolve, reject) => {\n      const poll = () => {\n        if (this.isResultAvailable()) {\n          resolve(this.getResult());\n          this._pollingPromise = null;\n        } else if (counter++ > limit) {\n          reject('Timed out');\n          this._pollingPromise = null;\n        } else {\n          requestAnimationFrame(poll);\n        }\n      };\n\n      requestAnimationFrame(poll);\n    });\n\n    return this._pollingPromise;\n  }\n\n  _createHandle() {\n    return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;\n  }\n\n  _deleteHandle() {\n    this.gl2.deleteQuery(this.handle);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}