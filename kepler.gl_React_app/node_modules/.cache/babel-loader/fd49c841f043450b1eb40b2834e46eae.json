{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport BoundingSphere from '../bounding-volumes/bounding-sphere';\nconst fromPointsXMin = new Vector3();\nconst fromPointsYMin = new Vector3();\nconst fromPointsZMin = new Vector3();\nconst fromPointsXMax = new Vector3();\nconst fromPointsYMax = new Vector3();\nconst fromPointsZMax = new Vector3();\nconst fromPointsCurrentPos = new Vector3();\nconst fromPointsScratch = new Vector3();\nconst fromPointsRitterCenter = new Vector3();\nconst fromPointsMinBoxPt = new Vector3();\nconst fromPointsMaxBoxPt = new Vector3();\nconst fromPointsNaiveCenterScratch = new Vector3();\nconst volumeConstant = 4.0 / 3.0 * Math.PI;\nexport default function makeBoundingSphereFromPoints(positions) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new BoundingSphere();\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n  for (const position of positions) {\n    currentPos.copy(position);\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n    if (x < xMin.x) {\n      xMin.copy(currentPos);\n    }\n    if (x > xMax.x) {\n      xMax.copy(currentPos);\n    }\n    if (y < yMin.y) {\n      yMin.copy(currentPos);\n    }\n    if (y > yMax.y) {\n      yMax.copy(currentPos);\n    }\n    if (z < zMin.z) {\n      zMin.copy(currentPos);\n    }\n    if (z > zMax.z) {\n      zMax.copy(currentPos);\n    }\n  }\n  const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n  let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  const naiveCenter = fromPointsNaiveCenterScratch.copy(minBoxPt).add(maxBoxPt).multiplyByScalar(0.5);\n  let naiveRadius = 0;\n  for (const position of positions) {\n    currentPos.copy(position);\n    const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n    const oldCenterToPointSquared = fromPointsScratch.copy(currentPos).subtract(ritterCenter).magnitudeSquared();\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n  return result;\n}","map":{"version":3,"sources":["../../../../src/lib/algorithms/bounding-sphere-from-points.ts"],"names":["Vector3","BoundingSphere","fromPointsXMin","fromPointsYMin","fromPointsZMin","fromPointsXMax","fromPointsYMax","fromPointsZMax","fromPointsCurrentPos","fromPointsScratch","fromPointsRitterCenter","fromPointsMinBoxPt","fromPointsMaxBoxPt","fromPointsNaiveCenterScratch","volumeConstant","Math","PI","makeBoundingSphereFromPoints","positions","result","length","fromCenterRadius","currentPos","copy","xMin","yMin","zMin","xMax","yMax","zMax","position","x","y","z","xSpan","subtract","magnitudeSquared","ySpan","zSpan","diameter1","diameter2","maxSpan","ritterCenter","radiusSquared","ritterRadius","sqrt","minBoxPt","maxBoxPt","naiveCenter","add","multiplyByScalar","naiveRadius","r","magnitude","oldCenterToPointSquared","oldCenterToPoint","oldToNew","to","center","radius"],"mappings":"AAGA,SAAQA,OAAR,QAAsB,eAAtB;AACA,OAAOC,cAAP,MAA2B,qCAA3B;AAGA,MAAMC,cAAc,GAAG,IAAIF,OAAJ,EAAvB;AACA,MAAMG,cAAc,GAAG,IAAIH,OAAJ,EAAvB;AACA,MAAMI,cAAc,GAAG,IAAIJ,OAAJ,EAAvB;AACA,MAAMK,cAAc,GAAG,IAAIL,OAAJ,EAAvB;AACA,MAAMM,cAAc,GAAG,IAAIN,OAAJ,EAAvB;AACA,MAAMO,cAAc,GAAG,IAAIP,OAAJ,EAAvB;AACA,MAAMQ,oBAAoB,GAAG,IAAIR,OAAJ,EAA7B;AACA,MAAMS,iBAAiB,GAAG,IAAIT,OAAJ,EAA1B;AACA,MAAMU,sBAAsB,GAAG,IAAIV,OAAJ,EAA/B;AACA,MAAMW,kBAAkB,GAAG,IAAIX,OAAJ,EAA3B;AACA,MAAMY,kBAAkB,GAAG,IAAIZ,OAAJ,EAA3B;AACA,MAAMa,4BAA4B,GAAG,IAAIb,OAAJ,EAArC;AACA,MAAMc,cAAc,GAAI,GAAA,GAAM,GAAP,GAAcC,IAAI,CAACC,EAA1C;AAaA,eAAe,SAASC,4BAAT,CACbC,SADa,EAGG;EAAA,IADhBC,MAAsB,uEAAG,IAAIlB,cAAJ,EAFZ;EAIb,IAAI,CAACiB,SAAD,IAAcA,SAAS,CAACE,MAAVF,KAAqB,CAAvC,EAA0C;IACxC,OAAOC,MAAM,CAACE,gBAAPF,CAAwB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAxBA,EAAmC,CAAnCA,CAAP;EACD;EAED,MAAMG,UAAU,GAAGd,oBAAoB,CAACe,IAArBf,CAA0BU,SAAS,CAAC,CAAD,CAAnCV,CAAnB;EAEA,MAAMgB,IAAI,GAAGtB,cAAc,CAACqB,IAAfrB,CAAoBoB,UAApBpB,CAAb;EACA,MAAMuB,IAAI,GAAGtB,cAAc,CAACoB,IAAfpB,CAAoBmB,UAApBnB,CAAb;EACA,MAAMuB,IAAI,GAAGtB,cAAc,CAACmB,IAAfnB,CAAoBkB,UAApBlB,CAAb;EAEA,MAAMuB,IAAI,GAAGtB,cAAc,CAACkB,IAAflB,CAAoBiB,UAApBjB,CAAb;EACA,MAAMuB,IAAI,GAAGtB,cAAc,CAACiB,IAAfjB,CAAoBgB,UAApBhB,CAAb;EACA,MAAMuB,IAAI,GAAGtB,cAAc,CAACgB,IAAfhB,CAAoBe,UAApBf,CAAb;EAEA,KAAK,MAAMuB,QAAX,IAAuBZ,SAAvB,EAAkC;IAChCI,UAAU,CAACC,IAAXD,CAAgBQ,QAAhBR,CAAAA;IAEA,MAAMS,CAAC,GAAGT,UAAU,CAACS,CAArB;IACA,MAAMC,CAAC,GAAGV,UAAU,CAACU,CAArB;IACA,MAAMC,CAAC,GAAGX,UAAU,CAACW,CAArB;IAGA,IAAIF,CAAC,GAAGP,IAAI,CAACO,CAAb,EAAgB;MACdP,IAAI,CAACD,IAALC,CAAUF,UAAVE,CAAAA;IACD;IAED,IAAIO,CAAC,GAAGJ,IAAI,CAACI,CAAb,EAAgB;MACdJ,IAAI,CAACJ,IAALI,CAAUL,UAAVK,CAAAA;IACD;IAED,IAAIK,CAAC,GAAGP,IAAI,CAACO,CAAb,EAAgB;MACdP,IAAI,CAACF,IAALE,CAAUH,UAAVG,CAAAA;IACD;IAED,IAAIO,CAAC,GAAGJ,IAAI,CAACI,CAAb,EAAgB;MACdJ,IAAI,CAACL,IAALK,CAAUN,UAAVM,CAAAA;IACD;IAED,IAAIK,CAAC,GAAGP,IAAI,CAACO,CAAb,EAAgB;MACdP,IAAI,CAACH,IAALG,CAAUJ,UAAVI,CAAAA;IACD;IAED,IAAIO,CAAC,GAAGJ,IAAI,CAACI,CAAb,EAAgB;MACdJ,IAAI,CAACN,IAALM,CAAUP,UAAVO,CAAAA;IACD;EACF;EAGD,MAAMK,KAAK,GAAGzB,iBAAiB,CAACc,IAAlBd,CAAuBkB,IAAvBlB,CAAAA,CAA6B0B,QAA7B1B,CAAsCe,IAAtCf,CAAAA,CAA4C2B,gBAA5C3B,EAAd;EACA,MAAM4B,KAAK,GAAG5B,iBAAiB,CAACc,IAAlBd,CAAuBmB,IAAvBnB,CAAAA,CAA6B0B,QAA7B1B,CAAsCgB,IAAtChB,CAAAA,CAA4C2B,gBAA5C3B,EAAd;EACA,MAAM6B,KAAK,GAAG7B,iBAAiB,CAACc,IAAlBd,CAAuBoB,IAAvBpB,CAAAA,CAA6B0B,QAA7B1B,CAAsCiB,IAAtCjB,CAAAA,CAA4C2B,gBAA5C3B,EAAd;EAGA,IAAI8B,SAAS,GAAGf,IAAhB;EACA,IAAIgB,SAAS,GAAGb,IAAhB;EACA,IAAIc,OAAO,GAAGP,KAAd;EACA,IAAIG,KAAK,GAAGI,OAAZ,EAAqB;IACnBA,OAAO,GAAGJ,KAAVI;IACAF,SAAS,GAAGd,IAAZc;IACAC,SAAS,GAAGZ,IAAZY;EACD;EACD,IAAIF,KAAK,GAAGG,OAAZ,EAAqB;IACnBA,OAAO,GAAGH,KAAVG;IACAF,SAAS,GAAGb,IAAZa;IACAC,SAAS,GAAGX,IAAZW;EACD;EAGD,MAAME,YAAY,GAAGhC,sBAArB;EACAgC,YAAY,CAACX,CAAbW,GAAiB,CAACH,SAAS,CAACR,CAAVQ,GAAcC,SAAS,CAACT,CAAzB,IAA8B,GAA/CW;EACAA,YAAY,CAACV,CAAbU,GAAiB,CAACH,SAAS,CAACP,CAAVO,GAAcC,SAAS,CAACR,CAAzB,IAA8B,GAA/CU;EACAA,YAAY,CAACT,CAAbS,GAAiB,CAACH,SAAS,CAACN,CAAVM,GAAcC,SAAS,CAACP,CAAzB,IAA8B,GAA/CS;EAGA,IAAIC,aAAa,GAAGlC,iBAAiB,CAACc,IAAlBd,CAAuB+B,SAAvB/B,CAAAA,CAAkC0B,QAAlC1B,CAA2CiC,YAA3CjC,CAAAA,CAAyD2B,gBAAzD3B,EAApB;EACA,IAAImC,YAAY,GAAG7B,IAAI,CAAC8B,IAAL9B,CAAU4B,aAAV5B,CAAnB;EAGA,MAAM+B,QAAQ,GAAGnC,kBAAjB;EACAmC,QAAQ,CAACf,CAATe,GAAatB,IAAI,CAACO,CAAlBe;EACAA,QAAQ,CAACd,CAATc,GAAarB,IAAI,CAACO,CAAlBc;EACAA,QAAQ,CAACb,CAATa,GAAapB,IAAI,CAACO,CAAlBa;EAEA,MAAMC,QAAQ,GAAGnC,kBAAjB;EACAmC,QAAQ,CAAChB,CAATgB,GAAapB,IAAI,CAACI,CAAlBgB;EACAA,QAAQ,CAACf,CAATe,GAAanB,IAAI,CAACI,CAAlBe;EACAA,QAAQ,CAACd,CAATc,GAAalB,IAAI,CAACI,CAAlBc;EAEA,MAAMC,WAAW,GAAGnC,4BAA4B,CAC7CU,IADiBV,CACZiC,QADYjC,CAAAA,CAEjBoC,GAFiBpC,CAEbkC,QAFalC,CAAAA,CAGjBqC,gBAHiBrC,CAGA,GAHAA,CAApB;EAMA,IAAIsC,WAAW,GAAG,CAAlB;EACA,KAAK,MAAMrB,QAAX,IAAuBZ,SAAvB,EAAkC;IAChCI,UAAU,CAACC,IAAXD,CAAgBQ,QAAhBR,CAAAA;IAGA,MAAM8B,CAAC,GAAG3C,iBAAiB,CAACc,IAAlBd,CAAuBa,UAAvBb,CAAAA,CAAmC0B,QAAnC1B,CAA4CuC,WAA5CvC,CAAAA,CAAyD4C,SAAzD5C,EAAV;IACA,IAAI2C,CAAC,GAAGD,WAAR,EAAqB;MACnBA,WAAW,GAAGC,CAAdD;IACD;IAGD,MAAMG,uBAAuB,GAAG7C,iBAAiB,CAC9Cc,IAD6Bd,CACxBa,UADwBb,CAAAA,CAE7B0B,QAF6B1B,CAEpBiC,YAFoBjC,CAAAA,CAG7B2B,gBAH6B3B,EAAhC;IAKA,IAAI6C,uBAAuB,GAAGX,aAA9B,EAA6C;MAC3C,MAAMY,gBAAgB,GAAGxC,IAAI,CAAC8B,IAAL9B,CAAUuC,uBAAVvC,CAAzB;MAEA6B,YAAY,GAAG,CAACA,YAAY,GAAGW,gBAAhB,IAAoC,GAAnDX;MACAD,aAAa,GAAGC,YAAY,GAAGA,YAA/BD;MAEA,MAAMa,QAAQ,GAAGD,gBAAgB,GAAGX,YAApC;MACAF,YAAY,CAACX,CAAbW,GAAiB,CAACE,YAAY,GAAGF,YAAY,CAACX,CAA5Ba,GAAgCY,QAAQ,GAAGlC,UAAU,CAACS,CAAvD,IAA4DwB,gBAA7Eb;MACAA,YAAY,CAACV,CAAbU,GAAiB,CAACE,YAAY,GAAGF,YAAY,CAACV,CAA5BY,GAAgCY,QAAQ,GAAGlC,UAAU,CAACU,CAAvD,IAA4DuB,gBAA7Eb;MACAA,YAAY,CAACT,CAAbS,GAAiB,CAACE,YAAY,GAAGF,YAAY,CAACT,CAA5BW,GAAgCY,QAAQ,GAAGlC,UAAU,CAACW,CAAvD,IAA4DsB,gBAA7Eb;IACD;EACF;EAED,IAAIE,YAAY,GAAGO,WAAnB,EAAgC;IAC9BT,YAAY,CAACe,EAAbf,CAAgBvB,MAAM,CAACuC,MAAvBhB,CAAAA;IACAvB,MAAM,CAACwC,MAAPxC,GAAgByB,YAAhBzB;EACD,CAHD,MAGO;IACL6B,WAAW,CAACS,EAAZT,CAAe7B,MAAM,CAACuC,MAAtBV,CAAAA;IACA7B,MAAM,CAACwC,MAAPxC,GAAgBgC,WAAhBhC;EACD;EAED,OAAOA,MAAP;AACD","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3} from '@math.gl/core';\nimport BoundingSphere from '../bounding-volumes/bounding-sphere';\n\n/* eslint-disable */\nconst fromPointsXMin = new Vector3();\nconst fromPointsYMin = new Vector3();\nconst fromPointsZMin = new Vector3();\nconst fromPointsXMax = new Vector3();\nconst fromPointsYMax = new Vector3();\nconst fromPointsZMax = new Vector3();\nconst fromPointsCurrentPos = new Vector3();\nconst fromPointsScratch = new Vector3();\nconst fromPointsRitterCenter = new Vector3();\nconst fromPointsMinBoxPt = new Vector3();\nconst fromPointsMaxBoxPt = new Vector3();\nconst fromPointsNaiveCenterScratch = new Vector3();\nconst volumeConstant = (4.0 / 3.0) * Math.PI;\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n *\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n * Bounding sphere computation article http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding\n *\n * @param positions An array of points that the bounding sphere will enclose.\n * @param result Optional object onto which to store the result.\n * @returns The modified result parameter or a new `BoundingSphere` instance if not provided.\n */\nexport default function makeBoundingSphereFromPoints(\n  positions: number[][],\n  result: BoundingSphere = new BoundingSphere()\n): BoundingSphere {\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      xMin.copy(currentPos);\n    }\n\n    if (x > xMax.x) {\n      xMax.copy(currentPos);\n    }\n\n    if (y < yMin.y) {\n      yMin.copy(currentPos);\n    }\n\n    if (y > yMax.y) {\n      yMax.copy(currentPos);\n    }\n\n    if (z < zMin.z) {\n      zMin.copy(currentPos);\n    }\n\n    if (z > zMax.z) {\n      zMax.copy(currentPos);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = fromPointsNaiveCenterScratch\n    .copy(minBoxPt)\n    .add(maxBoxPt)\n    .multiplyByScalar(0.5);\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = fromPointsScratch\n      .copy(currentPos)\n      .subtract(ritterCenter)\n      .magnitudeSquared();\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}