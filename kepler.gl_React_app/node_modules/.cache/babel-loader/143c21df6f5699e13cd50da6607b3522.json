{"ast":null,"code":"import { log } from '@deck.gl/core';\nimport { ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP } from './marching-squares-codes';\nexport var CONTOUR_TYPE = {\n  ISO_LINES: 1,\n  ISO_BANDS: 2\n};\nvar DEFAULT_THRESHOLD_DATA = {\n  zIndex: 0,\n  zOffset: 0.005\n};\nfunction getVertexCode(weight, threshold) {\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n    return weight < threshold[1] ? 1 : 2;\n  }\n  return weight >= threshold ? 1 : 0;\n}\nexport function getCode(opts) {\n  var cellWeights = opts.cellWeights,\n    x = opts.x,\n    y = opts.y,\n    width = opts.width,\n    height = opts.height;\n  var threshold = opts.threshold;\n  if (opts.thresholdValue) {\n    log.deprecated('thresholdValue', 'threshold')();\n    threshold = opts.thresholdValue;\n  }\n  var isLeftBoundary = x < 0;\n  var isRightBoundary = x >= width - 1;\n  var isBottomBoundary = y < 0;\n  var isTopBoundary = y >= height - 1;\n  var isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n  var weights = {};\n  var codes = {};\n  if (isLeftBoundary || isTopBoundary) {\n    codes.top = 0;\n  } else {\n    weights.top = cellWeights[(y + 1) * width + x];\n    codes.top = getVertexCode(weights.top, threshold);\n  }\n  if (isRightBoundary || isTopBoundary) {\n    codes.topRight = 0;\n  } else {\n    weights.topRight = cellWeights[(y + 1) * width + x + 1];\n    codes.topRight = getVertexCode(weights.topRight, threshold);\n  }\n  if (isRightBoundary || isBottomBoundary) {\n    codes.right = 0;\n  } else {\n    weights.right = cellWeights[y * width + x + 1];\n    codes.right = getVertexCode(weights.right, threshold);\n  }\n  if (isLeftBoundary || isBottomBoundary) {\n    codes.current = 0;\n  } else {\n    weights.current = cellWeights[y * width + x];\n    codes.current = getVertexCode(weights.current, threshold);\n  }\n  var top = codes.top,\n    topRight = codes.topRight,\n    right = codes.right,\n    current = codes.current;\n  var code = -1;\n  if (Number.isFinite(threshold)) {\n    code = top << 3 | topRight << 2 | right << 1 | current;\n  }\n  if (Array.isArray(threshold)) {\n    code = top << 6 | topRight << 4 | right << 2 | current;\n  }\n  var meanCode = 0;\n  if (!isBoundary) {\n    meanCode = getVertexCode((weights.top + weights.topRight + weights.right + weights.current) / 4, threshold);\n  }\n  return {\n    code: code,\n    meanCode: meanCode\n  };\n}\nexport function getVertices(opts) {\n  var gridOrigin = opts.gridOrigin,\n    cellSize = opts.cellSize,\n    x = opts.x,\n    y = opts.y,\n    code = opts.code,\n    meanCode = opts.meanCode,\n    _opts$type = opts.type,\n    type = _opts$type === void 0 ? CONTOUR_TYPE.ISO_LINES : _opts$type;\n  var thresholdData = Object.assign({}, DEFAULT_THRESHOLD_DATA, opts.thresholdData);\n  var offsets = type === CONTOUR_TYPE.ISO_BANDS ? ISOBANDS_CODE_OFFSET_MAP[code] : ISOLINES_CODE_OFFSET_MAP[code];\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n  var vZ = thresholdData.zIndex * thresholdData.zOffset;\n  var rX = (x + 1) * cellSize[0];\n  var rY = (y + 1) * cellSize[1];\n  var refVertexX = gridOrigin[0] + rX;\n  var refVertexY = gridOrigin[1] + rY;\n  if (type === CONTOUR_TYPE.ISO_BANDS) {\n    var polygons = [];\n    offsets.forEach(function (polygonOffsets) {\n      var polygon = [];\n      polygonOffsets.forEach(function (xyOffset) {\n        var vX = refVertexX + xyOffset[0] * cellSize[0];\n        var vY = refVertexY + xyOffset[1] * cellSize[1];\n        polygon.push([vX, vY, vZ]);\n      });\n      polygons.push(polygon);\n    });\n    return polygons;\n  }\n  var lines = [];\n  offsets.forEach(function (xyOffsets) {\n    xyOffsets.forEach(function (offset) {\n      var vX = refVertexX + offset[0] * cellSize[0];\n      var vY = refVertexY + offset[1] * cellSize[1];\n      lines.push([vX, vY, vZ]);\n    });\n  });\n  return lines;\n}","map":{"version":3,"sources":["../../../src/contour-layer/marching-squares.js"],"names":["log","ISOLINES_CODE_OFFSET_MAP","ISOBANDS_CODE_OFFSET_MAP","CONTOUR_TYPE","ISO_LINES","ISO_BANDS","DEFAULT_THRESHOLD_DATA","zIndex","zOffset","getVertexCode","weight","threshold","Array","isArray","getCode","opts","cellWeights","x","y","width","height","thresholdValue","deprecated","isLeftBoundary","isRightBoundary","isBottomBoundary","isTopBoundary","isBoundary","weights","codes","top","topRight","right","current","code","Number","isFinite","meanCode","getVertices","gridOrigin","cellSize","type","thresholdData","Object","assign","offsets","vZ","rX","rY","refVertexX","refVertexY","polygons","forEach","polygon","polygonOffsets","vX","xyOffset","vY","push","lines","xyOffsets","offset"],"mappings":"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","sourcesContent":["// All utility methods needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n\nimport {log} from '@deck.gl/core';\nimport {ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP} from './marching-squares-codes';\n\nexport const CONTOUR_TYPE = {\n  ISO_LINES: 1,\n  ISO_BANDS: 2\n};\n\nconst DEFAULT_THRESHOLD_DATA = {\n  zIndex: 0,\n  zOffset: 0.005\n};\n\n// Utility methods\n\nfunction getVertexCode(weight, threshold) {\n  // threshold must be a single value or a range (array of size 2)\n\n  // Iso-bands\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n    return weight < threshold[1] ? 1 : 2;\n  }\n  // Iso-lines\n  return weight >= threshold ? 1 : 0;\n}\n\n// Returns marching square code for given cell\n/* eslint-disable complexity, max-statements*/\nexport function getCode(opts) {\n  // Assumptions\n  // Origin is on bottom-left , and X increase to right, Y to top\n  // When processing one cell, we process 4 cells, by extending row to top and on column to right\n  // to create a 2X2 cell grid\n  const {cellWeights, x, y, width, height} = opts;\n  let threshold = opts.threshold;\n  if (opts.thresholdValue) {\n    log.deprecated('thresholdValue', 'threshold')();\n    threshold = opts.thresholdValue;\n  }\n\n  const isLeftBoundary = x < 0;\n  const isRightBoundary = x >= width - 1;\n  const isBottomBoundary = y < 0;\n  const isTopBoundary = y >= height - 1;\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n\n  const weights = {};\n  const codes = {};\n\n  // TOP\n  if (isLeftBoundary || isTopBoundary) {\n    codes.top = 0;\n  } else {\n    weights.top = cellWeights[(y + 1) * width + x];\n    codes.top = getVertexCode(weights.top, threshold);\n  }\n\n  // TOP-RIGHT\n  if (isRightBoundary || isTopBoundary) {\n    codes.topRight = 0;\n  } else {\n    weights.topRight = cellWeights[(y + 1) * width + x + 1];\n    codes.topRight = getVertexCode(weights.topRight, threshold);\n  }\n\n  // RIGHT\n  if (isRightBoundary || isBottomBoundary) {\n    codes.right = 0;\n  } else {\n    weights.right = cellWeights[y * width + x + 1];\n    codes.right = getVertexCode(weights.right, threshold);\n  }\n\n  // CURRENT\n  if (isLeftBoundary || isBottomBoundary) {\n    codes.current = 0;\n  } else {\n    weights.current = cellWeights[y * width + x];\n    codes.current = getVertexCode(weights.current, threshold);\n  }\n\n  const {top, topRight, right, current} = codes;\n  let code = -1;\n  if (Number.isFinite(threshold)) {\n    code = (top << 3) | (topRight << 2) | (right << 1) | current;\n  }\n  if (Array.isArray(threshold)) {\n    code = (top << 6) | (topRight << 4) | (right << 2) | current;\n  }\n\n  let meanCode = 0;\n  // meanCode is only needed for saddle cases, and they should\n  // only occur when we are not processing a cell on boundary\n  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\n  if (!isBoundary) {\n    meanCode = getVertexCode(\n      (weights.top + weights.topRight + weights.right + weights.current) / 4,\n      threshold\n    );\n  }\n  return {code, meanCode};\n}\n/* eslint-enable complexity, max-statements*/\n\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getVertices(opts) {\n  const {gridOrigin, cellSize, x, y, code, meanCode, type = CONTOUR_TYPE.ISO_LINES} = opts;\n  const thresholdData = Object.assign({}, DEFAULT_THRESHOLD_DATA, opts.thresholdData);\n  let offsets =\n    type === CONTOUR_TYPE.ISO_BANDS\n      ? ISOBANDS_CODE_OFFSET_MAP[code]\n      : ISOLINES_CODE_OFFSET_MAP[code];\n\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n\n  // Reference vertex is at top-right move to top-right corner\n\n  const vZ = thresholdData.zIndex * thresholdData.zOffset;\n  const rX = (x + 1) * cellSize[0];\n  const rY = (y + 1) * cellSize[1];\n\n  const refVertexX = gridOrigin[0] + rX;\n  const refVertexY = gridOrigin[1] + rY;\n\n  // offsets format\n  // ISO_LINES: [[1A, 1B], [2A, 2B]],\n  // ISO_BANDS: [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\n\n  // vertices format\n\n  // ISO_LINES: [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\n\n  // ISO_BANDS:  => confirms to SolidPolygonLayer's simple polygon format\n  //      [\n  //        [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\n  //        ...\n  //      ]\n\n  if (type === CONTOUR_TYPE.ISO_BANDS) {\n    const polygons = [];\n    offsets.forEach(polygonOffsets => {\n      const polygon = [];\n      polygonOffsets.forEach(xyOffset => {\n        const vX = refVertexX + xyOffset[0] * cellSize[0];\n        const vY = refVertexY + xyOffset[1] * cellSize[1];\n        polygon.push([vX, vY, vZ]);\n      });\n      polygons.push(polygon);\n    });\n    return polygons;\n  }\n\n  // default case is ISO_LINES\n  const lines = [];\n  offsets.forEach(xyOffsets => {\n    xyOffsets.forEach(offset => {\n      const vX = refVertexX + offset[0] * cellSize[0];\n      const vY = refVertexY + offset[1] * cellSize[1];\n      lines.push([vX, vY, vZ]);\n    });\n  });\n  return lines;\n}\n"]},"metadata":{},"sourceType":"module"}