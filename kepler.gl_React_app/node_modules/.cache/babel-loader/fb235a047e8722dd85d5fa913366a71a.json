{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport BinSorter from './bin-sorter';\nimport { getScaleFunctionByScaleType } from './scale-utils';\nimport { getValueFunc } from './aggregation-operation-utils';\nfunction nop() {}\nvar dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nvar _defaultDimensions = [{\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  pickingInfo: 'colorValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getColorValue',\n        updateTrigger: 'getColorValue'\n      },\n      weight: {\n        prop: 'getColorWeight',\n        updateTrigger: 'getColorWeight'\n      },\n      aggregation: {\n        prop: 'colorAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'lowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'upperPercentile'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'colorDomain'\n      },\n      range: {\n        prop: 'colorRange'\n      }\n    },\n    onSet: {\n      props: 'onSetColorDomain'\n    }\n  },\n  nullValue: [0, 0, 0, 0]\n}, {\n  key: 'elevation',\n  accessor: 'getElevation',\n  pickingInfo: 'elevationValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getElevationValue',\n        updateTrigger: 'getElevationValue'\n      },\n      weight: {\n        prop: 'getElevationWeight',\n        updateTrigger: 'getElevationWeight'\n      },\n      aggregation: {\n        prop: 'elevationAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'elevationLowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'elevationUpperPercentile'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'elevationDomain'\n      },\n      range: {\n        prop: 'elevationRange'\n      }\n    },\n    onSet: {\n      props: 'onSetElevationDomain'\n    }\n  },\n  nullValue: -1\n}];\nvar defaultGetCellSize = function defaultGetCellSize(props) {\n  return props.cellSize;\n};\nvar CPUAggregator = function () {\n  function CPUAggregator(opts) {\n    _classCallCheck(this, CPUAggregator);\n    this.state = {\n      layerData: {},\n      dimensions: {}\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || _defaultDimensions);\n  }\n  _createClass(CPUAggregator, [{\n    key: \"updateState\",\n    value: function updateState(opts, aggregationParams) {\n      var oldProps = opts.oldProps,\n        props = opts.props,\n        changeFlags = opts.changeFlags;\n      this.updateGetValueFuncs(oldProps, props, changeFlags);\n      var reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n      var aggregationDirty = false;\n      if (changeFlags.dataChanged || reprojectNeeded) {\n        this.getAggregatedData(props, aggregationParams);\n        aggregationDirty = true;\n      } else {\n        var dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n        dimensionChanges.forEach(function (f) {\n          return typeof f === 'function' && f();\n        });\n        aggregationDirty = true;\n      }\n      this.setState({\n        aggregationDirty: aggregationDirty\n      });\n      return this.state;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      this.state = Object.assign({}, this.state, updateObject);\n    }\n  }, {\n    key: \"setDimensionState\",\n    value: function setDimensionState(key, updateObject) {\n      this.setState({\n        dimensions: Object.assign({}, this.state.dimensions, _defineProperty({}, key, Object.assign({}, this.state.dimensions[key], updateObject)))\n      });\n    }\n  }, {\n    key: \"normalizeResult\",\n    value: function normalizeResult() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (result.hexagons) {\n        return Object.assign({\n          data: result.hexagons\n        }, result);\n      } else if (result.layerData) {\n        return Object.assign({\n          data: result.layerData\n        }, result);\n      }\n      return result;\n    }\n  }, {\n    key: \"getAggregatedData\",\n    value: function getAggregatedData(props, aggregationParams) {\n      var aggregator = this._getAggregator(props);\n      var result = aggregator(props, aggregationParams);\n      this.setState({\n        layerData: this.normalizeResult(result)\n      });\n      this.changeFlags = {\n        layerData: true\n      };\n      this.getSortedBins(props);\n    }\n  }, {\n    key: \"updateGetValueFuncs\",\n    value: function updateGetValueFuncs(oldProps, props, changeFlags) {\n      for (var key in this.dimensionUpdaters) {\n        var _this$dimensionUpdate = this.dimensionUpdaters[key].getBins.triggers,\n          value = _this$dimensionUpdate.value,\n          weight = _this$dimensionUpdate.weight,\n          aggregation = _this$dimensionUpdate.aggregation;\n        var getValue = props[value.prop];\n        var getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);\n        if (getValueChanged && getValue === null) {\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop]);\n        }\n        if (getValue) {\n          this.setDimensionState(key, {\n            getValue: getValue\n          });\n        }\n      }\n    }\n  }, {\n    key: \"needsReProjectPoints\",\n    value: function needsReProjectPoints(oldProps, props, changeFlags) {\n      return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);\n    }\n  }, {\n    key: \"addDimension\",\n    value: function addDimension(dimensions) {\n      this._addDimension(dimensions);\n    }\n  }, {\n    key: \"_addDimension\",\n    value: function _addDimension() {\n      var _this = this;\n      var dimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      dimensions.forEach(function (dimension) {\n        var key = dimension.key;\n        _this.dimensionUpdaters[key] = _this.getDimensionUpdaters(dimension);\n        _this.state.dimensions[key] = {\n          getValue: null,\n          domain: null,\n          sortedBins: null,\n          scaleFunc: nop\n        };\n      });\n    }\n  }, {\n    key: \"getDimensionUpdaters\",\n    value: function getDimensionUpdaters(_ref) {\n      var key = _ref.key,\n        accessor = _ref.accessor,\n        pickingInfo = _ref.pickingInfo,\n        getBins = _ref.getBins,\n        getDomain = _ref.getDomain,\n        getScaleFunc = _ref.getScaleFunc,\n        nullValue = _ref.nullValue;\n      return {\n        key: key,\n        accessor: accessor,\n        pickingInfo: pickingInfo,\n        getBins: Object.assign({\n          updater: this.getDimensionSortedBins\n        }, getBins),\n        getDomain: Object.assign({\n          updater: this.getDimensionValueDomain\n        }, getDomain),\n        getScaleFunc: Object.assign({\n          updater: this.getDimensionScale\n        }, getScaleFunc),\n        attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n      };\n    }\n  }, {\n    key: \"needUpdateDimensionStep\",\n    value: function needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n      return Object.values(dimensionStep.triggers).some(function (item) {\n        if (item.updateTrigger) {\n          return changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);\n        }\n        return oldProps[item.prop] !== props[item.prop];\n      });\n    }\n  }, {\n    key: \"getDimensionChanges\",\n    value: function getDimensionChanges(oldProps, props, changeFlags) {\n      var _this2 = this;\n      var updaters = [];\n      var _loop = function _loop(key) {\n        var needUpdate = dimensionSteps.find(function (step) {\n          return _this2.needUpdateDimensionStep(_this2.dimensionUpdaters[key][step], oldProps, props, changeFlags);\n        });\n        if (needUpdate) {\n          updaters.push(_this2.dimensionUpdaters[key][needUpdate].updater.bind(_this2, props, _this2.dimensionUpdaters[key]));\n        }\n      };\n      for (var key in this.dimensionUpdaters) {\n        _loop(key);\n      }\n      return updaters.length ? updaters : null;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers(props) {\n      var _this3 = this;\n      var _updateTriggers = props.updateTriggers || {};\n      var updateTriggers = {};\n      var _loop2 = function _loop2(key) {\n        var accessor = _this3.dimensionUpdaters[key].accessor;\n        updateTriggers[accessor] = {};\n        dimensionSteps.forEach(function (step) {\n          Object.values(_this3.dimensionUpdaters[key][step].triggers).forEach(function (_ref2) {\n            var prop = _ref2.prop,\n              updateTrigger = _ref2.updateTrigger;\n            if (updateTrigger) {\n              var fromProp = _updateTriggers[updateTrigger];\n              if (_typeof(fromProp) === 'object' && !Array.isArray(fromProp)) {\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          });\n        });\n      };\n      for (var key in this.dimensionUpdaters) {\n        _loop2(key);\n      }\n      return updateTriggers;\n    }\n  }, {\n    key: \"getSortedBins\",\n    value: function getSortedBins(props) {\n      for (var key in this.dimensionUpdaters) {\n        this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n      }\n    }\n  }, {\n    key: \"getDimensionSortedBins\",\n    value: function getDimensionSortedBins(props, dimensionUpdater) {\n      var key = dimensionUpdater.key;\n      var getValue = this.state.dimensions[key].getValue;\n      var sortedBins = new BinSorter(this.state.layerData.data || [], {\n        getValue: getValue,\n        filterData: props._filterData\n      });\n      this.setDimensionState(key, {\n        sortedBins: sortedBins\n      });\n      this.getDimensionValueDomain(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionValueDomain\",\n    value: function getDimensionValueDomain(props, dimensionUpdater) {\n      var getDomain = dimensionUpdater.getDomain,\n        key = dimensionUpdater.key;\n      var _getDomain$triggers = getDomain.triggers,\n        lowerPercentile = _getDomain$triggers.lowerPercentile,\n        upperPercentile = _getDomain$triggers.upperPercentile,\n        scaleType = _getDomain$triggers.scaleType;\n      var valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n      this.setDimensionState(key, {\n        valueDomain: valueDomain\n      });\n      this.getDimensionScale(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionScale\",\n    value: function getDimensionScale(props, dimensionUpdater) {\n      var key = dimensionUpdater.key,\n        getScaleFunc = dimensionUpdater.getScaleFunc,\n        getDomain = dimensionUpdater.getDomain;\n      var _getScaleFunc$trigger = getScaleFunc.triggers,\n        domain = _getScaleFunc$trigger.domain,\n        range = _getScaleFunc$trigger.range;\n      var scaleType = getDomain.triggers.scaleType;\n      var onSet = getScaleFunc.onSet;\n      var dimensionRange = props[range.prop];\n      var dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n      var getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n      var scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n      if (_typeof(onSet) === 'object' && typeof props[onSet.props] === 'function') {\n        props[onSet.props](scaleFunc.domain());\n      }\n      this.setDimensionState(key, {\n        scaleFunc: scaleFunc\n      });\n    }\n  }, {\n    key: \"getSubLayerDimensionAttribute\",\n    value: function getSubLayerDimensionAttribute(key, nullValue) {\n      var _this4 = this;\n      return function (cell) {\n        var _this4$state$dimensio = _this4.state.dimensions[key],\n          sortedBins = _this4$state$dimensio.sortedBins,\n          scaleFunc = _this4$state$dimensio.scaleFunc;\n        var bin = sortedBins.binMap[cell.index];\n        if (bin && bin.counts === 0) {\n          return nullValue;\n        }\n        var cv = bin && bin.value;\n        var domain = scaleFunc.domain();\n        var isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n        return isValueInDomain ? scaleFunc(cv) : nullValue;\n      };\n    }\n  }, {\n    key: \"getSubLayerAccessors\",\n    value: function getSubLayerAccessors(props) {\n      var accessors = {};\n      for (var key in this.dimensionUpdaters) {\n        var accessor = this.dimensionUpdaters[key].accessor;\n        accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n      }\n      return accessors;\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info;\n      var isPicked = info.picked && info.index > -1;\n      var object = null;\n      if (isPicked) {\n        var cell = this.state.layerData.data[info.index];\n        var binInfo = {};\n        for (var key in this.dimensionUpdaters) {\n          var pickingInfo = this.dimensionUpdaters[key].pickingInfo;\n          var sortedBins = this.state.dimensions[key].sortedBins;\n          var value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n          binInfo[pickingInfo] = value;\n        }\n        object = Object.assign(binInfo, cell, {\n          points: cell.filteredPoints || cell.points\n        });\n      }\n      return Object.assign(info, {\n        picked: Boolean(object),\n        object: object\n      });\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(dimensionKey) {\n      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n        return nop;\n      }\n      return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n    }\n  }], [{\n    key: \"defaultDimensions\",\n    value: function defaultDimensions() {\n      return _defaultDimensions;\n    }\n  }]);\n  return CPUAggregator;\n}();\nexport { CPUAggregator as default };","map":{"version":3,"sources":["../../../src/utils/cpu-aggregator.js"],"names":["BinSorter","getScaleFunctionByScaleType","getValueFunc","nop","dimensionSteps","defaultDimensions","key","accessor","pickingInfo","getBins","triggers","value","prop","updateTrigger","weight","aggregation","filterData","getDomain","lowerPercentile","upperPercentile","scaleType","getScaleFunc","domain","range","onSet","props","nullValue","defaultGetCellSize","cellSize","CPUAggregator","opts","state","layerData","dimensions","changeFlags","dimensionUpdaters","_getCellSize","getCellSize","_getAggregator","getAggregator","_addDimension","aggregationParams","oldProps","updateGetValueFuncs","reprojectNeeded","needsReProjectPoints","aggregationDirty","dataChanged","getAggregatedData","dimensionChanges","getDimensionChanges","forEach","f","setState","updateObject","Object","assign","result","hexagons","data","aggregator","normalizeResult","getSortedBins","getValue","getValueChanged","needUpdateDimensionStep","setDimensionState","updateTriggersChanged","all","getPosition","dimension","getDimensionUpdaters","sortedBins","scaleFunc","updater","getDimensionSortedBins","getDimensionValueDomain","getDimensionScale","attributeAccessor","getSubLayerDimensionAttribute","dimensionStep","values","some","item","updaters","needUpdate","find","step","push","bind","length","_updateTriggers","updateTriggers","fromProp","Array","isArray","undefined","dimensionUpdater","_filterData","valueDomain","getValueDomainByScale","dimensionRange","dimensionDomain","getScaleFunction","bin","binMap","cell","index","counts","cv","isValueInDomain","accessors","info","isPicked","picked","object","binInfo","points","filteredPoints","Boolean","dimensionKey","hasOwnProperty"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport BinSorter from './bin-sorter';\nimport {getScaleFunctionByScaleType} from './scale-utils';\nimport {getValueFunc} from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [\n  {\n    key: 'fillColor',\n    accessor: 'getFillColor',\n    pickingInfo: 'colorValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {\n          prop: 'colorScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      }\n    },\n    nullValue: [0, 0, 0, 0]\n  },\n  {\n    key: 'elevation',\n    accessor: 'getElevation',\n    pickingInfo: 'elevationValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {\n          prop: 'elevationScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      }\n    },\n    nullValue: -1\n  }\n];\nconst defaultGetCellSize = props => props.cellSize;\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      // project data into bin and aggregate wegiths per bin\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      // this here is layer\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n    this.setState({aggregationDirty});\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = Object.assign({}, this.state, updateObject);\n  }\n\n  // Update private state.dimensions\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: Object.assign({}, this.state.dimensions, {\n        [key]: Object.assign({}, this.state.dimensions[key], updateObject)\n      })\n    });\n  }\n\n  normalizeResult(result = {}) {\n    // support previous hexagonAggregator API\n    if (result.hexagons) {\n      return Object.assign({data: result.hexagons}, result);\n    } else if (result.layerData) {\n      return Object.assign({data: result.layerData}, result);\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {value, weight, aggregation} = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(\n        this.dimensionUpdaters[key].getBins,\n        oldProps,\n        props,\n        changeFlags\n      );\n\n      if (getValueChanged && getValue === null) {\n        // If `getValue` is not provided from props, build it with aggregation and weight.\n        getValue = getValueFunc(props[aggregation.prop], props[weight.prop]);\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {getValue});\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return (\n      this._getCellSize(oldProps) !== this._getCellSize(props) ||\n      this._getAggregator(oldProps) !== this._getAggregator(props) ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition))\n    );\n  }\n\n  // Adds dimensions\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue}) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: Object.assign({updater: this.getDimensionSortedBins}, getBins),\n      getDomain: Object.assign({updater: this.getDimensionValueDomain}, getDomain),\n      getScaleFunc: Object.assign({updater: this.getDimensionScale}, getScaleFunc),\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    // getBins: {\n    //   value: {\n    //     prop: 'getElevationValue',\n    //     updateTrigger: 'getElevationValue'\n    //   },\n    //   weight: {\n    //     prop: 'getElevationWeight',\n    //     updateTrigger: 'getElevationWeight'\n    //   },\n    //   aggregation: {\n    //     prop: 'elevationAggregation'\n    //   }\n    // }\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        return (\n          changeFlags.updateTriggersChanged &&\n          (changeFlags.updateTriggersChanged.all ||\n            changeFlags.updateTriggersChanged[item.updateTrigger])\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    // const {dimensionUpdaters} = this.state;\n    const updaters = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const needUpdate = dimensionSteps.find(step =>\n        this.needUpdateDimensionStep(\n          this.dimensionUpdaters[key][step],\n          oldProps,\n          props,\n          changeFlags\n        )\n      );\n\n      if (needUpdate) {\n        updaters.push(\n          this.dimensionUpdaters[key][needUpdate].updater.bind(\n            this,\n            props,\n            this.dimensionUpdaters[key]\n          )\n        );\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(\n          ({prop, updateTrigger}) => {\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              const fromProp = _updateTriggers[updateTrigger];\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          }\n        );\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {key} = dimensionUpdater;\n    const {getValue} = this.state.dimensions[key];\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {sortedBins});\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {getDomain, key} = dimensionUpdater;\n    const {\n      triggers: {lowerPercentile, upperPercentile, scaleType}\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n      props[scaleType.prop],\n      [props[lowerPercentile.prop], props[upperPercentile.prop]]\n    );\n\n    this.setDimensionState(key, {valueDomain});\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {key, getScaleFunc, getDomain} = dimensionUpdater;\n    const {domain, range} = getScaleFunc.triggers;\n    const {scaleType} = getDomain.triggers;\n    const {onSet} = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {scaleFunc});\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {sortedBins, scaleFunc} = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        // no points left in bin after filtering\n        return nullValue;\n      }\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n      // if cell value is outside domain, set alpha to 0\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({info}) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      // const {sortedColorBins, sortedElevationBins} = this.state;\n\n      const cell = this.state.layerData.data[info.index];\n\n      const binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {pickingInfo} = this.dimensionUpdaters[key];\n        const {sortedBins} = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // add bin colorValue and elevationValue to info\n    return Object.assign(info, {\n      picked: Boolean(object),\n      // override object with picked cell\n      object\n    });\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}