{"ast":null,"code":"import { getCode, getVertices, CONTOUR_TYPE } from './marching-squares';\nexport function generateContours(_ref) {\n  var thresholdData = _ref.thresholdData,\n    colors = _ref.colors,\n    cellWeights = _ref.cellWeights,\n    gridSize = _ref.gridSize,\n    gridOrigin = _ref.gridOrigin,\n    cellSize = _ref.cellSize;\n  var contourSegments = [];\n  var contourPolygons = [];\n  var width = gridSize[0];\n  var height = gridSize[1];\n  var segmentIndex = 0;\n  var polygonIndex = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n  try {\n    for (var _iterator = thresholdData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var data = _step.value;\n      var contour = data.contour;\n      var threshold = contour.threshold;\n      for (var x = -1; x < width; x++) {\n        for (var y = -1; y < height; y++) {\n          var _getCode = getCode({\n              cellWeights: cellWeights,\n              threshold: threshold,\n              x: x,\n              y: y,\n              width: width,\n              height: height\n            }),\n            code = _getCode.code,\n            meanCode = _getCode.meanCode;\n          var opts = {\n            gridOrigin: gridOrigin,\n            cellSize: cellSize,\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            code: code,\n            meanCode: meanCode,\n            thresholdData: data\n          };\n          if (Array.isArray(threshold)) {\n            opts.type = CONTOUR_TYPE.ISO_BANDS;\n            var polygons = getVertices(opts);\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n            try {\n              for (var _iterator2 = polygons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var polygon = _step2.value;\n                contourPolygons[polygonIndex++] = {\n                  vertices: polygon,\n                  contour: contour\n                };\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                  _iterator2[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          } else {\n            opts.type = CONTOUR_TYPE.ISO_LINES;\n            var vertices = getVertices(opts);\n            for (var i = 0; i < vertices.length; i += 2) {\n              contourSegments[segmentIndex++] = {\n                start: vertices[i],\n                end: vertices[i + 1],\n                contour: contour\n              };\n            }\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n  return {\n    contourSegments: contourSegments,\n    contourPolygons: contourPolygons\n  };\n}","map":{"version":3,"sources":["../../../src/contour-layer/contour-utils.js"],"names":["getCode","getVertices","CONTOUR_TYPE","generateContours","thresholdData","colors","cellWeights","gridSize","gridOrigin","cellSize","contourSegments","contourPolygons","width","height","segmentIndex","polygonIndex","data","contour","threshold","x","y","code","meanCode","opts","Array","isArray","type","ISO_BANDS","polygons","polygon","vertices","ISO_LINES","i","length","start","end"],"mappings":"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","sourcesContent":["import {getCode, getVertices, CONTOUR_TYPE} from './marching-squares';\n\n// Given all the cell weights, generates contours for each threshold.\n/* eslint-disable max-depth */\nexport function generateContours({\n  thresholdData,\n  colors,\n  cellWeights,\n  gridSize,\n  gridOrigin,\n  cellSize\n}) {\n  const contourSegments = [];\n  const contourPolygons = [];\n  const width = gridSize[0];\n  const height = gridSize[1];\n  let segmentIndex = 0;\n  let polygonIndex = 0;\n\n  for (const data of thresholdData) {\n    const {contour} = data;\n    const {threshold} = contour;\n    for (let x = -1; x < width; x++) {\n      for (let y = -1; y < height; y++) {\n        // Get the MarchingSquares code based on neighbor cell weights.\n        const {code, meanCode} = getCode({\n          cellWeights,\n          threshold,\n          x,\n          y,\n          width,\n          height\n        });\n        const opts = {\n          gridOrigin,\n          cellSize,\n          x,\n          y,\n          width,\n          height,\n          code,\n          meanCode,\n          thresholdData: data\n        };\n        if (Array.isArray(threshold)) {\n          opts.type = CONTOUR_TYPE.ISO_BANDS;\n          const polygons = getVertices(opts);\n          for (const polygon of polygons) {\n            contourPolygons[polygonIndex++] = {\n              vertices: polygon,\n              contour\n            };\n          }\n        } else {\n          // Get the intersection vertices based on MarchingSquares code.\n          opts.type = CONTOUR_TYPE.ISO_LINES;\n          const vertices = getVertices(opts);\n          for (let i = 0; i < vertices.length; i += 2) {\n            contourSegments[segmentIndex++] = {\n              start: vertices[i],\n              end: vertices[i + 1],\n              contour\n            };\n          }\n        }\n      }\n    }\n  }\n  return {contourSegments, contourPolygons};\n}\n/* eslint-enable max-depth */\n"]},"metadata":{},"sourceType":"module"}