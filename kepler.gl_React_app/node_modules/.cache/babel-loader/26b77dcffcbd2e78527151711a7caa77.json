{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { AsyncQueue, TableBatchBuilder, RowTableBatch } from '@loaders.gl/tables';\nimport Papa from './libs/papaparse';\nimport AsyncIteratorStreamer from './lib/async-iterator-streamer';\nvar VERSION = typeof \"2.3.13\" !== 'undefined' ? \"2.3.13\" : 'latest';\nvar CSVLoaderOptions = {\n  csv: {\n    TableBatch: RowTableBatch,\n    batchSize: 10,\n    optimizeMemoryUsage: false,\n    header: 'auto',\n    rowFormat: 'auto',\n    columnPrefix: 'column',\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: false,\n    delimitersToGuess: [',', '\\t', '|', ';']\n  }\n};\nexport default {\n  id: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv'],\n  mimeTypes: ['text/csv'],\n  category: 'table',\n  parse: function () {\n    var _parse = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(arrayBuffer, options) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", parseCSV(new TextDecoder().decode(arrayBuffer), options));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    function parse(_x, _x2) {\n      return _parse.apply(this, arguments);\n    }\n    return parse;\n  }(),\n  parseText: parseCSV,\n  parseInBatches: parseCSVInBatches,\n  testText: null,\n  options: CSVLoaderOptions\n};\nfunction parseCSV(_x3, _x4) {\n  return _parseCSV.apply(this, arguments);\n}\nfunction _parseCSV() {\n  _parseCSV = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(csvText, options) {\n    var header, config, result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _objectSpread(_objectSpread({}, CSVLoaderOptions), options);\n            options.csv = _objectSpread(_objectSpread({}, CSVLoaderOptions.csv), options.csv);\n            _context2.next = 4;\n            return hasHeader(csvText, options);\n          case 4:\n            header = _context2.sent;\n            config = _objectSpread(_objectSpread({\n              dynamicTyping: true\n            }, options.csv), {}, {\n              header: header,\n              download: false,\n              error: function error(e) {\n                throw new Error(e);\n              }\n            });\n            result = Papa.parse(csvText, config);\n            return _context2.abrupt(\"return\", result.data);\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _parseCSV.apply(this, arguments);\n}\nfunction parseCSVInBatches(asyncIterator, options) {\n  options = _objectSpread(_objectSpread({}, CSVLoaderOptions), options);\n  options.csv = _objectSpread(_objectSpread({}, CSVLoaderOptions.csv), options.csv);\n  var _options$csv = options.csv,\n    batchSize = _options$csv.batchSize,\n    optimizeMemoryUsage = _options$csv.optimizeMemoryUsage;\n  var TableBatchType = options.csv.TableBatch;\n  var asyncQueue = new AsyncQueue();\n  var convertToObject = options.csv.rowFormat === 'object';\n  var isFirstRow = true;\n  var headerRow = null;\n  var tableBatchBuilder = null;\n  var schema = null;\n  var config = _objectSpread(_objectSpread({\n    dynamicTyping: true\n  }, options.csv), {}, {\n    header: false,\n    download: false,\n    step: function step(results, parser) {\n      var row = results.data;\n      var bytesUsed = results.meta.cursor;\n      if (isFirstRow && !headerRow) {\n        var header = isHeaderRow(row, options);\n        if (header) {\n          headerRow = row;\n          return;\n        }\n      }\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = [];\n          for (var i = 0; i < row.length; i++) {\n            headerRow[i] = \"\".concat(options.csv.columnPrefix).concat(i + 1);\n          }\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n      tableBatchBuilder = tableBatchBuilder || new TableBatchBuilder(TableBatchType, schema, {\n        batchSize: batchSize,\n        convertToObject: convertToObject,\n        optimizeMemoryUsage: optimizeMemoryUsage\n      });\n      tableBatchBuilder.addRow(row);\n      if (tableBatchBuilder.isFull()) {\n        asyncQueue.enqueue(tableBatchBuilder.getBatch({\n          bytesUsed: bytesUsed\n        }));\n      }\n    },\n    complete: function complete(results, file) {\n      var bytesUsed = results.meta.cursor;\n      var batch = tableBatchBuilder.getBatch({\n        bytesUsed: bytesUsed\n      });\n      if (batch) {\n        asyncQueue.enqueue(batch);\n      }\n      asyncQueue.close();\n    }\n  });\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n  return asyncQueue;\n}\nfunction isHeaderRow(row, options) {\n  if (options && options.csv.header !== 'auto') {\n    return Boolean(options.csv.header);\n  }\n  return row.every(function (value) {\n    return typeof value === 'string';\n  });\n}\nfunction hasHeader(_x5, _x6) {\n  return _hasHeader.apply(this, arguments);\n}\nfunction _hasHeader() {\n  _hasHeader = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(csvText, options) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(options.csv.header !== 'auto')) {\n              _context3.next = 2;\n              break;\n            }\n            return _context3.abrupt(\"return\", Boolean(options.csv.header));\n          case 2:\n            _context3.next = 4;\n            return new Promise(function (resolve, reject) {\n              Papa.parse(csvText, {\n                download: false,\n                dynamicTyping: true,\n                step: function step(results, parser) {\n                  parser.abort();\n                  var row = results.data;\n                  resolve(isHeaderRow(row));\n                },\n                error: function error(e) {\n                  reject(new Error(e));\n                }\n              });\n            });\n          case 4:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _hasHeader.apply(this, arguments);\n}\nfunction deduceSchema(row, headerRow) {\n  var schema = headerRow ? {} : [];\n  for (var i = 0; i < row.length; i++) {\n    var columnName = headerRow && headerRow[i] || i;\n    var value = row[i];\n    switch (_typeof(value)) {\n      case 'number':\n      case 'boolean':\n        schema[columnName] = {\n          name: String(columnName),\n          index: i,\n          type: Float32Array\n        };\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {\n          name: String(columnName),\n          index: i,\n          type: Array\n        };\n    }\n  }\n  return schema;\n}","map":{"version":3,"sources":["../../src/csv-loader.js"],"names":["AsyncQueue","TableBatchBuilder","RowTableBatch","Papa","AsyncIteratorStreamer","VERSION","CSVLoaderOptions","csv","TableBatch","batchSize","optimizeMemoryUsage","header","rowFormat","columnPrefix","quoteChar","escapeChar","dynamicTyping","comments","skipEmptyLines","delimitersToGuess","id","name","version","extensions","mimeTypes","category","parse","arrayBuffer","options","parseCSV","TextDecoder","decode","parseText","parseInBatches","parseCSVInBatches","testText","csvText","hasHeader","config","download","error","Error","e","result","data","asyncIterator","TableBatchType","asyncQueue","convertToObject","isFirstRow","headerRow","tableBatchBuilder","schema","step","results","parser","row","bytesUsed","meta","cursor","isHeaderRow","i","length","deduceSchema","addRow","isFull","enqueue","getBatch","complete","file","batch","close","Boolean","every","value","Promise","resolve","reject","abort","columnName","String","index","type","Float32Array","Array"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAQA,UAAR,EAAoBC,iBAApB,EAAuCC,aAAvC,QAA2D,oBAA3D;AACA,OAAOC,IAAP,MAAiB,kBAAjB;AACA,OAAOC,qBAAP,MAAkC,+BAAlC;AAKA,IAAMC,OAAO,GAAG,OAAA,QAAA,KAAuB,WAAvB,GAAA,QAAA,GAAmD,QAAnE;AAEA,IAAMC,gBAAgB,GAAG;EACvBC,GAAG,EAAE;IACHC,UAAU,EAAEN,aADT;IAEHO,SAAS,EAAE,EAFR;IAGHC,mBAAmB,EAAE,KAHlB;IAKHC,MAAM,EAAE,MALL;IAMHC,SAAS,EAAE,MANR;IAOHC,YAAY,EAAE,QAPX;IAUHC,SAAS,EAAE,GAVR;IAWHC,UAAU,EAAE,GAXT;IAYHC,aAAa,EAAE,IAZZ;IAaHC,QAAQ,EAAE,KAbP;IAcHC,cAAc,EAAE,KAdb;IAgBHC,iBAAiB,EAAE,CAAC,GAAD,EAAM,IAAN,EAAY,GAAZ,EAAiB,GAAjB;EAhBhB;AADkB,CAAzB;AAuBA,eAAe;EACbC,EAAE,EAAE,KADS;EAEbC,IAAI,EAAE,KAFO;EAGbC,OAAO,EAAEjB,OAHI;EAIbkB,UAAU,EAAE,CAAC,KAAD,CAJC;EAKbC,SAAS,EAAE,CAAC,UAAD,CALE;EAMbC,QAAQ,EAAE,OANG;EAObC,KAAK,EAAA,YAAA;IAAA,IAAA,MAAA,GAAA,iBAAA,CAAA,mBAAA,CAAA,IAAA,CAAE,SAAA,OAAA,CAAOC,WAAP,EAAoBC,OAApB,EAAA;MAAA,OAAA,mBAAA,CAAA,IAAA,CAAA,SAAA,QAAA,CAAA,QAAA,EAAA;QAAA,OAAA,CAAA,EAAA;UAAA,QAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;YAAA,KAAA,CAAA;cAAA,OAAA,QAAA,CAAA,MAAA,CAAA,QAAA,EAAgCC,QAAQ,CAAC,IAAIC,WAAJ,EAAA,CAAkBC,MAAlB,CAAyBJ,WAAzB,CAAD,EAAwCC,OAAxC,CAAxC,CAAA;YAAA,KAAA,CAAA;YAAA,KAAA,KAAA;cAAA,OAAA,QAAA,CAAA,IAAA,EAAA;UAAA;QAAA;MAAA,CAAA,EAAA,OAAA,CAAA;IAAA,CAAF,CAAA,CAAA;IAAA,SAAA,KAAA,CAAA,EAAA,EAAA,GAAA,EAAA;MAAA,OAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA;IAAA;IAAA,OAAA,KAAA;EAAA,CAAA,EAPQ;EAQbI,SAAS,EAAEH,QARE;EASbI,cAAc,EAAEC,iBATH;EAUbC,QAAQ,EAAE,IAVG;EAWbP,OAAO,EAAEtB;AAXI,CAAf;SAceuB,Q;;;;yDAAf,SAAA,QAAA,CAAwBO,OAAxB,EAAiCR,OAAjC,EAAA;IAAA,IAAA,MAAA,EAAA,MAAA,EAAA,MAAA;IAAA,OAAA,mBAAA,CAAA,IAAA,CAAA,SAAA,SAAA,CAAA,SAAA,EAAA;MAAA,OAAA,CAAA,EAAA;QAAA,QAAA,SAAA,CAAA,IAAA,GAAA,SAAA,CAAA,IAAA;UAAA,KAAA,CAAA;YAEEA,OAAO,GAAA,aAAA,CAAA,aAAA,CAAA,CAAA,CAAA,EAAOtB,gBAAP,CAAA,EAA4BsB,OAA5B,CAAPA;YACAA,OAAO,CAACrB,GAARqB,GAAAA,aAAAA,CAAAA,aAAAA,CAAAA,CAAAA,CAAAA,EAAkBtB,gBAAgB,CAACC,GAAnCqB,CAAAA,EAA2CA,OAAO,CAACrB,GAAnDqB,CAAAA;YAHF,SAAA,CAAA,IAAA,GAAA,CAAA;YAAA,OAKuBS,SAAS,CAACD,OAAD,EAAUR,OAAV,CALhC;UAAA,KAAA,CAAA;YAKQjB,MALR,GAAA,SAAA,CAAA,IAAA;YAOQ2B,MAPR,GAAA,aAAA,CAAA,aAAA,CAAA;cAQItB,aAAa,EAAE;YARnB,CAAA,EASOY,OAAO,CAACrB,GATf,CAAA,EAAA,CAAA,CAAA,EAAA;cAUII,MAAM,EAANA,MAVJ;cAWI4B,QAAQ,EAAE,KAXd;cAYIC,KAAK,EAAE,SAAA,KAAA,CAAA,CAAC,EAAI;gBACV,MAAM,IAAIC,KAAJ,CAAUC,CAAV,CAAN;cACD;YAdL,CAAA,CAAA;YAiBQC,MAjBR,GAiBiBxC,IAAI,CAACuB,KAALvB,CAAWiC,OAAXjC,EAAoBmC,MAApBnC,CAjBjB;YAAA,OAAA,SAAA,CAAA,MAAA,CAAA,QAAA,EAkBSwC,MAAM,CAACC,IAlBhB,CAAA;UAAA,KAAA,CAAA;UAAA,KAAA,KAAA;YAAA,OAAA,SAAA,CAAA,IAAA,EAAA;QAAA;MAAA;IAAA,CAAA,EAAA,QAAA,CAAA;EAAA,C;;;AAsBA,SAASV,iBAAT,CAA2BW,aAA3B,EAA0CjB,OAA1C,EAAmD;EAEjDA,OAAO,GAAA,aAAA,CAAA,aAAA,CAAA,CAAA,CAAA,EAAOtB,gBAAP,CAAA,EAA4BsB,OAA5B,CAAPA;EACAA,OAAO,CAACrB,GAARqB,GAAAA,aAAAA,CAAAA,aAAAA,CAAAA,CAAAA,CAAAA,EAAkBtB,gBAAgB,CAACC,GAAnCqB,CAAAA,EAA2CA,OAAO,CAACrB,GAAnDqB,CAAAA;EAHiD,IAAA,YAAA,GAKRA,OAAO,CAACrB,GALA;IAK1CE,SAL0C,GAAA,YAAA,CAK1CA,SAL0C;IAK/BC,mBAL+B,GAAA,YAAA,CAK/BA,mBAL+B;EAMjD,IAAMoC,cAAc,GAAGlB,OAAO,CAACrB,GAARqB,CAAYpB,UAAnC;EAEA,IAAMuC,UAAU,GAAG,IAAI/C,UAAJ,EAAnB;EAEA,IAAMgD,eAAe,GAAGpB,OAAO,CAACrB,GAARqB,CAAYhB,SAAZgB,KAA0B,QAAlD;EAEA,IAAIqB,UAAU,GAAG,IAAjB;EACA,IAAIC,SAAS,GAAG,IAAhB;EACA,IAAIC,iBAAiB,GAAG,IAAxB;EACA,IAAIC,MAAM,GAAG,IAAb;EAEA,IAAMd,MAAM,GAAA,aAAA,CAAA,aAAA,CAAA;IACVtB,aAAa,EAAE;EADL,CAAA,EAEPY,OAAO,CAACrB,GAFD,CAAA,EAAA,CAAA,CAAA,EAAA;IAGVI,MAAM,EAAE,KAHE;IAIV4B,QAAQ,EAAE,KAJA;IAYVc,IAZU,EAAA,SAAA,IAAA,CAYLC,OAZK,EAYIC,MAZJ,EAYY;MACpB,IAAMC,GAAG,GAAGF,OAAO,CAACV,IAApB;MACA,IAAMa,SAAS,GAAGH,OAAO,CAACI,IAARJ,CAAaK,MAA/B;MAGA,IAAIV,UAAU,IAAI,CAACC,SAAnB,EAA8B;QAE5B,IAAMvC,MAAM,GAAGiD,WAAW,CAACJ,GAAD,EAAM5B,OAAN,CAA1B;QACA,IAAIjB,MAAJ,EAAY;UACVuC,SAAS,GAAGM,GAAZN;UACA;QACD;MACF;MAGD,IAAID,UAAJ,EAAgB;QACdA,UAAU,GAAG,KAAbA;QACA,IAAI,CAACC,SAAL,EAAgB;UACdA,SAAS,GAAG,EAAZA;UACA,KAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAAG,CAACM,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;YACnCX,SAAS,CAACW,CAAD,CAATX,GAAAA,EAAAA,CAAAA,MAAAA,CAAkBtB,OAAO,CAACrB,GAARqB,CAAYf,YAA9BqC,CAAAA,CAAAA,MAAAA,CAA6CW,CAAC,GAAG,CAAjDX,CAAAA;UACD;QACF;QACDE,MAAM,GAAGW,YAAY,CAACP,GAAD,EAAMN,SAAN,CAArBE;MACD;MAGDD,iBAAiB,GACfA,iBAAiB,IACjB,IAAIlD,iBAAJ,CAAsB6C,cAAtB,EAAsCM,MAAtC,EAA8C;QAC5C3C,SAAS,EAATA,SAD4C;QAE5CuC,eAAe,EAAfA,eAF4C;QAG5CtC,mBAAmB,EAAnBA;MAH4C,CAA9C,CAFFyC;MAQAA,iBAAiB,CAACa,MAAlBb,CAAyBK,GAAzBL,CAAAA;MAEA,IAAIA,iBAAiB,CAACc,MAAlBd,EAAJ,EAAgC;QAC9BJ,UAAU,CAACmB,OAAXnB,CAAmB,iBAAiB,CAACoB,QAAlB,CAA2B;UAACV,SAAS,EAATA;QAAD,CAA3B,CAAnBV,CAAAA;MACD;IACF,CApDS;IAuDVqB,QAvDU,EAAA,SAAA,QAAA,CAuDDd,OAvDC,EAuDQe,IAvDR,EAuDc;MACtB,IAAMZ,SAAS,GAAGH,OAAO,CAACI,IAARJ,CAAaK,MAA/B;MAEA,IAAMW,KAAK,GAAG,iBAAiB,CAACH,QAAlB,CAA2B;QAACV,SAAS,EAATA;MAAD,CAA3B,CAAd;MACA,IAAIa,KAAJ,EAAW;QACTvB,UAAU,CAACmB,OAAXnB,CAAmBuB,KAAnBvB,CAAAA;MACD;MACDA,UAAU,CAACwB,KAAXxB,EAAAA;IACD;EA/DS,CAAA,CAAZ;EAkEA5C,IAAI,CAACuB,KAALvB,CAAW0C,aAAX1C,EAA0BmC,MAA1BnC,EAAkCC,qBAAlCD,CAAAA;EAIA,OAAO4C,UAAP;AACD;AAED,SAASa,WAAT,CAAqBJ,GAArB,EAA0B5B,OAA1B,EAAmC;EACjC,IAAIA,OAAO,IAAIA,OAAO,CAACrB,GAARqB,CAAYjB,MAAZiB,KAAuB,MAAtC,EAA8C;IAC5C,OAAO4C,OAAO,CAAC5C,OAAO,CAACrB,GAARqB,CAAYjB,MAAb,CAAd;EACD;EAED,OAAO,GAAG,CAAC8D,KAAJ,CAAU,UAAA,KAAK,EAAA;IAAA,OAAI,OAAOC,KAAP,KAAiB,QAArB;EAAA,CAAf,CAAP;AACD;SAEcrC,S;;;;0DAAf,SAAA,QAAA,CAAyBD,OAAzB,EAAkCR,OAAlC,EAAA;IAAA,OAAA,mBAAA,CAAA,IAAA,CAAA,SAAA,SAAA,CAAA,SAAA,EAAA;MAAA,OAAA,CAAA,EAAA;QAAA,QAAA,SAAA,CAAA,IAAA,GAAA,SAAA,CAAA,IAAA;UAAA,KAAA,CAAA;YAAA,IAAA,EACMA,OAAO,CAACrB,GAARqB,CAAYjB,MAAZiB,KAAuB,MAD7B,CAAA,EAAA;cAAA,SAAA,CAAA,IAAA,GAAA,CAAA;cAAA;YAAA;YAAA,OAAA,SAAA,CAAA,MAAA,CAAA,QAAA,EAEW4C,OAAO,CAAC5C,OAAO,CAACrB,GAARqB,CAAYjB,MAAb,CAFlB,CAAA;UAAA,KAAA,CAAA;YAAA,SAAA,CAAA,IAAA,GAAA,CAAA;YAAA,OAKe,IAAIgE,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;cAC5C1E,IAAI,CAACuB,KAALvB,CAAWiC,OAAXjC,EAAoB;gBAClBoC,QAAQ,EAAE,KADQ;gBAElBvB,aAAa,EAAE,IAFG;gBAGlBqC,IAAI,EAAE,SAAA,IAAA,CAACC,OAAD,EAAUC,MAAV,EAAqB;kBACzBA,MAAM,CAACuB,KAAPvB,EAAAA;kBACA,IAAMC,GAAG,GAAGF,OAAO,CAACV,IAApB;kBAEAgC,OAAO,CAAChB,WAAW,CAACJ,GAAD,CAAZ,CAAPoB;gBACD,CARiB;gBASlBpC,KAAK,EAAE,SAAA,KAAA,CAAA,CAAC,EAAI;kBACVqC,MAAM,CAAC,IAAIpC,KAAJ,CAAUC,CAAV,CAAD,CAANmC;gBACD;cAXiB,CAApB1E,CAAAA;YAaD,CAdY,CALf;UAAA,KAAA,CAAA;YAAA,OAAA,SAAA,CAAA,MAAA,CAAA,QAAA,EAAA,SAAA,CAAA,IAAA,CAAA;UAAA,KAAA,CAAA;UAAA,KAAA,KAAA;YAAA,OAAA,SAAA,CAAA,IAAA,EAAA;QAAA;MAAA;IAAA,CAAA,EAAA,QAAA,CAAA;EAAA,C;;;AAsBA,SAAS4D,YAAT,CAAsBP,GAAtB,EAA2BN,SAA3B,EAAsC;EACpC,IAAME,MAAM,GAAGF,SAAS,GAAG,CAAA,CAAH,GAAQ,EAAhC;EACA,KAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAAG,CAACM,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;IACnC,IAAMkB,UAAU,GAAI7B,SAAS,IAAIA,SAAS,CAACW,CAAD,CAAvB,IAA+BA,CAAlD;IACA,IAAMa,KAAK,GAAGlB,GAAG,CAACK,CAAD,CAAjB;IACA,QAAA,OAAA,CAAea,KAAf,CAAA;MACE,KAAK,QAAL;MACA,KAAK,SAAL;QAEEtB,MAAM,CAAC2B,UAAD,CAAN3B,GAAqB;UAAC/B,IAAI,EAAE2D,MAAM,CAACD,UAAD,CAAb;UAA2BE,KAAK,EAAEpB,CAAlC;UAAqCqB,IAAI,EAAEC;QAA3C,CAArB/B;QACA;MACF,KAAK,QAAL;MACA;QACEA,MAAM,CAAC2B,UAAD,CAAN3B,GAAqB;UAAC/B,IAAI,EAAE2D,MAAM,CAACD,UAAD,CAAb;UAA2BE,KAAK,EAAEpB,CAAlC;UAAqCqB,IAAI,EAAEE;QAA3C,CAArBhC;IAAAA;EAIL;EACD,OAAOA,MAAP;AACD","sourcesContent":["/* global TextDecoder */\nimport {AsyncQueue, TableBatchBuilder, RowTableBatch} from '@loaders.gl/tables';\nimport Papa from './libs/papaparse';\nimport AsyncIteratorStreamer from './lib/async-iterator-streamer';\n/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nconst CSVLoaderOptions = {\n  csv: {\n    TableBatch: RowTableBatch,\n    batchSize: 10,\n    optimizeMemoryUsage: false,\n    // CSV options\n    header: 'auto',\n    rowFormat: 'auto',\n    columnPrefix: 'column',\n    // delimiter: auto\n    // newline: auto\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: false,\n    // transform: null?\n    delimitersToGuess: [',', '\\t', '|', ';']\n    // fastMode: auto\n  }\n};\n\n/** @type {LoaderObject} */\nexport default {\n  id: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv'],\n  mimeTypes: ['text/csv'],\n  category: 'table',\n  parse: async (arrayBuffer, options) => parseCSV(new TextDecoder().decode(arrayBuffer), options),\n  parseText: parseCSV,\n  parseInBatches: parseCSVInBatches,\n  testText: null,\n  options: CSVLoaderOptions\n};\n\nasync function parseCSV(csvText, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoaderOptions, ...options};\n  options.csv = {...CSVLoaderOptions.csv, ...options.csv};\n\n  const header = await hasHeader(csvText, options);\n\n  const config = {\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings\n    ...options.csv,\n    header,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    error: e => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, config);\n  return result.data;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(asyncIterator, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoaderOptions, ...options};\n  options.csv = {...CSVLoaderOptions.csv, ...options.csv};\n\n  const {batchSize, optimizeMemoryUsage} = options.csv;\n  const TableBatchType = options.csv.TableBatch;\n\n  const asyncQueue = new AsyncQueue();\n\n  const convertToObject = options.csv.rowFormat === 'object';\n\n  let isFirstRow = true;\n  let headerRow = null;\n  let tableBatchBuilder = null;\n  let schema = null;\n\n  const config = {\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings,\n    ...options.csv,\n    header: false, // Unfortunately, header detection is not automatic and does not infer types\n    download: false, // We handle loading, no need for papaparse to do it for us\n    // chunk(results, parser) {\n    //   // TODO batch before adding to queue.\n    //   console.log('Chunk:', results, parser);\n    //   asyncQueue.enqueue(results.data);\n    // },\n\n    // step is called on every row\n    step(results, parser) {\n      const row = results.data;\n      const bytesUsed = results.meta.cursor;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        // Auto detects or can be forced with options.csv.header\n        const header = isHeaderRow(row, options);\n        if (header) {\n          headerRow = row;\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = [];\n          for (let i = 0; i < row.length; i++) {\n            headerRow[i] = `${options.csv.columnPrefix}${i + 1}`;\n          }\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder ||\n        new TableBatchBuilder(TableBatchType, schema, {\n          batchSize,\n          convertToObject,\n          optimizeMemoryUsage\n        });\n\n      tableBatchBuilder.addRow(row);\n      // If a batch has been completed, emit it\n      if (tableBatchBuilder.isFull()) {\n        asyncQueue.enqueue(tableBatchBuilder.getBatch({bytesUsed}));\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results, file) {\n      const bytesUsed = results.meta.cursor;\n      // Ensure any final (partial) batch gets emitted\n      const batch = tableBatchBuilder.getBatch({bytesUsed});\n      if (batch) {\n        asyncQueue.enqueue(batch);\n      }\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\nfunction isHeaderRow(row, options) {\n  if (options && options.csv.header !== 'auto') {\n    return Boolean(options.csv.header);\n  }\n\n  return row.every(value => typeof value === 'string');\n}\n\nasync function hasHeader(csvText, options) {\n  if (options.csv.header !== 'auto') {\n    return Boolean(options.csv.header);\n  }\n\n  return await new Promise((resolve, reject) => {\n    Papa.parse(csvText, {\n      download: false,\n      dynamicTyping: true,\n      step: (results, parser) => {\n        parser.abort();\n        const row = results.data;\n        // Test the row\n        resolve(isHeaderRow(row));\n      },\n      error: e => {\n        reject(new Error(e));\n      }\n    });\n  });\n}\n\nfunction deduceSchema(row, headerRow) {\n  const schema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n"]},"metadata":{},"sourceType":"module"}