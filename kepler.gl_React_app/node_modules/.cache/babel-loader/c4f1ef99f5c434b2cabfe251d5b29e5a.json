{"ast":null,"code":"import { Manager } from './utils/hammer';\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\nimport EventRegistrar from './utils/event-registrar';\nimport { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';\nconst DEFAULT_OPTIONS = {\n  // event handlers\n  events: null,\n  // custom recognizers\n  recognizers: null,\n  recognizerOptions: {},\n  // Manager class\n  Manager,\n  // allow browser default touch action\n  // https://github.com/uber/react-map-gl/issues/506\n  touchAction: 'none',\n  tabIndex: 0\n};\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport default class EventManager {\n  constructor() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    /**\n     * Handle basic events using the 'hammer.input' Hammer.js API:\n     * Before running Recognizers, Hammer emits a 'hammer.input' event\n     * with the basic event info. This function emits all basic events\n     * aliased to the \"class\" of event received.\n     * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n     */\n    this._onBasicInput = event => {\n      const {\n        srcEvent\n      } = event;\n      const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n      if (alias) {\n        // fire all events aliased to srcEvent.type\n        this.manager.emit(alias, event);\n      }\n    };\n    /**\n     * Handle events not supported by Hammer.js,\n     * and pipe back out through same (Hammer) channel used by other events.\n     */\n    this._onOtherEvent = event => {\n      // console.log('onotherevent', event.type, event)\n      this.manager.emit(event.type, event);\n    };\n    this.options = {\n      ...DEFAULT_OPTIONS,\n      ...options\n    };\n    this.events = new Map();\n    this.setElement(element);\n    // Register all passed events.\n    const {\n      events\n    } = this.options;\n    if (events) {\n      this.on(events);\n    }\n  }\n  getElement() {\n    return this.element;\n  }\n  setElement(element) {\n    if (this.element) {\n      // unregister all events\n      this.destroy();\n    }\n    this.element = element;\n    if (!element) {\n      return;\n    }\n    const {\n      options\n    } = this;\n    const ManagerClass = options.Manager;\n    this.manager = new ManagerClass(element, {\n      touchAction: options.touchAction,\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n    if (!options.recognizers) {\n      // Set default recognize withs\n      // http://hammerjs.github.io/recognize-with/\n      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n        const recognizer = this.manager.get(name);\n        if (recognizer) {\n          RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n            recognizer.recognizeWith(otherName);\n          });\n        }\n      });\n    }\n    // Set recognizer options\n    for (const recognizerName in options.recognizerOptions) {\n      const recognizer = this.manager.get(recognizerName);\n      if (recognizer) {\n        const recognizerOption = options.recognizerOptions[recognizerName];\n        // `enable` is managed by the event registrations\n        delete recognizerOption.enable;\n        recognizer.set(recognizerOption);\n      }\n    }\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    // Register all existing events\n    for (const [eventAlias, eventRegistrar] of this.events) {\n      if (!eventRegistrar.isEmpty()) {\n        // Enable recognizer for this event.\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        this.manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n  }\n  // Tear down internal event management implementations.\n  destroy() {\n    if (this.element) {\n      // wheelInput etc. are created in setElement() and therefore\n      // cannot exist if there is no element\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.keyInput.destroy();\n      this.contextmenuInput.destroy();\n      this.manager.destroy();\n      this.wheelInput = null;\n      this.moveInput = null;\n      this.keyInput = null;\n      this.contextmenuInput = null;\n      this.manager = null;\n      this.element = null;\n    }\n  }\n  /** Register an event handler function to be called on `event` */\n  on(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n  once(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n  watch(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n  off(event, handler) {\n    this._removeEventHandler(event, handler);\n  }\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  _toggleRecognizer(name, enabled) {\n    const {\n      manager\n    } = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    // @ts-ignore\n    if (recognizer && recognizer.options.enable !== enabled) {\n      recognizer.set({\n        enable: enabled\n      });\n      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n      if (fallbackRecognizers && !this.options.recognizers) {\n        // Set default require failures\n        // http://hammerjs.github.io/require-failure/\n        fallbackRecognizers.forEach(otherName => {\n          const otherRecognizer = manager.get(otherName);\n          if (enabled) {\n            // Wait for this recognizer to fail\n            otherRecognizer.requireFailure(name);\n            /**\n             * This seems to be a bug in hammerjs:\n             * requireFailure() adds both ways\n             * dropRequireFailure() only drops one way\n             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n               recognizer-constructor.js#L136\n             */\n            recognizer.dropRequireFailure(otherName);\n          } else {\n            // Do not wait for this recognizer to fail\n            otherRecognizer.dropRequireFailure(name);\n          }\n        });\n      }\n    }\n    this.wheelInput.enableEventType(name, enabled);\n    this.moveInput.enableEventType(name, enabled);\n    this.keyInput.enableEventType(name, enabled);\n    this.contextmenuInput.enableEventType(name, enabled);\n  }\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  _addEventHandler(event, handler, opts, once, passive) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const eventName in event) {\n        this._addEventHandler(eventName, event[eventName], opts, once, passive);\n      }\n      return;\n    }\n    const {\n      manager,\n      events\n    } = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    let eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      eventRegistrar = new EventRegistrar(this);\n      events.set(eventAlias, eventRegistrar);\n      // Enable recognizer for this event.\n      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n      // Listen to the event\n      if (manager) {\n        manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  _removeEventHandler(event, handler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const eventName in event) {\n        this._removeEventHandler(eventName, event[eventName]);\n      }\n      return;\n    }\n    const {\n      events\n    } = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n    const eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      return;\n    }\n    eventRegistrar.remove(event, handler);\n    if (eventRegistrar.isEmpty()) {\n      const {\n        recognizerName\n      } = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../src/event-manager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Manager } from './utils/hammer';\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\nimport EventRegistrar from './utils/event-registrar';\nimport { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';\nconst DEFAULT_OPTIONS = {\n    // event handlers\n    events: null,\n    // custom recognizers\n    recognizers: null,\n    recognizerOptions: {},\n    // Manager class\n    Manager,\n    // allow browser default touch action\n    // https://github.com/uber/react-map-gl/issues/506\n    touchAction: 'none',\n    tabIndex: 0\n};\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport default class EventManager {\n    constructor(element = null, options) {\n        /**\n         * Handle basic events using the 'hammer.input' Hammer.js API:\n         * Before running Recognizers, Hammer emits a 'hammer.input' event\n         * with the basic event info. This function emits all basic events\n         * aliased to the \"class\" of event received.\n         * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n         */\n        this._onBasicInput = (event) => {\n            const { srcEvent } = event;\n            const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n            if (alias) {\n                // fire all events aliased to srcEvent.type\n                this.manager.emit(alias, event);\n            }\n        };\n        /**\n         * Handle events not supported by Hammer.js,\n         * and pipe back out through same (Hammer) channel used by other events.\n         */\n        this._onOtherEvent = (event) => {\n            // console.log('onotherevent', event.type, event)\n            this.manager.emit(event.type, event);\n        };\n        this.options = { ...DEFAULT_OPTIONS, ...options };\n        this.events = new Map();\n        this.setElement(element);\n        // Register all passed events.\n        const { events } = this.options;\n        if (events) {\n            this.on(events);\n        }\n    }\n    getElement() {\n        return this.element;\n    }\n    setElement(element) {\n        if (this.element) {\n            // unregister all events\n            this.destroy();\n        }\n        this.element = element;\n        if (!element) {\n            return;\n        }\n        const { options } = this;\n        const ManagerClass = options.Manager;\n        this.manager = new ManagerClass(element, {\n            touchAction: options.touchAction,\n            recognizers: options.recognizers || RECOGNIZERS\n        }).on('hammer.input', this._onBasicInput);\n        if (!options.recognizers) {\n            // Set default recognize withs\n            // http://hammerjs.github.io/recognize-with/\n            Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n                const recognizer = this.manager.get(name);\n                if (recognizer) {\n                    RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n                        recognizer.recognizeWith(otherName);\n                    });\n                }\n            });\n        }\n        // Set recognizer options\n        for (const recognizerName in options.recognizerOptions) {\n            const recognizer = this.manager.get(recognizerName);\n            if (recognizer) {\n                const recognizerOption = options.recognizerOptions[recognizerName];\n                // `enable` is managed by the event registrations\n                delete recognizerOption.enable;\n                recognizer.set(recognizerOption);\n            }\n        }\n        // Handle events not handled by Hammer.js:\n        // - mouse wheel\n        // - pointer/touch/mouse move\n        this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        this.moveInput = new MoveInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        this.keyInput = new KeyInput(element, this._onOtherEvent, {\n            enable: false,\n            tabIndex: options.tabIndex\n        });\n        this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n            enable: false\n        });\n        // Register all existing events\n        for (const [eventAlias, eventRegistrar] of this.events) {\n            if (!eventRegistrar.isEmpty()) {\n                // Enable recognizer for this event.\n                this._toggleRecognizer(eventRegistrar.recognizerName, true);\n                this.manager.on(eventAlias, eventRegistrar.handleEvent);\n            }\n        }\n    }\n    // Tear down internal event management implementations.\n    destroy() {\n        if (this.element) {\n            // wheelInput etc. are created in setElement() and therefore\n            // cannot exist if there is no element\n            this.wheelInput.destroy();\n            this.moveInput.destroy();\n            this.keyInput.destroy();\n            this.contextmenuInput.destroy();\n            this.manager.destroy();\n            this.wheelInput = null;\n            this.moveInput = null;\n            this.keyInput = null;\n            this.contextmenuInput = null;\n            this.manager = null;\n            this.element = null;\n        }\n    }\n    /** Register an event handler function to be called on `event` */\n    on(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, false);\n    }\n    once(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, true);\n    }\n    watch(event, handler, opts) {\n        this._addEventHandler(event, handler, opts, false, true);\n    }\n    off(event, handler) {\n        this._removeEventHandler(event, handler);\n    }\n    /*\n     * Enable/disable recognizer for the given event\n     */\n    _toggleRecognizer(name, enabled) {\n        const { manager } = this;\n        if (!manager) {\n            return;\n        }\n        const recognizer = manager.get(name);\n        // @ts-ignore\n        if (recognizer && recognizer.options.enable !== enabled) {\n            recognizer.set({ enable: enabled });\n            const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n            if (fallbackRecognizers && !this.options.recognizers) {\n                // Set default require failures\n                // http://hammerjs.github.io/require-failure/\n                fallbackRecognizers.forEach(otherName => {\n                    const otherRecognizer = manager.get(otherName);\n                    if (enabled) {\n                        // Wait for this recognizer to fail\n                        otherRecognizer.requireFailure(name);\n                        /**\n                         * This seems to be a bug in hammerjs:\n                         * requireFailure() adds both ways\n                         * dropRequireFailure() only drops one way\n                         * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n                           recognizer-constructor.js#L136\n                         */\n                        recognizer.dropRequireFailure(otherName);\n                    }\n                    else {\n                        // Do not wait for this recognizer to fail\n                        otherRecognizer.dropRequireFailure(name);\n                    }\n                });\n            }\n        }\n        this.wheelInput.enableEventType(name, enabled);\n        this.moveInput.enableEventType(name, enabled);\n        this.keyInput.enableEventType(name, enabled);\n        this.contextmenuInput.enableEventType(name, enabled);\n    }\n    /**\n     * Process the event registration for a single event + handler.\n     */\n    _addEventHandler(event, handler, opts, once, passive) {\n        if (typeof event !== 'string') {\n            // @ts-ignore\n            opts = handler;\n            // If `event` is a map, call `on()` for each entry.\n            for (const eventName in event) {\n                this._addEventHandler(eventName, event[eventName], opts, once, passive);\n            }\n            return;\n        }\n        const { manager, events } = this;\n        // Alias to a recognized gesture as necessary.\n        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n        let eventRegistrar = events.get(eventAlias);\n        if (!eventRegistrar) {\n            eventRegistrar = new EventRegistrar(this);\n            events.set(eventAlias, eventRegistrar);\n            // Enable recognizer for this event.\n            eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n            // Listen to the event\n            if (manager) {\n                manager.on(eventAlias, eventRegistrar.handleEvent);\n            }\n        }\n        eventRegistrar.add(event, handler, opts, once, passive);\n        if (!eventRegistrar.isEmpty()) {\n            this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        }\n    }\n    /**\n     * Process the event deregistration for a single event + handler.\n     */\n    _removeEventHandler(event, handler) {\n        if (typeof event !== 'string') {\n            // If `event` is a map, call `off()` for each entry.\n            for (const eventName in event) {\n                this._removeEventHandler(eventName, event[eventName]);\n            }\n            return;\n        }\n        const { events } = this;\n        // Alias to a recognized gesture as necessary.\n        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n        const eventRegistrar = events.get(eventAlias);\n        if (!eventRegistrar) {\n            return;\n        }\n        eventRegistrar.remove(event, handler);\n        if (eventRegistrar.isEmpty()) {\n            const { recognizerName } = eventRegistrar;\n            // Disable recognizer if no more handlers are attached to its events\n            let isRecognizerUsed = false;\n            for (const eh of events.values()) {\n                if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n                    isRecognizerUsed = true;\n                    break;\n                }\n            }\n            if (!isRecognizerUsed) {\n                this._toggleRecognizer(recognizerName, false);\n            }\n        }\n    }\n}\n//# sourceMappingURL=event-manager.js.map"]},"metadata":{},"sourceType":"module"}