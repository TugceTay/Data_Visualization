{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.pointColResolver = exports.mapboxRequiredColumns = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _baseLayer = _interopRequireWildcard(require(\"./base-layer\"));\nvar _reselect = require(\"reselect\");\nvar _mapboxUtils = require(\"./mapbox-utils\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar mapboxRequiredColumns = ['lat', 'lng'];\nexports.mapboxRequiredColumns = mapboxRequiredColumns;\nvar pointColResolver = function pointColResolver(_ref) {\n  var lat = _ref.lat,\n    lng = _ref.lng;\n  return \"\".concat(lat.fieldIdx, \"-\").concat(lng.fieldIdx);\n};\nexports.pointColResolver = pointColResolver;\nvar MapboxLayerGL = /*#__PURE__*/function (_Layer) {\n  (0, _inherits2[\"default\"])(MapboxLayerGL, _Layer);\n  var _super = _createSuper(MapboxLayerGL);\n  function MapboxLayerGL() {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, MapboxLayerGL);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"datasetSelector\", function (config) {\n      return config.dataId;\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"gpuFilterSelector\", function (config, datasets) {\n      return (datasets[config.dataId] || {}).gpuFilter;\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"columnsSelector\", function (config) {\n      return pointColResolver(config.columns);\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"sourceSelector\", (0, _reselect.createSelector)(_this.datasetSelector, _this.columnsSelector, function (datasetId, columns) {\n      return \"\".concat(datasetId, \"-\").concat(columns);\n    }));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"filterSelector\", (0, _reselect.createSelector)(_this.gpuFilterSelector, function (gpuFilter) {\n      return (0, _mapboxUtils.gpuFilterToMapboxFilter)(gpuFilter);\n    }));\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(MapboxLayerGL, [{\n    key: \"overlayType\",\n    get: function get() {\n      return _baseLayer.OVERLAY_TYPE.mapboxgl;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"isAggregated\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return mapboxRequiredColumns;\n    }\n  }, {\n    key: \"columnPairs\",\n    get: function get() {\n      return this.defaultPointColumnPairs;\n    }\n  }, {\n    key: \"noneLayerDataAffectingProps\",\n    get: function get() {\n      return [];\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      return {};\n    }\n  }, {\n    key: \"isValidFilter\",\n    value: function isValidFilter(filter) {\n      // mapbox will crash if filter is not an array or empty\n      return Array.isArray(filter) && filter.length;\n    }\n  }, {\n    key: \"getDataUpdateTriggers\",\n    value: function getDataUpdateTriggers(_ref2) {\n      var _this2 = this;\n      var filteredIndex = _ref2.filteredIndex,\n        gpuFilter = _ref2.gpuFilter,\n        id = _ref2.id;\n      var columns = this.config.columns;\n      var visualChannelFields = Object.values(this.visualChannels).reduce(function (accu, v) {\n        return _objectSpread(_objectSpread({}, accu), _this2.config[v.field] ? (0, _defineProperty2[\"default\"])({}, v.field, _this2.config[v.field].name) : {});\n      }, {});\n      var updateTriggers = {\n        getData: _objectSpread(_objectSpread({\n          datasetId: id,\n          columns: columns,\n          filteredIndex: filteredIndex\n        }, visualChannelFields), gpuFilter.filterValueUpdateTriggers),\n        getMeta: {\n          datasetId: id,\n          columns: columns\n        }\n      };\n      return updateTriggers;\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(_ref4, getPosition) {\n      var _this3 = this;\n      var dataContainer = _ref4.dataContainer,\n        filteredIndex = _ref4.filteredIndex,\n        gpuFilter = _ref4.gpuFilter;\n      var getGeometry = function getGeometry(d) {\n        return _this3.getGeometry(getPosition(d));\n      };\n      var vcFields = Object.values(this.visualChannels).map(function (v) {\n        return _this3.config[v.field];\n      }).filter(function (v) {\n        return v;\n      });\n      var getPropertyFromVisualChanel = vcFields.length ? function (d) {\n        return vcFields.reduce(function (accu, field) {\n          return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, field.name, field.valueAccessor(d)));\n        }, {});\n      } : function (d) {\n        return {};\n      };\n      var filterValueUpdateTriggers = gpuFilter.filterValueUpdateTriggers,\n        filterValueAccessor = gpuFilter.filterValueAccessor; // gpuField To property\n\n      var hasFilter = Object.values(filterValueUpdateTriggers).filter(function (d) {\n        return d;\n      }).length;\n      var valueAccessor = filterValueAccessor(dataContainer)();\n      var getPropertyFromFilter = hasFilter ? function (d) {\n        var filterValue = valueAccessor(d);\n        return Object.values(filterValueUpdateTriggers).reduce(function (accu, name, i) {\n          return _objectSpread(_objectSpread({}, accu), name ? (0, _defineProperty2[\"default\"])({}, (0, _mapboxUtils.prefixGpuField)(name), filterValue[i]) : {});\n        }, {});\n      } : function (d) {\n        return {};\n      };\n      var getProperties = function getProperties(d) {\n        return _objectSpread(_objectSpread({}, getPropertyFromVisualChanel(d)), getPropertyFromFilter(d));\n      };\n      return (0, _mapboxUtils.geoJsonFromData)(filteredIndex, getGeometry, getProperties);\n    } // this layer is rendered at mapbox level\n    // todo: maybe need to find a better solution for this one\n  }, {\n    key: \"shouldRenderLayer\",\n    value: function shouldRenderLayer() {\n      return this.type && this.config.isVisible && this.hasAllColumns();\n    }\n  }]);\n  return MapboxLayerGL;\n}(_baseLayer[\"default\"]);\nvar _default = MapboxLayerGL;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../../src/layers/mapboxgl-layer.js"],"names":["mapboxRequiredColumns","pointColResolver","lat","lng","fieldIdx","MapboxLayerGL","Layer","OVERLAY_TYPE","mapboxgl","defaultPointColumnPairs","config","dataId","datasets","gpuFilter","columns","datasetSelector","columnsSelector","datasetId","gpuFilterSelector","filter","Array","isArray","length","filteredIndex","id","visualChannelFields","values","visualChannels","reduce","accu","v","field","name","updateTriggers","getData","filterValueUpdateTriggers","getMeta","dataContainer","getPosition","getGeometry","d","vcFields","map","getPropertyFromVisualChanel","valueAccessor","filterValueAccessor","hasFilter","getPropertyFromFilter","filterValue","i","getProperties","type","isVisible","hasAllColumns"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport Layer, {OVERLAY_TYPE} from './base-layer';\nimport {createSelector} from 'reselect';\n\nimport {geoJsonFromData, prefixGpuField, gpuFilterToMapboxFilter} from './mapbox-utils';\n\nexport const mapboxRequiredColumns = ['lat', 'lng'];\n\nexport const pointColResolver = ({lat, lng}) => `${lat.fieldIdx}-${lng.fieldIdx}`;\n\nclass MapboxLayerGL extends Layer {\n  get overlayType() {\n    return OVERLAY_TYPE.mapboxgl;\n  }\n\n  get type() {\n    return null;\n  }\n\n  get isAggregated() {\n    return true;\n  }\n\n  get requiredLayerColumns() {\n    return mapboxRequiredColumns;\n  }\n\n  get columnPairs() {\n    return this.defaultPointColumnPairs;\n  }\n\n  get noneLayerDataAffectingProps() {\n    return [];\n  }\n\n  get visualChannels() {\n    return {};\n  }\n  datasetSelector = config => config.dataId;\n  gpuFilterSelector = (config, datasets) => (datasets[config.dataId] || {}).gpuFilter;\n  columnsSelector = config => pointColResolver(config.columns);\n\n  sourceSelector = createSelector(\n    this.datasetSelector,\n    this.columnsSelector,\n    (datasetId, columns) => `${datasetId}-${columns}`\n  );\n\n  filterSelector = createSelector(this.gpuFilterSelector, gpuFilter =>\n    gpuFilterToMapboxFilter(gpuFilter)\n  );\n\n  isValidFilter(filter) {\n    // mapbox will crash if filter is not an array or empty\n    return Array.isArray(filter) && filter.length;\n  }\n\n  getDataUpdateTriggers({filteredIndex, gpuFilter, id}) {\n    const {columns} = this.config;\n\n    const visualChannelFields = Object.values(this.visualChannels).reduce(\n      (accu, v) => ({\n        ...accu,\n        ...(this.config[v.field] ? {[v.field]: this.config[v.field].name} : {})\n      }),\n      {}\n    );\n\n    const updateTriggers = {\n      getData: {\n        datasetId: id,\n        columns,\n        filteredIndex,\n        ...visualChannelFields,\n        ...gpuFilter.filterValueUpdateTriggers\n      },\n      getMeta: {datasetId: id, columns}\n    };\n\n    return updateTriggers;\n  }\n\n  calculateDataAttribute({dataContainer, filteredIndex, gpuFilter}, getPosition) {\n    const getGeometry = d => this.getGeometry(getPosition(d));\n\n    const vcFields = Object.values(this.visualChannels)\n      .map(v => this.config[v.field])\n      .filter(v => v);\n\n    const getPropertyFromVisualChanel = vcFields.length\n      ? d =>\n          vcFields.reduce(\n            (accu, field) => ({\n              ...accu,\n              [field.name]: field.valueAccessor(d)\n            }),\n            {}\n          )\n      : d => ({});\n\n    const {filterValueUpdateTriggers, filterValueAccessor} = gpuFilter;\n\n    // gpuField To property\n    const hasFilter = Object.values(filterValueUpdateTriggers).filter(d => d).length;\n    const valueAccessor = filterValueAccessor(dataContainer)();\n\n    const getPropertyFromFilter = hasFilter\n      ? d => {\n          const filterValue = valueAccessor(d);\n          return Object.values(filterValueUpdateTriggers).reduce(\n            (accu, name, i) => ({\n              ...accu,\n              ...(name ? {[prefixGpuField(name)]: filterValue[i]} : {})\n            }),\n            {}\n          );\n        }\n      : d => ({});\n\n    const getProperties = d => ({\n      ...getPropertyFromVisualChanel(d),\n      ...getPropertyFromFilter(d)\n    });\n\n    return geoJsonFromData(filteredIndex, getGeometry, getProperties);\n  }\n\n  // this layer is rendered at mapbox level\n  // todo: maybe need to find a better solution for this one\n  shouldRenderLayer() {\n    return this.type && this.config.isVisible && this.hasAllColumns();\n  }\n}\n\nexport default MapboxLayerGL;\n"]},"metadata":{},"sourceType":"script"}