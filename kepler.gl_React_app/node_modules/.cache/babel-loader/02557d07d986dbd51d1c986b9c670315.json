{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDefaultFilter = getDefaultFilter;\nexports.shouldApplyFilter = shouldApplyFilter;\nexports.validatePolygonFilter = validatePolygonFilter;\nexports.validateFilter = validateFilter;\nexports.validateFilterWithData = validateFilterWithData;\nexports.getFilterProps = getFilterProps;\nexports.getFilterFunction = getFilterFunction;\nexports.updateFilterDataId = updateFilterDataId;\nexports.filterDataByFilterTypes = filterDataByFilterTypes;\nexports.getFilterRecord = getFilterRecord;\nexports.diffFilters = diffFilters;\nexports.adjustValueToFilterDomain = adjustValueToFilterDomain;\nexports.getNumericFieldDomain = getNumericFieldDomain;\nexports.getNumericStepSize = getNumericStepSize;\nexports.getTimestampFieldDomain = getTimestampFieldDomain;\nexports.histogramConstruct = histogramConstruct;\nexports.getHistogram = getHistogram;\nexports.formatNumberByStep = formatNumberByStep;\nexports.isInRange = isInRange;\nexports.isInPolygon = isInPolygon;\nexports.isValidTimeDomain = isValidTimeDomain;\nexports.getTimeWidgetTitleFormatter = getTimeWidgetTitleFormatter;\nexports.getTimeWidgetHintFormatter = getTimeWidgetHintFormatter;\nexports.isValidFilterValue = isValidFilterValue;\nexports.getFilterPlot = getFilterPlot;\nexports.getDefaultFilterPlotType = getDefaultFilterPlotType;\nexports.applyFiltersToDatasets = applyFiltersToDatasets;\nexports.applyFilterFieldName = applyFilterFieldName;\nexports.mergeFilterDomainStep = mergeFilterDomainStep;\nexports.generatePolygonFilter = generatePolygonFilter;\nexports.filterDatasetCPU = filterDatasetCPU;\nexports.validateFiltersUpdateDatasets = validateFiltersUpdateDatasets;\nexports.getIntervalBins = getIntervalBins;\nexports.getFilterIdInFeature = exports.featureToFilterValue = exports.getPolygonFilterFunctor = exports.LAYER_FILTERS = exports.FILTER_ID_LENGTH = exports.DEFAULT_FILTER_STRUCTURE = exports.FILTER_COMPONENTS = exports.LIMITED_FILTER_EFFECT_PROPS = exports.FILTER_UPDATER_PROPS = exports.PLOT_TYPES = exports.enlargedHistogramBins = exports.histogramBins = exports.TimestampStepMap = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _d3Array = require(\"d3-array\");\nvar _keymirror = _interopRequireDefault(require(\"keymirror\"));\nvar _console = require(\"global/console\");\nvar _lodash = _interopRequireDefault(require(\"lodash.get\"));\nvar _lodash2 = _interopRequireDefault(require(\"lodash.isequal\"));\nvar _booleanWithin = _interopRequireDefault(require(\"@turf/boolean-within\"));\nvar _helpers = require(\"@turf/helpers\");\nvar _decimal = require(\"decimal.js\");\nvar _defaultSettings = require(\"../constants/default-settings\");\nvar _dataUtils = require(\"./data-utils\");\nvar ScaleUtils = _interopRequireWildcard(require(\"./data-scale-utils\"));\nvar _types = require(\"../layers/types\");\nvar _utils = require(\"./utils\");\nvar _h3Utils = require(\"../layers/h3-hexagon-layer/h3-utils\");\nvar _FILTER_TYPES$timeRan, _FILTER_TYPES$range, _SupportedPlotType, _FILTER_COMPONENTS;\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n// TYPE\n\n/** @typedef {import('./table-utils/kepler-table').FilterRecord} FilterRecord */\n\n/** @typedef {import('./filter-utils').FilterResult} FilterResult */\nvar TimestampStepMap = [{\n  max: 1,\n  step: 0.05\n}, {\n  max: 10,\n  step: 0.1\n}, {\n  max: 100,\n  step: 1\n}, {\n  max: 500,\n  step: 5\n}, {\n  max: 1000,\n  step: 10\n}, {\n  max: 5000,\n  step: 50\n}, {\n  max: Number.POSITIVE_INFINITY,\n  step: 1000\n}];\nexports.TimestampStepMap = TimestampStepMap;\nvar histogramBins = 30;\nexports.histogramBins = histogramBins;\nvar enlargedHistogramBins = 100;\nexports.enlargedHistogramBins = enlargedHistogramBins;\nvar durationSecond = 1000;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationYear = durationDay * 365;\nvar PLOT_TYPES = (0, _keymirror[\"default\"])({\n  histogram: null,\n  lineChart: null\n});\nexports.PLOT_TYPES = PLOT_TYPES;\nvar FILTER_UPDATER_PROPS = (0, _keymirror[\"default\"])({\n  dataId: null,\n  name: null,\n  layerId: null\n});\nexports.FILTER_UPDATER_PROPS = FILTER_UPDATER_PROPS;\nvar LIMITED_FILTER_EFFECT_PROPS = (0, _keymirror[\"default\"])((0, _defineProperty2[\"default\"])({}, FILTER_UPDATER_PROPS.name, null));\n/**\n * Max number of filter value buffers that deck.gl provides\n */\n\nexports.LIMITED_FILTER_EFFECT_PROPS = LIMITED_FILTER_EFFECT_PROPS;\nvar SupportedPlotType = (_SupportedPlotType = {}, (0, _defineProperty2[\"default\"])(_SupportedPlotType, _defaultSettings.FILTER_TYPES.timeRange, (_FILTER_TYPES$timeRan = {\n  \"default\": 'histogram'\n}, (0, _defineProperty2[\"default\"])(_FILTER_TYPES$timeRan, _defaultSettings.ALL_FIELD_TYPES.integer, 'lineChart'), (0, _defineProperty2[\"default\"])(_FILTER_TYPES$timeRan, _defaultSettings.ALL_FIELD_TYPES.real, 'lineChart'), _FILTER_TYPES$timeRan)), (0, _defineProperty2[\"default\"])(_SupportedPlotType, _defaultSettings.FILTER_TYPES.range, (_FILTER_TYPES$range = {\n  \"default\": 'histogram'\n}, (0, _defineProperty2[\"default\"])(_FILTER_TYPES$range, _defaultSettings.ALL_FIELD_TYPES.integer, 'lineChart'), (0, _defineProperty2[\"default\"])(_FILTER_TYPES$range, _defaultSettings.ALL_FIELD_TYPES.real, 'lineChart'), _FILTER_TYPES$range)), _SupportedPlotType);\nvar FILTER_COMPONENTS = (_FILTER_COMPONENTS = {}, (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _defaultSettings.FILTER_TYPES.select, 'SingleSelectFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _defaultSettings.FILTER_TYPES.multiSelect, 'MultiSelectFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _defaultSettings.FILTER_TYPES.timeRange, 'TimeRangeFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _defaultSettings.FILTER_TYPES.range, 'RangeFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _defaultSettings.FILTER_TYPES.polygon, 'PolygonFilter'), _FILTER_COMPONENTS);\nexports.FILTER_COMPONENTS = FILTER_COMPONENTS;\nvar DEFAULT_FILTER_STRUCTURE = {\n  dataId: [],\n  // [string]\n  freeze: false,\n  id: null,\n  // time range filter specific\n  fixedDomain: false,\n  enlarged: false,\n  isAnimating: false,\n  animationWindow: _defaultSettings.ANIMATION_WINDOW.free,\n  speed: 1,\n  // field specific\n  name: [],\n  // string\n  type: null,\n  fieldIdx: [],\n  // [integer]\n  domain: null,\n  value: null,\n  // plot\n  plotType: PLOT_TYPES.histogram,\n  yAxis: null,\n  interval: null,\n  // mode\n  gpu: false\n};\nexports.DEFAULT_FILTER_STRUCTURE = DEFAULT_FILTER_STRUCTURE;\nvar FILTER_ID_LENGTH = 4;\nexports.FILTER_ID_LENGTH = FILTER_ID_LENGTH;\nvar LAYER_FILTERS = [_defaultSettings.FILTER_TYPES.polygon];\n/**\n * Generates a filter with a dataset id as dataId\n * @type {typeof import('./filter-utils').getDefaultFilter}\n */\n\nexports.LAYER_FILTERS = LAYER_FILTERS;\nfunction getDefaultFilter(dataId) {\n  return _objectSpread(_objectSpread({}, DEFAULT_FILTER_STRUCTURE), {}, {\n    // store it as dataId and it could be one or many\n    dataId: (0, _utils.toArray)(dataId),\n    id: (0, _utils.generateHashId)(FILTER_ID_LENGTH)\n  });\n}\n/**\n * Check if a filter is valid based on the given dataId\n * @param  filter to validate\n * @param  datasetId id to validate filter against\n * @return true if a filter is valid, false otherwise\n * @type {typeof import('./filter-utils').shouldApplyFilter}\n */\n\nfunction shouldApplyFilter(filter, datasetId) {\n  var dataIds = (0, _utils.toArray)(filter.dataId);\n  return dataIds.includes(datasetId) && filter.value !== null;\n}\n/**\n * Validates and modifies polygon filter structure\n * @param dataset\n * @param filter\n * @param layers\n * @return - {filter, dataset}\n * @type {typeof import('./filter-utils').validatePolygonFilter}\n */\n\nfunction validatePolygonFilter(dataset, filter, layers) {\n  var failed = {\n    dataset: dataset,\n    filter: null\n  };\n  var value = filter.value,\n    layerId = filter.layerId,\n    type = filter.type,\n    dataId = filter.dataId;\n  if (!layerId || !isValidFilterValue(type, value)) {\n    return failed;\n  }\n  var isValidDataset = dataId.includes(dataset.id);\n  if (!isValidDataset) {\n    return failed;\n  }\n  var layer = layers.find(function (l) {\n    return layerId.includes(l.id);\n  });\n  if (!layer) {\n    return failed;\n  }\n  return {\n    filter: _objectSpread(_objectSpread({}, filter), {}, {\n      freeze: true,\n      fieldIdx: []\n    }),\n    dataset: dataset\n  };\n}\n/**\n * Custom filter validators\n */\n\nvar filterValidators = (0, _defineProperty2[\"default\"])({}, _defaultSettings.FILTER_TYPES.polygon, validatePolygonFilter);\n/**\n * Default validate filter function\n * @param dataset\n * @param filter\n * @return - {filter, dataset}\n * @type {typeof import('./filter-utils').validateFilter}\n */\n\nfunction validateFilter(dataset, filter) {\n  // match filter.dataId\n  var failed = {\n    dataset: dataset,\n    filter: null\n  };\n  var filterDataId = (0, _utils.toArray)(filter.dataId);\n  var filterDatasetIndex = filterDataId.indexOf(dataset.id);\n  if (filterDatasetIndex < 0) {\n    // the current filter is not mapped against the current dataset\n    return failed;\n  }\n  var initializeFilter = _objectSpread(_objectSpread(_objectSpread({}, getDefaultFilter(filter.dataId)), filter), {}, {\n    dataId: filterDataId,\n    name: (0, _utils.toArray)(filter.name)\n  });\n  var fieldName = initializeFilter.name[filterDatasetIndex];\n  var _applyFilterFieldName = applyFilterFieldName(initializeFilter, dataset, fieldName, filterDatasetIndex, {\n      mergeDomain: true\n    }),\n    updatedFilter = _applyFilterFieldName.filter,\n    updatedDataset = _applyFilterFieldName.dataset;\n  if (!updatedFilter) {\n    return failed;\n  }\n  updatedFilter.value = adjustValueToFilterDomain(filter.value, updatedFilter);\n  updatedFilter.enlarged = typeof filter.enlarged === 'boolean' ? filter.enlarged : updatedFilter.enlarged;\n  if (updatedFilter.value === null) {\n    // cannot adjust saved value to filter\n    return failed;\n  }\n  return {\n    filter: validateFilterYAxis(updatedFilter, updatedDataset),\n    dataset: updatedDataset\n  };\n}\n/**\n * Validate saved filter config with new data,\n * calculate domain and fieldIdx based new fields and data\n *\n * @param dataset\n * @param filter - filter to be validate\n * @param layers - layers\n * @return validated filter\n * @type {typeof import('./filter-utils').validateFilterWithData}\n */\n\nfunction validateFilterWithData(dataset, filter, layers) {\n  // @ts-ignore\n  return filterValidators.hasOwnProperty(filter.type) ? filterValidators[filter.type](dataset, filter, layers) : validateFilter(dataset, filter);\n}\n/**\n * Validate YAxis\n * @param filter\n * @param dataset\n * @return {*}\n */\n\nfunction validateFilterYAxis(filter, dataset) {\n  // TODO: validate yAxis against other datasets\n  var fields = dataset.fields;\n  var _filter = filter,\n    yAxis = _filter.yAxis; // TODO: validate yAxis against other datasets\n\n  if (yAxis) {\n    var matchedAxis = fields.find(function (_ref) {\n      var name = _ref.name,\n        type = _ref.type;\n      return name === yAxis.name && type === yAxis.type;\n    });\n    filter = matchedAxis ? _objectSpread(_objectSpread({}, filter), {}, {\n      yAxis: matchedAxis\n    }, getFilterPlot(_objectSpread(_objectSpread({}, filter), {}, {\n      yAxis: matchedAxis\n    }), dataset)) : filter;\n  }\n  return filter;\n}\n/**\n * Get default filter prop based on field type\n *\n * @param field\n * @param fieldDomain\n * @returns default filter\n * @type {typeof import('./filter-utils').getFilterProps}\n */\n\nfunction getFilterProps(field, fieldDomain) {\n  var filterProps = _objectSpread(_objectSpread({}, fieldDomain), {}, {\n    fieldType: field.type\n  });\n  switch (field.type) {\n    case _defaultSettings.ALL_FIELD_TYPES.real:\n    case _defaultSettings.ALL_FIELD_TYPES.integer:\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        value: fieldDomain.domain,\n        type: _defaultSettings.FILTER_TYPES.range,\n        typeOptions: [_defaultSettings.FILTER_TYPES.range],\n        gpu: true\n      });\n    case _defaultSettings.ALL_FIELD_TYPES[\"boolean\"]:\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        type: _defaultSettings.FILTER_TYPES.select,\n        value: true,\n        gpu: false\n      });\n    case _defaultSettings.ALL_FIELD_TYPES.string:\n    case _defaultSettings.ALL_FIELD_TYPES.date:\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        type: _defaultSettings.FILTER_TYPES.multiSelect,\n        value: [],\n        gpu: false\n      });\n    case _defaultSettings.ALL_FIELD_TYPES.timestamp:\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        type: _defaultSettings.FILTER_TYPES.timeRange,\n        enlarged: true,\n        fixedDomain: true,\n        value: filterProps.domain,\n        gpu: true\n      });\n    default:\n      return {};\n  }\n}\nvar getPolygonFilterFunctor = function getPolygonFilterFunctor(layer, filter, dataContainer) {\n  var getPosition = layer.getPositionAccessor(dataContainer);\n  switch (layer.type) {\n    case _types.LAYER_TYPES.point:\n    case _types.LAYER_TYPES.icon:\n      return function (data) {\n        var pos = getPosition(data);\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    case _types.LAYER_TYPES.arc:\n    case _types.LAYER_TYPES.line:\n      return function (data) {\n        var pos = getPosition(data);\n        return pos.every(Number.isFinite) && [[pos[0], pos[1]], [pos[3], pos[4]]].every(function (point) {\n          return isInPolygon(point, filter.value);\n        });\n      };\n    case _types.LAYER_TYPES.hexagonId:\n      if (layer.dataToFeature && layer.dataToFeature.centroids) {\n        return function (data) {\n          // null or getCentroid({id})\n          var centroid = layer.dataToFeature.centroids[data.index];\n          return centroid && isInPolygon(centroid, filter.value);\n        };\n      }\n      return function (data) {\n        var id = getPosition(data);\n        if (!(0, _h3Utils.h3IsValid)(id)) {\n          return false;\n        }\n        var pos = (0, _h3Utils.getCentroid)({\n          id: id\n        });\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    default:\n      return function () {\n        return true;\n      };\n  }\n};\n/**\n * @param field dataset Field\n * @param dataId Dataset id\n * @param filter Filter object\n * @param layers list of layers to filter upon\n * @param dataContainer Data container\n * @return filterFunction\n * @type {typeof import('./filter-utils').getFilterFunction}\n */\n\nexports.getPolygonFilterFunctor = getPolygonFilterFunctor;\nfunction getFilterFunction(field, dataId, filter, layers, dataContainer) {\n  // field could be null in polygon filter\n  var valueAccessor = field ? field.valueAccessor : function (data) {\n    return null;\n  };\n  var defaultFunc = function defaultFunc(d) {\n    return true;\n  };\n  switch (filter.type) {\n    case _defaultSettings.FILTER_TYPES.range:\n      return function (data) {\n        return isInRange(valueAccessor(data), filter.value);\n      };\n    case _defaultSettings.FILTER_TYPES.multiSelect:\n      return function (data) {\n        return filter.value.includes(valueAccessor(data));\n      };\n    case _defaultSettings.FILTER_TYPES.select:\n      return function (data) {\n        return valueAccessor(data) === filter.value;\n      };\n    case _defaultSettings.FILTER_TYPES.timeRange:\n      if (!field) {\n        return defaultFunc;\n      }\n      var mappedValue = (0, _lodash[\"default\"])(field, ['filterProps', 'mappedValue']);\n      var accessor = Array.isArray(mappedValue) ? function (data) {\n        return mappedValue[data.index];\n      } : function (data) {\n        return (0, _dataUtils.timeToUnixMilli)(valueAccessor(data), field.format);\n      };\n      return function (data) {\n        return isInRange(accessor(data), filter.value);\n      };\n    case _defaultSettings.FILTER_TYPES.polygon:\n      if (!layers || !layers.length) {\n        return defaultFunc;\n      } // @ts-ignore\n\n      var layerFilterFunctions = filter.layerId.map(function (id) {\n        return layers.find(function (l) {\n          return l.id === id;\n        });\n      }).filter(function (l) {\n        return l && l.config.dataId === dataId;\n      }).map(function (layer) {\n        return getPolygonFilterFunctor(layer, filter, dataContainer);\n      });\n      return function (data) {\n        return layerFilterFunctions.every(function (filterFunc) {\n          return filterFunc(data);\n        });\n      };\n    default:\n      return defaultFunc;\n  }\n}\nfunction updateFilterDataId(dataId) {\n  return getDefaultFilter(dataId);\n}\n/**\n * @type {typeof import('./filter-utils').filterDataByFilterTypes}\n */\n\nfunction filterDataByFilterTypes(_ref2, dataContainer) {\n  var dynamicDomainFilters = _ref2.dynamicDomainFilters,\n    cpuFilters = _ref2.cpuFilters,\n    filterFuncs = _ref2.filterFuncs;\n  var result = _objectSpread(_objectSpread({}, dynamicDomainFilters ? {\n    filteredIndexForDomain: []\n  } : {}), cpuFilters ? {\n    filteredIndex: []\n  } : {});\n  var filterContext = {\n    index: -1,\n    dataContainer: dataContainer\n  };\n  var filterFuncCaller = function filterFuncCaller(filter) {\n    return filterFuncs[filter.id](filterContext);\n  };\n  var numRows = dataContainer.numRows();\n  for (var i = 0; i < numRows; ++i) {\n    filterContext.index = i;\n    var matchForDomain = dynamicDomainFilters && dynamicDomainFilters.every(filterFuncCaller);\n    if (matchForDomain) {\n      // @ts-ignore\n      result.filteredIndexForDomain.push(filterContext.index);\n    }\n    var matchForRender = cpuFilters && cpuFilters.every(filterFuncCaller);\n    if (matchForRender) {\n      // @ts-ignore\n      result.filteredIndex.push(filterContext.index);\n    }\n  }\n  return result;\n}\n/**\n * Get a record of filters based on domain type and gpu / cpu\n * @type {typeof import('./filter-utils').getFilterRecord}\n */\n\nfunction getFilterRecord(dataId, filters) {\n  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  /**\n   * @type {FilterRecord}\n   */\n  var filterRecord = {\n    dynamicDomain: [],\n    fixedDomain: [],\n    cpu: [],\n    gpu: []\n  };\n  filters.forEach(function (f) {\n    if (isValidFilterValue(f.type, f.value) && (0, _utils.toArray)(f.dataId).includes(dataId)) {\n      (f.fixedDomain || opt.ignoreDomain ? filterRecord.fixedDomain : filterRecord.dynamicDomain).push(f);\n      (f.gpu && !opt.cpuOnly ? filterRecord.gpu : filterRecord.cpu).push(f);\n    }\n  });\n  return filterRecord;\n}\n/**\n * Compare filter records to get what has changed\n * @type {typeof import('./filter-utils').diffFilters}\n */\n\nfunction diffFilters(filterRecord) {\n  var oldFilterRecord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var filterChanged = {};\n  Object.entries(filterRecord).forEach(function (_ref3) {\n    var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n      record = _ref4[0],\n      items = _ref4[1];\n    items.forEach(function (filter) {\n      var oldFilter = (oldFilterRecord[record] || []).find(function (f) {\n        return f.id === filter.id;\n      });\n      if (!oldFilter) {\n        // added\n        filterChanged = (0, _utils.set)([record, filter.id], 'added', filterChanged);\n      } else {\n        // check  what has changed\n        ['name', 'value', 'dataId'].forEach(function (prop) {\n          if (filter[prop] !== oldFilter[prop]) {\n            filterChanged = (0, _utils.set)([record, filter.id], \"\".concat(prop, \"_changed\"), filterChanged);\n          }\n        });\n      }\n    });\n    (oldFilterRecord[record] || []).forEach(function (oldFilter) {\n      // deleted\n      if (!items.find(function (f) {\n        return f.id === oldFilter.id;\n      })) {\n        filterChanged = (0, _utils.set)([record, oldFilter.id], 'deleted', filterChanged);\n      }\n    });\n    if (!filterChanged[record]) {\n      filterChanged[record] = null;\n    }\n  }); // @ts-ignore\n\n  return filterChanged;\n}\n/**\n * Call by parsing filters from URL\n * Check if value of filter within filter domain, if not adjust it to match\n * filter domain\n *\n * @type {typeof import('./filter-utils').adjustValueToFilterDomain}\n * @returns value - adjusted value to match filter or null to remove filter\n */\n\n/* eslint-disable complexity */\n\nfunction adjustValueToFilterDomain(value, _ref5) {\n  var domain = _ref5.domain,\n    type = _ref5.type;\n  if (!domain || !type) {\n    return false;\n  }\n  switch (type) {\n    case _defaultSettings.FILTER_TYPES.range:\n    case _defaultSettings.FILTER_TYPES.timeRange:\n      if (!Array.isArray(value) || value.length !== 2) {\n        return domain.map(function (d) {\n          return d;\n        });\n      }\n      return value.map(function (d, i) {\n        return (0, _dataUtils.notNullorUndefined)(d) && isInRange(d, domain) ? d : domain[i];\n      });\n    case _defaultSettings.FILTER_TYPES.multiSelect:\n      if (!Array.isArray(value)) {\n        return [];\n      }\n      var filteredValue = value.filter(function (d) {\n        return domain.includes(d);\n      });\n      return filteredValue.length ? filteredValue : [];\n    case _defaultSettings.FILTER_TYPES.select:\n      return domain.includes(value) ? value : true;\n    default:\n      return null;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Calculate numeric domain and suitable step\n *\n * @type {typeof import('./filter-utils').getNumericFieldDomain}\n */\n\nfunction getNumericFieldDomain(dataContainer, valueAccessor) {\n  var domain = [0, 1];\n  var step = 0.1;\n  var mappedValue = dataContainer.mapIndex(valueAccessor);\n  if (dataContainer.numRows() > 1) {\n    domain = ScaleUtils.getLinearDomain(mappedValue);\n    var diff = domain[1] - domain[0]; // in case equal domain, [96, 96], which will break quantize scale\n\n    if (!diff) {\n      domain[1] = domain[0] + 1;\n    }\n    step = getNumericStepSize(diff) || step;\n    domain[0] = formatNumberByStep(domain[0], step, 'floor');\n    domain[1] = formatNumberByStep(domain[1], step, 'ceil');\n  } // @ts-ignore\n\n  var _getHistogram = getHistogram(domain, mappedValue),\n    histogram = _getHistogram.histogram,\n    enlargedHistogram = _getHistogram.enlargedHistogram;\n  return {\n    domain: domain,\n    step: step,\n    histogram: histogram,\n    enlargedHistogram: enlargedHistogram\n  };\n}\n/**\n * Calculate step size for range and timerange filter\n *\n * @type {typeof import('./filter-utils').getNumericStepSize}\n */\n\nfunction getNumericStepSize(diff) {\n  diff = Math.abs(diff);\n  if (diff > 100) {\n    return 1;\n  } else if (diff > 3) {\n    return 0.01;\n  } else if (diff > 1) {\n    return 0.001;\n  } // Try to get at least 1000 steps - and keep the step size below that of\n  // the (diff > 1) case.\n\n  var x = diff / 1000; // Find the exponent and truncate to 10 to the power of that exponent\n\n  var exponentialForm = x.toExponential();\n  var exponent = parseFloat(exponentialForm.split('e')[1]); // Getting ready for node 12\n  // this is why we need decimal.js\n  // Math.pow(10, -5) = 0.000009999999999999999\n  // the above result shows in browser and node 10\n  // node 12 behaves correctly\n\n  return new _decimal.Decimal(10).pow(exponent).toNumber();\n}\n/**\n * Calculate timestamp domain and suitable step\n * @type {typeof import('./filter-utils').getTimestampFieldDomain}\n */\n\nfunction getTimestampFieldDomain(dataContainer, valueAccessor) {\n  // to avoid converting string format time to epoch\n  // every time we compare we store a value mapped to int in filter domain\n  var mappedValue = dataContainer.mapIndex(valueAccessor);\n  var domain = ScaleUtils.getLinearDomain(mappedValue);\n  var defaultTimeFormat = getTimeWidgetTitleFormatter(domain);\n  var step = 0.01;\n  var diff = domain[1] - domain[0];\n  var entry = TimestampStepMap.find(function (f) {\n    return f.max >= diff;\n  });\n  if (entry) {\n    step = entry.step;\n  }\n  var _getHistogram2 = getHistogram(domain, mappedValue),\n    histogram = _getHistogram2.histogram,\n    enlargedHistogram = _getHistogram2.enlargedHistogram;\n  return {\n    domain: domain,\n    step: step,\n    mappedValue: mappedValue,\n    histogram: histogram,\n    enlargedHistogram: enlargedHistogram,\n    defaultTimeFormat: defaultTimeFormat\n  };\n}\n/**\n *\n * @type {typeof import('./filter-utils').histogramConstruct}\n */\n\nfunction histogramConstruct(domain, mappedValue, bins) {\n  return (0, _d3Array.histogram)().thresholds((0, _d3Array.ticks)(domain[0], domain[1], bins)).domain(domain)(mappedValue).map(function (bin) {\n    return {\n      count: bin.length,\n      x0: bin.x0,\n      x1: bin.x1\n    };\n  });\n}\n/**\n * Calculate histogram from domain and array of values\n *\n * @type {typeof import('./filter-utils').getHistogram}\n */\n\nfunction getHistogram(domain, mappedValue) {\n  var histogram = histogramConstruct(domain, mappedValue, histogramBins);\n  var enlargedHistogram = histogramConstruct(domain, mappedValue, enlargedHistogramBins);\n  return {\n    histogram: histogram,\n    enlargedHistogram: enlargedHistogram\n  };\n}\n/**\n * round number based on step\n *\n * @param {Number} val\n * @param {Number} step\n * @param {string} bound\n * @returns {Number} rounded number\n */\n\nfunction formatNumberByStep(val, step, bound) {\n  if (bound === 'floor') {\n    return Math.floor(val * (1 / step)) / (1 / step);\n  }\n  return Math.ceil(val * (1 / step)) / (1 / step);\n}\n/**\n *\n * @type {typeof import('./filter-utils').isInRange}\n */\n\nfunction isInRange(val, domain) {\n  if (!Array.isArray(domain)) {\n    return false;\n  }\n  return val >= domain[0] && val <= domain[1];\n}\n/**\n * Determines whether a point is within the provided polygon\n *\n * @param point as input search [lat, lng]\n * @param polygon Points must be within these (Multi)Polygon(s)\n * @return {boolean}\n */\n\nfunction isInPolygon(point, polygon) {\n  return (0, _booleanWithin[\"default\"])((0, _helpers.point)(point), polygon);\n}\nfunction isValidTimeDomain(domain) {\n  return Array.isArray(domain) && domain.every(Number.isFinite);\n}\nfunction getTimeWidgetTitleFormatter(domain) {\n  if (!isValidTimeDomain(domain)) {\n    return null;\n  }\n  var diff = domain[1] - domain[0]; // Local aware formats\n  // https://momentjs.com/docs/#/parsing/string-format\n\n  return diff > durationYear ? 'L' : diff > durationDay ? 'L LT' : 'L LTS';\n}\nfunction getTimeWidgetHintFormatter(domain) {\n  if (!isValidTimeDomain(domain)) {\n    return null;\n  }\n  var diff = domain[1] - domain[0];\n  return diff > durationWeek ? 'L' : diff > durationDay ? 'L LT' : diff > durationHour ? 'LT' : 'LTS';\n}\n/**\n * Sanity check on filters to prepare for save\n * @type {typeof import('./filter-utils').isValidFilterValue}\n */\n\n/* eslint-disable complexity */\n\nfunction isValidFilterValue(type, value) {\n  if (!type) {\n    return false;\n  }\n  switch (type) {\n    case _defaultSettings.FILTER_TYPES.select:\n      return value === true || value === false;\n    case _defaultSettings.FILTER_TYPES.range:\n    case _defaultSettings.FILTER_TYPES.timeRange:\n      return Array.isArray(value) && value.every(function (v) {\n        return v !== null && !isNaN(v);\n      });\n    case _defaultSettings.FILTER_TYPES.multiSelect:\n      return Array.isArray(value) && Boolean(value.length);\n    case _defaultSettings.FILTER_TYPES.input:\n      return Boolean(value.length);\n    case _defaultSettings.FILTER_TYPES.polygon:\n      var coordinates = (0, _lodash[\"default\"])(value, ['geometry', 'coordinates']);\n      return Boolean(value && value.id && coordinates);\n    default:\n      return true;\n  }\n}\n/**\n *\n * @type {typeof import('./filter-utils').getFilterPlot}\n */\n\nfunction getFilterPlot(filter, dataset) {\n  if (filter.plotType === PLOT_TYPES.histogram || !filter.yAxis) {\n    // histogram should be calculated when create filter\n    return {};\n  }\n  var _filter$mappedValue = filter.mappedValue,\n    mappedValue = _filter$mappedValue === void 0 ? [] : _filter$mappedValue;\n  var yAxis = filter.yAxis;\n  var fieldIdx = dataset.getColumnFieldIdx(yAxis.name);\n  if (fieldIdx < 0) {\n    _console.console.warn(\"yAxis \".concat(yAxis.name, \" does not exist in dataset\"));\n    return {\n      lineChart: {},\n      yAxis: yAxis\n    };\n  } // return lineChart\n\n  var series = dataset.dataContainer.map(function (row, rowIndex) {\n    return {\n      x: mappedValue[rowIndex],\n      y: row.valueAt(fieldIdx)\n    };\n  }, true).filter(function (_ref6) {\n    var x = _ref6.x,\n      y = _ref6.y;\n    return Number.isFinite(x) && Number.isFinite(y);\n  }).sort(function (a, b) {\n    return (0, _d3Array.ascending)(a.x, b.x);\n  });\n  var yDomain = (0, _d3Array.extent)(series, function (d) {\n    return d.y;\n  });\n  var xDomain = [series[0].x, series[series.length - 1].x];\n  return {\n    lineChart: {\n      series: series,\n      yDomain: yDomain,\n      xDomain: xDomain\n    },\n    yAxis: yAxis\n  };\n}\nfunction getDefaultFilterPlotType(filter) {\n  var filterPlotTypes = SupportedPlotType[filter.type];\n  if (!filterPlotTypes) {\n    return null;\n  }\n  if (!filter.yAxis) {\n    return filterPlotTypes[\"default\"];\n  }\n  return filterPlotTypes[filter.yAxis.type] || null;\n}\n/**\n *\n * @param datasetIds list of dataset ids to be filtered\n * @param datasets all datasets\n * @param filters all filters to be applied to datasets\n * @return datasets - new updated datasets\n * @type {typeof import('./filter-utils').applyFiltersToDatasets}\n */\n\nfunction applyFiltersToDatasets(datasetIds, datasets, filters, layers) {\n  var dataIds = (0, _utils.toArray)(datasetIds);\n  return dataIds.reduce(function (acc, dataId) {\n    var layersToFilter = (layers || []).filter(function (l) {\n      return l.config.dataId === dataId;\n    });\n    var appliedFilters = filters.filter(function (d) {\n      return shouldApplyFilter(d, dataId);\n    });\n    var table = datasets[dataId];\n    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, dataId, table.filterTable(appliedFilters, layersToFilter, {})));\n  }, datasets);\n}\n/**\n * Applies a new field name value to fielter and update both filter and dataset\n * @param filter - to be applied the new field name on\n * @param dataset - dataset the field belongs to\n * @param fieldName - field.name\n * @param filterDatasetIndex - field.name\n * @param option\n * @return - {filter, datasets}\n * @type {typeof import('./filter-utils').applyFilterFieldName}\n */\n\nfunction applyFilterFieldName(filter, dataset, fieldName) {\n  var filterDatasetIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var option = arguments.length > 4 ? arguments[4] : undefined;\n  // using filterDatasetIndex we can filter only the specified dataset\n  var mergeDomain = option && option.hasOwnProperty('mergeDomain') ? option.mergeDomain : false;\n  var fieldIndex = dataset.getColumnFieldIdx(fieldName); // if no field with same name is found, move to the next datasets\n\n  if (fieldIndex === -1) {\n    // throw new Error(`fieldIndex not found. Dataset must contain a property with name: ${fieldName}`);\n    return {\n      filter: null,\n      dataset: dataset\n    };\n  } // TODO: validate field type\n\n  var filterProps = dataset.getColumnFilterProps(fieldName);\n  var newFilter = _objectSpread(_objectSpread({}, mergeDomain ? mergeFilterDomainStep(filter, filterProps) : _objectSpread(_objectSpread({}, filter), filterProps)), {}, {\n    name: Object.assign((0, _toConsumableArray2[\"default\"])((0, _utils.toArray)(filter.name)), (0, _defineProperty2[\"default\"])({}, filterDatasetIndex, fieldName)),\n    fieldIdx: Object.assign((0, _toConsumableArray2[\"default\"])((0, _utils.toArray)(filter.fieldIdx)), (0, _defineProperty2[\"default\"])({}, filterDatasetIndex, fieldIndex)),\n    // TODO, since we allow to add multiple fields to a filter we can no longer freeze the filter\n    freeze: true\n  });\n  return {\n    filter: newFilter,\n    dataset: dataset\n  };\n}\n/**\n * Merge one filter with other filter prop domain\n * @type {typeof import('./filter-utils').mergeFilterDomainStep}\n */\n\n/* eslint-disable complexity */\n\nfunction mergeFilterDomainStep(filter, filterProps) {\n  if (!filter) {\n    return null;\n  }\n  if (!filterProps) {\n    return filter;\n  }\n  if (filter.fieldType && filter.fieldType !== filterProps.fieldType || !filterProps.domain) {\n    return filter;\n  }\n  var combinedDomain = !filter.domain ? filterProps.domain : [].concat((0, _toConsumableArray2[\"default\"])(filter.domain || []), (0, _toConsumableArray2[\"default\"])(filterProps.domain || [])).sort(function (a, b) {\n    return a - b;\n  });\n  var newFilter = _objectSpread(_objectSpread(_objectSpread({}, filter), filterProps), {}, {\n    domain: [combinedDomain[0], combinedDomain[combinedDomain.length - 1]]\n  });\n  switch (filterProps.fieldType) {\n    case _defaultSettings.ALL_FIELD_TYPES.string:\n    case _defaultSettings.ALL_FIELD_TYPES.date:\n      return _objectSpread(_objectSpread({}, newFilter), {}, {\n        domain: (0, _dataUtils.unique)(combinedDomain).sort()\n      });\n    case _defaultSettings.ALL_FIELD_TYPES.timestamp:\n      // @ts-ignore\n      var step = filter.step < filterProps.step ? filter.step : filterProps.step;\n      return _objectSpread(_objectSpread({}, newFilter), {}, {\n        step: step\n      });\n    case _defaultSettings.ALL_FIELD_TYPES.real:\n    case _defaultSettings.ALL_FIELD_TYPES.integer:\n    default:\n      return newFilter;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Generates polygon filter\n * @type {typeof import('./filter-utils').featureToFilterValue}\n */\n\nvar featureToFilterValue = function featureToFilterValue(feature, filterId) {\n  var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _objectSpread(_objectSpread({}, feature), {}, {\n    id: feature.id,\n    properties: _objectSpread(_objectSpread(_objectSpread({}, feature.properties), properties), {}, {\n      filterId: filterId\n    })\n  });\n};\n/**\n * @type {typeof import('./filter-utils').getFilterIdInFeature}\n */\n\nexports.featureToFilterValue = featureToFilterValue;\nvar getFilterIdInFeature = function getFilterIdInFeature(f) {\n  return (0, _lodash[\"default\"])(f, ['properties', 'filterId']);\n};\n/**\n * Generates polygon filter\n * @type {typeof import('./filter-utils').generatePolygonFilter}\n */\n\nexports.getFilterIdInFeature = getFilterIdInFeature;\nfunction generatePolygonFilter(layers, feature) {\n  var dataId = layers.map(function (l) {\n    return l.config.dataId;\n  }).filter(function (d) {\n    return d;\n  });\n  var layerId = layers.map(function (l) {\n    return l.id;\n  });\n  var name = layers.map(function (l) {\n    return l.config.label;\n  }); // @ts-ignore\n\n  var filter = getDefaultFilter(dataId);\n  return _objectSpread(_objectSpread({}, filter), {}, {\n    fixedDomain: true,\n    type: _defaultSettings.FILTER_TYPES.polygon,\n    name: name,\n    layerId: layerId,\n    value: featureToFilterValue(feature, filter.id, {\n      isVisible: true\n    })\n  });\n}\n/**\n * Run filter entirely on CPU\n * @type {typeof import('./filter-utils').filterDatasetCPU}\n */\n\nfunction filterDatasetCPU(state, dataId) {\n  var datasetFilters = state.filters.filter(function (f) {\n    return f.dataId.includes(dataId);\n  });\n  var dataset = state.datasets[dataId];\n  if (!dataset) {\n    return state;\n  }\n  var cpuFilteredDataset = dataset.filterTableCPU(datasetFilters, state.layers);\n  return (0, _utils.set)(['datasets', dataId], cpuFilteredDataset, state);\n}\n/**\n * Validate parsed filters with datasets and add filterProps to field\n * @type {typeof import('./filter-utils').validateFiltersUpdateDatasets}\n */\n\nfunction validateFiltersUpdateDatasets(state) {\n  var filtersToValidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var validated = [];\n  var failed = [];\n  var datasets = state.datasets;\n  var updatedDatasets = datasets; // merge filters\n\n  filtersToValidate.forEach(function (filter) {\n    // we can only look for datasets define in the filter dataId\n    var datasetIds = (0, _utils.toArray)(filter.dataId); // we can merge a filter only if all datasets in filter.dataId are loaded\n\n    if (datasetIds.every(function (d) {\n      return datasets[d];\n    })) {\n      // all datasetIds in filter must be present the state datasets\n      var _datasetIds$reduce = datasetIds.reduce(function (acc, datasetId) {\n          var dataset = updatedDatasets[datasetId];\n          var layers = state.layers.filter(function (l) {\n            return l.config.dataId === dataset.id;\n          });\n          var _validateFilterWithDa = validateFilterWithData(acc.augmentedDatasets[datasetId] || dataset, filter, layers),\n            updatedFilter = _validateFilterWithDa.filter,\n            updatedDataset = _validateFilterWithDa.dataset;\n          if (updatedFilter) {\n            return _objectSpread(_objectSpread({}, acc), {}, {\n              // merge filter props\n              filter: acc.filter ? _objectSpread(_objectSpread({}, acc.filter), mergeFilterDomainStep(acc, updatedFilter)) : updatedFilter,\n              applyToDatasets: [].concat((0, _toConsumableArray2[\"default\"])(acc.applyToDatasets), [datasetId]),\n              augmentedDatasets: _objectSpread(_objectSpread({}, acc.augmentedDatasets), {}, (0, _defineProperty2[\"default\"])({}, datasetId, updatedDataset))\n            });\n          }\n          return acc;\n        }, {\n          filter: null,\n          applyToDatasets: [],\n          augmentedDatasets: {}\n        }),\n        validatedFilter = _datasetIds$reduce.filter,\n        applyToDatasets = _datasetIds$reduce.applyToDatasets,\n        augmentedDatasets = _datasetIds$reduce.augmentedDatasets;\n      if (validatedFilter && (0, _lodash2[\"default\"])(datasetIds, applyToDatasets)) {\n        validated.push(validatedFilter);\n        updatedDatasets = _objectSpread(_objectSpread({}, updatedDatasets), augmentedDatasets);\n      }\n    } else {\n      failed.push(filter);\n    }\n  });\n  return {\n    validated: validated,\n    failed: failed,\n    updatedDatasets: updatedDatasets\n  };\n}\n/**\n * Retrieve interval bins for time filter\n * @type {typeof import('./filter-utils').getIntervalBins}\n */\n\nfunction getIntervalBins(filter) {\n  var _filter$plotType;\n  var bins = filter.bins;\n  var interval = (_filter$plotType = filter.plotType) === null || _filter$plotType === void 0 ? void 0 : _filter$plotType.interval;\n  if (!interval || !bins || Object.keys(bins).length === 0) {\n    return null;\n  }\n  var values = Object.values(bins);\n  return values[0] ? values[0][interval] : null;\n}","map":{"version":3,"sources":["../../src/utils/filter-utils.js"],"names":["TimestampStepMap","max","step","Number","POSITIVE_INFINITY","histogramBins","enlargedHistogramBins","durationSecond","durationMinute","durationHour","durationDay","durationWeek","durationYear","PLOT_TYPES","histogram","lineChart","FILTER_UPDATER_PROPS","dataId","name","layerId","LIMITED_FILTER_EFFECT_PROPS","SupportedPlotType","FILTER_TYPES","timeRange","ALL_FIELD_TYPES","integer","real","range","FILTER_COMPONENTS","select","multiSelect","polygon","DEFAULT_FILTER_STRUCTURE","freeze","id","fixedDomain","enlarged","isAnimating","animationWindow","ANIMATION_WINDOW","free","speed","type","fieldIdx","domain","value","plotType","yAxis","interval","gpu","FILTER_ID_LENGTH","LAYER_FILTERS","getDefaultFilter","shouldApplyFilter","filter","datasetId","dataIds","includes","validatePolygonFilter","dataset","layers","failed","isValidFilterValue","isValidDataset","layer","find","l","filterValidators","validateFilter","filterDataId","filterDatasetIndex","indexOf","initializeFilter","fieldName","updatedFilter","updatedDataset","applyFilterFieldName","mergeDomain","adjustValueToFilterDomain","validateFilterYAxis","validateFilterWithData","hasOwnProperty","fields","matchedAxis","getFilterPlot","getFilterProps","field","fieldDomain","filterProps","fieldType","typeOptions","string","date","timestamp","getPolygonFilterFunctor","dataContainer","getPosition","getPositionAccessor","LAYER_TYPES","point","icon","pos","data","every","isFinite","isInPolygon","arc","line","hexagonId","dataToFeature","centroids","centroid","index","getFilterFunction","valueAccessor","defaultFunc","isInRange","mappedValue","accessor","isArray","format","length","layerFilterFunctions","map","config","filterFunc","updateFilterDataId","filterDataByFilterTypes","dynamicDomainFilters","cpuFilters","filterFuncs","result","filteredIndexForDomain","filteredIndex","filterContext","filterFuncCaller","numRows","i","matchForDomain","push","matchForRender","getFilterRecord","filters","opt","filterRecord","dynamicDomain","cpu","forEach","f","ignoreDomain","cpuOnly","diffFilters","oldFilterRecord","filterChanged","Object","entries","record","items","oldFilter","prop","Array","d","filteredValue","getNumericFieldDomain","mapIndex","ScaleUtils","getLinearDomain","diff","getNumericStepSize","formatNumberByStep","enlargedHistogram","getHistogram","Math","abs","x","exponentialForm","toExponential","exponent","parseFloat","split","Decimal","pow","toNumber","getTimestampFieldDomain","defaultTimeFormat","getTimeWidgetTitleFormatter","entry","histogramConstruct","bins","thresholds","count","bin","x0","x1","val","bound","floor","ceil","isValidTimeDomain","getTimeWidgetHintFormatter","v","isNaN","Boolean","input","coordinates","getColumnFieldIdx","Console","warn","series","row","rowIndex","y","valueAt","sort","a","b","yDomain","xDomain","getDefaultFilterPlotType","filterPlotTypes","applyFiltersToDatasets","datasetIds","datasets","reduce","acc","layersToFilter","appliedFilters","table","filterTable","option","fieldIndex","getColumnFilterProps","newFilter","mergeFilterDomainStep","assign","combinedDomain","featureToFilterValue","feature","filterId","properties","getFilterIdInFeature","generatePolygonFilter","label","isVisible","filterDatasetCPU","state","datasetFilters","cpuFilteredDataset","filterTableCPU","validateFiltersUpdateDatasets","filtersToValidate","validated","updatedDatasets","validatedFilter","applyToDatasets","augmentedDatasets","getIntervalBins","keys","values"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {ascending, extent, histogram as d3Histogram, ticks} from 'd3-array';\nimport keyMirror from 'keymirror';\nimport {console as Console} from 'global/console';\nimport get from 'lodash.get';\nimport isEqual from 'lodash.isequal';\n\nimport booleanWithin from '@turf/boolean-within';\nimport {point as turfPoint} from '@turf/helpers';\nimport {Decimal} from 'decimal.js';\nimport {ALL_FIELD_TYPES, FILTER_TYPES, ANIMATION_WINDOW} from 'constants/default-settings';\nimport {notNullorUndefined, unique, timeToUnixMilli} from './data-utils';\nimport * as ScaleUtils from './data-scale-utils';\nimport {LAYER_TYPES} from 'layers/types';\nimport {generateHashId, set, toArray} from './utils';\nimport {getCentroid, h3IsValid} from 'layers/h3-hexagon-layer/h3-utils';\n\n// TYPE\n/** @typedef {import('./table-utils/kepler-table').FilterRecord} FilterRecord */\n/** @typedef {import('./filter-utils').FilterResult} FilterResult */\n\nexport const TimestampStepMap = [\n  {max: 1, step: 0.05},\n  {max: 10, step: 0.1},\n  {max: 100, step: 1},\n  {max: 500, step: 5},\n  {max: 1000, step: 10},\n  {max: 5000, step: 50},\n  {max: Number.POSITIVE_INFINITY, step: 1000}\n];\n\nexport const histogramBins = 30;\nexport const enlargedHistogramBins = 100;\n\nconst durationSecond = 1000;\nconst durationMinute = durationSecond * 60;\nconst durationHour = durationMinute * 60;\nconst durationDay = durationHour * 24;\nconst durationWeek = durationDay * 7;\nconst durationYear = durationDay * 365;\n\nexport const PLOT_TYPES = keyMirror({\n  histogram: null,\n  lineChart: null\n});\n\nexport const FILTER_UPDATER_PROPS = keyMirror({\n  dataId: null,\n  name: null,\n  layerId: null\n});\n\nexport const LIMITED_FILTER_EFFECT_PROPS = keyMirror({\n  [FILTER_UPDATER_PROPS.name]: null\n});\n/**\n * Max number of filter value buffers that deck.gl provides\n */\n\nconst SupportedPlotType = {\n  [FILTER_TYPES.timeRange]: {\n    default: 'histogram',\n    [ALL_FIELD_TYPES.integer]: 'lineChart',\n    [ALL_FIELD_TYPES.real]: 'lineChart'\n  },\n  [FILTER_TYPES.range]: {\n    default: 'histogram',\n    [ALL_FIELD_TYPES.integer]: 'lineChart',\n    [ALL_FIELD_TYPES.real]: 'lineChart'\n  }\n};\n\nexport const FILTER_COMPONENTS = {\n  [FILTER_TYPES.select]: 'SingleSelectFilter',\n  [FILTER_TYPES.multiSelect]: 'MultiSelectFilter',\n  [FILTER_TYPES.timeRange]: 'TimeRangeFilter',\n  [FILTER_TYPES.range]: 'RangeFilter',\n  [FILTER_TYPES.polygon]: 'PolygonFilter'\n};\n\nexport const DEFAULT_FILTER_STRUCTURE = {\n  dataId: [], // [string]\n  freeze: false,\n  id: null,\n\n  // time range filter specific\n  fixedDomain: false,\n  enlarged: false,\n  isAnimating: false,\n  animationWindow: ANIMATION_WINDOW.free,\n  speed: 1,\n\n  // field specific\n  name: [], // string\n  type: null,\n  fieldIdx: [], // [integer]\n  domain: null,\n  value: null,\n\n  // plot\n  plotType: PLOT_TYPES.histogram,\n  yAxis: null,\n  interval: null,\n\n  // mode\n  gpu: false\n};\n\nexport const FILTER_ID_LENGTH = 4;\n\nexport const LAYER_FILTERS = [FILTER_TYPES.polygon];\n\n/**\n * Generates a filter with a dataset id as dataId\n * @type {typeof import('./filter-utils').getDefaultFilter}\n */\nexport function getDefaultFilter(dataId) {\n  return {\n    ...DEFAULT_FILTER_STRUCTURE,\n    // store it as dataId and it could be one or many\n    dataId: toArray(dataId),\n    id: generateHashId(FILTER_ID_LENGTH)\n  };\n}\n\n/**\n * Check if a filter is valid based on the given dataId\n * @param  filter to validate\n * @param  datasetId id to validate filter against\n * @return true if a filter is valid, false otherwise\n * @type {typeof import('./filter-utils').shouldApplyFilter}\n */\nexport function shouldApplyFilter(filter, datasetId) {\n  const dataIds = toArray(filter.dataId);\n  return dataIds.includes(datasetId) && filter.value !== null;\n}\n\n/**\n * Validates and modifies polygon filter structure\n * @param dataset\n * @param filter\n * @param layers\n * @return - {filter, dataset}\n * @type {typeof import('./filter-utils').validatePolygonFilter}\n */\nexport function validatePolygonFilter(dataset, filter, layers) {\n  const failed = {dataset, filter: null};\n  const {value, layerId, type, dataId} = filter;\n\n  if (!layerId || !isValidFilterValue(type, value)) {\n    return failed;\n  }\n\n  const isValidDataset = dataId.includes(dataset.id);\n\n  if (!isValidDataset) {\n    return failed;\n  }\n\n  const layer = layers.find(l => layerId.includes(l.id));\n\n  if (!layer) {\n    return failed;\n  }\n\n  return {\n    filter: {\n      ...filter,\n      freeze: true,\n      fieldIdx: []\n    },\n    dataset\n  };\n}\n\n/**\n * Custom filter validators\n */\nconst filterValidators = {\n  [FILTER_TYPES.polygon]: validatePolygonFilter\n};\n\n/**\n * Default validate filter function\n * @param dataset\n * @param filter\n * @return - {filter, dataset}\n * @type {typeof import('./filter-utils').validateFilter}\n */\nexport function validateFilter(dataset, filter) {\n  // match filter.dataId\n  const failed = {dataset, filter: null};\n  const filterDataId = toArray(filter.dataId);\n\n  const filterDatasetIndex = filterDataId.indexOf(dataset.id);\n  if (filterDatasetIndex < 0) {\n    // the current filter is not mapped against the current dataset\n    return failed;\n  }\n\n  const initializeFilter = {\n    ...getDefaultFilter(filter.dataId),\n    ...filter,\n    dataId: filterDataId,\n    name: toArray(filter.name)\n  };\n\n  const fieldName = initializeFilter.name[filterDatasetIndex];\n  const {filter: updatedFilter, dataset: updatedDataset} = applyFilterFieldName(\n    initializeFilter,\n    dataset,\n    fieldName,\n    filterDatasetIndex,\n    {mergeDomain: true}\n  );\n\n  if (!updatedFilter) {\n    return failed;\n  }\n\n  updatedFilter.value = adjustValueToFilterDomain(filter.value, updatedFilter);\n  updatedFilter.enlarged =\n    typeof filter.enlarged === 'boolean' ? filter.enlarged : updatedFilter.enlarged;\n\n  if (updatedFilter.value === null) {\n    // cannot adjust saved value to filter\n    return failed;\n  }\n\n  return {\n    filter: validateFilterYAxis(updatedFilter, updatedDataset),\n    dataset: updatedDataset\n  };\n}\n\n/**\n * Validate saved filter config with new data,\n * calculate domain and fieldIdx based new fields and data\n *\n * @param dataset\n * @param filter - filter to be validate\n * @param layers - layers\n * @return validated filter\n * @type {typeof import('./filter-utils').validateFilterWithData}\n */\nexport function validateFilterWithData(dataset, filter, layers) {\n  // @ts-ignore\n  return filterValidators.hasOwnProperty(filter.type)\n    ? filterValidators[filter.type](dataset, filter, layers)\n    : validateFilter(dataset, filter);\n}\n\n/**\n * Validate YAxis\n * @param filter\n * @param dataset\n * @return {*}\n */\nfunction validateFilterYAxis(filter, dataset) {\n  // TODO: validate yAxis against other datasets\n\n  const {fields} = dataset;\n  const {yAxis} = filter;\n  // TODO: validate yAxis against other datasets\n  if (yAxis) {\n    const matchedAxis = fields.find(({name, type}) => name === yAxis.name && type === yAxis.type);\n\n    filter = matchedAxis\n      ? {\n          ...filter,\n          yAxis: matchedAxis,\n          ...getFilterPlot({...filter, yAxis: matchedAxis}, dataset)\n        }\n      : filter;\n  }\n\n  return filter;\n}\n\n/**\n * Get default filter prop based on field type\n *\n * @param field\n * @param fieldDomain\n * @returns default filter\n * @type {typeof import('./filter-utils').getFilterProps}\n */\nexport function getFilterProps(field, fieldDomain) {\n  const filterProps = {\n    ...fieldDomain,\n    fieldType: field.type\n  };\n\n  switch (field.type) {\n    case ALL_FIELD_TYPES.real:\n    case ALL_FIELD_TYPES.integer:\n      return {\n        ...filterProps,\n        value: fieldDomain.domain,\n        type: FILTER_TYPES.range,\n        typeOptions: [FILTER_TYPES.range],\n        gpu: true\n      };\n\n    case ALL_FIELD_TYPES.boolean:\n      return {\n        ...filterProps,\n        type: FILTER_TYPES.select,\n        value: true,\n        gpu: false\n      };\n\n    case ALL_FIELD_TYPES.string:\n    case ALL_FIELD_TYPES.date:\n      return {\n        ...filterProps,\n        type: FILTER_TYPES.multiSelect,\n        value: [],\n        gpu: false\n      };\n\n    case ALL_FIELD_TYPES.timestamp:\n      return {\n        ...filterProps,\n        type: FILTER_TYPES.timeRange,\n        enlarged: true,\n        fixedDomain: true,\n        value: filterProps.domain,\n        gpu: true\n      };\n\n    default:\n      return {};\n  }\n}\n\nexport const getPolygonFilterFunctor = (layer, filter, dataContainer) => {\n  const getPosition = layer.getPositionAccessor(dataContainer);\n\n  switch (layer.type) {\n    case LAYER_TYPES.point:\n    case LAYER_TYPES.icon:\n      return data => {\n        const pos = getPosition(data);\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    case LAYER_TYPES.arc:\n    case LAYER_TYPES.line:\n      return data => {\n        const pos = getPosition(data);\n        return (\n          pos.every(Number.isFinite) &&\n          [\n            [pos[0], pos[1]],\n            [pos[3], pos[4]]\n          ].every(point => isInPolygon(point, filter.value))\n        );\n      };\n    case LAYER_TYPES.hexagonId:\n      if (layer.dataToFeature && layer.dataToFeature.centroids) {\n        return data => {\n          // null or getCentroid({id})\n          const centroid = layer.dataToFeature.centroids[data.index];\n          return centroid && isInPolygon(centroid, filter.value);\n        };\n      }\n      return data => {\n        const id = getPosition(data);\n        if (!h3IsValid(id)) {\n          return false;\n        }\n        const pos = getCentroid({id});\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    default:\n      return () => true;\n  }\n};\n\n/**\n * @param field dataset Field\n * @param dataId Dataset id\n * @param filter Filter object\n * @param layers list of layers to filter upon\n * @param dataContainer Data container\n * @return filterFunction\n * @type {typeof import('./filter-utils').getFilterFunction}\n */\nexport function getFilterFunction(field, dataId, filter, layers, dataContainer) {\n  // field could be null in polygon filter\n  const valueAccessor = field ? field.valueAccessor : data => null;\n  const defaultFunc = d => true;\n\n  switch (filter.type) {\n    case FILTER_TYPES.range:\n      return data => isInRange(valueAccessor(data), filter.value);\n    case FILTER_TYPES.multiSelect:\n      return data => filter.value.includes(valueAccessor(data));\n    case FILTER_TYPES.select:\n      return data => valueAccessor(data) === filter.value;\n    case FILTER_TYPES.timeRange:\n      if (!field) {\n        return defaultFunc;\n      }\n      const mappedValue = get(field, ['filterProps', 'mappedValue']);\n      const accessor = Array.isArray(mappedValue)\n        ? data => mappedValue[data.index]\n        : data => timeToUnixMilli(valueAccessor(data), field.format);\n      return data => isInRange(accessor(data), filter.value);\n    case FILTER_TYPES.polygon:\n      if (!layers || !layers.length) {\n        return defaultFunc;\n      }\n      // @ts-ignore\n      const layerFilterFunctions = filter.layerId\n        .map(id => layers.find(l => l.id === id))\n        .filter(l => l && l.config.dataId === dataId)\n        .map(layer => getPolygonFilterFunctor(layer, filter, dataContainer));\n\n      return data => layerFilterFunctions.every(filterFunc => filterFunc(data));\n    default:\n      return defaultFunc;\n  }\n}\n\nexport function updateFilterDataId(dataId) {\n  return getDefaultFilter(dataId);\n}\n\n/**\n * @type {typeof import('./filter-utils').filterDataByFilterTypes}\n */\nexport function filterDataByFilterTypes(\n  {dynamicDomainFilters, cpuFilters, filterFuncs},\n  dataContainer\n) {\n  const result = {\n    ...(dynamicDomainFilters ? {filteredIndexForDomain: []} : {}),\n    ...(cpuFilters ? {filteredIndex: []} : {})\n  };\n\n  const filterContext = {index: -1, dataContainer};\n  const filterFuncCaller = filter => filterFuncs[filter.id](filterContext);\n\n  const numRows = dataContainer.numRows();\n  for (let i = 0; i < numRows; ++i) {\n    filterContext.index = i;\n\n    const matchForDomain = dynamicDomainFilters && dynamicDomainFilters.every(filterFuncCaller);\n    if (matchForDomain) {\n      // @ts-ignore\n      result.filteredIndexForDomain.push(filterContext.index);\n    }\n\n    const matchForRender = cpuFilters && cpuFilters.every(filterFuncCaller);\n    if (matchForRender) {\n      // @ts-ignore\n      result.filteredIndex.push(filterContext.index);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Get a record of filters based on domain type and gpu / cpu\n * @type {typeof import('./filter-utils').getFilterRecord}\n */\nexport function getFilterRecord(dataId, filters, opt = {}) {\n  /**\n   * @type {FilterRecord}\n   */\n  const filterRecord = {\n    dynamicDomain: [],\n    fixedDomain: [],\n    cpu: [],\n    gpu: []\n  };\n\n  filters.forEach(f => {\n    if (isValidFilterValue(f.type, f.value) && toArray(f.dataId).includes(dataId)) {\n      (f.fixedDomain || opt.ignoreDomain\n        ? filterRecord.fixedDomain\n        : filterRecord.dynamicDomain\n      ).push(f);\n\n      (f.gpu && !opt.cpuOnly ? filterRecord.gpu : filterRecord.cpu).push(f);\n    }\n  });\n\n  return filterRecord;\n}\n\n/**\n * Compare filter records to get what has changed\n * @type {typeof import('./filter-utils').diffFilters}\n */\nexport function diffFilters(filterRecord, oldFilterRecord = {}) {\n  let filterChanged = {};\n\n  Object.entries(filterRecord).forEach(([record, items]) => {\n    items.forEach(filter => {\n      const oldFilter = (oldFilterRecord[record] || []).find(f => f.id === filter.id);\n\n      if (!oldFilter) {\n        // added\n        filterChanged = set([record, filter.id], 'added', filterChanged);\n      } else {\n        // check  what has changed\n        ['name', 'value', 'dataId'].forEach(prop => {\n          if (filter[prop] !== oldFilter[prop]) {\n            filterChanged = set([record, filter.id], `${prop}_changed`, filterChanged);\n          }\n        });\n      }\n    });\n\n    (oldFilterRecord[record] || []).forEach(oldFilter => {\n      // deleted\n      if (!items.find(f => f.id === oldFilter.id)) {\n        filterChanged = set([record, oldFilter.id], 'deleted', filterChanged);\n      }\n    });\n\n    if (!filterChanged[record]) {\n      filterChanged[record] = null;\n    }\n  });\n\n  // @ts-ignore\n  return filterChanged;\n}\n/**\n * Call by parsing filters from URL\n * Check if value of filter within filter domain, if not adjust it to match\n * filter domain\n *\n * @type {typeof import('./filter-utils').adjustValueToFilterDomain}\n * @returns value - adjusted value to match filter or null to remove filter\n */\n/* eslint-disable complexity */\nexport function adjustValueToFilterDomain(value, {domain, type}) {\n  if (!domain || !type) {\n    return false;\n  }\n\n  switch (type) {\n    case FILTER_TYPES.range:\n    case FILTER_TYPES.timeRange:\n      if (!Array.isArray(value) || value.length !== 2) {\n        return domain.map(d => d);\n      }\n\n      return value.map((d, i) => (notNullorUndefined(d) && isInRange(d, domain) ? d : domain[i]));\n\n    case FILTER_TYPES.multiSelect:\n      if (!Array.isArray(value)) {\n        return [];\n      }\n      const filteredValue = value.filter(d => domain.includes(d));\n      return filteredValue.length ? filteredValue : [];\n\n    case FILTER_TYPES.select:\n      return domain.includes(value) ? value : true;\n\n    default:\n      return null;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Calculate numeric domain and suitable step\n *\n * @type {typeof import('./filter-utils').getNumericFieldDomain}\n */\nexport function getNumericFieldDomain(dataContainer, valueAccessor) {\n  let domain = [0, 1];\n  let step = 0.1;\n\n  const mappedValue = dataContainer.mapIndex(valueAccessor);\n\n  if (dataContainer.numRows() > 1) {\n    domain = ScaleUtils.getLinearDomain(mappedValue);\n    const diff = domain[1] - domain[0];\n\n    // in case equal domain, [96, 96], which will break quantize scale\n    if (!diff) {\n      domain[1] = domain[0] + 1;\n    }\n\n    step = getNumericStepSize(diff) || step;\n    domain[0] = formatNumberByStep(domain[0], step, 'floor');\n    domain[1] = formatNumberByStep(domain[1], step, 'ceil');\n  }\n\n  // @ts-ignore\n  const {histogram, enlargedHistogram} = getHistogram(domain, mappedValue);\n\n  return {domain, step, histogram, enlargedHistogram};\n}\n\n/**\n * Calculate step size for range and timerange filter\n *\n * @type {typeof import('./filter-utils').getNumericStepSize}\n */\nexport function getNumericStepSize(diff) {\n  diff = Math.abs(diff);\n\n  if (diff > 100) {\n    return 1;\n  } else if (diff > 3) {\n    return 0.01;\n  } else if (diff > 1) {\n    return 0.001;\n  }\n  // Try to get at least 1000 steps - and keep the step size below that of\n  // the (diff > 1) case.\n  const x = diff / 1000;\n  // Find the exponent and truncate to 10 to the power of that exponent\n\n  const exponentialForm = x.toExponential();\n  const exponent = parseFloat(exponentialForm.split('e')[1]);\n\n  // Getting ready for node 12\n  // this is why we need decimal.js\n  // Math.pow(10, -5) = 0.000009999999999999999\n  // the above result shows in browser and node 10\n  // node 12 behaves correctly\n  return new Decimal(10).pow(exponent).toNumber();\n}\n\n/**\n * Calculate timestamp domain and suitable step\n * @type {typeof import('./filter-utils').getTimestampFieldDomain}\n */\nexport function getTimestampFieldDomain(dataContainer, valueAccessor) {\n  // to avoid converting string format time to epoch\n  // every time we compare we store a value mapped to int in filter domain\n\n  const mappedValue = dataContainer.mapIndex(valueAccessor);\n  const domain = ScaleUtils.getLinearDomain(mappedValue);\n  const defaultTimeFormat = getTimeWidgetTitleFormatter(domain);\n\n  let step = 0.01;\n\n  const diff = domain[1] - domain[0];\n  const entry = TimestampStepMap.find(f => f.max >= diff);\n  if (entry) {\n    step = entry.step;\n  }\n\n  const {histogram, enlargedHistogram} = getHistogram(domain, mappedValue);\n\n  return {\n    domain,\n    step,\n    mappedValue,\n    histogram,\n    enlargedHistogram,\n    defaultTimeFormat\n  };\n}\n\n/**\n *\n * @type {typeof import('./filter-utils').histogramConstruct}\n */\nexport function histogramConstruct(domain, mappedValue, bins) {\n  return d3Histogram()\n    .thresholds(ticks(domain[0], domain[1], bins))\n    .domain(domain)(mappedValue)\n    .map(bin => ({\n      count: bin.length,\n      x0: bin.x0,\n      x1: bin.x1\n    }));\n}\n/**\n * Calculate histogram from domain and array of values\n *\n * @type {typeof import('./filter-utils').getHistogram}\n */\nexport function getHistogram(domain, mappedValue) {\n  const histogram = histogramConstruct(domain, mappedValue, histogramBins);\n  const enlargedHistogram = histogramConstruct(domain, mappedValue, enlargedHistogramBins);\n\n  return {histogram, enlargedHistogram};\n}\n\n/**\n * round number based on step\n *\n * @param {Number} val\n * @param {Number} step\n * @param {string} bound\n * @returns {Number} rounded number\n */\nexport function formatNumberByStep(val, step, bound) {\n  if (bound === 'floor') {\n    return Math.floor(val * (1 / step)) / (1 / step);\n  }\n\n  return Math.ceil(val * (1 / step)) / (1 / step);\n}\n\n/**\n *\n * @type {typeof import('./filter-utils').isInRange}\n */\nexport function isInRange(val, domain) {\n  if (!Array.isArray(domain)) {\n    return false;\n  }\n\n  return val >= domain[0] && val <= domain[1];\n}\n\n/**\n * Determines whether a point is within the provided polygon\n *\n * @param point as input search [lat, lng]\n * @param polygon Points must be within these (Multi)Polygon(s)\n * @return {boolean}\n */\nexport function isInPolygon(point, polygon) {\n  return booleanWithin(turfPoint(point), polygon);\n}\nexport function isValidTimeDomain(domain) {\n  return Array.isArray(domain) && domain.every(Number.isFinite);\n}\nexport function getTimeWidgetTitleFormatter(domain) {\n  if (!isValidTimeDomain(domain)) {\n    return null;\n  }\n\n  const diff = domain[1] - domain[0];\n\n  // Local aware formats\n  // https://momentjs.com/docs/#/parsing/string-format\n  return diff > durationYear ? 'L' : diff > durationDay ? 'L LT' : 'L LTS';\n}\n\nexport function getTimeWidgetHintFormatter(domain) {\n  if (!isValidTimeDomain(domain)) {\n    return null;\n  }\n\n  const diff = domain[1] - domain[0];\n  return diff > durationWeek\n    ? 'L'\n    : diff > durationDay\n    ? 'L LT'\n    : diff > durationHour\n    ? 'LT'\n    : 'LTS';\n}\n\n/**\n * Sanity check on filters to prepare for save\n * @type {typeof import('./filter-utils').isValidFilterValue}\n */\n/* eslint-disable complexity */\nexport function isValidFilterValue(type, value) {\n  if (!type) {\n    return false;\n  }\n  switch (type) {\n    case FILTER_TYPES.select:\n      return value === true || value === false;\n\n    case FILTER_TYPES.range:\n    case FILTER_TYPES.timeRange:\n      return Array.isArray(value) && value.every(v => v !== null && !isNaN(v));\n\n    case FILTER_TYPES.multiSelect:\n      return Array.isArray(value) && Boolean(value.length);\n\n    case FILTER_TYPES.input:\n      return Boolean(value.length);\n\n    case FILTER_TYPES.polygon:\n      const coordinates = get(value, ['geometry', 'coordinates']);\n      return Boolean(value && value.id && coordinates);\n\n    default:\n      return true;\n  }\n}\n\n/**\n *\n * @type {typeof import('./filter-utils').getFilterPlot}\n */\nexport function getFilterPlot(filter, dataset) {\n  if (filter.plotType === PLOT_TYPES.histogram || !filter.yAxis) {\n    // histogram should be calculated when create filter\n    return {};\n  }\n\n  const {mappedValue = []} = filter;\n  const {yAxis} = filter;\n  const fieldIdx = dataset.getColumnFieldIdx(yAxis.name);\n  if (fieldIdx < 0) {\n    Console.warn(`yAxis ${yAxis.name} does not exist in dataset`);\n    return {lineChart: {}, yAxis};\n  }\n\n  // return lineChart\n  const series = dataset.dataContainer\n    .map(\n      (row, rowIndex) => ({\n        x: mappedValue[rowIndex],\n        y: row.valueAt(fieldIdx)\n      }),\n      true\n    )\n    .filter(({x, y}) => Number.isFinite(x) && Number.isFinite(y))\n    .sort((a, b) => ascending(a.x, b.x));\n\n  const yDomain = extent(series, d => d.y);\n  const xDomain = [series[0].x, series[series.length - 1].x];\n\n  return {lineChart: {series, yDomain, xDomain}, yAxis};\n}\n\nexport function getDefaultFilterPlotType(filter) {\n  const filterPlotTypes = SupportedPlotType[filter.type];\n  if (!filterPlotTypes) {\n    return null;\n  }\n\n  if (!filter.yAxis) {\n    return filterPlotTypes.default;\n  }\n\n  return filterPlotTypes[filter.yAxis.type] || null;\n}\n\n/**\n *\n * @param datasetIds list of dataset ids to be filtered\n * @param datasets all datasets\n * @param filters all filters to be applied to datasets\n * @return datasets - new updated datasets\n * @type {typeof import('./filter-utils').applyFiltersToDatasets}\n */\nexport function applyFiltersToDatasets(datasetIds, datasets, filters, layers) {\n  const dataIds = toArray(datasetIds);\n  return dataIds.reduce((acc, dataId) => {\n    const layersToFilter = (layers || []).filter(l => l.config.dataId === dataId);\n    const appliedFilters = filters.filter(d => shouldApplyFilter(d, dataId));\n    const table = datasets[dataId];\n\n    return {\n      ...acc,\n      [dataId]: table.filterTable(appliedFilters, layersToFilter, {})\n    };\n  }, datasets);\n}\n\n/**\n * Applies a new field name value to fielter and update both filter and dataset\n * @param filter - to be applied the new field name on\n * @param dataset - dataset the field belongs to\n * @param fieldName - field.name\n * @param filterDatasetIndex - field.name\n * @param option\n * @return - {filter, datasets}\n * @type {typeof import('./filter-utils').applyFilterFieldName}\n */\nexport function applyFilterFieldName(filter, dataset, fieldName, filterDatasetIndex = 0, option) {\n  // using filterDatasetIndex we can filter only the specified dataset\n  const mergeDomain = option && option.hasOwnProperty('mergeDomain') ? option.mergeDomain : false;\n\n  const fieldIndex = dataset.getColumnFieldIdx(fieldName);\n  // if no field with same name is found, move to the next datasets\n  if (fieldIndex === -1) {\n    // throw new Error(`fieldIndex not found. Dataset must contain a property with name: ${fieldName}`);\n    return {filter: null, dataset};\n  }\n\n  // TODO: validate field type\n  const filterProps = dataset.getColumnFilterProps(fieldName);\n\n  const newFilter = {\n    ...(mergeDomain ? mergeFilterDomainStep(filter, filterProps) : {...filter, ...filterProps}),\n    name: Object.assign([...toArray(filter.name)], {[filterDatasetIndex]: fieldName}),\n    fieldIdx: Object.assign([...toArray(filter.fieldIdx)], {\n      [filterDatasetIndex]: fieldIndex\n    }),\n    // TODO, since we allow to add multiple fields to a filter we can no longer freeze the filter\n    freeze: true\n  };\n\n  return {\n    filter: newFilter,\n    dataset\n  };\n}\n\n/**\n * Merge one filter with other filter prop domain\n * @type {typeof import('./filter-utils').mergeFilterDomainStep}\n */\n/* eslint-disable complexity */\nexport function mergeFilterDomainStep(filter, filterProps) {\n  if (!filter) {\n    return null;\n  }\n\n  if (!filterProps) {\n    return filter;\n  }\n\n  if ((filter.fieldType && filter.fieldType !== filterProps.fieldType) || !filterProps.domain) {\n    return filter;\n  }\n\n  const combinedDomain = !filter.domain\n    ? filterProps.domain\n    : [...(filter.domain || []), ...(filterProps.domain || [])].sort((a, b) => a - b);\n\n  const newFilter = {\n    ...filter,\n    ...filterProps,\n    domain: [combinedDomain[0], combinedDomain[combinedDomain.length - 1]]\n  };\n\n  switch (filterProps.fieldType) {\n    case ALL_FIELD_TYPES.string:\n    case ALL_FIELD_TYPES.date:\n      return {\n        ...newFilter,\n        domain: unique(combinedDomain).sort()\n      };\n\n    case ALL_FIELD_TYPES.timestamp:\n      // @ts-ignore\n      const step = filter.step < filterProps.step ? filter.step : filterProps.step;\n\n      return {\n        ...newFilter,\n        step\n      };\n    case ALL_FIELD_TYPES.real:\n    case ALL_FIELD_TYPES.integer:\n    default:\n      return newFilter;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Generates polygon filter\n * @type {typeof import('./filter-utils').featureToFilterValue}\n */\nexport const featureToFilterValue = (feature, filterId, properties = {}) => ({\n  ...feature,\n  id: feature.id,\n  properties: {\n    ...feature.properties,\n    ...properties,\n    filterId\n  }\n});\n\n/**\n * @type {typeof import('./filter-utils').getFilterIdInFeature}\n */\nexport const getFilterIdInFeature = f => get(f, ['properties', 'filterId']);\n\n/**\n * Generates polygon filter\n * @type {typeof import('./filter-utils').generatePolygonFilter}\n */\nexport function generatePolygonFilter(layers, feature) {\n  const dataId = layers.map(l => l.config.dataId).filter(d => d);\n  const layerId = layers.map(l => l.id);\n  const name = layers.map(l => l.config.label);\n  // @ts-ignore\n  const filter = getDefaultFilter(dataId);\n  return {\n    ...filter,\n    fixedDomain: true,\n    type: FILTER_TYPES.polygon,\n    name,\n    layerId,\n    value: featureToFilterValue(feature, filter.id, {isVisible: true})\n  };\n}\n\n/**\n * Run filter entirely on CPU\n * @type {typeof import('./filter-utils').filterDatasetCPU}\n */\nexport function filterDatasetCPU(state, dataId) {\n  const datasetFilters = state.filters.filter(f => f.dataId.includes(dataId));\n  const dataset = state.datasets[dataId];\n\n  if (!dataset) {\n    return state;\n  }\n\n  const cpuFilteredDataset = dataset.filterTableCPU(datasetFilters, state.layers);\n\n  return set(['datasets', dataId], cpuFilteredDataset, state);\n}\n\n/**\n * Validate parsed filters with datasets and add filterProps to field\n * @type {typeof import('./filter-utils').validateFiltersUpdateDatasets}\n */\nexport function validateFiltersUpdateDatasets(state, filtersToValidate = []) {\n  const validated = [];\n  const failed = [];\n  const {datasets} = state;\n  let updatedDatasets = datasets;\n\n  // merge filters\n  filtersToValidate.forEach(filter => {\n    // we can only look for datasets define in the filter dataId\n    const datasetIds = toArray(filter.dataId);\n\n    // we can merge a filter only if all datasets in filter.dataId are loaded\n    if (datasetIds.every(d => datasets[d])) {\n      // all datasetIds in filter must be present the state datasets\n      const {filter: validatedFilter, applyToDatasets, augmentedDatasets} = datasetIds.reduce(\n        (acc, datasetId) => {\n          const dataset = updatedDatasets[datasetId];\n          const layers = state.layers.filter(l => l.config.dataId === dataset.id);\n          const {filter: updatedFilter, dataset: updatedDataset} = validateFilterWithData(\n            acc.augmentedDatasets[datasetId] || dataset,\n            filter,\n            layers\n          );\n\n          if (updatedFilter) {\n            return {\n              ...acc,\n              // merge filter props\n              filter: acc.filter\n                ? {\n                    ...acc.filter,\n                    ...mergeFilterDomainStep(acc, updatedFilter)\n                  }\n                : updatedFilter,\n\n              applyToDatasets: [...acc.applyToDatasets, datasetId],\n\n              augmentedDatasets: {\n                ...acc.augmentedDatasets,\n                [datasetId]: updatedDataset\n              }\n            };\n          }\n\n          return acc;\n        },\n        {\n          filter: null,\n          applyToDatasets: [],\n          augmentedDatasets: {}\n        }\n      );\n\n      if (validatedFilter && isEqual(datasetIds, applyToDatasets)) {\n        validated.push(validatedFilter);\n        updatedDatasets = {\n          ...updatedDatasets,\n          ...augmentedDatasets\n        };\n      }\n    } else {\n      failed.push(filter);\n    }\n  });\n\n  return {validated, failed, updatedDatasets};\n}\n\n/**\n * Retrieve interval bins for time filter\n * @type {typeof import('./filter-utils').getIntervalBins}\n */\nexport function getIntervalBins(filter) {\n  const {bins} = filter;\n  const interval = filter.plotType?.interval;\n  if (!interval || !bins || Object.keys(bins).length === 0) {\n    return null;\n  }\n  const values = Object.values(bins);\n  return values[0] ? values[0][interval] : null;\n}\n"]},"metadata":{},"sourceType":"script"}