{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, { DEFAULT_CHAR_SET, DEFAULT_FONT_FAMILY, DEFAULT_FONT_WEIGHT, DEFAULT_FONT_SIZE, DEFAULT_BUFFER, DEFAULT_RADIUS, DEFAULT_CUTOFF } from './font-atlas-manager';\nimport { transformParagraph, getTextFromBuffer } from './utils';\nvar DEFAULT_FONT_SETTINGS = {\n  fontSize: DEFAULT_FONT_SIZE,\n  buffer: DEFAULT_BUFFER,\n  sdf: false,\n  radius: DEFAULT_RADIUS,\n  cutoff: DEFAULT_CUTOFF\n};\nvar TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n};\nvar ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n};\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar DEFAULT_LINE_HEIGHT = 1.0;\nvar FONT_SETTINGS_PROPS = ['fontSize', 'buffer', 'sdf', 'radius', 'cutoff'];\nvar defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  backgroundColor: {\n    type: 'color',\n    value: null,\n    optional: true\n  },\n  characterSet: DEFAULT_CHAR_SET,\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontWeight: DEFAULT_FONT_WEIGHT,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  fontSettings: {},\n  wordBreak: 'word-break',\n  maxWidth: {\n    type: 'number',\n    value: -1\n  },\n  getText: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.text;\n    }\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 32\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getTextAnchor: {\n    type: 'accessor',\n    value: 'middle'\n  },\n  getAlignmentBaseline: {\n    type: 'accessor',\n    value: 'center'\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  }\n};\nvar TextLayer = function (_CompositeLayer) {\n  _inherits(TextLayer, _CompositeLayer);\n  function TextLayer() {\n    _classCallCheck(this, TextLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(TextLayer).apply(this, arguments));\n  }\n  _createClass(TextLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        styleVersion: 0,\n        fontAtlasManager: new FontAtlasManager(this.context.gl)\n      };\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n        oldProps = _ref.oldProps,\n        changeFlags = _ref.changeFlags;\n      var fontChanged = this._fontChanged(oldProps, props);\n      if (fontChanged) {\n        this._updateFontAtlas(oldProps, props);\n      }\n      var styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;\n      var textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);\n      if (textChanged) {\n        this._updateText();\n      }\n      if (styleChanged) {\n        this.setState({\n          styleVersion: this.state.styleVersion + 1\n        });\n      }\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      _get(_getPrototypeOf(TextLayer.prototype), \"finalizeState\", this).call(this);\n      this.state.fontAtlasManager.finalize();\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2) {\n      var info = _ref2.info;\n      return Object.assign(info, {\n        object: info.index >= 0 ? this.props.data[info.index] : null\n      });\n    }\n  }, {\n    key: \"_updateFontAtlas\",\n    value: function _updateFontAtlas(oldProps, props) {\n      var characterSet = props.characterSet,\n        fontSettings = props.fontSettings,\n        fontFamily = props.fontFamily,\n        fontWeight = props.fontWeight;\n      var fontAtlasManager = this.state.fontAtlasManager;\n      fontAtlasManager.setProps(Object.assign({}, DEFAULT_FONT_SETTINGS, fontSettings, {\n        characterSet: characterSet,\n        fontFamily: fontFamily,\n        fontWeight: fontWeight\n      }));\n      this.setNeedsRedraw(true);\n    }\n  }, {\n    key: \"_fontChanged\",\n    value: function _fontChanged(oldProps, props) {\n      if (oldProps.fontFamily !== props.fontFamily || oldProps.characterSet !== props.characterSet || oldProps.fontWeight !== props.fontWeight) {\n        return true;\n      }\n      if (oldProps.fontSettings === props.fontSettings) {\n        return false;\n      }\n      var oldFontSettings = oldProps.fontSettings || {};\n      var fontSettings = props.fontSettings || {};\n      return FONT_SETTINGS_PROPS.some(function (prop) {\n        return oldFontSettings[prop] !== fontSettings[prop];\n      });\n    }\n  }, {\n    key: \"_updateText\",\n    value: function _updateText() {\n      var data = this.props.data;\n      var textBuffer = data.attributes && data.attributes.getText;\n      var getText = this.props.getText;\n      var startIndices = data.startIndices;\n      var numInstances;\n      if (textBuffer && startIndices) {\n        var _getTextFromBuffer = getTextFromBuffer(_objectSpread({}, ArrayBuffer.isView(textBuffer) ? {\n            value: textBuffer\n          } : textBuffer, {\n            length: data.length,\n            startIndices: startIndices\n          })),\n          texts = _getTextFromBuffer.texts,\n          characterCount = _getTextFromBuffer.characterCount;\n        numInstances = characterCount;\n        getText = function getText(_, _ref3) {\n          var index = _ref3.index;\n          return texts[index];\n        };\n      } else {\n        var _createIterable = createIterable(data),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n        startIndices = [0];\n        numInstances = 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n          for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var object = _step.value;\n            objectInfo.index++;\n            var text = getText(object, objectInfo) || '';\n            numInstances += text.length;\n            startIndices.push(numInstances);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n      this.setState({\n        getText: getText,\n        startIndices: startIndices,\n        numInstances: numInstances\n      });\n    }\n  }, {\n    key: \"getIconOffsets\",\n    value: function getIconOffsets(object, objectInfo) {\n      var iconMapping = this.state.fontAtlasManager.mapping;\n      var getText = this.state.getText;\n      var _this$props = this.props,\n        wordBreak = _this$props.wordBreak,\n        maxWidth = _this$props.maxWidth,\n        lineHeight = _this$props.lineHeight,\n        getTextAnchor = _this$props.getTextAnchor,\n        getAlignmentBaseline = _this$props.getAlignmentBaseline;\n      var paragraph = getText(object, objectInfo) || '';\n      var _transformParagraph = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping),\n        characters = _transformParagraph.characters,\n        _transformParagraph$s = _slicedToArray(_transformParagraph.size, 2),\n        width = _transformParagraph$s[0],\n        height = _transformParagraph$s[1];\n      var anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      var anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      var offsets = new Array(paragraph.length * 2);\n      var index = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        for (var _iterator2 = characters[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = _step2.value,\n            rowWidth = _step2$value.rowWidth,\n            x = _step2$value.x,\n            y = _step2$value.y;\n          var rowOffset = (1 - anchorX) * (width - rowWidth) / 2;\n          offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x;\n          offsets[index++] = (anchorY - 1) * height / 2 + y;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n      return offsets;\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$state = this.state,\n        startIndices = _this$state.startIndices,\n        numInstances = _this$state.numInstances,\n        getText = _this$state.getText,\n        _this$state$fontAtlas = _this$state.fontAtlasManager,\n        scale = _this$state$fontAtlas.scale,\n        texture = _this$state$fontAtlas.texture,\n        mapping = _this$state$fontAtlas.mapping,\n        styleVersion = _this$state.styleVersion;\n      var _this$props2 = this.props,\n        data = _this$props2.data,\n        _dataDiff = _this$props2._dataDiff,\n        backgroundColor = _this$props2.backgroundColor,\n        getPosition = _this$props2.getPosition,\n        getColor = _this$props2.getColor,\n        getSize = _this$props2.getSize,\n        getAngle = _this$props2.getAngle,\n        getPixelOffset = _this$props2.getPixelOffset,\n        billboard = _this$props2.billboard,\n        sdf = _this$props2.sdf,\n        sizeScale = _this$props2.sizeScale,\n        sizeUnits = _this$props2.sizeUnits,\n        sizeMinPixels = _this$props2.sizeMinPixels,\n        sizeMaxPixels = _this$props2.sizeMaxPixels,\n        transitions = _this$props2.transitions,\n        updateTriggers = _this$props2.updateTriggers;\n      var getIconOffsets = this.getIconOffsets.bind(this);\n      var SubLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n      return new SubLayerClass({\n        sdf: sdf,\n        iconAtlas: texture,\n        iconMapping: mapping,\n        backgroundColor: backgroundColor,\n        getPosition: getPosition,\n        getColor: getColor,\n        getSize: getSize,\n        getAngle: getAngle,\n        getPixelOffset: getPixelOffset,\n        billboard: billboard,\n        sizeScale: sizeScale * scale,\n        sizeUnits: sizeUnits,\n        sizeMinPixels: sizeMinPixels * scale,\n        sizeMaxPixels: sizeMaxPixels * scale,\n        transitions: transitions && {\n          getPosition: transitions.getPosition,\n          getAngle: transitions.getAngle,\n          getColor: transitions.getColor,\n          getSize: transitions.getSize,\n          getPixelOffset: updateTriggers.getPixelOffset\n        }\n      }, this.getSubLayerProps({\n        id: 'characters',\n        updateTriggers: {\n          getPosition: updateTriggers.getPosition,\n          getAngle: updateTriggers.getAngle,\n          getColor: updateTriggers.getColor,\n          getSize: updateTriggers.getSize,\n          getPixelOffset: updateTriggers.getPixelOffset,\n          getIconOffsets: {\n            getText: updateTriggers.getText,\n            getTextAnchor: updateTriggers.getTextAnchor,\n            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n            styleVersion: styleVersion\n          }\n        }\n      }), {\n        data: data,\n        _dataDiff: _dataDiff,\n        startIndices: startIndices,\n        numInstances: numInstances,\n        getIconOffsets: getIconOffsets,\n        getIcon: getText\n      });\n    }\n  }]);\n  return TextLayer;\n}(CompositeLayer);\nexport { TextLayer as default };\nTextLayer.layerName = 'TextLayer';\nTextLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/text-layer/text-layer.js"],"names":["CompositeLayer","createIterable","MultiIconLayer","FontAtlasManager","DEFAULT_CHAR_SET","DEFAULT_FONT_FAMILY","DEFAULT_FONT_WEIGHT","DEFAULT_FONT_SIZE","DEFAULT_BUFFER","DEFAULT_RADIUS","DEFAULT_CUTOFF","transformParagraph","getTextFromBuffer","DEFAULT_FONT_SETTINGS","fontSize","buffer","sdf","radius","cutoff","TEXT_ANCHOR","start","middle","end","ALIGNMENT_BASELINE","top","center","bottom","DEFAULT_COLOR","DEFAULT_LINE_HEIGHT","FONT_SETTINGS_PROPS","defaultProps","billboard","sizeScale","sizeUnits","sizeMinPixels","sizeMaxPixels","Number","MAX_SAFE_INTEGER","backgroundColor","type","value","optional","characterSet","fontFamily","fontWeight","lineHeight","fontSettings","wordBreak","maxWidth","getText","x","text","getPosition","position","getColor","getSize","getAngle","getTextAnchor","getAlignmentBaseline","getPixelOffset","TextLayer","state","styleVersion","fontAtlasManager","context","gl","props","oldProps","changeFlags","fontChanged","_fontChanged","_updateFontAtlas","styleChanged","textChanged","dataChanged","updateTriggersChanged","all","_updateText","setState","finalize","info","assign","object","index","data","setProps","setNeedsRedraw","oldFontSettings","some","prop","textBuffer","attributes","startIndices","numInstances","texts","characterCount","isView","length","_","iterable","objectInfo","push","iconMapping","mapping","paragraph","characters","size","width","height","anchorX","anchorY","offsets","Array","rowWidth","y","rowOffset","scale","texture","_dataDiff","transitions","updateTriggers","getIconOffsets","bind","SubLayerClass","getSubLayerClass","iconAtlas","getSubLayerProps","id","getIcon","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, createIterable} from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, {\n  DEFAULT_CHAR_SET,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_WEIGHT,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_BUFFER,\n  DEFAULT_RADIUS,\n  DEFAULT_CUTOFF\n} from './font-atlas-manager';\nimport {transformParagraph, getTextFromBuffer} from './utils';\n\nconst DEFAULT_FONT_SETTINGS = {\n  fontSize: DEFAULT_FONT_SIZE,\n  buffer: DEFAULT_BUFFER,\n  sdf: false,\n  radius: DEFAULT_RADIUS,\n  cutoff: DEFAULT_CUTOFF\n};\n\nconst TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n};\n\nconst ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n};\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst DEFAULT_LINE_HEIGHT = 1.0;\n\nconst FONT_SETTINGS_PROPS = ['fontSize', 'buffer', 'sdf', 'radius', 'cutoff'];\n\nconst defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  backgroundColor: {type: 'color', value: null, optional: true},\n\n  characterSet: DEFAULT_CHAR_SET,\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontWeight: DEFAULT_FONT_WEIGHT,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  fontSettings: {},\n\n  // auto wrapping options\n  wordBreak: 'word-break',\n  maxWidth: {type: 'number', value: -1},\n\n  getText: {type: 'accessor', value: x => x.text},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 32},\n  getAngle: {type: 'accessor', value: 0},\n  getTextAnchor: {type: 'accessor', value: 'middle'},\n  getAlignmentBaseline: {type: 'accessor', value: 'center'},\n  getPixelOffset: {type: 'accessor', value: [0, 0]}\n};\n\nexport default class TextLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      styleVersion: 0,\n      fontAtlasManager: new FontAtlasManager(this.context.gl)\n    };\n  }\n\n  // eslint-disable-next-line complexity\n  updateState({props, oldProps, changeFlags}) {\n    const fontChanged = this._fontChanged(oldProps, props);\n\n    if (fontChanged) {\n      this._updateFontAtlas(oldProps, props);\n    }\n\n    const styleChanged =\n      fontChanged ||\n      props.lineHeight !== oldProps.lineHeight ||\n      props.wordBreak !== oldProps.wordBreak ||\n      props.maxWidth !== oldProps.maxWidth;\n\n    const textChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText));\n\n    if (textChanged) {\n      this._updateText();\n    }\n    if (styleChanged) {\n      this.setState({\n        styleVersion: this.state.styleVersion + 1\n      });\n    }\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    // Release resources held by the font atlas manager\n    this.state.fontAtlasManager.finalize();\n  }\n\n  getPickingInfo({info}) {\n    // because `TextLayer` assign the same pickingInfoIndex for one text label,\n    // here info.index refers the index of text label in props.data\n    return Object.assign(info, {\n      // override object with original data\n      object: info.index >= 0 ? this.props.data[info.index] : null\n    });\n  }\n\n  _updateFontAtlas(oldProps, props) {\n    const {characterSet, fontSettings, fontFamily, fontWeight} = props;\n\n    // generate test characterSet\n    const {fontAtlasManager} = this.state;\n    fontAtlasManager.setProps(\n      Object.assign({}, DEFAULT_FONT_SETTINGS, fontSettings, {\n        characterSet,\n        fontFamily,\n        fontWeight\n      })\n    );\n\n    this.setNeedsRedraw(true);\n  }\n\n  _fontChanged(oldProps, props) {\n    if (\n      oldProps.fontFamily !== props.fontFamily ||\n      oldProps.characterSet !== props.characterSet ||\n      oldProps.fontWeight !== props.fontWeight\n    ) {\n      return true;\n    }\n\n    if (oldProps.fontSettings === props.fontSettings) {\n      return false;\n    }\n\n    const oldFontSettings = oldProps.fontSettings || {};\n    const fontSettings = props.fontSettings || {};\n\n    return FONT_SETTINGS_PROPS.some(prop => oldFontSettings[prop] !== fontSettings[prop]);\n  }\n\n  // Text strings are variable width objects\n  // Returns the index at the start of each string (every character is rendered by one instance)\n  _updateText() {\n    const {data} = this.props;\n    const textBuffer = data.attributes && data.attributes.getText;\n    let {getText} = this.props;\n    let {startIndices} = data;\n    let numInstances;\n\n    if (textBuffer && startIndices) {\n      const {texts, characterCount} = getTextFromBuffer({\n        ...(ArrayBuffer.isView(textBuffer) ? {value: textBuffer} : textBuffer),\n        length: data.length,\n        startIndices\n      });\n      numInstances = characterCount;\n      getText = (_, {index}) => texts[index];\n    } else {\n      const {iterable, objectInfo} = createIterable(data);\n      startIndices = [0];\n      numInstances = 0;\n\n      for (const object of iterable) {\n        objectInfo.index++;\n        const text = getText(object, objectInfo) || '';\n        numInstances += text.length;\n        startIndices.push(numInstances);\n      }\n    }\n\n    this.setState({getText, startIndices, numInstances});\n  }\n\n  // Returns the x, y offsets of each character in a text string\n  getIconOffsets(object, objectInfo) {\n    const iconMapping = this.state.fontAtlasManager.mapping;\n    const {getText} = this.state;\n    const {wordBreak, maxWidth, lineHeight, getTextAnchor, getAlignmentBaseline} = this.props;\n\n    const paragraph = getText(object, objectInfo) || '';\n    const {\n      characters,\n      size: [width, height]\n    } = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);\n    const anchorX =\n      TEXT_ANCHOR[\n        typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor\n      ];\n    const anchorY =\n      ALIGNMENT_BASELINE[\n        typeof getAlignmentBaseline === 'function'\n          ? getAlignmentBaseline(object, objectInfo)\n          : getAlignmentBaseline\n      ];\n\n    const offsets = new Array(paragraph.length * 2);\n    let index = 0;\n\n    for (const {rowWidth, x, y} of characters) {\n      // For a multi-line object, offset in x-direction needs consider\n      // the row offset in the paragraph and the object offset in the row\n      const rowOffset = ((1 - anchorX) * (width - rowWidth)) / 2;\n      offsets[index++] = ((anchorX - 1) * width) / 2 + rowOffset + x;\n      offsets[index++] = ((anchorY - 1) * height) / 2 + y;\n    }\n    return offsets;\n  }\n\n  renderLayers() {\n    const {\n      startIndices,\n      numInstances,\n      getText,\n      fontAtlasManager: {scale, texture, mapping},\n      styleVersion\n    } = this.state;\n\n    const {\n      data,\n      _dataDiff,\n      backgroundColor,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      billboard,\n      sdf,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    const getIconOffsets = this.getIconOffsets.bind(this);\n\n    const SubLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n\n    return new SubLayerClass(\n      {\n        sdf,\n        iconAtlas: texture,\n        iconMapping: mapping,\n        backgroundColor,\n\n        getPosition,\n        getColor,\n        getSize,\n        getAngle,\n        getPixelOffset,\n\n        billboard,\n        sizeScale: sizeScale * scale,\n        sizeUnits,\n        sizeMinPixels: sizeMinPixels * scale,\n        sizeMaxPixels: sizeMaxPixels * scale,\n\n        transitions: transitions && {\n          getPosition: transitions.getPosition,\n          getAngle: transitions.getAngle,\n          getColor: transitions.getColor,\n          getSize: transitions.getSize,\n          getPixelOffset: updateTriggers.getPixelOffset\n        }\n      },\n      this.getSubLayerProps({\n        id: 'characters',\n        updateTriggers: {\n          getPosition: updateTriggers.getPosition,\n          getAngle: updateTriggers.getAngle,\n          getColor: updateTriggers.getColor,\n          getSize: updateTriggers.getSize,\n          getPixelOffset: updateTriggers.getPixelOffset,\n          getIconOffsets: {\n            getText: updateTriggers.getText,\n            getTextAnchor: updateTriggers.getTextAnchor,\n            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n            styleVersion\n          }\n        }\n      }),\n      {\n        data,\n        _dataDiff,\n        startIndices,\n        numInstances,\n        getIconOffsets,\n        getIcon: getText\n      }\n    );\n  }\n}\n\nTextLayer.layerName = 'TextLayer';\nTextLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}