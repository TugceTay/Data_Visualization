{"ast":null,"code":"import { padArray } from '../../utils/array-utils';\nvar DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: function easing(t) {\n      return t;\n    }\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\nexport function normalizeTransitionSettings(userSettings, layerSettings) {\n  if (!userSettings) {\n    return null;\n  }\n  if (Number.isFinite(userSettings)) {\n    userSettings = {\n      duration: userSettings\n    };\n  }\n  userSettings.type = userSettings.type || 'interpolation';\n  return Object.assign({}, DEFAULT_TRANSITION_SETTINGS[userSettings.type], layerSettings, userSettings);\n}\nexport function getSourceBufferAttribute(gl, attribute) {\n  var buffer = attribute.getBuffer();\n  if (buffer) {\n    return [attribute.getBuffer(), {\n      divisor: 0,\n      size: attribute.size,\n      normalized: attribute.settings.normalized\n    }];\n  }\n  return attribute.value;\n}\nexport function getAttributeTypeFromSize(size) {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(\"No defined attribute type for size \\\"\".concat(size, \"\\\"\"));\n  }\n}\nexport function cycleBuffers(buffers) {\n  buffers.push(buffers.shift());\n}\nexport function getAttributeBufferLength(attribute, numInstances) {\n  var doublePrecision = attribute.doublePrecision,\n    settings = attribute.settings,\n    value = attribute.value,\n    size = attribute.size;\n  var multiplier = doublePrecision ? 2 : 1;\n  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;\n}\nexport function padBuffer(_ref) {\n  var buffer = _ref.buffer,\n    numInstances = _ref.numInstances,\n    attribute = _ref.attribute,\n    fromLength = _ref.fromLength,\n    fromStartIndices = _ref.fromStartIndices,\n    _ref$getData = _ref.getData,\n    getData = _ref$getData === void 0 ? function (x) {\n      return x;\n    } : _ref$getData;\n  var precisionMultiplier = attribute.doublePrecision ? 2 : 1;\n  var size = attribute.size * precisionMultiplier;\n  var byteOffset = attribute.byteOffset;\n  var toStartIndices = attribute.startIndices;\n  var hasStartIndices = fromStartIndices && toStartIndices;\n  var toLength = getAttributeBufferLength(attribute, numInstances);\n  var isConstant = attribute.state.constant;\n  if (!hasStartIndices && fromLength >= toLength) {\n    return;\n  }\n  var toData = isConstant ? attribute.value : attribute.getBuffer().getData({\n    srcByteOffset: byteOffset\n  });\n  if (attribute.settings.normalized && !isConstant) {\n    var getter = getData;\n    getData = function getData(value, chunk) {\n      return attribute._normalizeConstant(getter(value, chunk));\n    };\n  }\n  var getMissingData = isConstant ? function (i, chunk) {\n    return getData(toData, chunk);\n  } : function (i, chunk) {\n    return getData(toData.subarray(i, i + size), chunk);\n  };\n  var source = buffer.getData({\n    length: fromLength\n  });\n  var data = new Float32Array(toLength);\n  padArray({\n    source: source,\n    target: data,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size: size,\n    getData: getMissingData\n  });\n  if (buffer.byteLength < data.byteLength + byteOffset) {\n    buffer.reallocate(data.byteLength + byteOffset);\n  }\n  buffer.subData({\n    data: data,\n    offset: byteOffset\n  });\n}","map":{"version":3,"sources":["../../../../src/lib/attribute/attribute-transition-utils.js"],"names":["padArray","DEFAULT_TRANSITION_SETTINGS","interpolation","duration","easing","t","spring","stiffness","damping","normalizeTransitionSettings","userSettings","layerSettings","Number","isFinite","type","Object","assign","getSourceBufferAttribute","gl","attribute","buffer","getBuffer","divisor","size","normalized","settings","value","getAttributeTypeFromSize","Error","cycleBuffers","buffers","push","shift","getAttributeBufferLength","numInstances","doublePrecision","multiplier","noAlloc","length","padBuffer","fromLength","fromStartIndices","getData","x","precisionMultiplier","byteOffset","toStartIndices","startIndices","hasStartIndices","toLength","isConstant","state","constant","toData","srcByteOffset","getter","chunk","_normalizeConstant","getMissingData","i","subarray","source","data","Float32Array","target","sourceStartIndices","targetStartIndices","byteLength","reallocate","subData","offset"],"mappings":"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","sourcesContent":["import {padArray} from '../../utils/array-utils';\n\nconst DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: t => t\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\n\nexport function normalizeTransitionSettings(userSettings, layerSettings) {\n  if (!userSettings) {\n    return null;\n  }\n  if (Number.isFinite(userSettings)) {\n    userSettings = {duration: userSettings};\n  }\n  userSettings.type = userSettings.type || 'interpolation';\n  return Object.assign(\n    {},\n    DEFAULT_TRANSITION_SETTINGS[userSettings.type],\n    layerSettings,\n    userSettings\n  );\n}\n\n// NOTE: NOT COPYING OVER OFFSET OR STRIDE HERE BECAUSE:\n// (1) WE DON'T SUPPORT INTERLEAVED BUFFERS FOR TRANSITIONS\n// (2) BUFFERS WITH OFFSETS ALWAYS CONTAIN VALUES OF THE SAME SIZE\n// (3) THE OPERATIONS IN THE SHADER ARE PER-COMPONENT (addition and scaling)\nexport function getSourceBufferAttribute(gl, attribute) {\n  // The Attribute we pass to Transform as a sourceBuffer must have {divisor: 0}\n  // so we create a copy of the attribute (with divisor=0) to use when running\n  // transform feedback\n  const buffer = attribute.getBuffer();\n  if (buffer) {\n    return [\n      attribute.getBuffer(),\n      {\n        divisor: 0,\n        size: attribute.size,\n        normalized: attribute.settings.normalized\n      }\n    ];\n  }\n  // constant\n  // don't pass normalized here because the `value` from a normalized attribute is\n  // already normalized\n  return attribute.value;\n}\n\nexport function getAttributeTypeFromSize(size) {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`No defined attribute type for size \"${size}\"`);\n  }\n}\n\nexport function cycleBuffers(buffers) {\n  buffers.push(buffers.shift());\n}\n\nexport function getAttributeBufferLength(attribute, numInstances) {\n  const {doublePrecision, settings, value, size} = attribute;\n  const multiplier = doublePrecision ? 2 : 1;\n  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;\n}\n\n// This helper is used when transitioning attributes from a set of values in one buffer layout\n// to a set of values in a different buffer layout. (Buffer layouts are used when attribute values\n// within a buffer should be grouped for drawElements, like the Polygon layer.) For example, a\n// buffer layout of [3, 4] might have data [A1, A2, A3, B1, B2, B3, B4]. If it needs to transition\n// to a buffer layout of [4, 2], it should produce a buffer, using the transition setting's `enter`\n// function, that looks like this: [A1, A2, A3, A4 (user `enter` fn), B1, B2, 0]. Note: the final\n// 0 in this buffer is because we never shrink buffers, only grow them, for performance reasons.\nexport function padBuffer({\n  buffer,\n  numInstances,\n  attribute,\n  fromLength,\n  fromStartIndices,\n  getData = x => x\n}) {\n  // TODO: move the precisionMultiplier logic to the attribute when retrieving\n  // its `size` and `elementOffset`?\n  const precisionMultiplier = attribute.doublePrecision ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const toLength = getAttributeBufferLength(attribute, numInstances);\n  const isConstant = attribute.state.constant;\n\n  // check if buffer needs to be padded\n  if (!hasStartIndices && fromLength >= toLength) {\n    return;\n  }\n\n  const toData = isConstant\n    ? attribute.value\n    : attribute.getBuffer().getData({srcByteOffset: byteOffset});\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n    getData = (value, chunk) => attribute._normalizeConstant(getter(value, chunk));\n  }\n\n  const getMissingData = isConstant\n    ? (i, chunk) => getData(toData, chunk)\n    : (i, chunk) => getData(toData.subarray(i, i + size), chunk);\n\n  const source = buffer.getData({length: fromLength});\n  const data = new Float32Array(toLength);\n  padArray({\n    source,\n    target: data,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n\n  // TODO: support offset in buffer.setData?\n  if (buffer.byteLength < data.byteLength + byteOffset) {\n    buffer.reallocate(data.byteLength + byteOffset);\n  }\n  buffer.subData({data, offset: byteOffset});\n}\n"]},"metadata":{},"sourceType":"module"}