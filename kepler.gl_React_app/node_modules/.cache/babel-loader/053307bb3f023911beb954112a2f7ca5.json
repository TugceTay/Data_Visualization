{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nvar _marked = _regeneratorRuntime.mark(makeStringIterator);\nexport function makeStringIterator(string) {\n  var options,\n    _options$chunkSize,\n    chunkSize,\n    offset,\n    textEncoder,\n    chunkLength,\n    chunk,\n    _args = arguments;\n  return _regeneratorRuntime.wrap(function makeStringIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? 256 * 1024 : _options$chunkSize;\n          offset = 0;\n          textEncoder = new TextEncoder();\n        case 4:\n          if (!(offset < string.length)) {\n            _context.next = 12;\n            break;\n          }\n          chunkLength = Math.min(string.length - offset, chunkSize);\n          chunk = string.slice(offset, offset + chunkLength);\n          offset += chunkLength;\n          _context.next = 10;\n          return textEncoder.encode(chunk);\n        case 10:\n          _context.next = 4;\n          break;\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}","map":{"version":3,"sources":["../../../../src/iterator-utils/make-iterator/string-iterator.js"],"names":["makeStringIterator","string","options","chunkSize","offset","textEncoder","TextEncoder","length","chunkLength","Math","min","chunk","slice","encode"],"mappings":";uCAKiBA,kB;AAAjB,OAAO,SAAUA,kBAAV,CAA6BC,MAA7B,EAAA;EAAA,IAAA,OAAA;IAAA,kBAAA;IAAA,SAAA;IAAA,MAAA;IAAA,WAAA;IAAA,WAAA;IAAA,KAAA;IAAA,KAAA,GAAA,SAAA;EAAA,OAAA,mBAAA,CAAA,IAAA,CAAA,SAAA,mBAAA,CAAA,QAAA,EAAA;IAAA,OAAA,CAAA,EAAA;MAAA,QAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;QAAA,KAAA,CAAA;UAAqCC,OAArC,GAAA,KAAA,CAAA,MAAA,GAAA,CAAA,IAAA,KAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,KAAA,CAAA,CAAA,CAAA,GAA+C,CAAA,CAA/C;UAAA,kBAAA,GAC4BA,OAD5B,CACEC,SADF,EACEA,SADF,GAAA,kBAAA,KAAA,KAAA,CAAA,GACc,GAAA,GAAM,IADpB,GAAA,kBAAA;UAGDC,MAHC,GAGQ,CAHR;UAICC,WAJD,GAIe,IAAIC,WAAJ,EAJf;QAAA,KAAA,CAAA;UAAA,IAAA,EAKEF,MAAM,GAAGH,MAAM,CAACM,MALlB,CAAA,EAAA;YAAA,QAAA,CAAA,IAAA,GAAA,EAAA;YAAA;UAAA;UAOGC,WAPH,GAOiBC,IAAI,CAACC,GAALD,CAASR,MAAM,CAACM,MAAPN,GAAgBG,MAAzBK,EAAiCN,SAAjCM,CAPjB;UAQGE,KARH,GAQWV,MAAM,CAACW,KAAPX,CAAaG,MAAbH,EAAqBG,MAAM,GAAGI,WAA9BP,CARX;UASHG,MAAM,IAAII,WAAVJ;UATG,QAAA,CAAA,IAAA,GAAA,EAAA;UAYH,OAAMC,WAAW,CAACQ,MAAZR,CAAmBM,KAAnBN,CAAN;QAZG,KAAA,EAAA;UAAA,QAAA,CAAA,IAAA,GAAA,CAAA;UAAA;QAAA,KAAA,EAAA;QAAA,KAAA,KAAA;UAAA,OAAA,QAAA,CAAA,IAAA,EAAA;MAAA;IAAA;EAAA,CAAA,EAAA,OAAA,CAAA;AAAA","sourcesContent":["/* global TextEncoder */\n\n/**\n * Returns an iterator that breaks a big string into chunks and yields them one-by-one\n */\nexport function* makeStringIterator(string, options = {}) {\n  const {chunkSize = 256 * 1024} = options;\n\n  let offset = 0;\n  const textEncoder = new TextEncoder();\n  while (offset < string.length) {\n    // Create a chunk of the right size\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n\n    // yield an ArrayBuffer chunk\n    yield textEncoder.encode(chunk);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}