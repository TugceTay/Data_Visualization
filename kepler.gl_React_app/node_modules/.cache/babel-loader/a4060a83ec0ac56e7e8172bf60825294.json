{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport DoublyLinkedList from '../utils/doubly-linked-list';\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\nvar TilesetCache = function () {\n  function TilesetCache() {\n    _classCallCheck(this, TilesetCache);\n    this._list = new DoublyLinkedList();\n    this._sentinel = this._list.add('sentinel');\n    this._trimTiles = false;\n  }\n  _createClass(TilesetCache, [{\n    key: \"reset\",\n    value: function reset() {\n      this._list.splice(this._list.tail, this._sentinel);\n    }\n  }, {\n    key: \"touch\",\n    value: function touch(tile) {\n      var node = tile._cacheNode;\n      if (defined(node)) {\n        this._list.splice(this._sentinel, node);\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(tileset, tile, addCallback) {\n      if (!defined(tile._cacheNode)) {\n        tile._cacheNode = this._list.add(tile);\n        if (addCallback) {\n          addCallback(tileset, tile);\n        }\n      }\n    }\n  }, {\n    key: \"unloadTile\",\n    value: function unloadTile(tileset, tile, unloadCallback) {\n      var node = tile._cacheNode;\n      if (!defined(node)) {\n        return;\n      }\n      this._list.remove(node);\n      tile._cacheNode = undefined;\n      if (unloadCallback) {\n        unloadCallback(tileset, tile);\n      }\n    }\n  }, {\n    key: \"unloadTiles\",\n    value: function unloadTiles(tileset, unloadCallback) {\n      var trimTiles = this._trimTiles;\n      this._trimTiles = false;\n      var list = this._list;\n      var maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;\n      var sentinel = this._sentinel;\n      var node = list.head;\n      while (node !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {\n        var tile = node.item;\n        node = node.next;\n        this.unloadTile(tileset, tile, unloadCallback);\n      }\n    }\n  }, {\n    key: \"trim\",\n    value: function trim() {\n      this._trimTiles = true;\n    }\n  }]);\n  return TilesetCache;\n}();\nexport { TilesetCache as default };","map":{"version":3,"sources":["../../../src/tileset/tileset-cache.js"],"names":["DoublyLinkedList","defined","x","undefined","TilesetCache","_list","_sentinel","add","_trimTiles","splice","tail","tile","node","_cacheNode","tileset","addCallback","unloadCallback","remove","trimTiles","list","maximumMemoryUsageInBytes","maximumMemoryUsage","sentinel","head","gpuMemoryUsageInBytes","item","next","unloadTile"],"mappings":";;AAGA,OAAOA,gBAAP,MAA6B,6BAA7B;AAEA,SAASC,OAAT,CAAiBC,CAAjB,EAAoB;EAClB,OAAOA,CAAC,KAAKC,SAAND,IAAmBA,CAAC,KAAK,IAAhC;AACD;IAOoBE,Y;EACnB,SAAA,YAAA,GAAc;IAAA,eAAA,CAAA,IAAA,EAAA,YAAA,CAAA;IAGZ,IAAA,CAAKC,KAAL,GAAa,IAAIL,gBAAJ,EAAb;IACA,IAAA,CAAKM,SAAL,GAAiB,IAAA,CAAKD,KAAL,CAAWE,GAAX,CAAe,UAAf,CAAjB;IACA,IAAA,CAAKC,UAAL,GAAkB,KAAlB;EACD;;;4BAEO;MAIN,IAAA,CAAKH,KAAL,CAAWI,MAAX,CAAkB,IAAA,CAAKJ,KAAL,CAAWK,IAA7B,EAAmC,IAAA,CAAKJ,SAAxC,CAAA;IACD;;;0BAEKK,I,EAAM;MACV,IAAMC,IAAI,GAAGD,IAAI,CAACE,UAAlB;MACA,IAAIZ,OAAO,CAACW,IAAD,CAAX,EAAmB;QACjB,IAAA,CAAKP,KAAL,CAAWI,MAAX,CAAkB,IAAA,CAAKH,SAAvB,EAAkCM,IAAlC,CAAA;MACD;IACF;;;wBAEGE,O,EAASH,I,EAAMI,W,EAAa;MAC9B,IAAI,CAACd,OAAO,CAACU,IAAI,CAACE,UAAN,CAAZ,EAA+B;QAC7BF,IAAI,CAACE,UAALF,GAAkB,IAAA,CAAKN,KAAL,CAAWE,GAAX,CAAeI,IAAf,CAAlBA;QAEA,IAAII,WAAJ,EAAiB;UACfA,WAAW,CAACD,OAAD,EAAUH,IAAV,CAAXI;QACD;MACF;IACF;;;+BAEUD,O,EAASH,I,EAAMK,c,EAAgB;MACxC,IAAMJ,IAAI,GAAGD,IAAI,CAACE,UAAlB;MACA,IAAI,CAACZ,OAAO,CAACW,IAAD,CAAZ,EAAoB;QAClB;MACD;MAED,IAAA,CAAKP,KAAL,CAAWY,MAAX,CAAkBL,IAAlB,CAAA;MACAD,IAAI,CAACE,UAALF,GAAkBR,SAAlBQ;MACA,IAAIK,cAAJ,EAAoB;QAClBA,cAAc,CAACF,OAAD,EAAUH,IAAV,CAAdK;MACD;IACF;;;gCAEWF,O,EAASE,c,EAAgB;MACnC,IAAME,SAAS,GAAG,IAAA,CAAKV,UAAvB;MACA,IAAA,CAAKA,UAAL,GAAkB,KAAlB;MAEA,IAAMW,IAAI,GAAG,IAAA,CAAKd,KAAlB;MAEA,IAAMe,yBAAyB,GAAGN,OAAO,CAACO,kBAARP,GAA6B,IAA7BA,GAAoC,IAAtE;MAKA,IAAMQ,QAAQ,GAAG,IAAA,CAAKhB,SAAtB;MACA,IAAIM,IAAI,GAAGO,IAAI,CAACI,IAAhB;MAEA,OACEX,IAAI,KAAKU,QAATV,KACCE,OAAO,CAACU,qBAARV,GAAgCM,yBAAhCN,IAA6DI,SAD9DN,CADF,EAGE;QACA,IAAMD,IAAI,GAAGC,IAAI,CAACa,IAAlB;QACAb,IAAI,GAAGA,IAAI,CAACc,IAAZd;QACA,IAAA,CAAKe,UAAL,CAAgBb,OAAhB,EAAyBH,IAAzB,EAA+BK,cAA/B,CAAA;MACD;IACF;;;2BAEM;MACL,IAAA,CAAKR,UAAL,GAAkB,IAAlB;IACD;;;;SAxEkBJ,Y","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport DoublyLinkedList from '../utils/doubly-linked-list';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n/**\n * Stores tiles with content loaded.\n *\n * @private\n */\nexport default class TilesetCache {\n  constructor() {\n    // [head, sentinel) -> tiles that weren't selected this frame and may be removed from the cache\n    // (sentinel, tail] -> tiles that were selected this frame\n    this._list = new DoublyLinkedList();\n    this._sentinel = this._list.add('sentinel');\n    this._trimTiles = false;\n  }\n\n  reset() {\n    // Move sentinel node to the tail so, at the start of the frame, all tiles\n    // may be potentially replaced.  Tiles are moved to the right of the sentinel\n    // when they are selected so they will not be replaced.\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n\n  touch(tile) {\n    const node = tile._cacheNode;\n    if (defined(node)) {\n      this._list.splice(this._sentinel, node);\n    }\n  }\n\n  add(tileset, tile, addCallback) {\n    if (!defined(tile._cacheNode)) {\n      tile._cacheNode = this._list.add(tile);\n\n      if (addCallback) {\n        addCallback(tileset, tile);\n      }\n    }\n  }\n\n  unloadTile(tileset, tile, unloadCallback) {\n    const node = tile._cacheNode;\n    if (!defined(node)) {\n      return;\n    }\n\n    this._list.remove(node);\n    tile._cacheNode = undefined;\n    if (unloadCallback) {\n      unloadCallback(tileset, tile);\n    }\n  }\n\n  unloadTiles(tileset, unloadCallback) {\n    const trimTiles = this._trimTiles;\n    this._trimTiles = false;\n\n    const list = this._list;\n\n    const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;\n\n    // Traverse the list only to the sentinel since tiles/nodes to the\n    // right of the sentinel were used this frame.\n    // The sub-list to the left of the sentinel is ordered from LRU to MRU.\n    const sentinel = this._sentinel;\n    let node = list.head;\n\n    while (\n      node !== sentinel &&\n      (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)\n    ) {\n      const tile = node.item;\n      node = node.next;\n      this.unloadTile(tileset, tile, unloadCallback);\n    }\n  }\n\n  trim() {\n    this._trimTiles = true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}