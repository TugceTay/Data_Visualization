{"ast":null,"code":"import _readOnlyError from \"@babel/runtime/helpers/esm/readOnlyError\";\nvar defined = function defined(x) {\n  return x !== undefined;\n};\nexport function initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!jsonHeader) {\n    return null;\n  }\n  var hierarchy = batchTable.getExtension('3DTILES_batch_table_hierarchy');\n  var legacyHierarchy = jsonHeader.HIERARCHY;\n  if (legacyHierarchy) {\n    console.warn('3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.');\n    jsonHeader.extensions = jsonHeader.extensions || {};\n    jsonHeader.extensions['3DTILES_batch_table_hierarchy'] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n  if (!hierarchy) {\n    return null;\n  }\n  return initializeHierarchyValues(hierarchy, binaryBody);\n}\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n  var i;\n  var classId;\n  var binaryAccessor;\n  var instancesLength = hierarchyJson.instancesLength;\n  var classes = hierarchyJson.classes;\n  var classIds = hierarchyJson.classIds;\n  var parentCounts = hierarchyJson.parentCounts;\n  var parentIds = hierarchyJson.parentIds;\n  var parentIdsLength = instancesLength;\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = (_readOnlyError(\"classIds\"), binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength));\n  }\n  var parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = (_readOnlyError(\"parentCounts\"), binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength));\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = (_readOnlyError(\"parentIdsLength\"), 0);\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += (_readOnlyError(\"parentIdsLength\"), parentCounts[i]);\n    }\n  }\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = (_readOnlyError(\"parentIds\"), binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength));\n  }\n  var classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    var classInstancesLength = classes[i].length;\n    var properties = classes[i].instances;\n    var binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n  var classCounts = new Array(classesLength).fill(0);\n  var classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n  var hierarchy = {\n    classes: classes,\n    classIds: classIds,\n    classIndexes: classIndexes,\n    parentCounts: parentCounts,\n    parentIndexes: parentIndexes,\n    parentIds: parentIds\n  };\n  validateHierarchy(hierarchy);\n  return hierarchy;\n}\nexport function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  if (!hierarchy) {\n    return;\n  }\n  var parentCounts = hierarchy.parentCounts;\n  var parentIds = hierarchy.parentIds;\n  if (parentIds) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  }\n  if (parentCounts > 0) {\n    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n  }\n  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n  var classIds = hierarchy.classIds;\n  var parentCounts = hierarchy.parentCounts;\n  var parentIds = hierarchy.parentIds;\n  var parentIndexes = hierarchy.parentIndexes;\n  var instancesLength = classIds.length;\n  var visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  var visitedMarker = ++marker;\n  var stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    var result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      return result;\n    }\n    var parentCount = parentCounts[instanceIndex];\n    var parentIndex = parentIndexes[instanceIndex];\n    for (var i = 0; i < parentCount; ++i) {\n      var parentId = parentIds[parentIndex + i];\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n  return null;\n}\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n  var hasParent = true;\n  while (hasParent) {\n    var result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      return result;\n    }\n    var parentId = hierarchy.parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n  throw new Error('traverseHierarchySingleParent');\n}\nfunction validateHierarchy(hierarchy) {\n  var scratchValidateStack = [];\n  var classIds = hierarchy.classIds;\n  var instancesLength = classIds.length;\n  for (var i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  var parentCounts = hierarchy.parentCounts;\n  var parentIds = hierarchy.parentIds;\n  var parentIndexes = hierarchy.parentIndexes;\n  var classIds = hierarchy.classIds;\n  var instancesLength = classIds.length;\n  if (!defined(parentIds)) {\n    return;\n  }\n  assert(instanceIndex < instancesLength, \"Parent index \".concat(instanceIndex, \" exceeds the total number of instances: \").concat(instancesLength));\n  assert(stack.indexOf(instanceIndex) === -1, 'Circular dependency detected in the batch table hierarchy.');\n  stack.push(instanceIndex);\n  var parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  var parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n  for (var i = 0; i < parentCount; ++i) {\n    var parentId = parentIds[parentIndex + i];\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}","map":{"version":3,"sources":["../../../../src/lib/classes/tile-3d-batch-table-hierarchy.js"],"names":["defined","x","undefined","initializeHierarchy","batchTable","jsonHeader","binaryBody","hierarchy","getExtension","legacyHierarchy","HIERARCHY","console","warn","extensions","initializeHierarchyValues","hierarchyJson","i","classId","binaryAccessor","instancesLength","classes","classIds","parentCounts","parentIds","parentIdsLength","byteOffset","componentType","defaultValue","GL","UNSIGNED_SHORT","type","AttributeType","SCALAR","getBinaryAccessor","createArrayBufferView","buffer","parentIndexes","Uint16Array","classesLength","length","classInstancesLength","properties","instances","binaryProperties","getBinaryProperties","combine","classCounts","Array","fill","classIndexes","validateHierarchy","traverseHierarchy","instanceIndex","endConditionCallback","traverseHierarchyMultipleParents","traverseHierarchySingleParent","visited","scratchVisited","Math","max","visitedMarker","marker","stack","scratchStack","push","pop","result","parentCount","parentIndex","parentId","hasParent","Error","scratchValidateStack","validateInstance","assert","indexOf"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// TODO - Finish hierarchy suypport: this file is only half ported\n/* eslint-disable */\n// @ts-nocheck\nconst defined = x => x !== undefined;\n\nexport function initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!jsonHeader) {\n    return null;\n  }\n\n  let hierarchy = batchTable.getExtension('3DTILES_batch_table_hierarchy');\n\n  const legacyHierarchy = jsonHeader.HIERARCHY;\n  if (legacyHierarchy) {\n    // eslint-disable-next-line\n    console.warn('3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.');\n    jsonHeader.extensions = jsonHeader.extensions || {};\n    jsonHeader.extensions['3DTILES_batch_table_hierarchy'] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n\n  if (!hierarchy) {\n    return null;\n  }\n\n  return initializeHierarchyValues(hierarchy, binaryBody);\n}\n\n// eslint-disable-next-line max-statements\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  const classIds = hierarchyJson.classIds;\n  const parentCounts = hierarchyJson.parentCounts;\n  const parentIds = hierarchyJson.parentIds;\n  const parentIdsLength = instancesLength;\n\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + classIds.byteOffset,\n      instancesLength\n    );\n  }\n\n  let parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(\n        binaryBody.buffer,\n        binaryBody.byteOffset + parentCounts.byteOffset,\n        instancesLength\n      );\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n  }\n\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + parentIds.byteOffset,\n      parentIdsLength\n    );\n  }\n\n  const classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n\n  const classCounts = new Array(classesLength).fill(0);\n  const classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n\n  const hierarchy = {\n    classes,\n    classIds,\n    classIndexes,\n    parentCounts,\n    parentIndexes,\n    parentIds\n  };\n\n  validateHierarchy(hierarchy);\n\n  return hierarchy;\n}\n\n// HELPER CODE\n\n// Traverse over the hierarchy and process each instance with the endConditionCallback.\n// When the endConditionCallback returns a value, the traversal stops and that value is returned.\nexport function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  if (!hierarchy) {\n    return;\n  }\n\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  if (parentIds) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  }\n  if (parentCounts > 0) {\n    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n  }\n  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n\n// eslint-disable-next-line max-statements\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n  const classIds = hierarchy.classIds;\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const instancesLength = classIds.length;\n\n  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n      // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n  let hasParent = true;\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentId = hierarchy.parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n  throw new Error('traverseHierarchySingleParent');\n}\n\n// DEBUG CODE\n\nfunction validateHierarchy(hierarchy) {\n  const scratchValidateStack = [];\n\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\n\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n\n  assert(\n    instanceIndex < instancesLength,\n    `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`\n  );\n  assert(\n    stack.indexOf(instanceIndex) === -1,\n    'Circular dependency detected in the batch table hierarchy.'\n  );\n\n  stack.push(instanceIndex);\n  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}\n"]},"metadata":{},"sourceType":"module"}