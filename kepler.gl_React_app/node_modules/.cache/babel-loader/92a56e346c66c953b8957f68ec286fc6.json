{"ast":null,"code":"var logState = {\n  attributeUpdateMessages: []\n};\nvar LOG_LEVEL_MAJOR_UPDATE = 1;\nvar LOG_LEVEL_MINOR_UPDATE = 2;\nvar LOG_LEVEL_UPDATE_DETAIL = 3;\nvar LOG_LEVEL_INFO = 4;\nvar LOG_LEVEL_DRAW = 2;\nexport var getLoggers = function getLoggers(log) {\n  return {\n    'layer.changeFlag': function layerChangeFlag(layer, key, flags) {\n      log.log(LOG_LEVEL_UPDATE_DETAIL, \"\".concat(layer.id, \" \").concat(key, \": \"), flags[key])();\n    },\n    'layer.initialize': function layerInitialize(layer) {\n      log.log(LOG_LEVEL_MAJOR_UPDATE, \"Initializing \".concat(layer))();\n    },\n    'layer.update': function layerUpdate(layer, needsUpdate) {\n      if (needsUpdate) {\n        var flags = layer.getChangeFlags();\n        log.log(LOG_LEVEL_MINOR_UPDATE, \"Updating \".concat(layer, \" because: \").concat(Object.keys(flags).filter(function (key) {\n          return flags[key];\n        }).join(', ')))();\n      } else {\n        log.log(LOG_LEVEL_INFO, \"\".concat(layer, \" does not need update\"))();\n      }\n    },\n    'layer.matched': function layerMatched(layer, changed) {\n      if (changed) {\n        log.log(LOG_LEVEL_INFO, \"Matched \".concat(layer, \", state transfered\"))();\n      }\n    },\n    'layer.finalize': function layerFinalize(layer) {\n      log.log(LOG_LEVEL_MAJOR_UPDATE, \"Finalizing \".concat(layer))();\n    },\n    'compositeLayer.renderLayers': function compositeLayerRenderLayers(layer, updated, subLayers) {\n      if (updated) {\n        log.log(LOG_LEVEL_MINOR_UPDATE, \"Composite layer rendered new subLayers \".concat(layer), subLayers)();\n      } else {\n        log.log(LOG_LEVEL_INFO, \"Composite layer reused subLayers \".concat(layer), subLayers)();\n      }\n    },\n    'layerManager.setLayers': function layerManagerSetLayers(layerManager, updated, layers) {\n      if (updated) {\n        log.log(LOG_LEVEL_MINOR_UPDATE, \"Updating \".concat(layers.length, \" deck layers\"))();\n      }\n    },\n    'layerManager.activateViewport': function layerManagerActivateViewport(layerManager, viewport) {\n      log.log(LOG_LEVEL_UPDATE_DETAIL, 'Viewport changed', viewport)();\n    },\n    'attributeManager.invalidate': function attributeManagerInvalidate(attributeManager, trigger, attributeNames) {\n      log.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? \"invalidated attributes \".concat(attributeNames, \" (\").concat(trigger, \") for \").concat(attributeManager.id) : \"invalidated all attributes for \".concat(attributeManager.id))();\n    },\n    'attributeManager.updateStart': function attributeManagerUpdateStart(attributeManager) {\n      logState.attributeUpdateMessages.length = 0;\n      logState.attributeManagerUpdateStart = Date.now();\n    },\n    'attributeManager.updateEnd': function attributeManagerUpdateEnd(attributeManager, numInstances) {\n      var timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);\n      log.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, \"Updated attributes for \".concat(numInstances, \" instances in \").concat(attributeManager.id, \" in \").concat(timeMs, \"ms\"))();\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = logState.attributeUpdateMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var updateMessage = _step.value;\n          log.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      log.groupEnd(LOG_LEVEL_MINOR_UPDATE)();\n    },\n    'attribute.updateStart': function attributeUpdateStart(attribute) {\n      logState.attributeUpdateStart = Date.now();\n    },\n    'attribute.allocate': function attributeAllocate(attribute, numInstances) {\n      var message = \"\".concat(attribute.id, \" allocated \").concat(numInstances);\n      logState.attributeUpdateMessages.push(message);\n    },\n    'attribute.updateEnd': function attributeUpdateEnd(attribute, numInstances) {\n      var timeMs = Math.round(Date.now() - logState.attributeUpdateStart);\n      var message = \"\".concat(attribute.id, \" updated \").concat(numInstances, \" in \").concat(timeMs, \"ms\");\n      logState.attributeUpdateMessages.push(message);\n    },\n    'deckRenderer.renderLayers': function deckRendererRenderLayers(deckRenderer, renderStats, opts) {\n      var pass = opts.pass,\n        redrawReason = opts.redrawReason,\n        stats = opts.stats;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        for (var _iterator2 = renderStats[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var status = _step2.value;\n          var totalCount = status.totalCount,\n            visibleCount = status.visibleCount,\n            compositeCount = status.compositeCount,\n            pickableCount = status.pickableCount;\n          var primitiveCount = totalCount - compositeCount;\n          var hiddenCount = primitiveCount - visibleCount;\n          log.log(LOG_LEVEL_DRAW, \"RENDER #\".concat(deckRenderer.renderCount, \"   \").concat(visibleCount, \" (of \").concat(totalCount, \" layers) to \").concat(pass, \" because \").concat(redrawReason, \"   (\").concat(hiddenCount, \" hidden, \").concat(compositeCount, \" composite \").concat(pickableCount, \" pickable)\"))();\n          if (stats) {\n            stats.get('Redraw Layers').add(visibleCount);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["../../../src/debug/loggers.js"],"names":["logState","attributeUpdateMessages","LOG_LEVEL_MAJOR_UPDATE","LOG_LEVEL_MINOR_UPDATE","LOG_LEVEL_UPDATE_DETAIL","LOG_LEVEL_INFO","LOG_LEVEL_DRAW","getLoggers","layer","key","flags","log","id","needsUpdate","getChangeFlags","keys","filter","join","changed","updated","subLayers","layerManager","layers","length","viewport","attributeManager","trigger","attributeNames","attributeManagerUpdateStart","Date","now","numInstances","timeMs","Math","round","groupCollapsed","updateMessage","groupEnd","attributeUpdateStart","attribute","message","push","deckRenderer","renderStats","opts","pass","redrawReason","stats","status","totalCount","visibleCount","compositeCount","pickableCount","primitiveCount","hiddenCount","renderCount","get","add"],"mappings":"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","sourcesContent":["const logState = {\n  attributeUpdateMessages: []\n};\n\nconst LOG_LEVEL_MAJOR_UPDATE = 1; // Events with direct perf impact\nconst LOG_LEVEL_MINOR_UPDATE = 2; // Events that may affect perf\nconst LOG_LEVEL_UPDATE_DETAIL = 3;\nconst LOG_LEVEL_INFO = 4;\nconst LOG_LEVEL_DRAW = 2;\n\nexport const getLoggers = log => ({\n  /* Layer events */\n\n  'layer.changeFlag': (layer, key, flags) => {\n    log.log(LOG_LEVEL_UPDATE_DETAIL, `${layer.id} ${key}: `, flags[key])();\n  },\n\n  'layer.initialize': layer => {\n    log.log(LOG_LEVEL_MAJOR_UPDATE, `Initializing ${layer}`)();\n  },\n  'layer.update': (layer, needsUpdate) => {\n    if (needsUpdate) {\n      const flags = layer.getChangeFlags();\n      log.log(\n        LOG_LEVEL_MINOR_UPDATE,\n        `Updating ${layer} because: ${Object.keys(flags)\n          .filter(key => flags[key])\n          .join(', ')}`\n      )();\n    } else {\n      log.log(LOG_LEVEL_INFO, `${layer} does not need update`)();\n    }\n  },\n  'layer.matched': (layer, changed) => {\n    if (changed) {\n      log.log(LOG_LEVEL_INFO, `Matched ${layer}, state transfered`)();\n    }\n  },\n  'layer.finalize': layer => {\n    log.log(LOG_LEVEL_MAJOR_UPDATE, `Finalizing ${layer}`)();\n  },\n\n  /* CompositeLayer events */\n\n  'compositeLayer.renderLayers': (layer, updated, subLayers) => {\n    if (updated) {\n      log.log(\n        LOG_LEVEL_MINOR_UPDATE,\n        `Composite layer rendered new subLayers ${layer}`,\n        subLayers\n      )();\n    } else {\n      log.log(LOG_LEVEL_INFO, `Composite layer reused subLayers ${layer}`, subLayers)();\n    }\n  },\n\n  /* LayerManager events */\n\n  'layerManager.setLayers': (layerManager, updated, layers) => {\n    if (updated) {\n      log.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layers.length} deck layers`)();\n    }\n  },\n\n  'layerManager.activateViewport': (layerManager, viewport) => {\n    log.log(LOG_LEVEL_UPDATE_DETAIL, 'Viewport changed', viewport)();\n  },\n\n  /* AttributeManager events */\n\n  'attributeManager.invalidate': (attributeManager, trigger, attributeNames) => {\n    log.log(\n      LOG_LEVEL_MAJOR_UPDATE,\n      attributeNames\n        ? `invalidated attributes ${attributeNames} (${trigger}) for ${attributeManager.id}`\n        : `invalidated all attributes for ${attributeManager.id}`\n    )();\n  },\n\n  'attributeManager.updateStart': attributeManager => {\n    logState.attributeUpdateMessages.length = 0;\n    logState.attributeManagerUpdateStart = Date.now();\n  },\n  'attributeManager.updateEnd': (attributeManager, numInstances) => {\n    const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);\n    log.groupCollapsed(\n      LOG_LEVEL_MINOR_UPDATE,\n      `Updated attributes for ${numInstances} instances in ${attributeManager.id} in ${timeMs}ms`\n    )();\n    for (const updateMessage of logState.attributeUpdateMessages) {\n      log.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();\n    }\n    log.groupEnd(LOG_LEVEL_MINOR_UPDATE)();\n  },\n\n  /* Attribute events */\n\n  'attribute.updateStart': attribute => {\n    logState.attributeUpdateStart = Date.now();\n  },\n  'attribute.allocate': (attribute, numInstances) => {\n    const message = `${attribute.id} allocated ${numInstances}`;\n    logState.attributeUpdateMessages.push(message);\n  },\n  'attribute.updateEnd': (attribute, numInstances) => {\n    const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);\n    const message = `${attribute.id} updated ${numInstances} in ${timeMs}ms`;\n    logState.attributeUpdateMessages.push(message);\n  },\n\n  /* Render events */\n\n  'deckRenderer.renderLayers': (deckRenderer, renderStats, opts) => {\n    const {pass, redrawReason, stats} = opts;\n    for (const status of renderStats) {\n      const {totalCount, visibleCount, compositeCount, pickableCount} = status;\n      const primitiveCount = totalCount - compositeCount;\n      const hiddenCount = primitiveCount - visibleCount;\n\n      log.log(\n        LOG_LEVEL_DRAW,\n        `RENDER #${deckRenderer.renderCount} \\\n  ${visibleCount} (of ${totalCount} layers) to ${pass} because ${redrawReason} \\\n  (${hiddenCount} hidden, ${compositeCount} composite ${pickableCount} pickable)`\n      )();\n\n      if (stats) {\n        stats.get('Redraw Layers').add(visibleCount);\n      }\n    }\n  }\n});\n"]},"metadata":{},"sourceType":"module"}