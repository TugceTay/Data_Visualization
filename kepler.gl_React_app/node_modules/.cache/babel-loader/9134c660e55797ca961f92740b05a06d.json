{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _asyncIterator from \"@babel/runtime/helpers/esm/asyncIterator\";\nimport Papa from '../libs/papaparse';\nvar ChunkStreamer = Papa.ChunkStreamer;\nexport default function AsyncIteratorStreamer(config) {\n  config = config || {};\n  ChunkStreamer.call(this, config);\n  this.textDecoder = new TextDecoder(this._config.encoding);\n  this.stream = function () {\n    var _ref = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(asyncIterator) {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this._input = asyncIterator;\n              _context.prev = 1;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 4;\n              _iterator = _asyncIterator(asyncIterator);\n            case 6:\n              _context.next = 8;\n              return _iterator.next();\n            case 8:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 12;\n              return _step.value;\n            case 12:\n              _value = _context.sent;\n              if (_iteratorNormalCompletion) {\n                _context.next = 19;\n                break;\n              }\n              chunk = _value;\n              this.parseChunk(this.getStringChunk(chunk));\n            case 16:\n              _iteratorNormalCompletion = true;\n              _context.next = 6;\n              break;\n            case 19:\n              _context.next = 25;\n              break;\n            case 21:\n              _context.prev = 21;\n              _context.t0 = _context[\"catch\"](4);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n            case 25:\n              _context.prev = 25;\n              _context.prev = 26;\n              if (!(!_iteratorNormalCompletion && _iterator[\"return\"] != null)) {\n                _context.next = 30;\n                break;\n              }\n              _context.next = 30;\n              return _iterator[\"return\"]();\n            case 30:\n              _context.prev = 30;\n              if (!_didIteratorError) {\n                _context.next = 33;\n                break;\n              }\n              throw _iteratorError;\n            case 33:\n              return _context.finish(30);\n            case 34:\n              return _context.finish(25);\n            case 35:\n              this._finished = true;\n              this.parseChunk('');\n              _context.next = 42;\n              break;\n            case 39:\n              _context.prev = 39;\n              _context.t1 = _context[\"catch\"](1);\n              this._sendError(_context.t1);\n            case 42:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this, [[1, 39], [4, 21, 25, 35], [26,, 30, 34]]);\n    }));\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  this._nextChunk = function nextChunk() {};\n  this.getStringChunk = function (chunk) {\n    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {\n      stream: true\n    });\n  };\n}\nAsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);\nAsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;","map":{"version":3,"sources":["../../../src/lib/async-iterator-streamer.js"],"names":["Papa","ChunkStreamer","AsyncIteratorStreamer","config","call","textDecoder","TextDecoder","_config","encoding","stream","asyncIterator","_input","chunk","parseChunk","getStringChunk","_finished","_sendError","_nextChunk","nextChunk","decode","prototype","Object","create","constructor"],"mappings":"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","sourcesContent":["// A custom papaparse `Streamer` for async iterators\n// Ideally this can be contributed back to papaparse\n// Or papaparse can expose Streamer API so we can extend without forking.\n\n// @ts-nocheck\n/* eslint-disable no-invalid-this */\n/* global TextDecoder */\n\n// Note: papaparse is not an ES6 module\nimport Papa from '../libs/papaparse';\nconst {ChunkStreamer} = Papa;\n\nexport default function AsyncIteratorStreamer(config) {\n  config = config || {};\n\n  ChunkStreamer.call(this, config);\n\n  this.textDecoder = new TextDecoder(this._config.encoding);\n\n  // Implement ChunkStreamer base class methods\n\n  // this.pause = function() {\n  //   ChunkStreamer.prototype.pause.apply(this, arguments);\n  // };\n\n  // this.resume = function() {\n  //   ChunkStreamer.prototype.resume.apply(this, arguments);\n  //   this._input.resume();\n  // };\n\n  this.stream = async function(asyncIterator) {\n    this._input = asyncIterator;\n\n    try {\n      // ES2018 version\n      // TODO - check for pause and abort flags?\n      for await (const chunk of asyncIterator) {\n        this.parseChunk(this.getStringChunk(chunk));\n      }\n\n      // ES5 VERSION\n      // while (true) {\n      //   asyncIterator.next().then(function(value) {\n      //     if (value.done) {\n      //       // finalize iterator?\n      //     }\n      //   }\n      //   const  = await ;\n      //   if (done) return total;\n      //   total += value.length;\n      // }\n\n      this._finished = true;\n      this.parseChunk('');\n    } catch (error) {\n      // Inform ChunkStreamer base class of error\n      this._sendError(error);\n    }\n  };\n\n  this._nextChunk = function nextChunk() {\n    // Left empty, as async iterator automatically pulls next chunk\n  };\n\n  // HELPER METHODS\n  this.getStringChunk = function(chunk) {\n    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {stream: true});\n  };\n}\n\nAsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);\nAsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;\n"]},"metadata":{},"sourceType":"module"}