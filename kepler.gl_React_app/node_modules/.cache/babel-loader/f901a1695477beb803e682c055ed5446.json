{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nimport { load } from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\nimport { lodJudge } from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\nvar I3STilesetTraverser = function (_TilesetTraverser) {\n  _inherits(I3STilesetTraverser, _TilesetTraverser);\n  var _super = _createSuper(I3STilesetTraverser);\n  function I3STilesetTraverser(options) {\n    var _this;\n    _classCallCheck(this, I3STilesetTraverser);\n    _this = _super.call(this, options);\n    _this._tileManager = new I3STileManager();\n    return _this;\n  }\n  _createClass(I3STilesetTraverser, [{\n    key: \"shouldRefine\",\n    value: function shouldRefine(tile, frameState) {\n      tile._lodJudge = lodJudge(tile, frameState);\n      return tile._lodJudge === 'DIG';\n    }\n  }, {\n    key: \"updateChildTiles\",\n    value: function updateChildTiles(tile, frameState) {\n      var _this2 = this;\n      var children = tile.header.children || [];\n      var childTiles = tile.children;\n      var tileset = tile.tileset;\n      var _iterator = _createForOfIteratorHelper(children),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var child = _step.value;\n          var childTile = childTiles && childTiles.find(function (t) {\n            return t.id === child.id;\n          });\n          if (!childTile) {\n            var request = function request() {\n              return _this2._loadTile(child.id, tileset);\n            };\n            var cachedRequest = _this2._tileManager.find(child.id);\n            if (!cachedRequest) {\n              if (tileset.tileset.nodePages) {\n                request = function request() {\n                  return tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n                };\n              }\n              _this2._tileManager.add(request, child.id, function (header) {\n                return _this2._onTileLoad(header, tile);\n              }, frameState);\n            } else {\n              _this2._tileManager.update(child.id, frameState);\n            }\n          } else if (childTile) {\n            _this2.updateTile(childTile, frameState);\n          }\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_loadTile\",\n    value: function () {\n      var _loadTile2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(nodeId, tileset) {\n        var loader, nodeUrl, options;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                loader = tileset.loader;\n                nodeUrl = tileset.getTileUrl(\"\".concat(tileset.url, \"/nodes/\").concat(nodeId));\n                options = {\n                  i3s: _objectSpread(_objectSpread({}, tileset.fetchOptions), {}, {\n                    isTileHeader: true,\n                    loadContent: false\n                  })\n                };\n                _context.next = 5;\n                return load(nodeUrl, loader, options);\n              case 5:\n                return _context.abrupt(\"return\", _context.sent);\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      function _loadTile(_x, _x2) {\n        return _loadTile2.apply(this, arguments);\n      }\n      return _loadTile;\n    }()\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(header, tile) {\n      var basePath = this.options.basePath;\n      var childTile = new TileHeader(tile.tileset, header, tile, basePath);\n      tile.children.push(childTile);\n      var frameState = this._tileManager.find(childTile.id).frameState;\n      this.updateTile(childTile, frameState);\n      if (this._frameNumber === frameState.frameNumber) {\n        this.executeTraversal(childTile, frameState);\n      }\n    }\n  }]);\n  return I3STilesetTraverser;\n}(TilesetTraverser);\nexport { I3STilesetTraverser as default };","map":{"version":3,"sources":["../../../../src/tileset/traversers/i3s-tilset-traverser.js"],"names":["load","TilesetTraverser","lodJudge","TileHeader","I3STileManager","I3STilesetTraverser","options","_tileManager","tile","frameState","_lodJudge","children","header","childTiles","tileset","child","childTile","find","t","id","request","_loadTile","cachedRequest","nodePages","nodePagesTile","formTileFromNodePages","add","_onTileLoad","update","updateTile","nodeId","loader","nodeUrl","getTileUrl","url","i3s","fetchOptions","isTileHeader","loadContent","basePath","push","_frameNumber","frameNumber","executeTraversal"],"mappings":"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","sourcesContent":["import {load} from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\n\nimport {lodJudge} from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\n\nexport default class I3STilesetTraverser extends TilesetTraverser {\n  constructor(options) {\n    super(options);\n    this._tileManager = new I3STileManager();\n  }\n\n  shouldRefine(tile, frameState) {\n    // TODO refactor loaJudge\n    tile._lodJudge = lodJudge(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.header.children || [];\n    // children which are already fetched and constructed as Tile3D instances\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n\n    for (const child of children) {\n      // if child tile is not fetched\n      const childTile = childTiles && childTiles.find(t => t.id === child.id);\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n        const cachedRequest = this._tileManager.find(child.id);\n        if (!cachedRequest) {\n          // eslint-disable-next-line max-depth\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n          this._tileManager.add(\n            request,\n            child.id,\n            header => this._onTileLoad(header, tile),\n            frameState\n          );\n        } else {\n          // update frameNumber since it is still needed in current frame\n          this._tileManager.update(child.id, frameState);\n        }\n      } else if (childTile) {\n        // if child tile is fetched and available\n        this.updateTile(childTile, frameState);\n      }\n    }\n  }\n\n  async _loadTile(nodeId, tileset) {\n    const {loader} = tileset;\n    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n    // load metadata\n    const options = {\n      i3s: {\n        ...tileset.fetchOptions,\n        isTileHeader: true,\n        loadContent: false\n      }\n    };\n\n    return await load(nodeUrl, loader, options);\n  }\n\n  _onTileLoad(header, tile) {\n    const basePath = this.options.basePath;\n    // after child tile is fetched\n    const childTile = new TileHeader(tile.tileset, header, tile, basePath);\n    tile.children.push(childTile);\n    const frameState = this._tileManager.find(childTile.id).frameState;\n    this.updateTile(childTile, frameState);\n\n    // after tile fetched, resume traversal if still in current update/traversal frame\n    if (this._frameNumber === frameState.frameNumber) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}