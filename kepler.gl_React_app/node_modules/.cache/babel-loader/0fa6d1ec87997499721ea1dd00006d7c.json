{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nexport function binaryToGeoJson(data, type, format) {\n  if (format === 'geometry') {\n    return parseGeometry(data);\n  }\n  var dataArray = normalizeInput(data, type);\n  switch (deduceReturnType(dataArray)) {\n    case 'Geometry':\n      return parseGeometry(dataArray[0]);\n    case 'FeatureCollection':\n      return parseFeatureCollection(dataArray);\n    default:\n      break;\n  }\n  return null;\n}\nfunction normalizeInput(data, type) {\n  var isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n  if (!isHeterogeneousType) {\n    data.type = type || parseType(data);\n    return [data];\n  }\n  var features = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n  return features;\n}\nfunction deduceReturnType(dataArray) {\n  if (dataArray.length > 1) {\n    return 'FeatureCollection';\n  }\n  var data = dataArray[0];\n  if (!(data.featureIds || data.globalFeatureIds || data.numericProps || data.properties)) {\n    return 'Geometry';\n  }\n  return 'FeatureCollection';\n}\nfunction parseFeatureCollection(dataArray) {\n  var features = [];\n  var _iterator = _createForOfIteratorHelper(dataArray),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var data = _step.value;\n      if (data.featureIds.value.length === 0) {\n        continue;\n      }\n      var lastIndex = 0;\n      var lastValue = data.featureIds.value[0];\n      for (var i = 0; i < data.featureIds.value.length; i++) {\n        var currValue = data.featureIds.value[i];\n        if (currValue === lastValue) {\n          continue;\n        }\n        features.push(parseFeature(data, lastIndex, i));\n        lastIndex = i;\n        lastValue = currValue;\n      }\n      features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return features;\n}\nfunction parseFeature(data, startIndex, endIndex) {\n  var geometry = parseGeometry(data, startIndex, endIndex);\n  var properties = parseProperties(data, startIndex, endIndex);\n  return {\n    type: 'Feature',\n    geometry: geometry,\n    properties: properties\n  };\n}\nfunction parseProperties(data, startIndex, endIndex) {\n  var properties = Object.assign(data.properties[data.featureIds.value[startIndex]]);\n  for (var key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\nfunction parseGeometry(data, startIndex, endIndex) {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      throw new Error(\"Unsupported geometry type: \".concat(data.type));\n  }\n}\nfunction polygonToGeoJson(data) {\n  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  var endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  var positions = data.positions;\n  var polygonIndices = data.polygonIndices.value.filter(function (x) {\n    return x >= startIndex && x <= endIndex;\n  });\n  var primitivePolygonIndices = data.primitivePolygonIndices.value.filter(function (x) {\n    return x >= startIndex && x <= endIndex;\n  });\n  var multi = polygonIndices.length > 2;\n  var coordinates = [];\n  if (!multi) {\n    for (var i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      var startRingIndex = primitivePolygonIndices[i];\n      var endRingIndex = primitivePolygonIndices[i + 1];\n      var ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n    return {\n      type: 'Polygon',\n      coordinates: coordinates\n    };\n  }\n  for (var _i = 0; _i < polygonIndices.length - 1; _i++) {\n    var startPolygonIndex = polygonIndices[_i];\n    var endPolygonIndex = polygonIndices[_i + 1];\n    var polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;\n    coordinates.push(polygonCoordinates);\n  }\n  return {\n    type: 'MultiPolygon',\n    coordinates: coordinates\n  };\n}\nfunction lineStringToGeoJson(data) {\n  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  var endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  var positions = data.positions;\n  var pathIndices = data.pathIndices.value.filter(function (x) {\n    return x >= startIndex && x <= endIndex;\n  });\n  var multi = pathIndices.length > 2;\n  if (!multi) {\n    var _coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {\n      type: 'LineString',\n      coordinates: _coordinates\n    };\n  }\n  var coordinates = [];\n  for (var i = 0; i < pathIndices.length - 1; i++) {\n    var ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n  return {\n    type: 'MultiLineString',\n    coordinates: coordinates\n  };\n}\nfunction pointToGeoJson(data, startIndex, endIndex) {\n  var positions = data.positions;\n  var coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  var multi = coordinates.length > 1;\n  if (multi) {\n    return {\n      type: 'MultiPoint',\n      coordinates: coordinates\n    };\n  }\n  return {\n    type: 'Point',\n    coordinates: coordinates[0]\n  };\n}\nfunction ringToGeoJson(positions, startIndex, endIndex) {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n  var ringCoordinates = [];\n  for (var j = startIndex; j < endIndex; j++) {\n    ringCoordinates.push(Array.from(positions.value.subarray(j * positions.size, (j + 1) * positions.size)));\n  }\n  return ringCoordinates;\n}\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n  return 'Point';\n}","map":{"version":3,"sources":["../../../src/lib/binary-to-geojson.js"],"names":["binaryToGeoJson","data","type","format","parseGeometry","dataArray","normalizeInput","deduceReturnType","parseFeatureCollection","isHeterogeneousType","Boolean","points","lines","polygons","parseType","features","push","length","featureIds","globalFeatureIds","numericProps","properties","value","lastIndex","lastValue","i","currValue","parseFeature","startIndex","endIndex","geometry","parseProperties","Object","assign","key","pointToGeoJson","lineStringToGeoJson","polygonToGeoJson","Error","Infinity","positions","polygonIndices","filter","x","primitivePolygonIndices","multi","coordinates","startRingIndex","endRingIndex","ringCoordinates","ringToGeoJson","startPolygonIndex","endPolygonIndex","polygonCoordinates","pathIndices","size","j","Array","from","subarray"],"mappings":"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","sourcesContent":["export function binaryToGeoJson(data, type, format) {\n  if (format === 'geometry') {\n    return parseGeometry(data);\n  }\n\n  const dataArray = normalizeInput(data, type);\n\n  switch (deduceReturnType(dataArray)) {\n    case 'Geometry':\n      return parseGeometry(dataArray[0]);\n    case 'FeatureCollection':\n      return parseFeatureCollection(dataArray);\n    default:\n      break;\n  }\n\n  return null;\n}\n\n// Normalize features\n// Return an array of data objects, each of which have a type key\nfunction normalizeInput(data, type) {\n  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    data.type = type || parseType(data);\n    return [data];\n  }\n\n  const features = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n  return features;\n}\n\n// Determine whether a geometry or feature collection should be returned\n// If the input data doesn't have property identifiers, returns a single geometry\nfunction deduceReturnType(dataArray) {\n  // If more than one item in dataArray, multiple geometry types, must be a featurecollection\n  if (dataArray.length > 1) {\n    return 'FeatureCollection';\n  }\n\n  const data = dataArray[0];\n  if (!(data.featureIds || data.globalFeatureIds || data.numericProps || data.properties)) {\n    return 'Geometry';\n  }\n\n  return 'FeatureCollection';\n}\n\n/** Parse input binary data and return an array of GeoJSON Features */\nfunction parseFeatureCollection(dataArray) {\n  const features = [];\n  for (const data of dataArray) {\n    if (data.featureIds.value.length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Need to deduce start, end indices of each feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    // Last feature\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n  return features;\n}\n\n/** Parse input binary data and return a single GeoJSON Feature */\nfunction parseFeature(data, startIndex, endIndex) {\n  const geometry = parseGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  return {type: 'Feature', geometry, properties};\n}\n\n/** Parse input binary data and return an object of properties */\nfunction parseProperties(data, startIndex, endIndex) {\n  const properties = Object.assign(data.properties[data.featureIds.value[startIndex]]);\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\n\n/** Parse input binary data and return a valid GeoJSON geometry object */\nfunction parseGeometry(data, startIndex, endIndex) {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      throw new Error(`Unsupported geometry type: ${data.type}`);\n  }\n}\n\n/** Parse binary data of type Polygon */\nfunction polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n  const {positions} = data;\n  const polygonIndices = data.polygonIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(\n    x => x >= startIndex && x <= endIndex\n  );\n  const multi = polygonIndices.length > 2;\n\n  const coordinates = [];\n  // Polygon\n  if (!multi) {\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {type: 'Polygon', coordinates};\n  }\n\n  // MultiPolygon\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex)\n      .coordinates;\n    coordinates.push(polygonCoordinates);\n  }\n\n  return {type: 'MultiPolygon', coordinates};\n}\n\n/** Parse binary data of type LineString */\nfunction lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n  const {positions} = data;\n  const pathIndices = data.pathIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {type: 'LineString', coordinates};\n  }\n\n  const coordinates = [];\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {type: 'MultiLineString', coordinates};\n}\n\n/** Parse binary data of type Point */\nfunction pointToGeoJson(data, startIndex, endIndex) {\n  const {positions} = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n\n  if (multi) {\n    return {type: 'MultiPoint', coordinates};\n  }\n\n  return {type: 'Point', coordinates: coordinates[0]};\n}\n\n/**\n * Parse a linear ring of positions to a GeoJSON linear ring\n *\n * @param positions Positions TypedArray\n * @param  {number?} startIndex Start index to include in ring\n * @param  {number?} endIndex End index to include in ring\n * @return {number[][]} GeoJSON ring\n */\nfunction ringToGeoJson(positions, startIndex, endIndex) {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n\n  const ringCoordinates = [];\n  for (let j = startIndex; j < endIndex; j++) {\n    ringCoordinates.push(\n      Array.from(positions.value.subarray(j * positions.size, (j + 1) * positions.size))\n    );\n  }\n  return ringCoordinates;\n}\n\n// Deduce geometry type of data object\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}\n"]},"metadata":{},"sourceType":"module"}