{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport * as Polygon from './polygon';\nimport { Tesselator } from '@deck.gl/core';\nimport { cutPolygonByGrid, cutPolygonByMercatorBounds } from '@math.gl/polygon';\nvar PolygonTesselator = function (_Tesselator) {\n  _inherits(PolygonTesselator, _Tesselator);\n  function PolygonTesselator(opts) {\n    _classCallCheck(this, PolygonTesselator);\n    var fp64 = opts.fp64,\n      _opts$IndexType = opts.IndexType,\n      IndexType = _opts$IndexType === void 0 ? Uint32Array : _opts$IndexType;\n    return _possibleConstructorReturn(this, _getPrototypeOf(PolygonTesselator).call(this, _objectSpread({}, opts, {\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    })));\n  }\n  _createClass(PolygonTesselator, [{\n    key: \"get\",\n    value: function get(attributeName) {\n      var attributes = this.attributes;\n      if (attributeName === 'indices') {\n        return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n      }\n      return attributes[attributeName];\n    }\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry(opts) {\n      _get(_getPrototypeOf(PolygonTesselator.prototype), \"updateGeometry\", this).call(this, opts);\n      var externalIndices = this.buffers.indices;\n      if (externalIndices) {\n        this.vertexCount = (externalIndices.value || externalIndices).length;\n      }\n    }\n  }, {\n    key: \"normalizeGeometry\",\n    value: function normalizeGeometry(polygon) {\n      if (this.normalize) {\n        polygon = Polygon.normalize(polygon, this.positionSize);\n        if (this.opts.resolution) {\n          return cutPolygonByGrid(polygon.positions || polygon, polygon.holeIndices, {\n            size: this.positionSize,\n            gridResolution: this.opts.resolution,\n            edgeTypes: true\n          });\n        }\n        if (this.opts.wrapLongitude) {\n          return cutPolygonByMercatorBounds(polygon.positions || polygon, polygon.holeIndices, {\n            size: this.positionSize,\n            maxLatitude: 86,\n            edgeTypes: true\n          });\n        }\n      }\n      return polygon;\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(polygon) {\n      if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n        var size = 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n          for (var _iterator = polygon[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var subPolygon = _step.value;\n            size += this.getGeometrySize(subPolygon);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n        return size;\n      }\n      return (polygon.positions || polygon).length / this.positionSize;\n    }\n  }, {\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(buffer) {\n      if (this.normalize || !this.buffers.indices) {\n        return _get(_getPrototypeOf(PolygonTesselator.prototype), \"getGeometryFromBuffer\", this).call(this, buffer);\n      }\n      return function () {\n        return null;\n      };\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(polygon, context) {\n      if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n        try {\n          for (var _iterator2 = polygon[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var subPolygon = _step2.value;\n            var geometrySize = this.getGeometrySize(subPolygon);\n            context.geometrySize = geometrySize;\n            this.updateGeometryAttributes(subPolygon, context);\n            context.vertexStart += geometrySize;\n            context.indexStart = this.indexStarts[context.geometryIndex + 1];\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } else {\n        this._updateIndices(polygon, context);\n        this._updatePositions(polygon, context);\n        this._updateVertexValid(polygon, context);\n      }\n    }\n  }, {\n    key: \"_updateIndices\",\n    value: function _updateIndices(polygon, _ref) {\n      var geometryIndex = _ref.geometryIndex,\n        offset = _ref.vertexStart,\n        indexStart = _ref.indexStart;\n      var attributes = this.attributes,\n        indexStarts = this.indexStarts,\n        typedArrayManager = this.typedArrayManager;\n      var target = attributes.indices;\n      if (!target) {\n        return;\n      }\n      var i = indexStart;\n      var indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n      target = typedArrayManager.allocate(target, indexStart + indices.length, {\n        copy: true\n      });\n      for (var j = 0; j < indices.length; j++) {\n        target[i++] = indices[j] + offset;\n      }\n      indexStarts[geometryIndex + 1] = indexStart + indices.length;\n      attributes.indices = target;\n    }\n  }, {\n    key: \"_updatePositions\",\n    value: function _updatePositions(polygon, _ref2) {\n      var vertexStart = _ref2.vertexStart,\n        geometrySize = _ref2.geometrySize;\n      var positions = this.attributes.positions,\n        positionSize = this.positionSize;\n      if (!positions) {\n        return;\n      }\n      var polygonPositions = polygon.positions || polygon;\n      for (var i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n        var x = polygonPositions[j * positionSize];\n        var y = polygonPositions[j * positionSize + 1];\n        var z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n        positions[i * 3] = x;\n        positions[i * 3 + 1] = y;\n        positions[i * 3 + 2] = z;\n      }\n    }\n  }, {\n    key: \"_updateVertexValid\",\n    value: function _updateVertexValid(polygon, _ref3) {\n      var vertexStart = _ref3.vertexStart,\n        geometrySize = _ref3.geometrySize;\n      var vertexValid = this.attributes.vertexValid,\n        positionSize = this.positionSize;\n      var holeIndices = polygon && polygon.holeIndices;\n      if (polygon && polygon.edgeTypes) {\n        vertexValid.set(polygon.edgeTypes, vertexStart);\n      } else {\n        vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n      }\n      if (holeIndices) {\n        for (var j = 0; j < holeIndices.length; j++) {\n          vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n        }\n      }\n      vertexValid[vertexStart + geometrySize - 1] = 0;\n    }\n  }]);\n  return PolygonTesselator;\n}(Tesselator);\nexport { PolygonTesselator as default };","map":{"version":3,"sources":["../../../src/solid-polygon-layer/polygon-tesselator.js"],"names":["Polygon","Tesselator","cutPolygonByGrid","cutPolygonByMercatorBounds","PolygonTesselator","opts","fp64","IndexType","Uint32Array","attributes","positions","size","type","Float64Array","Float32Array","vertexValid","Uint8ClampedArray","indices","attributeName","subarray","vertexCount","externalIndices","buffers","value","length","polygon","normalize","positionSize","resolution","holeIndices","gridResolution","edgeTypes","wrapLongitude","maxLatitude","Array","isArray","Number","isFinite","subPolygon","getGeometrySize","buffer","context","geometrySize","updateGeometryAttributes","vertexStart","indexStart","indexStarts","geometryIndex","_updateIndices","_updatePositions","_updateVertexValid","offset","typedArrayManager","target","i","getSurfaceIndices","preproject","allocate","copy","j","polygonPositions","x","y","z","set","fill"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\nimport {cutPolygonByGrid, cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /* Getters */\n  get(attributeName) {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    }\n  }\n\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      polygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n    }\n    return polygon;\n  }\n\n  getGeometrySize(polygon) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return (polygon.positions || polygon).length / this.positionSize;\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return () => null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n      this._updatePositions(polygon, context);\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  // Flatten the indices array\n  _updateIndices(polygon, {geometryIndex, vertexStart: offset, indexStart}) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  _updatePositions(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions) {\n      return;\n    }\n    const polygonPositions = polygon.positions || polygon;\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {vertexValid},\n      positionSize\n    } = this;\n    const holeIndices = polygon && polygon.holeIndices;\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}