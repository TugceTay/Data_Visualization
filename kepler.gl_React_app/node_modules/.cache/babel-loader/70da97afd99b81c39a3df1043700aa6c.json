{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { toRadians } from '@math.gl/core';\nvar WGS84_RADIUS_X = 6378137.0;\nvar qualityFactor = Math.PI / 2;\nexport function lodJudge(tile, frameState) {\n  var viewport = frameState.viewport;\n  var metersPerPixel = viewport.metersPerPixel;\n  var mbsLat = tile.header.mbs[1];\n  var mbsLon = tile.header.mbs[0];\n  var mbsZ = tile.header.mbs[2];\n  var mbsR = tile.header.mbs[3];\n  var height = viewport.height,\n    width = viewport.width,\n    latitude = viewport.latitude,\n    longitude = viewport.longitude;\n  var viewportCenter = [longitude, latitude];\n  var mbsCenter = [mbsLon, mbsLat, mbsZ];\n  var mbsLatProjected = [longitude, mbsLat];\n  var mbsLonProjected = [mbsLon, latitude];\n  var diagonalInMeters = Math.sqrt(height * height + width * width) * metersPerPixel[0];\n  var distanceInMeters = getDistanceFromLatLon(viewportCenter, mbsCenter);\n  var visibleHeight = height * 0.5 + mbsR / WGS84_RADIUS_X;\n  var visibleWidth = width * 0.5 + mbsR / WGS84_RADIUS_X;\n  if (distanceInMeters > diagonalInMeters + mbsR / WGS84_RADIUS_X) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLatProjected) > visibleHeight) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLonProjected) > visibleWidth) {\n    return 'OUT';\n  }\n  if (tile.lodMetricValue === 0) {\n    return 'DIG';\n  }\n  var screenSize = getI3ScreenSize(tile, frameState);\n  screenSize *= qualityFactor;\n  if (screenSize < 0.5) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\nfunction projectVertexToSphere(_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n    x = _ref2[0],\n    y = _ref2[1],\n    z = _ref2[2];\n  var azim = toRadians(x);\n  var incl = toRadians(y);\n  var radius = 1.0 + z / WGS84_RADIUS_X;\n  var radCosInc = radius * Math.cos(incl);\n  x = radCosInc * Math.cos(azim);\n  y = radCosInc * Math.sin(azim);\n  z = radius * Math.sin(incl);\n  return [x, y, z];\n}\nfunction getDistanceFromLatLon(_ref3, _ref4) {\n  var _ref5 = _slicedToArray(_ref3, 3),\n    observerLon = _ref5[0],\n    observerLat = _ref5[1],\n    _ref5$ = _ref5[2],\n    observerZ = _ref5$ === void 0 ? 0.0 : _ref5$;\n  var _ref6 = _slicedToArray(_ref4, 3),\n    centerLon = _ref6[0],\n    centerLat = _ref6[1],\n    _ref6$ = _ref6[2],\n    centerZ = _ref6$ === void 0 ? 0.0 : _ref6$;\n  var projectedCenter = projectVertexToSphere([centerLon, centerLat, centerZ]);\n  var projectedObserver = projectVertexToSphere([observerLon, observerLat, observerZ]);\n  var dx = projectedObserver[0] - projectedCenter[0];\n  var dy = projectedObserver[1] - projectedCenter[1];\n  var dz = projectedObserver[2] - projectedCenter[2];\n  return dx * dx + dy * dy + dz * dz;\n}\nexport function getI3ScreenSize(tile, frameState) {\n  var viewport = frameState.viewport;\n  var mbsLat = tile.header.mbs[1];\n  var mbsLon = tile.header.mbs[0];\n  var mbsZ = tile.header.mbs[2];\n  var mbsR = tile.header.mbs[3];\n  var mbsCenter = [mbsLon, mbsLat, mbsZ];\n  var cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  var dSquared = getDistanceFromLatLon(cameraPositionCartographic, mbsCenter);\n  var mbsRNormalized = mbsR / WGS84_RADIUS_X;\n  var d = dSquared - mbsRNormalized * mbsRNormalized;\n  var fltMax = 3.4028235e38;\n  if (d <= 0.0) {\n    return 0.5 * fltMax;\n  }\n  var screenSizeFactor = calculateScreenSizeFactor(tile, frameState);\n  screenSizeFactor *= mbsRNormalized / Math.sqrt(d) / viewport.scale;\n  return screenSizeFactor;\n}\nfunction calculateScreenSizeFactor(tile, frameState) {\n  var _frameState$viewport = frameState.viewport,\n    width = _frameState$viewport.width,\n    height = _frameState$viewport.height,\n    pixelProjectionMatrix = _frameState$viewport.pixelProjectionMatrix;\n  var tanOfHalfVFAngle = Math.tan(Math.atan(Math.sqrt(1.0 / (pixelProjectionMatrix[0] * pixelProjectionMatrix[0]) + 1.0 / (pixelProjectionMatrix[5] * pixelProjectionMatrix[5]))));\n  var screenCircleFactor = Math.sqrt(height * height + width * width) / tanOfHalfVFAngle;\n  return screenCircleFactor;\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/i3s-lod.js"],"names":["toRadians","WGS84_RADIUS_X","qualityFactor","Math","PI","lodJudge","tile","frameState","viewport","metersPerPixel","mbsLat","header","mbs","mbsLon","mbsZ","mbsR","height","width","latitude","longitude","viewportCenter","mbsCenter","mbsLatProjected","mbsLonProjected","diagonalInMeters","sqrt","distanceInMeters","getDistanceFromLatLon","visibleHeight","visibleWidth","lodMetricValue","screenSize","getI3ScreenSize","children","projectVertexToSphere","x","y","z","azim","incl","radius","radCosInc","cos","sin","observerLon","observerLat","observerZ","centerLon","centerLat","centerZ","projectedCenter","projectedObserver","dx","dy","dz","cameraPositionCartographic","unprojectPosition","cameraPosition","dSquared","mbsRNormalized","d","fltMax","screenSizeFactor","calculateScreenSizeFactor","scale","pixelProjectionMatrix","tanOfHalfVFAngle","tan","atan","screenCircleFactor"],"mappings":"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","sourcesContent":["import {toRadians} from '@math.gl/core';\n\nconst WGS84_RADIUS_X = 6378137.0;\n// use this to bias the lod switching  (1+ results in increasing the LOD quality)\nconst qualityFactor = Math.PI / 2; // empirical derived bias factor\n/* eslint-disable max-statements */\nexport function lodJudge(tile, frameState) {\n  const viewport = frameState.viewport;\n  const metersPerPixel = viewport.metersPerPixel;\n\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const {height, width, latitude, longitude} = viewport;\n\n  const viewportCenter = [longitude, latitude];\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const mbsLatProjected = [longitude, mbsLat];\n  const mbsLonProjected = [mbsLon, latitude];\n\n  const diagonalInMeters = Math.sqrt(height * height + width * width) * metersPerPixel[0];\n  const distanceInMeters = getDistanceFromLatLon(viewportCenter, mbsCenter);\n\n  const visibleHeight = height * 0.5 + mbsR / WGS84_RADIUS_X;\n  const visibleWidth = width * 0.5 + mbsR / WGS84_RADIUS_X;\n\n  if (distanceInMeters > diagonalInMeters + mbsR / WGS84_RADIUS_X) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLatProjected) > visibleHeight) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLonProjected) > visibleWidth) {\n    return 'OUT';\n  }\n\n  if (tile.lodMetricValue === 0) {\n    return 'DIG';\n  }\n\n  // For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n  // as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n  // In this sense a value of 0 means you should always load it's children,\n  // or if it's a leaf node, you should always display it.\n  let screenSize = getI3ScreenSize(tile, frameState); // in pixels\n  screenSize *= qualityFactor;\n  if (screenSize < 0.5) {\n    return 'OUT';\n  }\n  // Hack: 1000 is a Magic number to get the correct LoD\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/* eslint-enable max-statements */\n\nfunction projectVertexToSphere([x, y, z]) {\n  const azim = toRadians(x);\n  const incl = toRadians(y);\n  const radius = 1.0 + z / WGS84_RADIUS_X;\n  const radCosInc = radius * Math.cos(incl);\n  x = radCosInc * Math.cos(azim);\n  y = radCosInc * Math.sin(azim);\n  z = radius * Math.sin(incl);\n  return [x, y, z];\n}\n\nfunction getDistanceFromLatLon(\n  [observerLon, observerLat, observerZ = 0.0],\n  [centerLon, centerLat, centerZ = 0.0]\n) {\n  const projectedCenter = projectVertexToSphere([centerLon, centerLat, centerZ]);\n  const projectedObserver = projectVertexToSphere([observerLon, observerLat, observerZ]);\n  const dx = projectedObserver[0] - projectedCenter[0];\n  const dy = projectedObserver[1] - projectedCenter[1];\n  const dz = projectedObserver[2] - projectedCenter[2];\n  return dx * dx + dy * dy + dz * dz;\n}\n\nexport function getI3ScreenSize(tile, frameState) {\n  const viewport = frameState.viewport;\n  // https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const dSquared = getDistanceFromLatLon(cameraPositionCartographic, mbsCenter);\n  const mbsRNormalized = mbsR / WGS84_RADIUS_X;\n  const d = dSquared - mbsRNormalized * mbsRNormalized;\n  const fltMax = 3.4028235e38; // convert from 0x7f7fffff which is the maximum\n  if (d <= 0.0) {\n    return 0.5 * fltMax;\n  }\n  let screenSizeFactor = calculateScreenSizeFactor(tile, frameState);\n  // viewport changed in deck.gl v8.0\n  screenSizeFactor *= mbsRNormalized / Math.sqrt(d) / viewport.scale;\n  return screenSizeFactor;\n}\n\nfunction calculateScreenSizeFactor(tile, frameState) {\n  const {width, height, pixelProjectionMatrix} = frameState.viewport;\n  const tanOfHalfVFAngle = Math.tan(\n    Math.atan(\n      Math.sqrt(\n        1.0 / (pixelProjectionMatrix[0] * pixelProjectionMatrix[0]) +\n          1.0 / (pixelProjectionMatrix[5] * pixelProjectionMatrix[5])\n      )\n    )\n  );\n\n  const screenCircleFactor = Math.sqrt(height * height + width * width) / tanOfHalfVFAngle;\n\n  return screenCircleFactor;\n}\n"]},"metadata":{},"sourceType":"module"}