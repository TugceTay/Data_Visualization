{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { normalizeTransitionSettings } from './attribute/attribute-transition-utils';\nimport CPUInterpolationTransition from '../transitions/cpu-interpolation-transition';\nimport CPUSpringTransition from '../transitions/cpu-spring-transition';\nimport log from '../utils/log';\nvar TRANSITION_TYPES = {\n  interpolation: CPUInterpolationTransition,\n  spring: CPUSpringTransition\n};\nvar UniformTransitionManager = function () {\n  function UniformTransitionManager(timeline) {\n    _classCallCheck(this, UniformTransitionManager);\n    this.transitions = new Map();\n    this.timeline = timeline;\n  }\n  _createClass(UniformTransitionManager, [{\n    key: \"add\",\n    value: function add(key, fromValue, toValue, settings) {\n      var transitions = this.transitions;\n      if (transitions.has(key)) {\n        var _transition = transitions.get(key);\n        fromValue = _transition.value;\n        this.remove(key);\n      }\n      settings = normalizeTransitionSettings(settings);\n      if (!settings) {\n        return;\n      }\n      var TransitionType = TRANSITION_TYPES[settings.type];\n      if (!TransitionType) {\n        log.error(\"unsupported transition type '\".concat(settings.type, \"'\"))();\n        return;\n      }\n      var transition = new TransitionType(this.timeline);\n      transition.start(_objectSpread({}, settings, {\n        fromValue: fromValue,\n        toValue: toValue\n      }));\n      transitions.set(key, transition);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var transitions = this.transitions;\n      if (transitions.has(key)) {\n        transitions.get(key).cancel();\n        transitions[\"delete\"](key);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var propsInTransition = {};\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = this.transitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            transition = _step$value[1];\n          transition.update();\n          propsInTransition[key] = transition.value;\n          if (!transition.inProgress) {\n            this.remove(key);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return propsInTransition;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        for (var _iterator2 = this.transitions.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var key = _step2.value;\n          this.remove(key);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"active\",\n    get: function get() {\n      return this.transitions.size > 0;\n    }\n  }]);\n  return UniformTransitionManager;\n}();\nexport { UniformTransitionManager as default };","map":{"version":3,"sources":["../../../src/lib/uniform-transition-manager.js"],"names":["normalizeTransitionSettings","CPUInterpolationTransition","CPUSpringTransition","log","TRANSITION_TYPES","interpolation","spring","UniformTransitionManager","timeline","transitions","Map","size","key","fromValue","toValue","settings","has","transition","get","value","remove","TransitionType","type","error","start","set","cancel","propsInTransition","update","inProgress","keys"],"mappings":"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","sourcesContent":["import {normalizeTransitionSettings} from './attribute/attribute-transition-utils';\nimport CPUInterpolationTransition from '../transitions/cpu-interpolation-transition';\nimport CPUSpringTransition from '../transitions/cpu-spring-transition';\nimport log from '../utils/log';\n\nconst TRANSITION_TYPES = {\n  interpolation: CPUInterpolationTransition,\n  spring: CPUSpringTransition\n};\n\nexport default class UniformTransitionManager {\n  constructor(timeline) {\n    this.transitions = new Map();\n    this.timeline = timeline;\n  }\n\n  get active() {\n    return this.transitions.size > 0;\n  }\n\n  add(key, fromValue, toValue, settings) {\n    const {transitions} = this;\n    if (transitions.has(key)) {\n      const transition = transitions.get(key);\n      // start from interrupted position\n      fromValue = transition.value;\n      this.remove(key);\n    }\n\n    settings = normalizeTransitionSettings(settings);\n    if (!settings) {\n      return;\n    }\n\n    const TransitionType = TRANSITION_TYPES[settings.type];\n    if (!TransitionType) {\n      log.error(`unsupported transition type '${settings.type}'`)();\n      return;\n    }\n    const transition = new TransitionType(this.timeline);\n    transition.start({\n      ...settings,\n      fromValue,\n      toValue\n    });\n    transitions.set(key, transition);\n  }\n\n  remove(key) {\n    const {transitions} = this;\n    if (transitions.has(key)) {\n      transitions.get(key).cancel();\n      transitions.delete(key);\n    }\n  }\n\n  update() {\n    const propsInTransition = {};\n\n    for (const [key, transition] of this.transitions) {\n      transition.update();\n      propsInTransition[key] = transition.value;\n      if (!transition.inProgress) {\n        // transition ended\n        this.remove(key);\n      }\n    }\n\n    return propsInTransition;\n  }\n\n  clear() {\n    for (const key of this.transitions.keys()) {\n      this.remove(key);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}