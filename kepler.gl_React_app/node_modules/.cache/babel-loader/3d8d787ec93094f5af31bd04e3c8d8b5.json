{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unique = unique;\nexports.findMapBounds = findMapBounds;\nexports.getLatLngBounds = getLatLngBounds;\nexports.clamp = clamp;\nexports.getSampleData = getSampleData;\nexports.timeToUnixMilli = timeToUnixMilli;\nexports.maybeToDate = maybeToDate;\nexports.notNullorUndefined = notNullorUndefined;\nexports.isNumber = isNumber;\nexports.isPlainObject = isPlainObject;\nexports.numberSort = numberSort;\nexports.getSortingFunction = getSortingFunction;\nexports.preciseRound = preciseRound;\nexports.getRoundingDecimalFromStep = getRoundingDecimalFromStep;\nexports.snapToMarks = snapToMarks;\nexports.normalizeSliderValue = normalizeSliderValue;\nexports.roundValToStep = roundValToStep;\nexports.getFormatter = getFormatter;\nexports.applyDefaultFormat = applyDefaultFormat;\nexports.getBooleanFormatter = getBooleanFormatter;\nexports.applyCustomFormat = applyCustomFormat;\nexports.datetimeFormatter = datetimeFormatter;\nexports.arrayMove = exports.parseFieldValue = exports.FIELD_DISPLAY_FORMAT = exports.defaultFormatter = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar _defaultSettings = require(\"../constants/default-settings\");\nvar _tooltip = require(\"../constants/tooltip\");\nvar _d3Format = require(\"d3-format\");\nvar _d3Array = require(\"d3-array\");\nvar _momentTimezone = _interopRequireDefault(require(\"moment-timezone\"));\nvar _FIELD_DISPLAY_FORMAT;\nvar MAX_LATITUDE = 90;\nvar MIN_LATITUDE = -90;\nvar MAX_LONGITUDE = 180;\nvar MIN_LONGITUDE = -180;\n/**\n * simple getting unique values of an array\n *\n * @param {array} values\n * @returns {array} unique values\n */\n\nfunction unique(values) {\n  var results = [];\n  var uniqueSet = new Set(values);\n  uniqueSet.forEach(function (v) {\n    if (notNullorUndefined(v)) {\n      results.push(v);\n    }\n  });\n  return results;\n}\n/* eslint-disable max-statements */\n\n/**\n * return center of map from given points\n * @param {array} layers\n * @returns {object} coordinates of map center, empty if not found\n */\n\nfunction findMapBounds(layers) {\n  // find bounds in formatted layerData\n  // take ALL layers into account when finding map bounds\n  var availableLayerBounds = layers.reduce(function (res, l) {\n    if (l.meta && l.meta.bounds) {\n      res.push(l.meta.bounds);\n    }\n    return res;\n  }, []); // return null if no layer is available\n\n  if (availableLayerBounds.length === 0) {\n    return null;\n  } // merge bounds in each layer\n\n  var newBounds = availableLayerBounds.reduce(function (res, b) {\n    return [Math.min(res[0], b[0]), Math.min(res[1], b[1]), Math.max(res[2], b[2]), Math.max(res[3], b[3])];\n  }, [MAX_LONGITUDE, MAX_LATITUDE, MIN_LONGITUDE, MIN_LATITUDE]);\n  return newBounds;\n}\n/* eslint-enable max-statements */\n\nfunction getLatLngBounds(points, idx, limit) {\n  var lats = points.map(function (d) {\n    return Array.isArray(d) && d[idx];\n  }).filter(Number.isFinite).sort(numberSort);\n  if (!lats.length) {\n    return null;\n  } // clamp to limit\n\n  return [Math.max(lats[0], limit[0]), Math.min(lats[lats.length - 1], limit[1])];\n}\nfunction clamp(_ref, val) {\n  var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n    min = _ref2[0],\n    max = _ref2[1];\n  return val <= min ? min : val >= max ? max : val;\n}\nfunction getSampleData(data) {\n  var sampleSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  var getValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (d) {\n    return d;\n  };\n  var sampleStep = Math.max(Math.floor(data.length / sampleSize), 1);\n  var output = [];\n  for (var i = 0; i < data.length; i += sampleStep) {\n    output.push(getValue(data[i]));\n  }\n  return output;\n}\n/**\n * Convert different time format to unix milliseconds\n * @type {typeof import('./data-utils').timeToUnixMilli}\n */\n\nfunction timeToUnixMilli(value, format) {\n  if (notNullorUndefined(value)) {\n    return typeof value === 'string' ? _momentTimezone[\"default\"].utc(value, format).valueOf() : format === 'x' ? value * 1000 : value;\n  }\n  return null;\n}\n/**\n *\n * @type {typeof import('./data-utils').maybeToDate}\n */\n\nfunction maybeToDate(isTime, fieldIdx, format, dc, d) {\n  if (isTime) {\n    return timeToUnixMilli(dc.valueAt(d.index, fieldIdx), format);\n  }\n  return dc.valueAt(d.index, fieldIdx);\n}\n/**\n * whether null or undefined\n * @type {typeof import('./data-utils').notNullorUndefined}\n */\n\nfunction notNullorUndefined(d) {\n  return d !== undefined && d !== null;\n}\n/**\n * Whether d is a number, this filtered out NaN as well\n * @type {typeof import('./data-utils').notNullorUndefined}\n */\n\nfunction isNumber(d) {\n  return Number.isFinite(d);\n}\n/**\n * whether null or undefined\n */\n\nfunction isPlainObject(obj) {\n  return obj === Object(obj) && typeof obj !== 'function' && !Array.isArray(obj);\n}\n/**\n * @type {typeof import('./data-utils').numberSort}\n */\n\nfunction numberSort(a, b) {\n  return a - b;\n}\n/**\n * @type {typeof import('./data-utils').getSortingFunction}\n */\n\nfunction getSortingFunction(fieldType) {\n  switch (fieldType) {\n    case _defaultSettings.ALL_FIELD_TYPES.real:\n    case _defaultSettings.ALL_FIELD_TYPES.integer:\n    case _defaultSettings.ALL_FIELD_TYPES.timestamp:\n      return numberSort;\n    default:\n      return undefined;\n  }\n}\n/**\n * round number with exact number of decimals\n * return as a string\n * @type {typeof import('./data-utils').preciseRound}\n */\n\nfunction preciseRound(num, decimals) {\n  var t = Math.pow(10, decimals);\n  return (Math.round(num * t + (decimals > 0 ? 1 : 0) * (Math.sign(num) * (10 / Math.pow(100, decimals)))) / t).toFixed(decimals);\n}\n/**\n * get number of decimals to round to for slider from step\n * @param {number} step\n * @returns {number} - number of decimal\n */\n\nfunction getRoundingDecimalFromStep(step) {\n  if (isNaN(step)) {\n    (0, _assert[\"default\"])('step is not a number');\n    (0, _assert[\"default\"])(step);\n  }\n  var splitZero = step.toString().split('.');\n  if (splitZero.length === 1) {\n    return 0;\n  }\n  return splitZero[1].length;\n}\n/**\n * Use in slider, given a number and an array of numbers, return the nears number from the array\n * @type {typeof import('./data-utils').snapToMarks}\n * @param value\n * @param marks\n */\n\nfunction snapToMarks(value, marks) {\n  // always use bin x0\n  var i = (0, _d3Array.bisectLeft)(marks, value);\n  if (i === 0) {\n    return marks[i];\n  } else if (i === marks.length) {\n    return marks[i - 1];\n  }\n  var idx = marks[i] - value < value - marks[i - 1] ? i : i - 1;\n  return marks[idx];\n}\n/**\n * If marks is provided, snap to marks, if not normalize to step\n * @type {typeof import('./data-utils').normalizeSliderValue}\n * @param val\n * @param minValue\n * @param step\n * @param marks\n */\n\nfunction normalizeSliderValue(val, minValue, step, marks) {\n  if (marks && marks.length) {\n    return snapToMarks(val, marks);\n  }\n  return roundValToStep(minValue, step, val);\n}\n/**\n * round the value to step for the slider\n * @type {typeof import('./data-utils').roundValToStep}\n * @param minValue\n * @param step\n * @param val\n * @returns - rounded number\n */\n\nfunction roundValToStep(minValue, step, val) {\n  if (!isNumber(step) || !isNumber(minValue)) {\n    return val;\n  }\n  var decimal = getRoundingDecimalFromStep(step);\n  var steps = Math.floor((val - minValue) / step);\n  var remain = val - (steps * step + minValue); // has to round because javascript turns 0.1 into 0.9999999999999987\n\n  remain = Number(preciseRound(remain, 8));\n  var closest;\n  if (remain === 0) {\n    closest = val;\n  } else if (remain < step / 2) {\n    closest = steps * step + minValue;\n  } else {\n    closest = (steps + 1) * step + minValue;\n  } // precise round return a string rounded to the defined decimal\n\n  var rounded = preciseRound(closest, decimal);\n  return Number(rounded);\n}\n/**\n * Get the value format based on field and format options\n * Used in render tooltip value\n * @type {typeof import('./data-utils').defaultFormatter}\n */\n\nvar defaultFormatter = function defaultFormatter(v) {\n  return notNullorUndefined(v) ? String(v) : '';\n};\nexports.defaultFormatter = defaultFormatter;\nvar FIELD_DISPLAY_FORMAT = (_FIELD_DISPLAY_FORMAT = {}, (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.string, defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.timestamp, defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.integer, defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.real, defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES[\"boolean\"], defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.date, defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _defaultSettings.ALL_FIELD_TYPES.geojson, function (d) {\n  return typeof d === 'string' ? d : isPlainObject(d) ? JSON.stringify(d) : Array.isArray(d) ? \"[\".concat(String(d), \"]\") : '';\n}), _FIELD_DISPLAY_FORMAT);\n/**\n * Parse field value and type and return a string representation\n * @type {typeof import('./data-utils').parseFieldValue}\n */\n\nexports.FIELD_DISPLAY_FORMAT = FIELD_DISPLAY_FORMAT;\nvar parseFieldValue = function parseFieldValue(value, type) {\n  if (!notNullorUndefined(value)) {\n    return '';\n  }\n  return FIELD_DISPLAY_FORMAT[type] ? FIELD_DISPLAY_FORMAT[type](value) : String(value);\n};\nexports.parseFieldValue = parseFieldValue;\nvar arrayMoveMutate = function arrayMoveMutate(array, from, to) {\n  array.splice(to < 0 ? array.length + to : to, 0, array.splice(from, 1)[0]);\n};\n/**\n *\n * @param {*} array\n * @param {*} from\n * @param {*} to\n */\n\nvar arrayMove = function arrayMove(array, from, to) {\n  array = array.slice();\n  arrayMoveMutate(array, from, to);\n  return array;\n};\n/**\n * Get the value format based on field and format options\n * Used in render tooltip value\n * @type {typeof import('./data-utils').getFormatter}\n * @param format\n * @param field\n */\n\nexports.arrayMove = arrayMove;\nfunction getFormatter(format, field) {\n  if (!format) {\n    return defaultFormatter;\n  }\n  var tooltipFormat = Object.values(_tooltip.TOOLTIP_FORMATS).find(function (f) {\n    return f[_tooltip.TOOLTIP_KEY] === format;\n  });\n  if (tooltipFormat) {\n    return applyDefaultFormat(tooltipFormat);\n  } else if (typeof format === 'string' && field) {\n    return applyCustomFormat(format, field);\n  }\n  return defaultFormatter;\n}\nfunction applyDefaultFormat(tooltipFormat) {\n  if (!tooltipFormat || !tooltipFormat.format) {\n    return defaultFormatter;\n  }\n  switch (tooltipFormat.type) {\n    case _tooltip.TOOLTIP_FORMAT_TYPES.DECIMAL:\n      return (0, _d3Format.format)(tooltipFormat.format);\n    case _tooltip.TOOLTIP_FORMAT_TYPES.DATE:\n    case _tooltip.TOOLTIP_FORMAT_TYPES.DATE_TIME:\n      return datetimeFormatter(null)(tooltipFormat.format);\n    case _tooltip.TOOLTIP_FORMAT_TYPES.PERCENTAGE:\n      return function (v) {\n        return \"\".concat((0, _d3Format.format)(_tooltip.TOOLTIP_FORMATS.DECIMAL_DECIMAL_FIXED_2.format)(v), \"%\");\n      };\n    case _tooltip.TOOLTIP_FORMAT_TYPES.BOOLEAN:\n      return getBooleanFormatter(tooltipFormat.format);\n    default:\n      return defaultFormatter;\n  }\n}\nfunction getBooleanFormatter(format) {\n  switch (format) {\n    case '01':\n      return function (v) {\n        return v ? '1' : '0';\n      };\n    case 'yn':\n      return function (v) {\n        return v ? 'yes' : 'no';\n      };\n    default:\n      return defaultFormatter;\n  }\n} // Allow user to specify custom tooltip format via config\n\nfunction applyCustomFormat(format, field) {\n  switch (field.type) {\n    case _defaultSettings.ALL_FIELD_TYPES.real:\n    case _defaultSettings.ALL_FIELD_TYPES.integer:\n      return (0, _d3Format.format)(format);\n    case _defaultSettings.ALL_FIELD_TYPES.date:\n    case _defaultSettings.ALL_FIELD_TYPES.timestamp:\n      return datetimeFormatter(null)(format);\n    default:\n      return function (v) {\n        return v;\n      };\n  }\n}\n/**\n * Format epoch milliseconds with a format string\n * @type {typeof import('./data-utils').datetimeFormatter} timezone\n */\n\nfunction datetimeFormatter(timezone) {\n  return timezone ? function (format) {\n    return function (ts) {\n      return _momentTimezone[\"default\"].utc(ts).tz(timezone).format(format);\n    };\n  } : function (format) {\n    return function (ts) {\n      return _momentTimezone[\"default\"].utc(ts).format(format);\n    };\n  };\n}","map":{"version":3,"sources":["../../src/utils/data-utils.js"],"names":["MAX_LATITUDE","MIN_LATITUDE","MAX_LONGITUDE","MIN_LONGITUDE","unique","values","results","uniqueSet","Set","forEach","notNullorUndefined","v","push","findMapBounds","layers","availableLayerBounds","reduce","res","l","meta","bounds","length","newBounds","b","Math","min","max","getLatLngBounds","points","idx","limit","lats","map","Array","isArray","d","filter","Number","isFinite","sort","numberSort","clamp","val","getSampleData","data","sampleSize","getValue","sampleStep","floor","output","i","timeToUnixMilli","value","format","moment","utc","valueOf","maybeToDate","isTime","fieldIdx","dc","valueAt","index","undefined","isNumber","isPlainObject","obj","Object","a","getSortingFunction","fieldType","ALL_FIELD_TYPES","real","integer","timestamp","preciseRound","num","decimals","t","pow","round","sign","toFixed","getRoundingDecimalFromStep","step","isNaN","splitZero","toString","split","snapToMarks","marks","normalizeSliderValue","minValue","roundValToStep","decimal","steps","remain","closest","rounded","defaultFormatter","String","FIELD_DISPLAY_FORMAT","string","date","geojson","JSON","stringify","parseFieldValue","type","arrayMoveMutate","array","from","to","splice","arrayMove","slice","getFormatter","field","tooltipFormat","TOOLTIP_FORMATS","find","f","TOOLTIP_KEY","applyDefaultFormat","applyCustomFormat","TOOLTIP_FORMAT_TYPES","DECIMAL","DATE","DATE_TIME","datetimeFormatter","PERCENTAGE","DECIMAL_DECIMAL_FIXED_2","BOOLEAN","getBooleanFormatter","timezone","ts","tz"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport assert from 'assert';\nimport {ALL_FIELD_TYPES} from 'constants/default-settings';\nimport {TOOLTIP_FORMATS, TOOLTIP_FORMAT_TYPES, TOOLTIP_KEY} from 'constants/tooltip';\nimport {format as d3Format} from 'd3-format';\nimport {bisectLeft} from 'd3-array';\nimport moment from 'moment-timezone';\n\nconst MAX_LATITUDE = 90;\nconst MIN_LATITUDE = -90;\nconst MAX_LONGITUDE = 180;\nconst MIN_LONGITUDE = -180;\n\n/**\n * simple getting unique values of an array\n *\n * @param {array} values\n * @returns {array} unique values\n */\nexport function unique(values) {\n  const results = [];\n  const uniqueSet = new Set(values);\n  uniqueSet.forEach(v => {\n    if (notNullorUndefined(v)) {\n      results.push(v);\n    }\n  });\n  return results;\n}\n\n/* eslint-disable max-statements */\n/**\n * return center of map from given points\n * @param {array} layers\n * @returns {object} coordinates of map center, empty if not found\n */\nexport function findMapBounds(layers) {\n  // find bounds in formatted layerData\n  // take ALL layers into account when finding map bounds\n  const availableLayerBounds = layers.reduce((res, l) => {\n    if (l.meta && l.meta.bounds) {\n      res.push(l.meta.bounds);\n    }\n    return res;\n  }, []);\n  // return null if no layer is available\n  if (availableLayerBounds.length === 0) {\n    return null;\n  }\n  // merge bounds in each layer\n  const newBounds = availableLayerBounds.reduce(\n    (res, b) => {\n      return [\n        Math.min(res[0], b[0]),\n        Math.min(res[1], b[1]),\n        Math.max(res[2], b[2]),\n        Math.max(res[3], b[3])\n      ];\n    },\n    [MAX_LONGITUDE, MAX_LATITUDE, MIN_LONGITUDE, MIN_LATITUDE]\n  );\n  return newBounds;\n}\n/* eslint-enable max-statements */\n\nexport function getLatLngBounds(points, idx, limit) {\n  const lats = points\n    .map(d => Array.isArray(d) && d[idx])\n    .filter(Number.isFinite)\n    .sort(numberSort);\n\n  if (!lats.length) {\n    return null;\n  }\n\n  // clamp to limit\n  return [Math.max(lats[0], limit[0]), Math.min(lats[lats.length - 1], limit[1])];\n}\n\nexport function clamp([min, max], val) {\n  return val <= min ? min : val >= max ? max : val;\n}\n\nexport function getSampleData(data, sampleSize = 500, getValue = d => d) {\n  const sampleStep = Math.max(Math.floor(data.length / sampleSize), 1);\n  const output = [];\n  for (let i = 0; i < data.length; i += sampleStep) {\n    output.push(getValue(data[i]));\n  }\n\n  return output;\n}\n\n/**\n * Convert different time format to unix milliseconds\n * @type {typeof import('./data-utils').timeToUnixMilli}\n */\nexport function timeToUnixMilli(value, format) {\n  if (notNullorUndefined(value)) {\n    return typeof value === 'string'\n      ? moment.utc(value, format).valueOf()\n      : format === 'x'\n      ? value * 1000\n      : value;\n  }\n  return null;\n}\n\n/**\n *\n * @type {typeof import('./data-utils').maybeToDate}\n */\nexport function maybeToDate(isTime, fieldIdx, format, dc, d) {\n  if (isTime) {\n    return timeToUnixMilli(dc.valueAt(d.index, fieldIdx), format);\n  }\n\n  return dc.valueAt(d.index, fieldIdx);\n}\n\n/**\n * whether null or undefined\n * @type {typeof import('./data-utils').notNullorUndefined}\n */\nexport function notNullorUndefined(d) {\n  return d !== undefined && d !== null;\n}\n\n/**\n * Whether d is a number, this filtered out NaN as well\n * @type {typeof import('./data-utils').notNullorUndefined}\n */\nexport function isNumber(d) {\n  return Number.isFinite(d);\n}\n/**\n * whether null or undefined\n */\nexport function isPlainObject(obj) {\n  return obj === Object(obj) && typeof obj !== 'function' && !Array.isArray(obj);\n}\n\n/**\n * @type {typeof import('./data-utils').numberSort}\n */\nexport function numberSort(a, b) {\n  return a - b;\n}\n\n/**\n * @type {typeof import('./data-utils').getSortingFunction}\n */\nexport function getSortingFunction(fieldType) {\n  switch (fieldType) {\n    case ALL_FIELD_TYPES.real:\n    case ALL_FIELD_TYPES.integer:\n    case ALL_FIELD_TYPES.timestamp:\n      return numberSort;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * round number with exact number of decimals\n * return as a string\n * @type {typeof import('./data-utils').preciseRound}\n */\nexport function preciseRound(num, decimals) {\n  const t = Math.pow(10, decimals);\n  return (\n    Math.round(\n      num * t + (decimals > 0 ? 1 : 0) * (Math.sign(num) * (10 / Math.pow(100, decimals)))\n    ) / t\n  ).toFixed(decimals);\n}\n\n/**\n * get number of decimals to round to for slider from step\n * @param {number} step\n * @returns {number} - number of decimal\n */\nexport function getRoundingDecimalFromStep(step) {\n  if (isNaN(step)) {\n    assert('step is not a number');\n    assert(step);\n  }\n\n  const splitZero = step.toString().split('.');\n  if (splitZero.length === 1) {\n    return 0;\n  }\n  return splitZero[1].length;\n}\n\n/**\n * Use in slider, given a number and an array of numbers, return the nears number from the array\n * @type {typeof import('./data-utils').snapToMarks}\n * @param value\n * @param marks\n */\nexport function snapToMarks(value, marks) {\n  // always use bin x0\n  const i = bisectLeft(marks, value);\n  if (i === 0) {\n    return marks[i];\n  } else if (i === marks.length) {\n    return marks[i - 1];\n  }\n  const idx = marks[i] - value < value - marks[i - 1] ? i : i - 1;\n  return marks[idx];\n}\n\n/**\n * If marks is provided, snap to marks, if not normalize to step\n * @type {typeof import('./data-utils').normalizeSliderValue}\n * @param val\n * @param minValue\n * @param step\n * @param marks\n */\nexport function normalizeSliderValue(val, minValue, step, marks) {\n  if (marks && marks.length) {\n    return snapToMarks(val, marks);\n  }\n\n  return roundValToStep(minValue, step, val);\n}\n\n/**\n * round the value to step for the slider\n * @type {typeof import('./data-utils').roundValToStep}\n * @param minValue\n * @param step\n * @param val\n * @returns - rounded number\n */\nexport function roundValToStep(minValue, step, val) {\n  if (!isNumber(step) || !isNumber(minValue)) {\n    return val;\n  }\n\n  const decimal = getRoundingDecimalFromStep(step);\n  const steps = Math.floor((val - minValue) / step);\n  let remain = val - (steps * step + minValue);\n\n  // has to round because javascript turns 0.1 into 0.9999999999999987\n  remain = Number(preciseRound(remain, 8));\n\n  let closest;\n  if (remain === 0) {\n    closest = val;\n  } else if (remain < step / 2) {\n    closest = steps * step + minValue;\n  } else {\n    closest = (steps + 1) * step + minValue;\n  }\n\n  // precise round return a string rounded to the defined decimal\n  const rounded = preciseRound(closest, decimal);\n\n  return Number(rounded);\n}\n\n/**\n * Get the value format based on field and format options\n * Used in render tooltip value\n * @type {typeof import('./data-utils').defaultFormatter}\n */\nexport const defaultFormatter = v => (notNullorUndefined(v) ? String(v) : '');\n\nexport const FIELD_DISPLAY_FORMAT = {\n  [ALL_FIELD_TYPES.string]: defaultFormatter,\n  [ALL_FIELD_TYPES.timestamp]: defaultFormatter,\n  [ALL_FIELD_TYPES.integer]: defaultFormatter,\n  [ALL_FIELD_TYPES.real]: defaultFormatter,\n  [ALL_FIELD_TYPES.boolean]: defaultFormatter,\n  [ALL_FIELD_TYPES.date]: defaultFormatter,\n  [ALL_FIELD_TYPES.geojson]: d =>\n    typeof d === 'string'\n      ? d\n      : isPlainObject(d)\n      ? JSON.stringify(d)\n      : Array.isArray(d)\n      ? `[${String(d)}]`\n      : ''\n};\n\n/**\n * Parse field value and type and return a string representation\n * @type {typeof import('./data-utils').parseFieldValue}\n */\nexport const parseFieldValue = (value, type) => {\n  if (!notNullorUndefined(value)) {\n    return '';\n  }\n\n  return FIELD_DISPLAY_FORMAT[type] ? FIELD_DISPLAY_FORMAT[type](value) : String(value);\n};\n\nconst arrayMoveMutate = (array, from, to) => {\n  array.splice(to < 0 ? array.length + to : to, 0, array.splice(from, 1)[0]);\n};\n\n/**\n *\n * @param {*} array\n * @param {*} from\n * @param {*} to\n */\nexport const arrayMove = (array, from, to) => {\n  array = array.slice();\n  arrayMoveMutate(array, from, to);\n  return array;\n};\n\n/**\n * Get the value format based on field and format options\n * Used in render tooltip value\n * @type {typeof import('./data-utils').getFormatter}\n * @param format\n * @param field\n */\nexport function getFormatter(format, field) {\n  if (!format) {\n    return defaultFormatter;\n  }\n  const tooltipFormat = Object.values(TOOLTIP_FORMATS).find(f => f[TOOLTIP_KEY] === format);\n\n  if (tooltipFormat) {\n    return applyDefaultFormat(tooltipFormat);\n  } else if (typeof format === 'string' && field) {\n    return applyCustomFormat(format, field);\n  }\n\n  return defaultFormatter;\n}\n\nexport function applyDefaultFormat(tooltipFormat) {\n  if (!tooltipFormat || !tooltipFormat.format) {\n    return defaultFormatter;\n  }\n\n  switch (tooltipFormat.type) {\n    case TOOLTIP_FORMAT_TYPES.DECIMAL:\n      return d3Format(tooltipFormat.format);\n    case TOOLTIP_FORMAT_TYPES.DATE:\n    case TOOLTIP_FORMAT_TYPES.DATE_TIME:\n      return datetimeFormatter(null)(tooltipFormat.format);\n    case TOOLTIP_FORMAT_TYPES.PERCENTAGE:\n      return v => `${d3Format(TOOLTIP_FORMATS.DECIMAL_DECIMAL_FIXED_2.format)(v)}%`;\n    case TOOLTIP_FORMAT_TYPES.BOOLEAN:\n      return getBooleanFormatter(tooltipFormat.format);\n    default:\n      return defaultFormatter;\n  }\n}\n\nexport function getBooleanFormatter(format) {\n  switch (format) {\n    case '01':\n      return v => (v ? '1' : '0');\n    case 'yn':\n      return v => (v ? 'yes' : 'no');\n    default:\n      return defaultFormatter;\n  }\n}\n// Allow user to specify custom tooltip format via config\nexport function applyCustomFormat(format, field) {\n  switch (field.type) {\n    case ALL_FIELD_TYPES.real:\n    case ALL_FIELD_TYPES.integer:\n      return d3Format(format);\n    case ALL_FIELD_TYPES.date:\n    case ALL_FIELD_TYPES.timestamp:\n      return datetimeFormatter(null)(format);\n    default:\n      return v => v;\n  }\n}\n\n/**\n * Format epoch milliseconds with a format string\n * @type {typeof import('./data-utils').datetimeFormatter} timezone\n */\nexport function datetimeFormatter(timezone) {\n  return timezone\n    ? format => ts =>\n        moment\n          .utc(ts)\n          .tz(timezone)\n          .format(format)\n    : format => ts => moment.utc(ts).format(format);\n}\n"]},"metadata":{},"sourceType":"script"}