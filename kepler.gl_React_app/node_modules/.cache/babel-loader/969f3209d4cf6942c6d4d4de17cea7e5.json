{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeFilters = mergeFilters;\nexports.createLayerFromConfig = createLayerFromConfig;\nexports.serializeLayer = serializeLayer;\nexports.mergeLayers = mergeLayers;\nexports.insertLayerAtRightOrder = insertLayerAtRightOrder;\nexports.mergeInteractions = mergeInteractions;\nexports.mergeSplitMaps = mergeSplitMaps;\nexports.mergeInteractionTooltipConfig = mergeInteractionTooltipConfig;\nexports.mergeLayerBlending = mergeLayerBlending;\nexports.mergeAnimationConfig = mergeAnimationConfig;\nexports.validateSavedLayerColumns = validateSavedLayerColumns;\nexports.validateColumn = validateColumn;\nexports.validateSavedTextLabel = validateSavedTextLabel;\nexports.validateSavedVisualChannels = validateSavedVisualChannels;\nexports.validateLayersByDatasets = validateLayersByDatasets;\nexports.validateLayerWithData = validateLayerWithData;\nexports.isValidMerger = isValidMerger;\nexports.VIS_STATE_MERGERS = void 0;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.uniq\"));\nvar _lodash2 = _interopRequireDefault(require(\"lodash.pick\"));\nvar _lodash3 = _interopRequireDefault(require(\"lodash.flattendeep\"));\nvar _utils = require(\"../utils/utils\");\nvar _filterUtils = require(\"../utils/filter-utils\");\nvar _splitMapUtils = require(\"../utils/split-map-utils\");\nvar _gpuFilterUtils = require(\"../utils/gpu-filter-utils\");\nvar _defaultSettings = require(\"../constants/default-settings\");\nvar _schemas = require(\"../schemas\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n/**\n * Merge loaded filters with current state, if no fields or data are loaded\n * save it for later\n *\n * @type {typeof import('./vis-state-merger').mergeFilters}\n */\nfunction mergeFilters(state, filtersToMerge) {\n  if (!Array.isArray(filtersToMerge) || !filtersToMerge.length) {\n    return state;\n  }\n  var _validateFiltersUpdat = (0, _filterUtils.validateFiltersUpdateDatasets)(state, filtersToMerge),\n    validated = _validateFiltersUpdat.validated,\n    failed = _validateFiltersUpdat.failed,\n    updatedDatasets = _validateFiltersUpdat.updatedDatasets; // merge filter with existing\n\n  var updatedFilters = [].concat((0, _toConsumableArray2[\"default\"])(state.filters || []), (0, _toConsumableArray2[\"default\"])(validated));\n  updatedFilters = (0, _gpuFilterUtils.resetFilterGpuMode)(updatedFilters);\n  updatedFilters = (0, _gpuFilterUtils.assignGpuChannels)(updatedFilters); // filter data\n\n  var datasetsToFilter = (0, _lodash[\"default\"])((0, _lodash3[\"default\"])(validated.map(function (f) {\n    return f.dataId;\n  })));\n  var filtered = (0, _filterUtils.applyFiltersToDatasets)(datasetsToFilter, updatedDatasets, updatedFilters, state.layers);\n  return _objectSpread(_objectSpread({}, state), {}, {\n    filters: updatedFilters,\n    datasets: filtered,\n    filterToBeMerged: [].concat((0, _toConsumableArray2[\"default\"])(state.filterToBeMerged), (0, _toConsumableArray2[\"default\"])(failed))\n  });\n}\nfunction createLayerFromConfig(state, layerConfig) {\n  // first validate config against dataset\n  var _validateLayersByData = validateLayersByDatasets(state.datasets, state.layerClasses, [layerConfig]),\n    validated = _validateLayersByData.validated,\n    failed = _validateLayersByData.failed;\n  if (failed.length || !validated.length) {\n    // failed\n    return null;\n  }\n  var newLayer = validated[0];\n  newLayer.updateLayerDomain(state.datasets);\n  return newLayer;\n}\nfunction serializeLayer(newLayer) {\n  var savedVisState = _schemas.visStateSchema[_schemas.CURRENT_VERSION].save({\n    layers: [newLayer],\n    layerOrder: [0]\n  }).visState;\n  var loadedLayer = _schemas.visStateSchema[_schemas.CURRENT_VERSION].load(savedVisState).visState.layers[0];\n  return loadedLayer;\n}\n/**\n * Merge layers from de-serialized state, if no fields or data are loaded\n * save it for later\n *\n * @type {typeof import('./vis-state-merger').mergeLayers}\n */\n\nfunction mergeLayers(state, layersToMerge, fromConfig) {\n  var preserveLayerOrder = fromConfig ? layersToMerge.map(function (l) {\n    return l.id;\n  }) : state.preserveLayerOrder;\n  if (!Array.isArray(layersToMerge) || !layersToMerge.length) {\n    return state;\n  }\n  var _validateLayersByData2 = validateLayersByDatasets(state.datasets, state.layerClasses, layersToMerge),\n    mergedLayer = _validateLayersByData2.validated,\n    unmerged = _validateLayersByData2.failed; // put new layers in front of current layers\n\n  var _insertLayerAtRightOr = insertLayerAtRightOrder(state.layers, mergedLayer, state.layerOrder, preserveLayerOrder),\n    newLayerOrder = _insertLayerAtRightOr.newLayerOrder,\n    newLayers = _insertLayerAtRightOr.newLayers;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    layers: newLayers,\n    layerOrder: newLayerOrder,\n    preserveLayerOrder: preserveLayerOrder,\n    layerToBeMerged: [].concat((0, _toConsumableArray2[\"default\"])(state.layerToBeMerged), (0, _toConsumableArray2[\"default\"])(unmerged))\n  });\n}\nfunction insertLayerAtRightOrder(currentLayers, layersToInsert, currentOrder) {\n  var preservedOrder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  // perservedOrder ['a', 'b', 'c'];\n  // layerOrder [1, 0, 3]\n  // layerOrderMap ['a', 'c']\n  var layerOrderQueue = currentOrder.map(function (i) {\n    return currentLayers[i].id;\n  });\n  var newLayers = currentLayers;\n  var _iterator = _createForOfIteratorHelper(layersToInsert),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var newLayer = _step.value;\n      // find where to insert it\n      var expectedIdx = preservedOrder.indexOf(newLayer.id); // if cant find place to insert, insert at the font\n\n      var insertAt = 0;\n      if (expectedIdx > 0) {\n        // look for layer to insert after\n        var i = expectedIdx + 1;\n        var preceedIdx = null;\n        while (i-- > 0 && preceedIdx === null) {\n          var preceedLayer = preservedOrder[expectedIdx - 1];\n          preceedIdx = layerOrderQueue.indexOf(preceedLayer);\n        }\n        if (preceedIdx > -1) {\n          insertAt = preceedIdx + 1;\n        }\n      }\n      layerOrderQueue = (0, _utils.arrayInsert)(layerOrderQueue, insertAt, newLayer.id);\n      newLayers = newLayers.concat(newLayer);\n    } // reconstruct layerOrder after insert\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var newLayerOrder = layerOrderQueue.map(function (id) {\n    return newLayers.findIndex(function (l) {\n      return l.id === id;\n    });\n  });\n  return {\n    newLayerOrder: newLayerOrder,\n    newLayers: newLayers\n  };\n}\n/**\n * Merge interactions with saved config\n *\n * @type {typeof import('./vis-state-merger').mergeInteractions}\n */\n\nfunction mergeInteractions(state, interactionToBeMerged) {\n  var merged = {};\n  var unmerged = {};\n  if (interactionToBeMerged) {\n    Object.keys(interactionToBeMerged).forEach(function (key) {\n      if (!state.interactionConfig[key]) {\n        return;\n      }\n      var currentConfig = state.interactionConfig[key].config;\n      var _ref = interactionToBeMerged[key] || {},\n        enabled = _ref.enabled,\n        configSaved = (0, _objectWithoutProperties2[\"default\"])(_ref, [\"enabled\"]);\n      var configToMerge = configSaved;\n      if (key === 'tooltip') {\n        var _mergeInteractionTool = mergeInteractionTooltipConfig(state, configSaved),\n          mergedTooltip = _mergeInteractionTool.mergedTooltip,\n          unmergedTooltip = _mergeInteractionTool.unmergedTooltip; // merge new dataset tooltips with original dataset tooltips\n\n        configToMerge = {\n          fieldsToShow: _objectSpread(_objectSpread({}, currentConfig.fieldsToShow), mergedTooltip)\n        };\n        if (Object.keys(unmergedTooltip).length) {\n          unmerged.tooltip = {\n            fieldsToShow: unmergedTooltip,\n            enabled: enabled\n          };\n        }\n      }\n      merged[key] = _objectSpread(_objectSpread({}, state.interactionConfig[key]), {}, {\n        enabled: enabled\n      }, currentConfig ? {\n        config: (0, _lodash2[\"default\"])(_objectSpread(_objectSpread({}, currentConfig), configToMerge), Object.keys(currentConfig))\n      } : {});\n    });\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    interactionConfig: _objectSpread(_objectSpread({}, state.interactionConfig), merged),\n    interactionToBeMerged: unmerged\n  });\n}\n/**\n * Merge splitMaps config with current visStete.\n * 1. if current map is split, but splitMap DOESNOT contain maps\n *    : don't merge anything\n * 2. if current map is NOT split, but splitMaps contain maps\n *    : add to splitMaps, and add current layers to splitMaps\n * @type {typeof import('./vis-state-merger').mergeInteractions}\n */\n\nfunction mergeSplitMaps(state) {\n  var splitMaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var merged = (0, _toConsumableArray2[\"default\"])(state.splitMaps);\n  var unmerged = [];\n  splitMaps.forEach(function (sm, i) {\n    Object.entries(sm.layers).forEach(function (_ref2) {\n      var _ref3 = (0, _slicedToArray2[\"default\"])(_ref2, 2),\n        id = _ref3[0],\n        value = _ref3[1];\n\n      // check if layer exists\n      var pushTo = state.layers.find(function (l) {\n        return l.id === id;\n      }) ? merged : unmerged; // create map panel if current map is not split\n\n      pushTo[i] = pushTo[i] || {\n        layers: pushTo === merged ? (0, _splitMapUtils.getInitialMapLayersForSplitMap)(state.layers) : []\n      };\n      pushTo[i].layers = _objectSpread(_objectSpread({}, pushTo[i].layers), {}, (0, _defineProperty2[\"default\"])({}, id, value));\n    });\n  });\n  return _objectSpread(_objectSpread({}, state), {}, {\n    splitMaps: merged,\n    splitMapsToBeMerged: [].concat((0, _toConsumableArray2[\"default\"])(state.splitMapsToBeMerged), unmerged)\n  });\n}\n/**\n * Merge interactionConfig.tooltip with saved config,\n * validate fieldsToShow\n *\n * @param {object} state\n * @param {object} tooltipConfig\n * @return {object} - {mergedTooltip: {}, unmergedTooltip: {}}\n */\n\nfunction mergeInteractionTooltipConfig(state) {\n  var tooltipConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var unmergedTooltip = {};\n  var mergedTooltip = {};\n  if (!tooltipConfig.fieldsToShow || !Object.keys(tooltipConfig.fieldsToShow).length) {\n    return {\n      mergedTooltip: mergedTooltip,\n      unmergedTooltip: unmergedTooltip\n    };\n  }\n  for (var dataId in tooltipConfig.fieldsToShow) {\n    if (!state.datasets[dataId]) {\n      // is not yet loaded\n      unmergedTooltip[dataId] = tooltipConfig.fieldsToShow[dataId];\n    } else {\n      (function () {\n        // if dataset is loaded\n        var allFields = state.datasets[dataId].fields.map(function (d) {\n          return d.name;\n        });\n        var foundFieldsToShow = tooltipConfig.fieldsToShow[dataId].filter(function (field) {\n          return allFields.includes(field.name);\n        });\n        mergedTooltip[dataId] = foundFieldsToShow;\n      })();\n    }\n  }\n  return {\n    mergedTooltip: mergedTooltip,\n    unmergedTooltip: unmergedTooltip\n  };\n}\n/**\n * Merge layerBlending with saved\n *\n * @type {typeof import('./vis-state-merger').mergeLayerBlending}\n */\n\nfunction mergeLayerBlending(state, layerBlending) {\n  if (layerBlending && _defaultSettings.LAYER_BLENDINGS[layerBlending]) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      layerBlending: layerBlending\n    });\n  }\n  return state;\n}\n/**\n * Merge animation config\n * @type {typeof import('./vis-state-merger').mergeAnimationConfig}\n */\n\nfunction mergeAnimationConfig(state, animation) {\n  if (animation && animation.currentTime) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      animationConfig: _objectSpread(_objectSpread(_objectSpread({}, state.animationConfig), animation), {}, {\n        domain: null\n      })\n    });\n  }\n  return state;\n}\n/**\n * Validate saved layer columns with new data,\n * update fieldIdx based on new fields\n *\n * @param {Array<Object>} fields\n * @param {Object} savedCols\n * @param {Object} emptyCols\n * @return {null | Object} - validated columns or null\n */\n\nfunction validateSavedLayerColumns(fields) {\n  var savedCols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var emptyCols = arguments.length > 2 ? arguments[2] : undefined;\n  // Prepare columns for the validator\n  var columns = {};\n  var _loop = function _loop() {\n    var key = _Object$keys[_i];\n    columns[key] = _objectSpread({}, emptyCols[key]);\n    var saved = savedCols[key];\n    if (saved) {\n      var fieldIdx = fields.findIndex(function (_ref4) {\n        var name = _ref4.name;\n        return name === saved;\n      });\n      if (fieldIdx > -1) {\n        // update found columns\n        columns[key].fieldIdx = fieldIdx;\n        columns[key].value = saved;\n      }\n    }\n  };\n  for (var _i = 0, _Object$keys = Object.keys(emptyCols); _i < _Object$keys.length; _i++) {\n    _loop();\n  } // find actual column fieldIdx, in case it has changed\n\n  var allColFound = Object.keys(columns).every(function (key) {\n    return validateColumn(columns[key], columns, fields);\n  });\n  if (allColFound) {\n    return columns;\n  }\n  return null;\n}\nfunction validateColumn(column, columns, allFields) {\n  if (column.optional || column.value) {\n    return true;\n  }\n  if (column.validator) {\n    return column.validator(column, columns, allFields);\n  }\n  return false;\n}\n/**\n * Validate saved text label config with new data\n * refer to vis-state-schema.js TextLabelSchemaV1\n *\n * @param {Array<Object>} fields\n * @param {Object} savedTextLabel\n * @return {Object} - validated textlabel\n */\n\nfunction validateSavedTextLabel(fields, _ref5, savedTextLabel) {\n  var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 1),\n    layerTextLabel = _ref6[0];\n  var savedTextLabels = Array.isArray(savedTextLabel) ? savedTextLabel : [savedTextLabel]; // validate field\n\n  return savedTextLabels.map(function (textLabel) {\n    var field = textLabel.field ? fields.find(function (fd) {\n      return Object.keys(textLabel.field).every(function (key) {\n        return textLabel.field[key] === fd[key];\n      });\n    }) : null;\n    return Object.keys(layerTextLabel).reduce(function (accu, key) {\n      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, key === 'field' ? field : textLabel[key] || layerTextLabel[key]));\n    }, {});\n  });\n}\n/**\n * Validate saved visual channels config with new data,\n * refer to vis-state-schema.js VisualChannelSchemaV1\n * @type {typeof import('./vis-state-merger').validateSavedVisualChannels}\n */\n\nfunction validateSavedVisualChannels(fields, newLayer, savedLayer) {\n  Object.values(newLayer.visualChannels).forEach(function (_ref7) {\n    var field = _ref7.field,\n      scale = _ref7.scale,\n      key = _ref7.key;\n    var foundField;\n    if (savedLayer.config) {\n      if (savedLayer.config[field]) {\n        foundField = fields.find(function (fd) {\n          return savedLayer.config && fd.name === savedLayer.config[field].name;\n        });\n      }\n      var foundChannel = _objectSpread(_objectSpread({}, foundField ? (0, _defineProperty2[\"default\"])({}, field, foundField) : {}), savedLayer.config[scale] ? (0, _defineProperty2[\"default\"])({}, scale, savedLayer.config[scale]) : {});\n      if (Object.keys(foundChannel).length) {\n        newLayer.updateLayerConfig(foundChannel);\n      }\n      newLayer.validateVisualChannel(key);\n    }\n  });\n  return newLayer;\n}\nfunction validateLayersByDatasets(datasets, layerClasses, layers) {\n  var validated = [];\n  var failed = [];\n  layers.forEach(function (layer) {\n    var validateLayer;\n    if (!layer || !layer.config) {\n      validateLayer = null;\n    } else if (datasets[layer.config.dataId]) {\n      // datasets are already loaded\n      validateLayer = validateLayerWithData(datasets[layer.config.dataId], layer, layerClasses);\n    }\n    if (validateLayer) {\n      validated.push(validateLayer);\n    } else {\n      // datasets not yet loaded\n      failed.push(layer);\n    }\n  });\n  return {\n    validated: validated,\n    failed: failed\n  };\n}\n/**\n * Validate saved layer config with new data,\n * update fieldIdx based on new fields\n * @type {typeof import('./vis-state-merger').validateLayerWithData}\n */\n\nfunction validateLayerWithData(_ref10, savedLayer, layerClasses) {\n  var fields = _ref10.fields,\n    dataId = _ref10.id;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var type = savedLayer.type; // layer doesnt have a valid type\n\n  if (!type || !layerClasses.hasOwnProperty(type) || !savedLayer.config) {\n    return null;\n  }\n  var newLayer = new layerClasses[type]({\n    id: savedLayer.id,\n    dataId: dataId,\n    label: savedLayer.config.label,\n    color: savedLayer.config.color,\n    isVisible: savedLayer.config.isVisible,\n    hidden: savedLayer.config.hidden,\n    highlightColor: savedLayer.config.highlightColor\n  }); // find column fieldIdx\n\n  var columnConfig = newLayer.getLayerColumns();\n  if (Object.keys(columnConfig).length) {\n    var columns = validateSavedLayerColumns(fields, savedLayer.config.columns, columnConfig);\n    if (columns) {\n      newLayer.updateLayerConfig({\n        columns: columns\n      });\n    } else if (!options.allowEmptyColumn) {\n      return null;\n    }\n  } // visual channel field is saved to be {name, type}\n  // find visual channel field by matching both name and type\n  // refer to vis-state-schema.js VisualChannelSchemaV1\n\n  newLayer = validateSavedVisualChannels(fields, newLayer, savedLayer);\n  var textLabel = savedLayer.config.textLabel && newLayer.config.textLabel ? validateSavedTextLabel(fields, newLayer.config.textLabel, savedLayer.config.textLabel) : newLayer.config.textLabel; // copy visConfig over to emptyLayer to make sure it has all the props\n\n  var visConfig = newLayer.copyLayerConfig(newLayer.config.visConfig, savedLayer.config.visConfig || {}, {\n    shallowCopy: ['colorRange', 'strokeColorRange']\n  });\n  newLayer.updateLayerConfig({\n    visConfig: visConfig,\n    textLabel: textLabel\n  });\n  return newLayer;\n}\nfunction isValidMerger(merger) {\n  return (0, _utils.isObject)(merger) && typeof merger.merge === 'function' && typeof merger.prop === 'string';\n}\nvar VIS_STATE_MERGERS = [{\n  merge: mergeLayers,\n  prop: 'layers',\n  toMergeProp: 'layerToBeMerged'\n}, {\n  merge: mergeFilters,\n  prop: 'filters',\n  toMergeProp: 'filterToBeMerged'\n}, {\n  merge: mergeInteractions,\n  prop: 'interactionConfig',\n  toMergeProp: 'interactionToBeMerged'\n}, {\n  merge: mergeLayerBlending,\n  prop: 'layerBlending'\n}, {\n  merge: mergeSplitMaps,\n  prop: 'splitMaps',\n  toMergeProp: 'splitMapsToBeMerged'\n}, {\n  merge: mergeAnimationConfig,\n  prop: 'animationConfig'\n}];\nexports.VIS_STATE_MERGERS = VIS_STATE_MERGERS;","map":{"version":3,"sources":["../../src/reducers/vis-state-merger.js"],"names":["mergeFilters","state","filtersToMerge","Array","isArray","length","validated","failed","updatedDatasets","updatedFilters","filters","datasetsToFilter","map","f","dataId","filtered","layers","datasets","filterToBeMerged","createLayerFromConfig","layerConfig","validateLayersByDatasets","layerClasses","newLayer","updateLayerDomain","serializeLayer","savedVisState","CURRENT_VERSION","save","layerOrder","visState","loadedLayer","visStateSchema","load","mergeLayers","layersToMerge","fromConfig","preserveLayerOrder","l","id","mergedLayer","unmerged","newLayerOrder","newLayers","insertLayerAtRightOrder","layerToBeMerged","currentLayers","layersToInsert","currentOrder","preservedOrder","layerOrderQueue","i","expectedIdx","indexOf","insertAt","preceedIdx","preceedLayer","concat","findIndex","mergeInteractions","interactionToBeMerged","merged","Object","keys","forEach","interactionConfig","key","currentConfig","config","enabled","configSaved","configToMerge","mergedTooltip","unmergedTooltip","mergeInteractionTooltipConfig","fieldsToShow","tooltip","mergeSplitMaps","splitMaps","sm","entries","value","pushTo","find","splitMapsToBeMerged","tooltipConfig","allFields","fields","d","name","foundFieldsToShow","filter","includes","field","mergeLayerBlending","layerBlending","LAYER_BLENDINGS","mergeAnimationConfig","animation","currentTime","animationConfig","domain","validateSavedLayerColumns","savedCols","emptyCols","columns","saved","fieldIdx","allColFound","every","validateColumn","column","optional","validator","validateSavedTextLabel","layerTextLabel","savedTextLabel","savedTextLabels","textLabel","fd","reduce","accu","validateSavedVisualChannels","savedLayer","values","visualChannels","scale","foundField","foundChannel","updateLayerConfig","validateVisualChannel","validateLayer","layer","validateLayerWithData","push","options","type","hasOwnProperty","label","color","isVisible","hidden","highlightColor","columnConfig","getLayerColumns","allowEmptyColumn","visConfig","copyLayerConfig","shallowCopy","isValidMerger","merger","merge","prop","VIS_STATE_MERGERS","toMergeProp"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport uniq from 'lodash.uniq';\nimport pick from 'lodash.pick';\nimport flattenDeep from 'lodash.flattendeep';\nimport {isObject, arrayInsert} from 'utils/utils';\nimport {applyFiltersToDatasets, validateFiltersUpdateDatasets} from 'utils/filter-utils';\n\nimport {getInitialMapLayersForSplitMap} from 'utils/split-map-utils';\nimport {resetFilterGpuMode, assignGpuChannels} from 'utils/gpu-filter-utils';\nimport {LAYER_BLENDINGS} from 'constants/default-settings';\nimport {CURRENT_VERSION, visStateSchema} from 'schemas';\n\n/**\n * Merge loaded filters with current state, if no fields or data are loaded\n * save it for later\n *\n * @type {typeof import('./vis-state-merger').mergeFilters}\n */\nexport function mergeFilters(state, filtersToMerge) {\n  if (!Array.isArray(filtersToMerge) || !filtersToMerge.length) {\n    return state;\n  }\n\n  const {validated, failed, updatedDatasets} = validateFiltersUpdateDatasets(state, filtersToMerge);\n\n  // merge filter with existing\n  let updatedFilters = [...(state.filters || []), ...validated];\n  updatedFilters = resetFilterGpuMode(updatedFilters);\n  updatedFilters = assignGpuChannels(updatedFilters);\n  // filter data\n  const datasetsToFilter = uniq(flattenDeep(validated.map(f => f.dataId)));\n\n  const filtered = applyFiltersToDatasets(\n    datasetsToFilter,\n    updatedDatasets,\n    updatedFilters,\n    state.layers\n  );\n\n  return {\n    ...state,\n    filters: updatedFilters,\n    datasets: filtered,\n    filterToBeMerged: [...state.filterToBeMerged, ...failed]\n  };\n}\n\nexport function createLayerFromConfig(state, layerConfig) {\n  // first validate config against dataset\n  const {validated, failed} = validateLayersByDatasets(state.datasets, state.layerClasses, [\n    layerConfig\n  ]);\n\n  if (failed.length || !validated.length) {\n    // failed\n    return null;\n  }\n\n  const newLayer = validated[0];\n  newLayer.updateLayerDomain(state.datasets);\n  return newLayer;\n}\n\nexport function serializeLayer(newLayer) {\n  const savedVisState = visStateSchema[CURRENT_VERSION].save({\n    layers: [newLayer],\n    layerOrder: [0]\n  }).visState;\n  const loadedLayer = visStateSchema[CURRENT_VERSION].load(savedVisState).visState.layers[0];\n  return loadedLayer;\n}\n\n/**\n * Merge layers from de-serialized state, if no fields or data are loaded\n * save it for later\n *\n * @type {typeof import('./vis-state-merger').mergeLayers}\n */\nexport function mergeLayers(state, layersToMerge, fromConfig) {\n  const preserveLayerOrder = fromConfig ? layersToMerge.map(l => l.id) : state.preserveLayerOrder;\n\n  if (!Array.isArray(layersToMerge) || !layersToMerge.length) {\n    return state;\n  }\n\n  const {validated: mergedLayer, failed: unmerged} = validateLayersByDatasets(\n    state.datasets,\n    state.layerClasses,\n    layersToMerge\n  );\n\n  // put new layers in front of current layers\n  const {newLayerOrder, newLayers} = insertLayerAtRightOrder(\n    state.layers,\n    mergedLayer,\n    state.layerOrder,\n    preserveLayerOrder\n  );\n\n  return {\n    ...state,\n    layers: newLayers,\n    layerOrder: newLayerOrder,\n    preserveLayerOrder,\n    layerToBeMerged: [...state.layerToBeMerged, ...unmerged]\n  };\n}\n\nexport function insertLayerAtRightOrder(\n  currentLayers,\n  layersToInsert,\n  currentOrder,\n  preservedOrder = []\n) {\n  // perservedOrder ['a', 'b', 'c'];\n  // layerOrder [1, 0, 3]\n  // layerOrderMap ['a', 'c']\n  let layerOrderQueue = currentOrder.map(i => currentLayers[i].id);\n  let newLayers = currentLayers;\n\n  for (const newLayer of layersToInsert) {\n    // find where to insert it\n    const expectedIdx = preservedOrder.indexOf(newLayer.id);\n    // if cant find place to insert, insert at the font\n    let insertAt = 0;\n\n    if (expectedIdx > 0) {\n      // look for layer to insert after\n      let i = expectedIdx + 1;\n      let preceedIdx = null;\n      while (i-- > 0 && preceedIdx === null) {\n        const preceedLayer = preservedOrder[expectedIdx - 1];\n        preceedIdx = layerOrderQueue.indexOf(preceedLayer);\n      }\n\n      if (preceedIdx > -1) {\n        insertAt = preceedIdx + 1;\n      }\n    }\n\n    layerOrderQueue = arrayInsert(layerOrderQueue, insertAt, newLayer.id);\n    newLayers = newLayers.concat(newLayer);\n  }\n\n  // reconstruct layerOrder after insert\n  const newLayerOrder = layerOrderQueue.map(id => newLayers.findIndex(l => l.id === id));\n\n  return {\n    newLayerOrder,\n    newLayers\n  };\n}\n\n/**\n * Merge interactions with saved config\n *\n * @type {typeof import('./vis-state-merger').mergeInteractions}\n */\nexport function mergeInteractions(state, interactionToBeMerged) {\n  const merged = {};\n  const unmerged = {};\n\n  if (interactionToBeMerged) {\n    Object.keys(interactionToBeMerged).forEach(key => {\n      if (!state.interactionConfig[key]) {\n        return;\n      }\n\n      const currentConfig = state.interactionConfig[key].config;\n\n      const {enabled, ...configSaved} = interactionToBeMerged[key] || {};\n      let configToMerge = configSaved;\n\n      if (key === 'tooltip') {\n        const {mergedTooltip, unmergedTooltip} = mergeInteractionTooltipConfig(state, configSaved);\n\n        // merge new dataset tooltips with original dataset tooltips\n        configToMerge = {\n          fieldsToShow: {\n            ...currentConfig.fieldsToShow,\n            ...mergedTooltip\n          }\n        };\n\n        if (Object.keys(unmergedTooltip).length) {\n          unmerged.tooltip = {fieldsToShow: unmergedTooltip, enabled};\n        }\n      }\n\n      merged[key] = {\n        ...state.interactionConfig[key],\n        enabled,\n        ...(currentConfig\n          ? {\n              config: pick(\n                {\n                  ...currentConfig,\n                  ...configToMerge\n                },\n                Object.keys(currentConfig)\n              )\n            }\n          : {})\n      };\n    });\n  }\n\n  return {\n    ...state,\n    interactionConfig: {\n      ...state.interactionConfig,\n      ...merged\n    },\n    interactionToBeMerged: unmerged\n  };\n}\n\n/**\n * Merge splitMaps config with current visStete.\n * 1. if current map is split, but splitMap DOESNOT contain maps\n *    : don't merge anything\n * 2. if current map is NOT split, but splitMaps contain maps\n *    : add to splitMaps, and add current layers to splitMaps\n * @type {typeof import('./vis-state-merger').mergeInteractions}\n */\nexport function mergeSplitMaps(state, splitMaps = []) {\n  const merged = [...state.splitMaps];\n  const unmerged = [];\n  splitMaps.forEach((sm, i) => {\n    Object.entries(sm.layers).forEach(([id, value]) => {\n      // check if layer exists\n      const pushTo = state.layers.find(l => l.id === id) ? merged : unmerged;\n\n      // create map panel if current map is not split\n      pushTo[i] = pushTo[i] || {\n        layers: pushTo === merged ? getInitialMapLayersForSplitMap(state.layers) : []\n      };\n      pushTo[i].layers = {\n        ...pushTo[i].layers,\n        [id]: value\n      };\n    });\n  });\n\n  return {\n    ...state,\n    splitMaps: merged,\n    splitMapsToBeMerged: [...state.splitMapsToBeMerged, ...unmerged]\n  };\n}\n\n/**\n * Merge interactionConfig.tooltip with saved config,\n * validate fieldsToShow\n *\n * @param {object} state\n * @param {object} tooltipConfig\n * @return {object} - {mergedTooltip: {}, unmergedTooltip: {}}\n */\nexport function mergeInteractionTooltipConfig(state, tooltipConfig = {}) {\n  const unmergedTooltip = {};\n  const mergedTooltip = {};\n\n  if (!tooltipConfig.fieldsToShow || !Object.keys(tooltipConfig.fieldsToShow).length) {\n    return {mergedTooltip, unmergedTooltip};\n  }\n\n  for (const dataId in tooltipConfig.fieldsToShow) {\n    if (!state.datasets[dataId]) {\n      // is not yet loaded\n      unmergedTooltip[dataId] = tooltipConfig.fieldsToShow[dataId];\n    } else {\n      // if dataset is loaded\n      const allFields = state.datasets[dataId].fields.map(d => d.name);\n      const foundFieldsToShow = tooltipConfig.fieldsToShow[dataId].filter(field =>\n        allFields.includes(field.name)\n      );\n\n      mergedTooltip[dataId] = foundFieldsToShow;\n    }\n  }\n\n  return {mergedTooltip, unmergedTooltip};\n}\n/**\n * Merge layerBlending with saved\n *\n * @type {typeof import('./vis-state-merger').mergeLayerBlending}\n */\nexport function mergeLayerBlending(state, layerBlending) {\n  if (layerBlending && LAYER_BLENDINGS[layerBlending]) {\n    return {\n      ...state,\n      layerBlending\n    };\n  }\n\n  return state;\n}\n\n/**\n * Merge animation config\n * @type {typeof import('./vis-state-merger').mergeAnimationConfig}\n */\nexport function mergeAnimationConfig(state, animation) {\n  if (animation && animation.currentTime) {\n    return {\n      ...state,\n      animationConfig: {\n        ...state.animationConfig,\n        ...animation,\n        domain: null\n      }\n    };\n  }\n\n  return state;\n}\n\n/**\n * Validate saved layer columns with new data,\n * update fieldIdx based on new fields\n *\n * @param {Array<Object>} fields\n * @param {Object} savedCols\n * @param {Object} emptyCols\n * @return {null | Object} - validated columns or null\n */\n\nexport function validateSavedLayerColumns(fields, savedCols = {}, emptyCols) {\n  // Prepare columns for the validator\n  const columns = {};\n  for (const key of Object.keys(emptyCols)) {\n    columns[key] = {...emptyCols[key]};\n\n    const saved = savedCols[key];\n    if (saved) {\n      const fieldIdx = fields.findIndex(({name}) => name === saved);\n\n      if (fieldIdx > -1) {\n        // update found columns\n        columns[key].fieldIdx = fieldIdx;\n        columns[key].value = saved;\n      }\n    }\n  }\n\n  // find actual column fieldIdx, in case it has changed\n  const allColFound = Object.keys(columns).every(key =>\n    validateColumn(columns[key], columns, fields)\n  );\n\n  if (allColFound) {\n    return columns;\n  }\n\n  return null;\n}\n\nexport function validateColumn(column, columns, allFields) {\n  if (column.optional || column.value) {\n    return true;\n  }\n  if (column.validator) {\n    return column.validator(column, columns, allFields);\n  }\n  return false;\n}\n\n/**\n * Validate saved text label config with new data\n * refer to vis-state-schema.js TextLabelSchemaV1\n *\n * @param {Array<Object>} fields\n * @param {Object} savedTextLabel\n * @return {Object} - validated textlabel\n */\nexport function validateSavedTextLabel(fields, [layerTextLabel], savedTextLabel) {\n  const savedTextLabels = Array.isArray(savedTextLabel) ? savedTextLabel : [savedTextLabel];\n\n  // validate field\n  return savedTextLabels.map(textLabel => {\n    const field = textLabel.field\n      ? fields.find(fd =>\n          Object.keys(textLabel.field).every(key => textLabel.field[key] === fd[key])\n        )\n      : null;\n\n    return Object.keys(layerTextLabel).reduce(\n      (accu, key) => ({\n        ...accu,\n        [key]: key === 'field' ? field : textLabel[key] || layerTextLabel[key]\n      }),\n      {}\n    );\n  });\n}\n\n/**\n * Validate saved visual channels config with new data,\n * refer to vis-state-schema.js VisualChannelSchemaV1\n * @type {typeof import('./vis-state-merger').validateSavedVisualChannels}\n */\nexport function validateSavedVisualChannels(fields, newLayer, savedLayer) {\n  Object.values(newLayer.visualChannels).forEach(({field, scale, key}) => {\n    let foundField;\n    if (savedLayer.config) {\n      if (savedLayer.config[field]) {\n        foundField = fields.find(\n          fd => savedLayer.config && fd.name === savedLayer.config[field].name\n        );\n      }\n\n      const foundChannel = {\n        ...(foundField ? {[field]: foundField} : {}),\n        ...(savedLayer.config[scale] ? {[scale]: savedLayer.config[scale]} : {})\n      };\n      if (Object.keys(foundChannel).length) {\n        newLayer.updateLayerConfig(foundChannel);\n      }\n\n      newLayer.validateVisualChannel(key);\n    }\n  });\n  return newLayer;\n}\n\nexport function validateLayersByDatasets(datasets, layerClasses, layers) {\n  const validated = [];\n  const failed = [];\n\n  layers.forEach(layer => {\n    let validateLayer;\n    if (!layer || !layer.config) {\n      validateLayer = null;\n    } else if (datasets[layer.config.dataId]) {\n      // datasets are already loaded\n      validateLayer = validateLayerWithData(datasets[layer.config.dataId], layer, layerClasses);\n    }\n\n    if (validateLayer) {\n      validated.push(validateLayer);\n    } else {\n      // datasets not yet loaded\n      failed.push(layer);\n    }\n  });\n\n  return {validated, failed};\n}\n/**\n * Validate saved layer config with new data,\n * update fieldIdx based on new fields\n * @type {typeof import('./vis-state-merger').validateLayerWithData}\n */\nexport function validateLayerWithData(\n  {fields, id: dataId},\n  savedLayer,\n  layerClasses,\n  options = {}\n) {\n  const {type} = savedLayer;\n  // layer doesnt have a valid type\n  if (!type || !layerClasses.hasOwnProperty(type) || !savedLayer.config) {\n    return null;\n  }\n\n  let newLayer = new layerClasses[type]({\n    id: savedLayer.id,\n    dataId,\n    label: savedLayer.config.label,\n    color: savedLayer.config.color,\n    isVisible: savedLayer.config.isVisible,\n    hidden: savedLayer.config.hidden,\n    highlightColor: savedLayer.config.highlightColor\n  });\n\n  // find column fieldIdx\n  const columnConfig = newLayer.getLayerColumns();\n  if (Object.keys(columnConfig).length) {\n    const columns = validateSavedLayerColumns(fields, savedLayer.config.columns, columnConfig);\n    if (columns) {\n      newLayer.updateLayerConfig({columns});\n    } else if (!options.allowEmptyColumn) {\n      return null;\n    }\n  }\n\n  // visual channel field is saved to be {name, type}\n  // find visual channel field by matching both name and type\n  // refer to vis-state-schema.js VisualChannelSchemaV1\n  newLayer = validateSavedVisualChannels(fields, newLayer, savedLayer);\n\n  const textLabel =\n    savedLayer.config.textLabel && newLayer.config.textLabel\n      ? validateSavedTextLabel(fields, newLayer.config.textLabel, savedLayer.config.textLabel)\n      : newLayer.config.textLabel;\n\n  // copy visConfig over to emptyLayer to make sure it has all the props\n  const visConfig = newLayer.copyLayerConfig(\n    newLayer.config.visConfig,\n    savedLayer.config.visConfig || {},\n    {shallowCopy: ['colorRange', 'strokeColorRange']}\n  );\n\n  newLayer.updateLayerConfig({\n    visConfig,\n    textLabel\n  });\n\n  return newLayer;\n}\n\nexport function isValidMerger(merger) {\n  return isObject(merger) && typeof merger.merge === 'function' && typeof merger.prop === 'string';\n}\n\nexport const VIS_STATE_MERGERS = [\n  {merge: mergeLayers, prop: 'layers', toMergeProp: 'layerToBeMerged'},\n  {merge: mergeFilters, prop: 'filters', toMergeProp: 'filterToBeMerged'},\n  {merge: mergeInteractions, prop: 'interactionConfig', toMergeProp: 'interactionToBeMerged'},\n  {merge: mergeLayerBlending, prop: 'layerBlending'},\n  {merge: mergeSplitMaps, prop: 'splitMaps', toMergeProp: 'splitMapsToBeMerged'},\n  {merge: mergeAnimationConfig, prop: 'animationConfig'}\n];\n"]},"metadata":{},"sourceType":"script"}