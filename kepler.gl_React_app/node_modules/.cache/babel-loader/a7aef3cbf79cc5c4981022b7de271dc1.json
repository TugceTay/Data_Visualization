{"ast":null,"code":"import Input from './input';\nimport { INPUT_EVENT_TYPES } from '../constants';\nconst {\n  MOUSE_EVENTS\n} = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst ENTER_EVENT_TYPE = 'pointerenter';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport default class MoveInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, options);\n    this.handleEvent = event => {\n      this.handleOverEvent(event);\n      this.handleOutEvent(event);\n      this.handleEnterEvent(event);\n      this.handleLeaveEvent(event);\n      this.handleMoveEvent(event);\n    };\n    this.pressed = false;\n    const {\n      enable\n    } = this.options;\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n    this.events = (this.options.events || []).concat(MOUSE_EVENTS);\n    this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n  destroy() {\n    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    if (eventType === MOVE_EVENT_TYPE) {\n      this.enableMoveEvent = enabled;\n    }\n    if (eventType === OVER_EVENT_TYPE) {\n      this.enableOverEvent = enabled;\n    }\n    if (eventType === OUT_EVENT_TYPE) {\n      this.enableOutEvent = enabled;\n    }\n    if (eventType === ENTER_EVENT_TYPE) {\n      this.enableEnterEvent = enabled;\n    }\n    if (eventType === LEAVE_EVENT_TYPE) {\n      this.enableLeaveEvent = enabled;\n    }\n  }\n  handleOverEvent(event) {\n    if (this.enableOverEvent) {\n      if (event.type === 'mouseover') {\n        this._emit(OVER_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleOutEvent(event) {\n    if (this.enableOutEvent) {\n      if (event.type === 'mouseout') {\n        this._emit(OUT_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleEnterEvent(event) {\n    if (this.enableEnterEvent) {\n      if (event.type === 'mouseenter') {\n        this._emit(ENTER_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleLeaveEvent(event) {\n    if (this.enableLeaveEvent) {\n      if (event.type === 'mouseleave') {\n        this._emit(LEAVE_EVENT_TYPE, event);\n      }\n    }\n  }\n  handleMoveEvent(event) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n          break;\n        case 'mousemove':\n          // Move events use `which` to track the button being pressed\n          if (event.which === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit(MOVE_EVENT_TYPE, event);\n          }\n          break;\n        case 'mouseup':\n          this.pressed = false;\n          break;\n        default:\n      }\n    }\n  }\n  _emit(type, event) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target\n    });\n  }\n}","map":{"version":3,"sources":["../../../src/inputs/move-input.ts"],"names":[],"mappings":"AACA,OAAO,KAAqB,MAAM,SAAS;AAC3C,SAAQ,iBAAiB,QAAO,cAAc;AAE9C,MAAM;EAAC;AAAY,CAAC,GAAG,iBAAiB;AACxC,MAAM,eAAe,GAAG,aAAa;AACrC,MAAM,eAAe,GAAG,aAAa;AACrC,MAAM,cAAc,GAAG,YAAY;AACnC,MAAM,gBAAgB,GAAG,cAAc;AACvC,MAAM,gBAAgB,GAAG,cAAc;AAEvC;;;;;;;AAOG;AACH,eAAc,MAAO,SAAU,SAAQ,KAA2C,CAAA;EAUhF,WAAA,CACE,OAAoB,EACpB,QAAiD,EACjD,OAAqB,EAAA;IAErB,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,CAAC;IA0CnC,IAAA,CAAA,WAAW,GAAI,KAAmB,IAAI;MACpC,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC;MAC3B,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;MAC1B,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC;MAC5B,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC;MAC5B,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC;IAC7B,CAAC;IA9CC,IAAI,CAAC,OAAO,GAAG,KAAK;IACpB,MAAM;MAAC;IAAM,CAAC,GAAG,IAAI,CAAC,OAAO;IAE7B,IAAI,CAAC,eAAe,GAAG,MAAM;IAC7B,IAAI,CAAC,gBAAgB,GAAG,MAAM;IAC9B,IAAI,CAAC,gBAAgB,GAAG,MAAM;IAC9B,IAAI,CAAC,cAAc,GAAG,MAAM;IAC5B,IAAI,CAAC,eAAe,GAAG,MAAM;IAE7B,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,EAAE,EAAE,MAAM,CAAC,YAAY,CAAC;IAE9D,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI,OAAO,CAAC,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;EACjF;EAEA,OAAO,GAAA;IACL,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;EACzF;EAEA;;;AAGG;EACH,eAAe,CAAC,SAAiB,EAAE,OAAgB,EAAA;IACjD,IAAI,SAAS,KAAK,eAAe,EAAE;MACjC,IAAI,CAAC,eAAe,GAAG,OAAO;IAC/B;IACD,IAAI,SAAS,KAAK,eAAe,EAAE;MACjC,IAAI,CAAC,eAAe,GAAG,OAAO;IAC/B;IACD,IAAI,SAAS,KAAK,cAAc,EAAE;MAChC,IAAI,CAAC,cAAc,GAAG,OAAO;IAC9B;IACD,IAAI,SAAS,KAAK,gBAAgB,EAAE;MAClC,IAAI,CAAC,gBAAgB,GAAG,OAAO;IAChC;IACD,IAAI,SAAS,KAAK,gBAAgB,EAAE;MAClC,IAAI,CAAC,gBAAgB,GAAG,OAAO;IAChC;EACH;EAUA,eAAe,CAAC,KAAmB,EAAA;IACjC,IAAI,IAAI,CAAC,eAAe,EAAE;MACxB,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;QAC9B,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,KAAK,CAAC;MACnC;IACF;EACH;EAEA,cAAc,CAAC,KAAmB,EAAA;IAChC,IAAI,IAAI,CAAC,cAAc,EAAE;MACvB,IAAI,KAAK,CAAC,IAAI,KAAK,UAAU,EAAE;QAC7B,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,KAAK,CAAC;MAClC;IACF;EACH;EAEA,gBAAgB,CAAC,KAAmB,EAAA;IAClC,IAAI,IAAI,CAAC,gBAAgB,EAAE;MACzB,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY,EAAE;QAC/B,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,KAAK,CAAC;MACpC;IACF;EACH;EAEA,gBAAgB,CAAC,KAAmB,EAAA;IAClC,IAAI,IAAI,CAAC,gBAAgB,EAAE;MACzB,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY,EAAE;QAC/B,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,KAAK,CAAC;MACpC;IACF;EACH;EAEA,eAAe,CAAC,KAAmB,EAAA;IACjC,IAAI,IAAI,CAAC,eAAe,EAAE;MACxB,QAAQ,KAAK,CAAC,IAAI;QAChB,KAAK,WAAW;UACd,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC,EAAE;YACrB;YACA,IAAI,CAAC,OAAO,GAAG,IAAI;UACpB;UACD;QACF,KAAK,WAAW;UACd;UACA,IAAI,KAAK,CAAC,KAAK,KAAK,CAAC,EAAE;YACrB;YACA,IAAI,CAAC,OAAO,GAAG,KAAK;UACrB;UACD,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB;YACA;YACA,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,KAAK,CAAC;UACnC;UACD;QACF,KAAK,SAAS;UACZ,IAAI,CAAC,OAAO,GAAG,KAAK;UACpB;QACF;MAAQ;IAEX;EACH;EAEA,KAAK,CACH,IAAoF,EACpF,KAAmB,EAAA;IAEnB,IAAI,CAAC,QAAQ,CAAC;MACZ,IAAI;MACJ,MAAM,EAAE;QACN,CAAC,EAAE,KAAK,CAAC,OAAO;QAChB,CAAC,EAAE,KAAK,CAAC;OACV;MACD,QAAQ,EAAE,KAAK;MACf,WAAW,EAAE,OAAO;MACpB,MAAM,EAAE,KAAK,CAAC;KACf,CAAC;EACJ;AACD","sourceRoot":"","sourcesContent":["import Input from './input';\nimport { INPUT_EVENT_TYPES } from '../constants';\nconst { MOUSE_EVENTS } = INPUT_EVENT_TYPES;\nconst MOVE_EVENT_TYPE = 'pointermove';\nconst OVER_EVENT_TYPE = 'pointerover';\nconst OUT_EVENT_TYPE = 'pointerout';\nconst ENTER_EVENT_TYPE = 'pointerenter';\nconst LEAVE_EVENT_TYPE = 'pointerleave';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport default class MoveInput extends Input {\n    constructor(element, callback, options) {\n        super(element, callback, options);\n        this.handleEvent = (event) => {\n            this.handleOverEvent(event);\n            this.handleOutEvent(event);\n            this.handleEnterEvent(event);\n            this.handleLeaveEvent(event);\n            this.handleMoveEvent(event);\n        };\n        this.pressed = false;\n        const { enable } = this.options;\n        this.enableMoveEvent = enable;\n        this.enableLeaveEvent = enable;\n        this.enableEnterEvent = enable;\n        this.enableOutEvent = enable;\n        this.enableOverEvent = enable;\n        this.events = (this.options.events || []).concat(MOUSE_EVENTS);\n        this.events.forEach(event => element.addEventListener(event, this.handleEvent));\n    }\n    destroy() {\n        this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n    }\n    /**\n     * Enable this input (begin processing events)\n     * if the specified event type is among those handled by this input.\n     */\n    enableEventType(eventType, enabled) {\n        if (eventType === MOVE_EVENT_TYPE) {\n            this.enableMoveEvent = enabled;\n        }\n        if (eventType === OVER_EVENT_TYPE) {\n            this.enableOverEvent = enabled;\n        }\n        if (eventType === OUT_EVENT_TYPE) {\n            this.enableOutEvent = enabled;\n        }\n        if (eventType === ENTER_EVENT_TYPE) {\n            this.enableEnterEvent = enabled;\n        }\n        if (eventType === LEAVE_EVENT_TYPE) {\n            this.enableLeaveEvent = enabled;\n        }\n    }\n    handleOverEvent(event) {\n        if (this.enableOverEvent) {\n            if (event.type === 'mouseover') {\n                this._emit(OVER_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleOutEvent(event) {\n        if (this.enableOutEvent) {\n            if (event.type === 'mouseout') {\n                this._emit(OUT_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleEnterEvent(event) {\n        if (this.enableEnterEvent) {\n            if (event.type === 'mouseenter') {\n                this._emit(ENTER_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleLeaveEvent(event) {\n        if (this.enableLeaveEvent) {\n            if (event.type === 'mouseleave') {\n                this._emit(LEAVE_EVENT_TYPE, event);\n            }\n        }\n    }\n    handleMoveEvent(event) {\n        if (this.enableMoveEvent) {\n            switch (event.type) {\n                case 'mousedown':\n                    if (event.button >= 0) {\n                        // Button is down\n                        this.pressed = true;\n                    }\n                    break;\n                case 'mousemove':\n                    // Move events use `which` to track the button being pressed\n                    if (event.which === 0) {\n                        // Button is not down\n                        this.pressed = false;\n                    }\n                    if (!this.pressed) {\n                        // Drag events are emitted by hammer already\n                        // we just need to emit the move event on hover\n                        this._emit(MOVE_EVENT_TYPE, event);\n                    }\n                    break;\n                case 'mouseup':\n                    this.pressed = false;\n                    break;\n                default:\n            }\n        }\n    }\n    _emit(type, event) {\n        this.callback({\n            type,\n            center: {\n                x: event.clientX,\n                y: event.clientY\n            },\n            srcEvent: event,\n            pointerType: 'mouse',\n            target: event.target\n        });\n    }\n}\n//# sourceMappingURL=move-input.js.map"]},"metadata":{},"sourceType":"module"}