{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { h3ToGeoBoundary, h3GetResolution, h3ToGeo, geoToH3, h3IsPentagon, h3Distance, edgeLength, UNITS } from 'h3-js';\nimport { lerp } from 'math.gl';\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport { ColumnLayer, PolygonLayer } from '@deck.gl/layers';\nvar UPDATE_THRESHOLD_KM = 10;\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n  try {\n    for (var _iterator = vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var pt = _step.value;\n      var deltaLng = pt[0] - refLng;\n      if (deltaLng > 180) {\n        pt[0] -= 360;\n      } else if (deltaLng < -180) {\n        pt[0] += 360;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\nexport function scalePolygon(hexId, vertices, factor) {\n  var _h3ToGeo = h3ToGeo(hexId),\n    _h3ToGeo2 = _slicedToArray(_h3ToGeo, 2),\n    lat = _h3ToGeo2[0],\n    lng = _h3ToGeo2[1];\n  var actualCount = vertices.length;\n  normalizeLongitudes(vertices, lng);\n  var vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n  for (var i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  var hexagonId = getHexagon(object, objectInfo);\n  var _h3ToGeo3 = h3ToGeo(hexagonId),\n    _h3ToGeo4 = _slicedToArray(_h3ToGeo3, 2),\n    lat = _h3ToGeo4[0],\n    lng = _h3ToGeo4[1];\n  return [lng, lat];\n}\nfunction h3ToPolygon(hexId) {\n  var coverage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var flatten = arguments.length > 2 ? arguments[2] : undefined;\n  var vertices = h3ToGeoBoundary(hexId, true);\n  if (coverage !== 1) {\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    normalizeLongitudes(vertices);\n  }\n  if (flatten) {\n    var positions = new Float64Array(vertices.length * 2);\n    var i = 0;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n    try {\n      for (var _iterator2 = vertices[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var pt = _step2.value;\n        positions[i++] = pt[0];\n        positions[i++] = pt[1];\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n    return positions;\n  }\n  return vertices;\n}\nfunction mergeTriggers(getHexagon, coverage) {\n  var trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (_typeof(getHexagon) === 'object') {\n    trigger = Object.assign({}, getHexagon, {\n      coverage: coverage\n    });\n  } else {\n    trigger = {\n      getHexagon: getHexagon,\n      coverage: coverage\n    };\n  }\n  return trigger;\n}\nvar defaultProps = Object.assign({}, PolygonLayer.defaultProps, {\n  highPrecision: false,\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  centerHexagon: null,\n  getHexagon: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.hexagon;\n    }\n  },\n  extruded: true\n});\ndelete defaultProps.getLineDashArray;\nvar H3HexagonLayer = function (_CompositeLayer) {\n  _inherits(H3HexagonLayer, _CompositeLayer);\n  function H3HexagonLayer() {\n    _classCallCheck(this, H3HexagonLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(H3HexagonLayer).apply(this, arguments));\n  }\n  _createClass(H3HexagonLayer, [{\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n        oldProps = _ref2.oldProps,\n        changeFlags = _ref2.changeFlags;\n      if (changeFlags.dataChanged || changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagon) {\n        var resolution = -1;\n        var hasPentagon = false;\n        var hasMultipleRes = false;\n        var _createIterable = createIterable(props.data),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n        try {\n          for (var _iterator3 = iterable[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var object = _step3.value;\n            objectInfo.index++;\n            var hexId = props.getHexagon(object, objectInfo);\n            var hexResolution = h3GetResolution(hexId);\n            if (resolution < 0) resolution = hexResolution;else if (resolution !== hexResolution) {\n              hasMultipleRes = true;\n              break;\n            }\n            if (h3IsPentagon(hexId)) {\n              hasPentagon = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n        this.setState({\n          resolution: resolution,\n          edgeLengthKM: resolution >= 0 ? edgeLength(resolution, UNITS.km) : 0,\n          hasMultipleRes: hasMultipleRes,\n          hasPentagon: hasPentagon\n        });\n      }\n      this._updateVertices(this.context.viewport);\n    }\n  }, {\n    key: \"_shouldUseHighPrecision\",\n    value: function _shouldUseHighPrecision() {\n      var _this$state = this.state,\n        resolution = _this$state.resolution,\n        hasPentagon = _this$state.hasPentagon,\n        hasMultipleRes = _this$state.hasMultipleRes;\n      return this.props.highPrecision || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;\n    }\n  }, {\n    key: \"_updateVertices\",\n    value: function _updateVertices(viewport) {\n      if (this._shouldUseHighPrecision()) {\n        return;\n      }\n      var _this$state2 = this.state,\n        resolution = _this$state2.resolution,\n        edgeLengthKM = _this$state2.edgeLengthKM,\n        centerHex = _this$state2.centerHex;\n      if (resolution < 0) {\n        return;\n      }\n      var hex = this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n      if (centerHex === hex) {\n        return;\n      }\n      if (centerHex) {\n        var distance = h3Distance(centerHex, hex);\n        if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n          return;\n        }\n      }\n      var unitsPerMeter = viewport.distanceScales.unitsPerMeter;\n      var vertices = h3ToPolygon(hex);\n      var _h3ToGeo5 = h3ToGeo(hex),\n        _h3ToGeo6 = _slicedToArray(_h3ToGeo5, 2),\n        centerLat = _h3ToGeo6[0],\n        centerLng = _h3ToGeo6[1];\n      var _viewport$projectFlat = viewport.projectFlat([centerLng, centerLat]),\n        _viewport$projectFlat2 = _slicedToArray(_viewport$projectFlat, 2),\n        centerX = _viewport$projectFlat2[0],\n        centerY = _viewport$projectFlat2[1];\n      vertices = vertices.map(function (p) {\n        var worldPosition = viewport.projectFlat(p);\n        worldPosition[0] = (worldPosition[0] - centerX) / unitsPerMeter[0];\n        worldPosition[1] = (worldPosition[1] - centerY) / unitsPerMeter[1];\n        return worldPosition;\n      });\n      this.setState({\n        centerHex: hex,\n        vertices: vertices\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n    }\n  }, {\n    key: \"_getForwardProps\",\n    value: function _getForwardProps() {\n      var _this$props = this.props,\n        elevationScale = _this$props.elevationScale,\n        material = _this$props.material,\n        coverage = _this$props.coverage,\n        extruded = _this$props.extruded,\n        wireframe = _this$props.wireframe,\n        stroked = _this$props.stroked,\n        filled = _this$props.filled,\n        lineWidthUnits = _this$props.lineWidthUnits,\n        lineWidthScale = _this$props.lineWidthScale,\n        lineWidthMinPixels = _this$props.lineWidthMinPixels,\n        lineWidthMaxPixels = _this$props.lineWidthMaxPixels,\n        getFillColor = _this$props.getFillColor,\n        getElevation = _this$props.getElevation,\n        getLineColor = _this$props.getLineColor,\n        getLineWidth = _this$props.getLineWidth,\n        updateTriggers = _this$props.updateTriggers;\n      return {\n        elevationScale: elevationScale,\n        extruded: extruded,\n        coverage: coverage,\n        wireframe: wireframe,\n        stroked: stroked,\n        filled: filled,\n        lineWidthUnits: lineWidthUnits,\n        lineWidthScale: lineWidthScale,\n        lineWidthMinPixels: lineWidthMinPixels,\n        lineWidthMaxPixels: lineWidthMaxPixels,\n        material: material,\n        getElevation: getElevation,\n        getFillColor: getFillColor,\n        getLineColor: getLineColor,\n        getLineWidth: getLineWidth,\n        updateTriggers: {\n          getFillColor: updateTriggers.getFillColor,\n          getElevation: updateTriggers.getElevation,\n          getLineColor: updateTriggers.getLineColor,\n          getLineWidth: updateTriggers.getLineWidth\n        }\n      };\n    }\n  }, {\n    key: \"_renderPolygonLayer\",\n    value: function _renderPolygonLayer() {\n      var _this$props2 = this.props,\n        data = _this$props2.data,\n        getHexagon = _this$props2.getHexagon,\n        updateTriggers = _this$props2.updateTriggers,\n        coverage = _this$props2.coverage;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n      var forwardProps = this._getForwardProps();\n      forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n      return new SubLayerClass(forwardProps, this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }), {\n        data: data,\n        _normalize: false,\n        positionFormat: 'XY',\n        getPolygon: function getPolygon(object, objectInfo) {\n          var hexagonId = getHexagon(object, objectInfo);\n          return h3ToPolygon(hexagonId, coverage, true);\n        }\n      });\n    }\n  }, {\n    key: \"_renderColumnLayer\",\n    value: function _renderColumnLayer() {\n      var _this$props3 = this.props,\n        data = _this$props3.data,\n        getHexagon = _this$props3.getHexagon,\n        updateTriggers = _this$props3.updateTriggers;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n      var forwardProps = this._getForwardProps();\n      forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n      return new SubLayerClass(forwardProps, this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers: forwardProps.updateTriggers\n      }), {\n        data: data,\n        diskResolution: 6,\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      });\n    }\n  }]);\n  return H3HexagonLayer;\n}(CompositeLayer);\nexport { H3HexagonLayer as default };\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';","map":{"version":3,"sources":["../../../src/h3-layers/h3-hexagon-layer.js"],"names":["h3ToGeoBoundary","h3GetResolution","h3ToGeo","geoToH3","h3IsPentagon","h3Distance","edgeLength","UNITS","lerp","CompositeLayer","createIterable","ColumnLayer","PolygonLayer","UPDATE_THRESHOLD_KM","normalizeLongitudes","vertices","refLng","undefined","pt","deltaLng","scalePolygon","hexId","factor","lat","lng","actualCount","length","vertexCount","i","getHexagonCentroid","getHexagon","object","objectInfo","hexagonId","h3ToPolygon","coverage","flatten","positions","Float64Array","mergeTriggers","trigger","assign","defaultProps","highPrecision","type","min","max","value","centerHexagon","x","hexagon","extruded","getLineDashArray","H3HexagonLayer","changeFlags","_shouldUseHighPrecision","propsOrDataChanged","somethingChanged","props","oldProps","dataChanged","updateTriggers","resolution","hasPentagon","hasMultipleRes","iterable","data","index","hexResolution","setState","edgeLengthKM","km","_updateVertices","context","viewport","state","centerHex","hex","latitude","longitude","distance","unitsPerMeter","distanceScales","centerLat","centerLng","centerX","centerY","projectFlat","map","worldPosition","p","_renderPolygonLayer","_renderColumnLayer","elevationScale","material","wireframe","stroked","filled","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","getFillColor","getElevation","getLineColor","getLineWidth","SubLayerClass","getSubLayerClass","forwardProps","_getForwardProps","getPolygon","getSubLayerProps","id","_normalize","positionFormat","getPosition","diskResolution","radius","bind","layerName"],"mappings":"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","sourcesContent":["import {\n  h3ToGeoBoundary,\n  h3GetResolution,\n  h3ToGeo,\n  geoToH3,\n  h3IsPentagon,\n  h3Distance,\n  edgeLength,\n  UNITS\n} from 'h3-js';\nimport {lerp} from 'math.gl';\nimport {CompositeLayer, createIterable} from '@deck.gl/core';\nimport {ColumnLayer, PolygonLayer} from '@deck.gl/layers';\n\n// There is a cost to updating the instanced geometries when using highPrecision: false\n// This constant defines the distance between two hexagons that leads to \"significant\n// distortion.\" Smaller value makes the column layer more sensitive to viewport change.\nconst UPDATE_THRESHOLD_KM = 10;\n\n// normalize longitudes w.r.t center (refLng), when not provided first vertex\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n  for (const pt of vertices) {\n    const deltaLng = pt[0] - refLng;\n    if (deltaLng > 180) {\n      pt[0] -= 360;\n    } else if (deltaLng < -180) {\n      pt[0] += 360;\n    }\n  }\n}\n\n// scale polygon vertices w.r.t center (hexId)\nexport function scalePolygon(hexId, vertices, factor) {\n  const [lat, lng] = h3ToGeo(hexId);\n  const actualCount = vertices.length;\n\n  // normalize with respect to center\n  normalizeLongitudes(vertices, lng);\n\n  // `h3ToGeoBoundary` returns same array object for first and last vertex (closed polygon),\n  // if so skip scaling the last vertex\n  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n  for (let i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  const hexagonId = getHexagon(object, objectInfo);\n  const [lat, lng] = h3ToGeo(hexagonId);\n  return [lng, lat];\n}\n\nfunction h3ToPolygon(hexId, coverage = 1, flatten) {\n  const vertices = h3ToGeoBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    // scale and normalize vertices w.r.t to center\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    // normalize w.r.t to start vertex\n    normalizeLongitudes(vertices);\n  }\n\n  if (flatten) {\n    const positions = new Float64Array(vertices.length * 2);\n    let i = 0;\n    for (const pt of vertices) {\n      positions[i++] = pt[0];\n      positions[i++] = pt[1];\n    }\n    return positions;\n  }\n\n  return vertices;\n}\n\nfunction mergeTriggers(getHexagon, coverage) {\n  let trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = Object.assign({}, getHexagon, {coverage});\n  } else {\n    trigger = {getHexagon, coverage};\n  }\n  return trigger;\n}\n\nconst defaultProps = Object.assign({}, PolygonLayer.defaultProps, {\n  highPrecision: false,\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  centerHexagon: null,\n  getHexagon: {type: 'accessor', value: x => x.hexagon},\n  extruded: true\n});\n\n// not supported\ndelete defaultProps.getLineDashArray;\n\n/**\n * A subclass of HexagonLayer that uses H3 hexagonIds in data objects\n * rather than centroid lat/longs. The shape of each hexagon is determined\n * based on a single \"center\" hexagon, which can be selected by passing in\n * a center lat/lon pair. If not provided, the map center will be used.\n *\n * Also sets the `hexagonId` field in the onHover/onClick callback's info\n * objects. Since this is calculated using math, hexagonId will be present\n * even when no corresponding hexagon is in the data set. You can check\n * index !== -1 to see if picking matches an actual object.\n */\nexport default class H3HexagonLayer extends CompositeLayer {\n  shouldUpdateState({changeFlags}) {\n    return this._shouldUseHighPrecision()\n      ? changeFlags.propsOrDataChanged\n      : changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    if (\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagon)\n    ) {\n      let resolution = -1;\n      let hasPentagon = false;\n      let hasMultipleRes = false;\n      const {iterable, objectInfo} = createIterable(props.data);\n      for (const object of iterable) {\n        objectInfo.index++;\n        const hexId = props.getHexagon(object, objectInfo);\n        // Take the resolution of the first hex\n        const hexResolution = h3GetResolution(hexId);\n        if (resolution < 0) resolution = hexResolution;\n        else if (resolution !== hexResolution) {\n          hasMultipleRes = true;\n          break;\n        }\n        if (h3IsPentagon(hexId)) {\n          hasPentagon = true;\n          break;\n        }\n      }\n      this.setState({\n        resolution,\n        edgeLengthKM: resolution >= 0 ? edgeLength(resolution, UNITS.km) : 0,\n        hasMultipleRes,\n        hasPentagon\n      });\n    }\n\n    this._updateVertices(this.context.viewport);\n  }\n\n  _shouldUseHighPrecision() {\n    const {resolution, hasPentagon, hasMultipleRes} = this.state;\n    return (\n      this.props.highPrecision ||\n      hasMultipleRes ||\n      hasPentagon ||\n      (resolution >= 0 && resolution <= 5)\n    );\n  }\n\n  _updateVertices(viewport) {\n    if (this._shouldUseHighPrecision()) {\n      return;\n    }\n    const {resolution, edgeLengthKM, centerHex} = this.state;\n    if (resolution < 0) {\n      return;\n    }\n    const hex =\n      this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n    if (centerHex === hex) {\n      return;\n    }\n    if (centerHex) {\n      const distance = h3Distance(centerHex, hex);\n      // h3Distance returns a negative number if the distance could not be computed\n      // due to the two indexes very far apart or on opposite sides of a pentagon.\n      if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n        return;\n      }\n    }\n\n    const {unitsPerMeter} = viewport.distanceScales;\n\n    let vertices = h3ToPolygon(hex);\n    const [centerLat, centerLng] = h3ToGeo(hex);\n\n    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);\n    vertices = vertices.map(p => {\n      const worldPosition = viewport.projectFlat(p);\n      worldPosition[0] = (worldPosition[0] - centerX) / unitsPerMeter[0];\n      worldPosition[1] = (worldPosition[1] - centerY) / unitsPerMeter[1];\n      return worldPosition;\n    });\n\n    this.setState({centerHex: hex, vertices});\n  }\n\n  renderLayers() {\n    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n  }\n\n  _getForwardProps() {\n    const {\n      elevationScale,\n      material,\n      coverage,\n      extruded,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      getFillColor,\n      getElevation,\n      getLineColor,\n      getLineWidth,\n      updateTriggers\n    } = this.props;\n\n    return {\n      elevationScale,\n      extruded,\n      coverage,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      material,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      updateTriggers: {\n        getFillColor: updateTriggers.getFillColor,\n        getElevation: updateTriggers.getElevation,\n        getLineColor: updateTriggers.getLineColor,\n        getLineWidth: updateTriggers.getLineWidth\n      }\n    };\n  }\n\n  _renderPolygonLayer() {\n    const {data, getHexagon, updateTriggers, coverage} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n    const forwardProps = this._getForwardProps();\n\n    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        _normalize: false,\n        positionFormat: 'XY',\n        getPolygon: (object, objectInfo) => {\n          const hexagonId = getHexagon(object, objectInfo);\n          return h3ToPolygon(hexagonId, coverage, true);\n        }\n      }\n    );\n  }\n\n  _renderColumnLayer() {\n    const {data, getHexagon, updateTriggers} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        diskResolution: 6, // generate an extruded hexagon as the base geometry\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      }\n    );\n  }\n}\n\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';\n"]},"metadata":{},"sourceType":"module"}