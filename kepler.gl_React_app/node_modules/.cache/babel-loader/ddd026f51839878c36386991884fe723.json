{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.colorMaker = exports.layerColors = exports.OVERLAY_TYPE = exports.LAYER_ID_LENGTH = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _window = require(\"global/window\");\nvar _keymirror = _interopRequireDefault(require(\"keymirror\"));\nvar _extensions = require(\"@deck.gl/extensions\");\nvar _core = require(\"@deck.gl/core\");\nvar _layers = require(\"@deck.gl/layers\");\nvar _defaultLayerIcon = _interopRequireDefault(require(\"./default-layer-icon\"));\nvar _layerUpdate = require(\"./layer-update\");\nvar _defaultSettings = require(\"../constants/default-settings\");\nvar _colorRanges = require(\"../constants/color-ranges\");\nvar _customColorRanges = require(\"../constants/custom-color-ranges\");\nvar _layerFactory = require(\"./layer-factory\");\nvar _utils = require(\"../utils/utils\");\nvar _dataUtils = require(\"../utils/data-utils\");\nvar _dataContainerUtils = require(\"../utils/table-utils/data-container-utils\");\nvar _colorUtils = require(\"../utils/color-utils\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar _marked = /*#__PURE__*/_regenerator[\"default\"].mark(generateColor);\n\n/** @typedef {import('./index').Layer} LayerClass} */\n\n/**\n * Approx. number of points to sample in a large data set\n * @type {number}\n */\nvar LAYER_ID_LENGTH = 6;\nexports.LAYER_ID_LENGTH = LAYER_ID_LENGTH;\nvar MAX_SAMPLE_SIZE = 5000;\nvar defaultDomain = [0, 1];\nvar dataFilterExtension = new _extensions.DataFilterExtension({\n  filterSize: _defaultSettings.MAX_GPU_FILTERS\n});\nvar defaultDataAccessor = function defaultDataAccessor(dc) {\n  return function (d) {\n    return d;\n  };\n};\nvar defaultGetFieldValue = function defaultGetFieldValue(field, d) {\n  return field.valueAccessor(d);\n};\nvar OVERLAY_TYPE = (0, _keymirror[\"default\"])({\n  deckgl: null,\n  mapboxgl: null\n});\nexports.OVERLAY_TYPE = OVERLAY_TYPE;\nvar layerColors = Object.values(_customColorRanges.DataVizColors).map(_colorUtils.hexToRgb);\nexports.layerColors = layerColors;\nfunction generateColor() {\n  var index;\n  return _regenerator[\"default\"].wrap(function generateColor$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          index = 0;\n        case 1:\n          if (!(index < layerColors.length + 1)) {\n            _context.next = 7;\n            break;\n          }\n          if (index === layerColors.length) {\n            index = 0;\n          }\n          _context.next = 5;\n          return layerColors[index++];\n        case 5:\n          _context.next = 1;\n          break;\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\nvar colorMaker = generateColor();\n/** @type {LayerClass} */\n\nexports.colorMaker = colorMaker;\nvar Layer = /*#__PURE__*/function () {\n  function Layer() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck2[\"default\"])(this, Layer);\n    this.id = props.id || (0, _utils.generateHashId)(LAYER_ID_LENGTH); // meta\n\n    this.meta = {}; // visConfigSettings\n\n    this.visConfigSettings = {}; // @ts-ignore\n\n    this.config = this.getDefaultLayerConfig(_objectSpread({\n      columns: this.getLayerColumns()\n    }, props));\n  }\n  (0, _createClass2[\"default\"])(Layer, [{\n    key: \"layerIcon\",\n    get: function get() {\n      return _defaultLayerIcon[\"default\"];\n    }\n  }, {\n    key: \"overlayType\",\n    get: function get() {\n      return OVERLAY_TYPE.deckgl;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.type;\n    }\n  }, {\n    key: \"isAggregated\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return [];\n    }\n  }, {\n    key: \"optionalColumns\",\n    get: function get() {\n      return [];\n    }\n  }, {\n    key: \"noneLayerDataAffectingProps\",\n    get: function get() {\n      return ['label', 'opacity', 'thickness', 'isVisible', 'hidden'];\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      return {\n        color: {\n          property: 'color',\n          field: 'colorField',\n          scale: 'colorScale',\n          domain: 'colorDomain',\n          range: 'colorRange',\n          key: 'color',\n          channelScaleType: _defaultSettings.CHANNEL_SCALES.color,\n          nullValue: _defaultSettings.NO_VALUE_COLOR,\n          defaultValue: function defaultValue(config) {\n            return config.color;\n          }\n        },\n        size: {\n          property: 'size',\n          field: 'sizeField',\n          scale: 'sizeScale',\n          domain: 'sizeDomain',\n          range: 'sizeRange',\n          key: 'size',\n          channelScaleType: _defaultSettings.CHANNEL_SCALES.size,\n          nullValue: 0,\n          defaultValue: 1\n        }\n      };\n    }\n    /*\n     * Column pairs maps layer column to a specific field pairs,\n     * By default, it is set to null\n     */\n  }, {\n    key: \"columnPairs\",\n    get: function get() {\n      return null;\n    }\n    /*\n     * Default point column pairs, can be used for point based layers: point, icon etc.\n     */\n  }, {\n    key: \"defaultPointColumnPairs\",\n    get: function get() {\n      return {\n        lat: {\n          pair: 'lng',\n          fieldPairKey: 'lat'\n        },\n        lng: {\n          pair: 'lat',\n          fieldPairKey: 'lng'\n        }\n      };\n    }\n    /*\n     * Default link column pairs, can be used for link based layers: arc, line etc\n     */\n  }, {\n    key: \"defaultLinkColumnPairs\",\n    get: function get() {\n      return {\n        lat0: {\n          pair: 'lng0',\n          fieldPairKey: 'lat'\n        },\n        lng0: {\n          pair: 'lat0',\n          fieldPairKey: 'lng'\n        },\n        lat1: {\n          pair: 'lng1',\n          fieldPairKey: 'lat'\n        },\n        lng1: {\n          pair: 'lat1',\n          fieldPairKey: 'lng'\n        }\n      };\n    }\n    /**\n     * Return a React component for to render layer instructions in a modal\n     * @returns {object} - an object\n     * @example\n     *  return {\n     *    id: 'iconInfo',\n     *    template: IconInfoModal,\n     *    modalProps: {\n     *      title: 'How to draw icons'\n     *   };\n     * }\n     */\n  }, {\n    key: \"layerInfoModal\",\n    get: function get() {\n      return null;\n    }\n    /*\n     * Given a dataset, automatically find props to create layer based on it\n     * and return the props and previous found layers.\n     * By default, no layers will be found\n     */\n  }, {\n    key: \"getDefaultLayerConfig\",\n    value: function getDefaultLayerConfig() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        dataId: props.dataId || null,\n        label: props.label || _layerFactory.DEFAULT_LAYER_LABEL,\n        color: props.color || colorMaker.next().value,\n        columns: props.columns || null,\n        isVisible: props.isVisible || false,\n        isConfigActive: props.isConfigActive || false,\n        highlightColor: props.highlightColor || _layerFactory.DEFAULT_HIGHLIGHT_COLOR,\n        hidden: props.hidden || false,\n        // TODO: refactor this into separate visual Channel config\n        // color by field, domain is set by filters, field, scale type\n        colorField: null,\n        colorDomain: [0, 1],\n        colorScale: _defaultSettings.SCALE_TYPES.quantile,\n        // color by size, domain is set by filters, field, scale type\n        sizeDomain: [0, 1],\n        sizeScale: _defaultSettings.SCALE_TYPES.linear,\n        sizeField: null,\n        visConfig: {},\n        textLabel: [_layerFactory.DEFAULT_TEXT_LABEL],\n        colorUI: {\n          color: _layerFactory.DEFAULT_COLOR_UI,\n          colorRange: _layerFactory.DEFAULT_COLOR_UI\n        },\n        animation: {\n          enabled: false\n        }\n      };\n    }\n    /**\n     * Get the description of a visualChannel config\n     * @param key\n     * @returns {{label: string, measure: (string|string)}}\n     */\n  }, {\n    key: \"getVisualChannelDescription\",\n    value: function getVisualChannelDescription(key) {\n      // e.g. label: Color, measure: Vehicle Type\n      return {\n        label: this.visConfigSettings[this.visualChannels[key].range].label,\n        measure: this.config[this.visualChannels[key].field] ? this.config[this.visualChannels[key].field].displayName || this.config[this.visualChannels[key].field].name : this.visualChannels[key].defaultMeasure\n      };\n    }\n    /**\n     * Assign a field to layer column, return column config\n     * @param key - Column Key\n     * @param field - Selected field\n     * @returns {{}} - Column config\n     */\n  }, {\n    key: \"assignColumn\",\n    value: function assignColumn(key, field) {\n      // field value could be null for optional columns\n      var update = field ? {\n        value: field.name,\n        fieldIdx: field.fieldIdx\n      } : {\n        value: null,\n        fieldIdx: -1\n      };\n      return _objectSpread(_objectSpread({}, this.config.columns), {}, (0, _defineProperty2[\"default\"])({}, key, _objectSpread(_objectSpread({}, this.config.columns[key]), update)));\n    }\n    /**\n     * Assign a field pair to column config, return column config\n     * @param key - Column Key\n     * @param pair - field Pair\n     * @returns {object} - Column config\n     */\n  }, {\n    key: \"assignColumnPairs\",\n    value: function assignColumnPairs(key, pair) {\n      var _this$columnPairs, _this$columnPairs2, _this$columnPairs3, _objectSpread3;\n      if (!this.columnPairs || !((_this$columnPairs = this.columnPairs) !== null && _this$columnPairs !== void 0 && _this$columnPairs[key])) {\n        // should not end in this state\n        return this.config.columns;\n      }\n      var _this$columnPairs$key = (_this$columnPairs2 = this.columnPairs) === null || _this$columnPairs2 === void 0 ? void 0 : _this$columnPairs2[key],\n        partnerKey = _this$columnPairs$key.pair,\n        fieldPairKey = _this$columnPairs$key.fieldPairKey;\n      var _this$columnPairs$par = (_this$columnPairs3 = this.columnPairs) === null || _this$columnPairs3 === void 0 ? void 0 : _this$columnPairs3[partnerKey],\n        partnerFieldPairKey = _this$columnPairs$par.fieldPairKey;\n      return _objectSpread(_objectSpread({}, this.config.columns), {}, (_objectSpread3 = {}, (0, _defineProperty2[\"default\"])(_objectSpread3, key, pair[fieldPairKey]), (0, _defineProperty2[\"default\"])(_objectSpread3, partnerKey, pair[partnerFieldPairKey]), _objectSpread3));\n    }\n    /**\n     * Calculate a radius zoom multiplier to render points, so they are visible in all zoom level\n     * @param {object} mapState\n     * @param {number} mapState.zoom - actual zoom\n     * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image\n     * @returns {number}\n     */\n  }, {\n    key: \"getZoomFactor\",\n    value: function getZoomFactor(_ref) {\n      var zoom = _ref.zoom,\n        _ref$zoomOffset = _ref.zoomOffset,\n        zoomOffset = _ref$zoomOffset === void 0 ? 0 : _ref$zoomOffset;\n      return Math.pow(2, Math.max(14 - zoom + zoomOffset, 0));\n    }\n    /**\n     * Calculate a elevation zoom multiplier to render points, so they are visible in all zoom level\n     * @param {object} mapState\n     * @param {number} mapState.zoom - actual zoom\n     * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image\n     * @returns {number}\n     */\n  }, {\n    key: \"getElevationZoomFactor\",\n    value: function getElevationZoomFactor(_ref2) {\n      var zoom = _ref2.zoom,\n        _ref2$zoomOffset = _ref2.zoomOffset,\n        zoomOffset = _ref2$zoomOffset === void 0 ? 0 : _ref2$zoomOffset;\n      return this.config.visConfig.enableElevationZoomFactor ? Math.pow(2, Math.max(8 - zoom + zoomOffset, 0)) : 1;\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, filteredIndex) {\n      return {};\n    }\n  }, {\n    key: \"renderLayer\",\n    value: function renderLayer() {\n      return [];\n    }\n  }, {\n    key: \"getHoverData\",\n    value: function getHoverData(object, dataContainer) {\n      if (!object) {\n        return null;\n      } // By default, each entry of layerData should have an index of a row in the original data container.\n      // Each layer can implement its own getHoverData method\n\n      return dataContainer.row(object.index);\n    }\n    /**\n     * When change layer type, try to copy over layer configs as much as possible\n     * @param configToCopy - config to copy over\n     * @param visConfigSettings - visConfig settings of config to copy\n     */\n  }, {\n    key: \"assignConfigToLayer\",\n    value: function assignConfigToLayer(configToCopy, visConfigSettings) {\n      var _this = this;\n\n      // don't deep merge visualChannel field\n      // don't deep merge color range, reversed: is not a key by default\n      var shallowCopy = ['colorRange', 'strokeColorRange'].concat(Object.values(this.visualChannels).map(function (v) {\n        return v.field;\n      })); // don't copy over domain and animation\n\n      var notToCopy = ['animation'].concat(Object.values(this.visualChannels).map(function (v) {\n        return v.domain;\n      })); // if range is for the same property group copy it, otherwise, not to copy\n\n      Object.values(this.visualChannels).forEach(function (v) {\n        if (configToCopy.visConfig[v.range] && _this.visConfigSettings[v.range] && visConfigSettings[v.range].group !== _this.visConfigSettings[v.range].group) {\n          notToCopy.push(v.range);\n        }\n      }); // don't copy over visualChannel range\n\n      var currentConfig = this.config;\n      var copied = this.copyLayerConfig(currentConfig, configToCopy, {\n        shallowCopy: shallowCopy,\n        notToCopy: notToCopy\n      });\n      this.updateLayerConfig(copied); // validate visualChannel field type and scale types\n\n      Object.keys(this.visualChannels).forEach(function (channel) {\n        _this.validateVisualChannel(channel);\n      });\n    }\n    /*\n     * Recursively copy config over to an empty layer\n     * when received saved config, or copy config over from a different layer type\n     * make sure to only copy over value to existing keys\n     * @param {object} currentConfig - existing config to be override\n     * @param {object} configToCopy - new Config to copy over\n     * @param {string[]} shallowCopy - array of properties to not to be deep copied\n     * @param {string[]} notToCopy - array of properties not to copy\n     * @returns {object} - copied config\n     */\n  }, {\n    key: \"copyLayerConfig\",\n    value: function copyLayerConfig(currentConfig, configToCopy) {\n      var _this2 = this;\n      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref3$shallowCopy = _ref3.shallowCopy,\n        shallowCopy = _ref3$shallowCopy === void 0 ? [] : _ref3$shallowCopy,\n        _ref3$notToCopy = _ref3.notToCopy,\n        notToCopy = _ref3$notToCopy === void 0 ? [] : _ref3$notToCopy;\n      var copied = {};\n      Object.keys(currentConfig).forEach(function (key) {\n        if ((0, _utils.isPlainObject)(currentConfig[key]) && (0, _utils.isPlainObject)(configToCopy[key]) && !shallowCopy.includes(key) && !notToCopy.includes(key)) {\n          // recursively assign object value\n          copied[key] = _this2.copyLayerConfig(currentConfig[key], configToCopy[key], {\n            shallowCopy: shallowCopy,\n            notToCopy: notToCopy\n          });\n        } else if ((0, _dataUtils.notNullorUndefined)(configToCopy[key]) && !notToCopy.includes(key)) {\n          // copy\n          copied[key] = configToCopy[key];\n        } else {\n          // keep existing\n          copied[key] = currentConfig[key];\n        }\n      });\n      return copied;\n    }\n  }, {\n    key: \"registerVisConfig\",\n    value: function registerVisConfig(layerVisConfigs) {\n      var _this3 = this;\n      Object.keys(layerVisConfigs).forEach(function (item) {\n        if (typeof item === 'string' && _layerFactory.LAYER_VIS_CONFIGS[layerVisConfigs[item]]) {\n          // if assigned one of default LAYER_CONFIGS\n          _this3.config.visConfig[item] = _layerFactory.LAYER_VIS_CONFIGS[layerVisConfigs[item]].defaultValue;\n          _this3.visConfigSettings[item] = _layerFactory.LAYER_VIS_CONFIGS[layerVisConfigs[item]];\n        } else if (['type', 'defaultValue'].every(function (p) {\n          return layerVisConfigs[item].hasOwnProperty(p);\n        })) {\n          // if provided customized visConfig, and has type && defaultValue\n          // TODO: further check if customized visConfig is valid\n          _this3.config.visConfig[item] = layerVisConfigs[item].defaultValue;\n          _this3.visConfigSettings[item] = layerVisConfigs[item];\n        }\n      });\n    }\n  }, {\n    key: \"getLayerColumns\",\n    value: function getLayerColumns() {\n      var columnValidators = this.columnValidators || {};\n      var required = this.requiredLayerColumns.reduce(function (accu, key) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, columnValidators[key] ? {\n          value: null,\n          fieldIdx: -1,\n          validator: columnValidators[key]\n        } : {\n          value: null,\n          fieldIdx: -1\n        }));\n      }, {});\n      var optional = this.optionalColumns.reduce(function (accu, key) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, {\n          value: null,\n          fieldIdx: -1,\n          optional: true\n        }));\n      }, {});\n      return _objectSpread(_objectSpread({}, required), optional);\n    }\n  }, {\n    key: \"updateLayerConfig\",\n    value: function updateLayerConfig(newConfig) {\n      this.config = _objectSpread(_objectSpread({}, this.config), newConfig);\n      return this;\n    }\n  }, {\n    key: \"updateLayerVisConfig\",\n    value: function updateLayerVisConfig(newVisConfig) {\n      this.config.visConfig = _objectSpread(_objectSpread({}, this.config.visConfig), newVisConfig);\n      return this;\n    }\n  }, {\n    key: \"updateLayerColorUI\",\n    value: function updateLayerColorUI(prop, newConfig) {\n      var _this$config = this.config,\n        previous = _this$config.colorUI,\n        visConfig = _this$config.visConfig;\n      if (!(0, _utils.isPlainObject)(newConfig) || typeof prop !== 'string') {\n        return this;\n      }\n      var colorUIProp = Object.entries(newConfig).reduce(function (accu, _ref4) {\n        var _ref5 = (0, _slicedToArray2[\"default\"])(_ref4, 2),\n          key = _ref5[0],\n          value = _ref5[1];\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, (0, _utils.isPlainObject)(accu[key]) && (0, _utils.isPlainObject)(value) ? _objectSpread(_objectSpread({}, accu[key]), value) : value));\n      }, previous[prop] || _layerFactory.DEFAULT_COLOR_UI);\n      var colorUI = _objectSpread(_objectSpread({}, previous), {}, (0, _defineProperty2[\"default\"])({}, prop, colorUIProp));\n      this.updateLayerConfig({\n        colorUI: colorUI\n      }); // if colorUI[prop] is colorRange\n\n      var isColorRange = visConfig[prop] && visConfig[prop].colors;\n      if (isColorRange) {\n        this.updateColorUIByColorRange(newConfig, prop);\n        this.updateColorRangeByColorUI(newConfig, previous, prop);\n        this.updateCustomPalette(newConfig, previous, prop);\n      }\n      return this;\n    }\n  }, {\n    key: \"updateCustomPalette\",\n    value: function updateCustomPalette(newConfig, previous, prop) {\n      if (!newConfig.colorRangeConfig || !newConfig.colorRangeConfig.custom) {\n        return;\n      }\n      var _this$config2 = this.config,\n        colorUI = _this$config2.colorUI,\n        visConfig = _this$config2.visConfig;\n      if (!visConfig[prop]) return;\n      var colors = visConfig[prop].colors;\n      var customPalette = _objectSpread(_objectSpread({}, colorUI[prop].customPalette), {}, {\n        name: 'Custom Palette',\n        colors: (0, _toConsumableArray2[\"default\"])(colors)\n      });\n      this.updateLayerConfig({\n        colorUI: _objectSpread(_objectSpread({}, colorUI), {}, (0, _defineProperty2[\"default\"])({}, prop, _objectSpread(_objectSpread({}, colorUI[prop]), {}, {\n          customPalette: customPalette\n        })))\n      });\n    }\n    /**\n     * if open dropdown and prop is color range\n     * Automatically set colorRangeConfig's step and reversed\n     * @param {*} newConfig\n     * @param {*} prop\n     */\n  }, {\n    key: \"updateColorUIByColorRange\",\n    value: function updateColorUIByColorRange(newConfig, prop) {\n      if (typeof newConfig.showDropdown !== 'number') return;\n      var _this$config3 = this.config,\n        colorUI = _this$config3.colorUI,\n        visConfig = _this$config3.visConfig;\n      this.updateLayerConfig({\n        colorUI: _objectSpread(_objectSpread({}, colorUI), {}, (0, _defineProperty2[\"default\"])({}, prop, _objectSpread(_objectSpread({}, colorUI[prop]), {}, {\n          colorRangeConfig: _objectSpread(_objectSpread({}, colorUI[prop].colorRangeConfig), {}, {\n            steps: visConfig[prop].colors.length,\n            reversed: Boolean(visConfig[prop].reversed)\n          })\n        })))\n      });\n    }\n  }, {\n    key: \"updateColorRangeByColorUI\",\n    value: function updateColorRangeByColorUI(newConfig, previous, prop) {\n      // only update colorRange if changes in UI is made to 'reversed', 'steps' or steps\n      var shouldUpdate = newConfig.colorRangeConfig && ['reversed', 'steps'].some(function (key) {\n        return newConfig.colorRangeConfig.hasOwnProperty(key) && newConfig.colorRangeConfig[key] !== (previous[prop] || _layerFactory.DEFAULT_COLOR_UI).colorRangeConfig[key];\n      });\n      if (!shouldUpdate) return;\n      var _this$config4 = this.config,\n        colorUI = _this$config4.colorUI,\n        visConfig = _this$config4.visConfig;\n      var _colorUI$prop$colorRa = colorUI[prop].colorRangeConfig,\n        steps = _colorUI$prop$colorRa.steps,\n        reversed = _colorUI$prop$colorRa.reversed;\n      var colorRange = visConfig[prop]; // find based on step or reversed\n\n      var update;\n      if (newConfig.colorRangeConfig.hasOwnProperty('steps')) {\n        var group = (0, _colorUtils.getColorGroupByName)(colorRange);\n        if (group) {\n          var sameGroup = _colorRanges.COLOR_RANGES.filter(function (cr) {\n            return (0, _colorUtils.getColorGroupByName)(cr) === group;\n          });\n          update = sameGroup.find(function (cr) {\n            return cr.colors.length === steps;\n          });\n          if (update && colorRange.reversed) {\n            update = (0, _colorUtils.reverseColorRange)(true, update);\n          }\n        }\n      }\n      if (newConfig.colorRangeConfig.hasOwnProperty('reversed')) {\n        update = (0, _colorUtils.reverseColorRange)(reversed, update || colorRange);\n      }\n      if (update) {\n        this.updateLayerVisConfig((0, _defineProperty2[\"default\"])({}, prop, update));\n      }\n    }\n    /**\n     * Check whether layer has all columns\n     * @returns {boolean} yes or no\n     */\n  }, {\n    key: \"hasAllColumns\",\n    value: function hasAllColumns() {\n      var columns = this.config.columns;\n      return columns && Object.values(columns).every(function (v) {\n        return Boolean(v.optional || v.value && v.fieldIdx > -1);\n      });\n    }\n    /**\n     * Check whether layer has data\n     *\n     * @param {Array | Object} layerData\n     * @returns {boolean} yes or no\n     */\n  }, {\n    key: \"hasLayerData\",\n    value: function hasLayerData(layerData) {\n      if (!layerData) {\n        return false;\n      }\n      return Boolean(layerData.data && layerData.data.length);\n    }\n  }, {\n    key: \"isValidToSave\",\n    value: function isValidToSave() {\n      return this.type && this.hasAllColumns();\n    }\n  }, {\n    key: \"shouldRenderLayer\",\n    value: function shouldRenderLayer(data) {\n      return this.type && this.hasAllColumns() && this.hasLayerData(data) && typeof this.renderLayer === 'function';\n    }\n  }, {\n    key: \"getColorScale\",\n    value: function getColorScale(colorScale, colorDomain, colorRange) {\n      if (Array.isArray(colorRange.colorMap)) {\n        var cMap = new Map();\n        colorRange.colorMap.forEach(function (_ref6) {\n          var _ref7 = (0, _slicedToArray2[\"default\"])(_ref6, 2),\n            k = _ref7[0],\n            v = _ref7[1];\n          cMap.set(k, typeof v === 'string' ? (0, _colorUtils.hexToRgb)(v) : v);\n        }); // @ts-ignore d3 scale\n\n        var scale = _defaultSettings.SCALE_FUNC[_defaultSettings.SCALE_TYPES.ordinal]().domain(cMap.keys()).range(cMap.values()).unknown(cMap.get(_layerFactory.UNKNOWN_COLOR_KEY) || _defaultSettings.NO_VALUE_COLOR);\n        return scale;\n      }\n      return this.getVisChannelScale(colorScale, colorDomain, colorRange.colors.map(_colorUtils.hexToRgb));\n    }\n    /**\n     * Mapping from visual channels to deck.gl accesors\n     * @param {Object} param Parameters\n     * @param {Function} param.dataAccessor Access kepler.gl layer data from deck.gl layer\n     * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} param.dataContainer DataContainer to use use with dataAccessor\n     * @return {Object} attributeAccessors - deck.gl layer attribute accessors\n     */\n  }, {\n    key: \"getAttributeAccessors\",\n    value: function getAttributeAccessors(_ref8) {\n      var _this4 = this;\n      var _ref8$dataAccessor = _ref8.dataAccessor,\n        dataAccessor = _ref8$dataAccessor === void 0 ? defaultDataAccessor : _ref8$dataAccessor,\n        dataContainer = _ref8.dataContainer;\n      var attributeAccessors = {};\n      Object.keys(this.visualChannels).forEach(function (channel) {\n        var _this4$visualChannels = _this4.visualChannels[channel],\n          field = _this4$visualChannels.field,\n          fixed = _this4$visualChannels.fixed,\n          scale = _this4$visualChannels.scale,\n          domain = _this4$visualChannels.domain,\n          range = _this4$visualChannels.range,\n          accessor = _this4$visualChannels.accessor,\n          defaultValue = _this4$visualChannels.defaultValue,\n          getAttributeValue = _this4$visualChannels.getAttributeValue,\n          nullValue = _this4$visualChannels.nullValue,\n          channelScaleType = _this4$visualChannels.channelScaleType;\n        var shouldGetScale = _this4.config[field];\n        if (shouldGetScale) {\n          var args = [_this4.config[scale], _this4.config[domain], _this4.config.visConfig[range]];\n          var isFixed = fixed && _this4.config.visConfig[fixed];\n          var scaleFunction = channelScaleType === _defaultSettings.CHANNEL_SCALES.color ? _this4.getColorScale.apply(_this4, args) : _this4.getVisChannelScale.apply(_this4, args.concat([isFixed]));\n          attributeAccessors[accessor] = function (d) {\n            return _this4.getEncodedChannelValue(scaleFunction, dataAccessor(dataContainer)(d), _this4.config[field], nullValue);\n          };\n        } else if (typeof getAttributeValue === 'function') {\n          attributeAccessors[accessor] = getAttributeValue(_this4.config);\n        } else {\n          attributeAccessors[accessor] = typeof defaultValue === 'function' ? defaultValue(_this4.config) : defaultValue;\n        }\n        if (!attributeAccessors[accessor]) {\n          _window.console.warn(\"Failed to provide accessor function for \".concat(accessor || channel));\n        }\n      });\n      return attributeAccessors;\n    }\n  }, {\n    key: \"getVisChannelScale\",\n    value: function getVisChannelScale(scale, domain, range, fixed) {\n      // @ts-ignore d3-scale type\n      return _defaultSettings.SCALE_FUNC[fixed ? 'linear' : scale]().domain(domain).range(fixed ? domain : range);\n    }\n    /**\n     * Get longitude and latitude bounds of the data.\n     * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} dataContainer DataContainer to calculate bounds for.\n     * @param {(d: {index: number}, dc: import('utils/table-utils/data-container-interface').DataContainerInterface) => number[]} getPosition Access kepler.gl layer data from deck.gl layer\n     * @return {number[]|null} bounds of the data.\n     */\n  }, {\n    key: \"getPointsBounds\",\n    value: function getPointsBounds(dataContainer, getPosition) {\n      // no need to loop through the entire dataset\n      // get a sample of data to calculate bounds\n      var sampleData = dataContainer.numRows() > MAX_SAMPLE_SIZE ? (0, _dataContainerUtils.getSampleData)(dataContainer, MAX_SAMPLE_SIZE) : dataContainer;\n      var points = sampleData.mapIndex(getPosition);\n      var latBounds = (0, _dataUtils.getLatLngBounds)(points, 1, [-90, 90]);\n      var lngBounds = (0, _dataUtils.getLatLngBounds)(points, 0, [-180, 180]);\n      if (!latBounds || !lngBounds) {\n        return null;\n      }\n      return [lngBounds[0], latBounds[0], lngBounds[1], latBounds[1]];\n    }\n  }, {\n    key: \"getChangedTriggers\",\n    value: function getChangedTriggers(dataUpdateTriggers) {\n      var triggerChanged = (0, _layerUpdate.diffUpdateTriggers)(dataUpdateTriggers, this._oldDataUpdateTriggers);\n      this._oldDataUpdateTriggers = dataUpdateTriggers;\n      return triggerChanged;\n    }\n  }, {\n    key: \"getEncodedChannelValue\",\n    value: function getEncodedChannelValue(scale, data, field) {\n      var nullValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultSettings.NO_VALUE_COLOR;\n      var getValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultGetFieldValue;\n      var type = field.type;\n      var value = getValue(field, data);\n      if (!(0, _dataUtils.notNullorUndefined)(value)) {\n        return nullValue;\n      }\n      var attributeValue;\n      if (type === _defaultSettings.ALL_FIELD_TYPES.timestamp) {\n        // shouldn't need to convert here\n        // scale Function should take care of it\n        attributeValue = scale(new Date(value));\n      } else {\n        attributeValue = scale(value);\n      }\n      if (!(0, _dataUtils.notNullorUndefined)(attributeValue)) {\n        attributeValue = nullValue;\n      }\n      return attributeValue;\n    }\n  }, {\n    key: \"updateMeta\",\n    value: function updateMeta(meta) {\n      this.meta = _objectSpread(_objectSpread({}, this.meta), meta);\n    }\n  }, {\n    key: \"getDataUpdateTriggers\",\n    value: function getDataUpdateTriggers(_ref9) {\n      var filteredIndex = _ref9.filteredIndex,\n        id = _ref9.id,\n        allData = _ref9.allData;\n      var columns = this.config.columns;\n      return _objectSpread({\n        getData: {\n          datasetId: id,\n          allData: allData,\n          columns: columns,\n          filteredIndex: filteredIndex\n        },\n        getMeta: {\n          datasetId: id,\n          allData: allData,\n          columns: columns\n        }\n      }, (this.config.textLabel || []).reduce(function (accu, tl, i) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, \"getLabelCharacterSet-\".concat(i), tl.field ? tl.field.name : null));\n      }, {}));\n    }\n  }, {\n    key: \"updateData\",\n    value: function updateData(datasets, oldLayerData) {\n      if (!this.config.dataId) {\n        return {};\n      }\n      var layerDataset = datasets[this.config.dataId];\n      var dataContainer = layerDataset.dataContainer;\n      var getPosition = this.getPositionAccessor(dataContainer);\n      var dataUpdateTriggers = this.getDataUpdateTriggers(layerDataset);\n      var triggerChanged = this.getChangedTriggers(dataUpdateTriggers);\n      if (triggerChanged.getMeta) {\n        this.updateLayerMeta(dataContainer, getPosition);\n      }\n      var data = [];\n      if (!triggerChanged.getData && oldLayerData && oldLayerData.data) {\n        // same data\n        data = oldLayerData.data;\n      } else {\n        data = this.calculateDataAttribute(layerDataset, getPosition);\n      }\n      return {\n        data: data,\n        triggerChanged: triggerChanged\n      };\n    }\n    /**\n     * helper function to update one layer domain when state.data changed\n     * if state.data change is due ot update filter, newFiler will be passed\n     * called by updateAllLayerDomainData\n     * @param {Object} datasets\n     * @param {Object} newFilter\n     * @returns {object} layer\n     */\n  }, {\n    key: \"updateLayerDomain\",\n    value: function updateLayerDomain(datasets, newFilter) {\n      var _this5 = this;\n      var table = this.getDataset(datasets);\n      if (!table) {\n        return this;\n      }\n      Object.values(this.visualChannels).forEach(function (channel) {\n        var scale = channel.scale;\n        var scaleType = _this5.config[scale]; // ordinal domain is based on dataContainer, if only filter changed\n        // no need to update ordinal domain\n\n        if (!newFilter || scaleType !== _defaultSettings.SCALE_TYPES.ordinal) {\n          var domain = channel.domain;\n          var updatedDomain = _this5.calculateLayerDomain(table, channel);\n          _this5.updateLayerConfig((0, _defineProperty2[\"default\"])({}, domain, updatedDomain));\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"getDataset\",\n    value: function getDataset(datasets) {\n      return this.config.dataId ? datasets[this.config.dataId] : null;\n    }\n    /**\n     * Validate visual channel field and scales based on supported field & scale type\n     * @param channel\n     */\n  }, {\n    key: \"validateVisualChannel\",\n    value: function validateVisualChannel(channel) {\n      this.validateFieldType(channel);\n      this.validateScale(channel);\n    }\n    /**\n     * Validate field type based on channelScaleType\n     */\n  }, {\n    key: \"validateFieldType\",\n    value: function validateFieldType(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var field = visualChannel.field,\n        channelScaleType = visualChannel.channelScaleType,\n        supportedFieldTypes = visualChannel.supportedFieldTypes;\n      if (this.config[field]) {\n        // if field is selected, check if field type is supported\n        var channelSupportedFieldTypes = supportedFieldTypes || _defaultSettings.CHANNEL_SCALE_SUPPORTED_FIELDS[channelScaleType];\n        if (!channelSupportedFieldTypes.includes(this.config[field].type)) {\n          // field type is not supported, set it back to null\n          // set scale back to default\n          this.updateLayerConfig((0, _defineProperty2[\"default\"])({}, field, null));\n        }\n      }\n    }\n    /**\n     * Validate scale type based on aggregation\n     */\n  }, {\n    key: \"validateScale\",\n    value: function validateScale(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var scale = visualChannel.scale;\n      if (!scale) {\n        // visualChannel doesn't have scale\n        return;\n      }\n      var scaleOptions = this.getScaleOptions(channel); // check if current selected scale is\n      // supported, if not, change to default\n\n      if (!scaleOptions.includes(this.config[scale])) {\n        this.updateLayerConfig((0, _defineProperty2[\"default\"])({}, scale, scaleOptions[0]));\n      }\n    }\n    /**\n     * Get scale options based on current field\n     * @param {string} channel\n     * @returns {string[]}\n     */\n  }, {\n    key: \"getScaleOptions\",\n    value: function getScaleOptions(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var field = visualChannel.field,\n        scale = visualChannel.scale,\n        channelScaleType = visualChannel.channelScaleType;\n      return this.config[field] ? _defaultSettings.FIELD_OPTS[this.config[field].type].scale[channelScaleType] : [this.getDefaultLayerConfig()[scale]];\n    }\n  }, {\n    key: \"updateLayerVisualChannel\",\n    value: function updateLayerVisualChannel(dataset, channel) {\n      var visualChannel = this.visualChannels[channel];\n      this.validateVisualChannel(channel); // calculate layer channel domain\n\n      var updatedDomain = this.calculateLayerDomain(dataset, visualChannel);\n      this.updateLayerConfig((0, _defineProperty2[\"default\"])({}, visualChannel.domain, updatedDomain));\n    }\n  }, {\n    key: \"getVisualChannelUpdateTriggers\",\n    value: function getVisualChannelUpdateTriggers() {\n      var _this6 = this;\n      var updateTriggers = {};\n      Object.values(this.visualChannels).forEach(function (visualChannel) {\n        var _objectSpread11;\n\n        // field range scale domain\n        var accessor = visualChannel.accessor,\n          field = visualChannel.field,\n          scale = visualChannel.scale,\n          domain = visualChannel.domain,\n          range = visualChannel.range,\n          defaultValue = visualChannel.defaultValue,\n          fixed = visualChannel.fixed;\n        updateTriggers[accessor] = _objectSpread((_objectSpread11 = {}, (0, _defineProperty2[\"default\"])(_objectSpread11, field, _this6.config[field]), (0, _defineProperty2[\"default\"])(_objectSpread11, scale, _this6.config[scale]), (0, _defineProperty2[\"default\"])(_objectSpread11, domain, _this6.config[domain]), (0, _defineProperty2[\"default\"])(_objectSpread11, range, _this6.config.visConfig[range]), (0, _defineProperty2[\"default\"])(_objectSpread11, \"defaultValue\", typeof defaultValue === 'function' ? defaultValue(_this6.config) : defaultValue), _objectSpread11), fixed ? (0, _defineProperty2[\"default\"])({}, fixed, _this6.config.visConfig[fixed]) : {});\n      });\n      return updateTriggers;\n    }\n  }, {\n    key: \"calculateLayerDomain\",\n    value: function calculateLayerDomain(dataset, visualChannel) {\n      var scale = visualChannel.scale;\n      var scaleType = this.config[scale];\n      var field = this.config[visualChannel.field];\n      if (!field) {\n        // if colorField or sizeField were set back to null\n        return defaultDomain;\n      }\n      return dataset.getColumnLayerDomain(field, scaleType) || defaultDomain;\n    }\n  }, {\n    key: \"hasHoveredObject\",\n    value: function hasHoveredObject(objectInfo) {\n      return this.isLayerHovered(objectInfo) && objectInfo.object ? objectInfo.object : null;\n    }\n  }, {\n    key: \"isLayerHovered\",\n    value: function isLayerHovered(objectInfo) {\n      var _objectInfo$layer, _objectInfo$layer$pro;\n      return (objectInfo === null || objectInfo === void 0 ? void 0 : objectInfo.picked) && (objectInfo === null || objectInfo === void 0 ? void 0 : (_objectInfo$layer = objectInfo.layer) === null || _objectInfo$layer === void 0 ? void 0 : (_objectInfo$layer$pro = _objectInfo$layer.props) === null || _objectInfo$layer$pro === void 0 ? void 0 : _objectInfo$layer$pro.id) === this.id;\n    }\n  }, {\n    key: \"getRadiusScaleByZoom\",\n    value: function getRadiusScaleByZoom(mapState, fixedRadius) {\n      var radiusChannel = Object.values(this.visualChannels).find(function (vc) {\n        return vc.property === 'radius';\n      });\n      if (!radiusChannel) {\n        return 1;\n      }\n      var field = radiusChannel.field;\n      var fixed = fixedRadius === undefined ? this.config.visConfig.fixedRadius : fixedRadius;\n      var radius = this.config.visConfig.radius; // @ts-ignore\n\n      return fixed ? 1 : (this.config[field] ? 1 : radius) * this.getZoomFactor(mapState);\n    }\n  }, {\n    key: \"shouldCalculateLayerData\",\n    value: function shouldCalculateLayerData(props) {\n      var _this7 = this;\n      return props.some(function (p) {\n        return !_this7.noneLayerDataAffectingProps.includes(p);\n      });\n    }\n  }, {\n    key: \"getBrushingExtensionProps\",\n    value: function getBrushingExtensionProps(interactionConfig, brushingTarget) {\n      var brush = interactionConfig.brush;\n      return {\n        // brushing\n        autoHighlight: !brush.enabled,\n        brushingRadius: brush.config.size * 1000,\n        brushingTarget: brushingTarget || 'source',\n        brushingEnabled: brush.enabled\n      };\n    }\n  }, {\n    key: \"getDefaultDeckLayerProps\",\n    value: function getDefaultDeckLayerProps(_ref11) {\n      var idx = _ref11.idx,\n        gpuFilter = _ref11.gpuFilter,\n        mapState = _ref11.mapState,\n        visible = _ref11.visible;\n      return {\n        id: this.id,\n        idx: idx,\n        coordinateSystem: _core.COORDINATE_SYSTEM.LNGLAT,\n        pickable: true,\n        wrapLongitude: true,\n        parameters: {\n          depthTest: Boolean(mapState.dragRotate || this.config.visConfig.enable3d)\n        },\n        hidden: this.config.hidden,\n        // visconfig\n        opacity: this.config.visConfig.opacity,\n        highlightColor: this.config.highlightColor,\n        // data filtering\n        extensions: [dataFilterExtension],\n        filterRange: gpuFilter ? gpuFilter.filterRange : undefined,\n        // layer should be visible and if splitMap, shown in to one of panel\n        visible: this.config.isVisible && visible\n      };\n    }\n  }, {\n    key: \"getDefaultHoverLayerProps\",\n    value: function getDefaultHoverLayerProps() {\n      return {\n        id: \"\".concat(this.id, \"-hovered\"),\n        pickable: false,\n        wrapLongitude: true,\n        coordinateSystem: _core.COORDINATE_SYSTEM.LNGLAT\n      };\n    }\n  }, {\n    key: \"renderTextLabelLayer\",\n    value: function renderTextLabelLayer(_ref12, renderOpts) {\n      var _this8 = this;\n      var getPosition = _ref12.getPosition,\n        getPixelOffset = _ref12.getPixelOffset,\n        updateTriggers = _ref12.updateTriggers,\n        sharedProps = _ref12.sharedProps;\n      var data = renderOpts.data,\n        mapState = renderOpts.mapState;\n      var textLabel = this.config.textLabel;\n      return data.textLabels.reduce(function (accu, d, i) {\n        if (d.getText) {\n          var _textLabel$i$field, _textLabel$i$field2;\n          accu.push(new _layers.TextLayer(_objectSpread(_objectSpread({}, sharedProps), {}, {\n            id: \"\".concat(_this8.id, \"-label-\").concat((_textLabel$i$field = textLabel[i].field) === null || _textLabel$i$field === void 0 ? void 0 : _textLabel$i$field.name),\n            data: data.data,\n            getText: d.getText,\n            getPosition: getPosition,\n            characterSet: d.characterSet,\n            getPixelOffset: getPixelOffset(textLabel[i]),\n            getSize: 1,\n            sizeScale: textLabel[i].size,\n            getTextAnchor: textLabel[i].anchor,\n            getAlignmentBaseline: textLabel[i].alignment,\n            getColor: textLabel[i].color,\n            parameters: {\n              // text will always show on top of all layers\n              depthTest: false\n            },\n            getFilterValue: data.getFilterValue,\n            updateTriggers: _objectSpread(_objectSpread({}, updateTriggers), {}, {\n              getText: (_textLabel$i$field2 = textLabel[i].field) === null || _textLabel$i$field2 === void 0 ? void 0 : _textLabel$i$field2.name,\n              getPixelOffset: _objectSpread(_objectSpread({}, updateTriggers.getRadius), {}, {\n                mapState: mapState,\n                anchor: textLabel[i].anchor,\n                alignment: textLabel[i].alignment\n              }),\n              getTextAnchor: textLabel[i].anchor,\n              getAlignmentBaseline: textLabel[i].alignment,\n              getColor: textLabel[i].color\n            })\n          })));\n        }\n        return accu;\n      }, []);\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(keplerTable, getPosition) {\n      // implemented in subclasses\n      return [];\n    }\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer, getPosition) {// implemented in subclasses\n    }\n  }, {\n    key: \"getPositionAccessor\",\n    value: function getPositionAccessor(dataContainer) {\n      // implemented in subclasses\n      return function () {\n        return null;\n      };\n    }\n  }], [{\n    key: \"findDefaultLayerProps\",\n    value: function findDefaultLayerProps(dataset, foundLayers) {\n      return {\n        props: [],\n        foundLayers: foundLayers\n      };\n    }\n    /**\n     * Given a array of preset required column names\n     * found field that has the same name to set as layer column\n     *\n     * @param {object} defaultFields\n     * @param {object[]} allFields\n     * @returns {object[] | null} all possible required layer column pairs\n     */\n  }, {\n    key: \"findDefaultColumnField\",\n    value: function findDefaultColumnField(defaultFields, allFields) {\n      // find all matched fields for each required col\n      var requiredColumns = Object.keys(defaultFields).reduce(function (prev, key) {\n        var requiredFields = allFields.filter(function (f) {\n          return f.name === defaultFields[key] || defaultFields[key].includes(f.name);\n        });\n        prev[key] = requiredFields.length ? requiredFields.map(function (f) {\n          return {\n            value: f.name,\n            fieldIdx: f.fieldIdx\n          };\n        }) : null;\n        return prev;\n      }, {});\n      if (!Object.values(requiredColumns).every(Boolean)) {\n        // if any field missing, return null\n        return null;\n      }\n      return this.getAllPossibleColumnParis(requiredColumns);\n    }\n  }, {\n    key: \"getAllPossibleColumnParis\",\n    value: function getAllPossibleColumnParis(requiredColumns) {\n      // for multiple matched field for one required column, return multiple\n      // combinations, e. g. if column a has 2 matched, column b has 3 matched\n      // 6 possible column pairs will be returned\n      var allKeys = Object.keys(requiredColumns);\n      var pointers = allKeys.map(function (k, i) {\n        return i === allKeys.length - 1 ? -1 : 0;\n      });\n      var countPerKey = allKeys.map(function (k) {\n        return requiredColumns[k].length;\n      });\n      var pairs = [];\n      /* eslint-disable no-loop-func */\n\n      while (incrementPointers(pointers, countPerKey, pointers.length - 1)) {\n        var newPair = pointers.reduce(function (prev, cuur, i) {\n          prev[allKeys[i]] = requiredColumns[allKeys[i]][cuur];\n          return prev;\n        }, {});\n        pairs.push(newPair);\n      }\n      /* eslint-enable no-loop-func */\n      // recursively increment pointers\n\n      function incrementPointers(pts, counts, index) {\n        if (index === 0 && pts[0] === counts[0] - 1) {\n          // nothing to increment\n          return false;\n        }\n        if (pts[index] + 1 < counts[index]) {\n          pts[index] = pts[index] + 1;\n          return true;\n        }\n        pts[index] = 0;\n        return incrementPointers(pts, counts, index - 1);\n      }\n      return pairs;\n    }\n  }, {\n    key: \"hexToRgb\",\n    value: function hexToRgb(c) {\n      return (0, _colorUtils.hexToRgb)(c);\n    }\n  }]);\n  return Layer;\n}();\nvar _default = Layer;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../../src/layers/base-layer.js"],"names":["LAYER_ID_LENGTH","MAX_SAMPLE_SIZE","defaultDomain","dataFilterExtension","DataFilterExtension","filterSize","MAX_GPU_FILTERS","defaultDataAccessor","d","defaultGetFieldValue","field","valueAccessor","OVERLAY_TYPE","deckgl","mapboxgl","layerColors","Object","values","DataVizColors","map","hexToRgb","generateColor","index","length","colorMaker","Layer","props","id","meta","visConfigSettings","config","getDefaultLayerConfig","columns","getLayerColumns","DefaultLayerIcon","type","color","property","scale","domain","range","key","channelScaleType","CHANNEL_SCALES","nullValue","NO_VALUE_COLOR","defaultValue","size","lat","pair","fieldPairKey","lng","lat0","lng0","lat1","lng1","dataset","foundLayers","defaultFields","allFields","requiredColumns","keys","reduce","prev","requiredFields","filter","f","name","includes","value","fieldIdx","every","Boolean","getAllPossibleColumnParis","allKeys","pointers","k","i","countPerKey","pairs","incrementPointers","newPair","cuur","push","pts","counts","c","dataId","label","DEFAULT_LAYER_LABEL","next","isVisible","isConfigActive","highlightColor","DEFAULT_HIGHLIGHT_COLOR","hidden","colorField","colorDomain","colorScale","SCALE_TYPES","quantile","sizeDomain","sizeScale","linear","sizeField","visConfig","textLabel","DEFAULT_TEXT_LABEL","colorUI","DEFAULT_COLOR_UI","colorRange","animation","enabled","visualChannels","measure","displayName","defaultMeasure","update","columnPairs","partnerKey","partnerFieldPairKey","zoom","zoomOffset","Math","pow","max","enableElevationZoomFactor","datasets","filteredIndex","object","dataContainer","row","configToCopy","shallowCopy","concat","v","notToCopy","forEach","group","currentConfig","copied","copyLayerConfig","updateLayerConfig","validateVisualChannel","channel","layerVisConfigs","item","LAYER_VIS_CONFIGS","hasOwnProperty","p","columnValidators","required","requiredLayerColumns","accu","validator","optional","optionalColumns","newConfig","newVisConfig","prop","previous","colorUIProp","entries","isColorRange","colors","updateColorUIByColorRange","updateColorRangeByColorUI","updateCustomPalette","colorRangeConfig","custom","customPalette","showDropdown","steps","reversed","shouldUpdate","some","sameGroup","cr","find","updateLayerVisConfig","layerData","data","hasAllColumns","hasLayerData","renderLayer","Array","isArray","colorMap","cMap","Map","set","SCALE_FUNC","ordinal","unknown","get","UNKNOWN_COLOR_KEY","getVisChannelScale","dataAccessor","attributeAccessors","fixed","accessor","getAttributeValue","shouldGetScale","args","isFixed","scaleFunction","getColorScale","getEncodedChannelValue","Console","warn","getPosition","sampleData","numRows","points","mapIndex","latBounds","lngBounds","dataUpdateTriggers","triggerChanged","_oldDataUpdateTriggers","getValue","attributeValue","ALL_FIELD_TYPES","timestamp","Date","allData","getData","datasetId","getMeta","tl","oldLayerData","layerDataset","getPositionAccessor","getDataUpdateTriggers","getChangedTriggers","updateLayerMeta","calculateDataAttribute","newFilter","table","getDataset","scaleType","updatedDomain","calculateLayerDomain","validateFieldType","validateScale","visualChannel","supportedFieldTypes","channelSupportedFieldTypes","CHANNEL_SCALE_SUPPORTED_FIELDS","scaleOptions","getScaleOptions","FIELD_OPTS","updateTriggers","getColumnLayerDomain","objectInfo","isLayerHovered","picked","layer","mapState","fixedRadius","radiusChannel","vc","undefined","radius","getZoomFactor","noneLayerDataAffectingProps","interactionConfig","brushingTarget","brush","autoHighlight","brushingRadius","brushingEnabled","idx","gpuFilter","visible","coordinateSystem","COORDINATE_SYSTEM","LNGLAT","pickable","wrapLongitude","parameters","depthTest","dragRotate","enable3d","opacity","extensions","filterRange","getPixelOffset","sharedProps","renderOpts","textLabels","getText","TextLayer","characterSet","getSize","getTextAnchor","anchor","getAlignmentBaseline","alignment","getColor","getFilterValue","getRadius","keplerTable"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {console as Console} from 'global/window';\nimport keymirror from 'keymirror';\nimport {DataFilterExtension} from '@deck.gl/extensions';\nimport {COORDINATE_SYSTEM} from '@deck.gl/core';\nimport {TextLayer} from '@deck.gl/layers';\n\nimport DefaultLayerIcon from './default-layer-icon';\nimport {diffUpdateTriggers} from './layer-update';\n\nimport {\n  ALL_FIELD_TYPES,\n  NO_VALUE_COLOR,\n  SCALE_TYPES,\n  CHANNEL_SCALES,\n  FIELD_OPTS,\n  SCALE_FUNC,\n  CHANNEL_SCALE_SUPPORTED_FIELDS,\n  MAX_GPU_FILTERS\n} from 'constants/default-settings';\nimport {COLOR_RANGES} from 'constants/color-ranges';\nimport {DataVizColors} from 'constants/custom-color-ranges';\nimport {\n  LAYER_VIS_CONFIGS,\n  DEFAULT_TEXT_LABEL,\n  DEFAULT_COLOR_UI,\n  UNKNOWN_COLOR_KEY,\n  DEFAULT_HIGHLIGHT_COLOR,\n  DEFAULT_LAYER_LABEL\n} from './layer-factory';\n\nimport {generateHashId, isPlainObject} from 'utils/utils';\n\nimport {getLatLngBounds, notNullorUndefined} from 'utils/data-utils';\nimport {getSampleData} from 'utils/table-utils/data-container-utils';\n\nimport {hexToRgb, getColorGroupByName, reverseColorRange} from 'utils/color-utils';\n\n/** @typedef {import('./index').Layer} LayerClass} */\n\n/**\n * Approx. number of points to sample in a large data set\n * @type {number}\n */\nexport const LAYER_ID_LENGTH = 6;\n\nconst MAX_SAMPLE_SIZE = 5000;\nconst defaultDomain = [0, 1];\nconst dataFilterExtension = new DataFilterExtension({filterSize: MAX_GPU_FILTERS});\n\nconst defaultDataAccessor = dc => d => d;\nconst defaultGetFieldValue = (field, d) => field.valueAccessor(d);\n\nexport const OVERLAY_TYPE = keymirror({\n  deckgl: null,\n  mapboxgl: null\n});\n\nexport const layerColors = Object.values(DataVizColors).map(hexToRgb);\nfunction* generateColor() {\n  let index = 0;\n  while (index < layerColors.length + 1) {\n    if (index === layerColors.length) {\n      index = 0;\n    }\n    yield layerColors[index++];\n  }\n}\n\nexport const colorMaker = generateColor();\n\n/** @type {LayerClass} */\nclass Layer {\n  constructor(props = {}) {\n    this.id = props.id || generateHashId(LAYER_ID_LENGTH);\n\n    // meta\n    this.meta = {};\n\n    // visConfigSettings\n    this.visConfigSettings = {};\n\n    // @ts-ignore\n    this.config = this.getDefaultLayerConfig({\n      columns: this.getLayerColumns(),\n      ...props\n    });\n  }\n\n  get layerIcon() {\n    return DefaultLayerIcon;\n  }\n\n  get overlayType() {\n    return OVERLAY_TYPE.deckgl;\n  }\n\n  get type() {\n    return null;\n  }\n\n  get name() {\n    return this.type;\n  }\n\n  get isAggregated() {\n    return false;\n  }\n\n  get requiredLayerColumns() {\n    return [];\n  }\n\n  get optionalColumns() {\n    return [];\n  }\n\n  get noneLayerDataAffectingProps() {\n    return ['label', 'opacity', 'thickness', 'isVisible', 'hidden'];\n  }\n\n  get visualChannels() {\n    return {\n      color: {\n        property: 'color',\n        field: 'colorField',\n        scale: 'colorScale',\n        domain: 'colorDomain',\n        range: 'colorRange',\n        key: 'color',\n        channelScaleType: CHANNEL_SCALES.color,\n        nullValue: NO_VALUE_COLOR,\n        defaultValue: config => config.color\n      },\n      size: {\n        property: 'size',\n        field: 'sizeField',\n        scale: 'sizeScale',\n        domain: 'sizeDomain',\n        range: 'sizeRange',\n        key: 'size',\n        channelScaleType: CHANNEL_SCALES.size,\n        nullValue: 0,\n        defaultValue: 1\n      }\n    };\n  }\n\n  /*\n   * Column pairs maps layer column to a specific field pairs,\n   * By default, it is set to null\n   */\n  get columnPairs() {\n    return null;\n  }\n\n  /*\n   * Default point column pairs, can be used for point based layers: point, icon etc.\n   */\n  get defaultPointColumnPairs() {\n    return {\n      lat: {pair: 'lng', fieldPairKey: 'lat'},\n      lng: {pair: 'lat', fieldPairKey: 'lng'}\n    };\n  }\n\n  /*\n   * Default link column pairs, can be used for link based layers: arc, line etc\n   */\n  get defaultLinkColumnPairs() {\n    return {\n      lat0: {pair: 'lng0', fieldPairKey: 'lat'},\n      lng0: {pair: 'lat0', fieldPairKey: 'lng'},\n      lat1: {pair: 'lng1', fieldPairKey: 'lat'},\n      lng1: {pair: 'lat1', fieldPairKey: 'lng'}\n    };\n  }\n\n  /**\n   * Return a React component for to render layer instructions in a modal\n   * @returns {object} - an object\n   * @example\n   *  return {\n   *    id: 'iconInfo',\n   *    template: IconInfoModal,\n   *    modalProps: {\n   *      title: 'How to draw icons'\n   *   };\n   * }\n   */\n  get layerInfoModal() {\n    return null;\n  }\n  /*\n   * Given a dataset, automatically find props to create layer based on it\n   * and return the props and previous found layers.\n   * By default, no layers will be found\n   */\n  static findDefaultLayerProps(dataset, foundLayers) {\n    return {props: [], foundLayers};\n  }\n\n  /**\n   * Given a array of preset required column names\n   * found field that has the same name to set as layer column\n   *\n   * @param {object} defaultFields\n   * @param {object[]} allFields\n   * @returns {object[] | null} all possible required layer column pairs\n   */\n  static findDefaultColumnField(defaultFields, allFields) {\n    // find all matched fields for each required col\n    const requiredColumns = Object.keys(defaultFields).reduce((prev, key) => {\n      const requiredFields = allFields.filter(\n        f => f.name === defaultFields[key] || defaultFields[key].includes(f.name)\n      );\n\n      prev[key] = requiredFields.length\n        ? requiredFields.map(f => ({\n            value: f.name,\n            fieldIdx: f.fieldIdx\n          }))\n        : null;\n      return prev;\n    }, {});\n\n    if (!Object.values(requiredColumns).every(Boolean)) {\n      // if any field missing, return null\n      return null;\n    }\n\n    return this.getAllPossibleColumnParis(requiredColumns);\n  }\n\n  static getAllPossibleColumnParis(requiredColumns) {\n    // for multiple matched field for one required column, return multiple\n    // combinations, e. g. if column a has 2 matched, column b has 3 matched\n    // 6 possible column pairs will be returned\n    const allKeys = Object.keys(requiredColumns);\n    const pointers = allKeys.map((k, i) => ((i === allKeys.length - 1 ? -1 : 0)));\n    const countPerKey = allKeys.map(k => requiredColumns[k].length);\n    const pairs = [];\n\n    /* eslint-disable no-loop-func */\n    while (incrementPointers(pointers, countPerKey, pointers.length - 1)) {\n      const newPair = pointers.reduce((prev, cuur, i) => {\n        prev[allKeys[i]] = requiredColumns[allKeys[i]][cuur];\n        return prev;\n      }, {});\n\n      pairs.push(newPair);\n    }\n    /* eslint-enable no-loop-func */\n\n    // recursively increment pointers\n    function incrementPointers(pts, counts, index) {\n      if (index === 0 && pts[0] === counts[0] - 1) {\n        // nothing to increment\n        return false;\n      }\n\n      if (pts[index] + 1 < counts[index]) {\n        pts[index] = pts[index] + 1;\n        return true;\n      }\n\n      pts[index] = 0;\n      return incrementPointers(pts, counts, index - 1);\n    }\n\n    return pairs;\n  }\n\n  static hexToRgb(c) {\n    return hexToRgb(c);\n  }\n\n  getDefaultLayerConfig(props = {}) {\n    return {\n      dataId: props.dataId || null,\n      label: props.label || DEFAULT_LAYER_LABEL,\n      color: props.color || colorMaker.next().value,\n      columns: props.columns || null,\n      isVisible: props.isVisible || false,\n      isConfigActive: props.isConfigActive || false,\n      highlightColor: props.highlightColor || DEFAULT_HIGHLIGHT_COLOR,\n      hidden: props.hidden || false,\n\n      // TODO: refactor this into separate visual Channel config\n      // color by field, domain is set by filters, field, scale type\n      colorField: null,\n      colorDomain: [0, 1],\n      colorScale: SCALE_TYPES.quantile,\n\n      // color by size, domain is set by filters, field, scale type\n      sizeDomain: [0, 1],\n      sizeScale: SCALE_TYPES.linear,\n      sizeField: null,\n\n      visConfig: {},\n\n      textLabel: [DEFAULT_TEXT_LABEL],\n\n      colorUI: {\n        color: DEFAULT_COLOR_UI,\n        colorRange: DEFAULT_COLOR_UI\n      },\n      animation: {enabled: false}\n    };\n  }\n\n  /**\n   * Get the description of a visualChannel config\n   * @param key\n   * @returns {{label: string, measure: (string|string)}}\n   */\n  getVisualChannelDescription(key) {\n    // e.g. label: Color, measure: Vehicle Type\n    return {\n      label: this.visConfigSettings[this.visualChannels[key].range].label,\n      measure: this.config[this.visualChannels[key].field]\n        ? (this.config[this.visualChannels[key].field].displayName ||\n          this.config[this.visualChannels[key].field].name)\n        : this.visualChannels[key].defaultMeasure\n    };\n  }\n\n  /**\n   * Assign a field to layer column, return column config\n   * @param key - Column Key\n   * @param field - Selected field\n   * @returns {{}} - Column config\n   */\n  assignColumn(key, field) {\n    // field value could be null for optional columns\n    const update = field\n      ? {\n          value: field.name,\n          fieldIdx: field.fieldIdx\n        }\n      : {value: null, fieldIdx: -1};\n\n    return {\n      ...this.config.columns,\n      [key]: {\n        ...this.config.columns[key],\n        ...update\n      }\n    };\n  }\n\n  /**\n   * Assign a field pair to column config, return column config\n   * @param key - Column Key\n   * @param pair - field Pair\n   * @returns {object} - Column config\n   */\n  assignColumnPairs(key, pair) {\n    if (!this.columnPairs || !this.columnPairs?.[key]) {\n      // should not end in this state\n      return this.config.columns;\n    }\n\n    const {pair: partnerKey, fieldPairKey} = this.columnPairs?.[key];\n    const {fieldPairKey: partnerFieldPairKey} = this.columnPairs?.[partnerKey];\n\n    return {\n      ...this.config.columns,\n      [key]: pair[fieldPairKey],\n      [partnerKey]: pair[partnerFieldPairKey]\n    };\n  }\n\n  /**\n   * Calculate a radius zoom multiplier to render points, so they are visible in all zoom level\n   * @param {object} mapState\n   * @param {number} mapState.zoom - actual zoom\n   * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image\n   * @returns {number}\n   */\n  getZoomFactor({zoom, zoomOffset = 0}) {\n    return Math.pow(2, Math.max(14 - zoom + zoomOffset, 0));\n  }\n\n  /**\n   * Calculate a elevation zoom multiplier to render points, so they are visible in all zoom level\n   * @param {object} mapState\n   * @param {number} mapState.zoom - actual zoom\n   * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image\n   * @returns {number}\n   */\n  getElevationZoomFactor({zoom, zoomOffset = 0}) {\n    return this.config.visConfig.enableElevationZoomFactor\n      ? Math.pow(2, Math.max(8 - zoom + zoomOffset, 0))\n      : 1;\n  }\n\n  formatLayerData(datasets, filteredIndex) {\n    return {};\n  }\n\n  renderLayer() {\n    return [];\n  }\n\n  getHoverData(object, dataContainer) {\n    if (!object) {\n      return null;\n    }\n\n    // By default, each entry of layerData should have an index of a row in the original data container.\n    // Each layer can implement its own getHoverData method\n    return dataContainer.row(object.index);\n  }\n\n  /**\n   * When change layer type, try to copy over layer configs as much as possible\n   * @param configToCopy - config to copy over\n   * @param visConfigSettings - visConfig settings of config to copy\n   */\n  assignConfigToLayer(configToCopy, visConfigSettings) {\n    // don't deep merge visualChannel field\n    // don't deep merge color range, reversed: is not a key by default\n    const shallowCopy = ['colorRange', 'strokeColorRange'].concat(\n      Object.values(this.visualChannels).map(v => v.field)\n    );\n\n    // don't copy over domain and animation\n    const notToCopy = ['animation'].concat(Object.values(this.visualChannels).map(v => v.domain));\n    // if range is for the same property group copy it, otherwise, not to copy\n    Object.values(this.visualChannels).forEach(v => {\n      if (\n        configToCopy.visConfig[v.range] &&\n        this.visConfigSettings[v.range] &&\n        visConfigSettings[v.range].group !== this.visConfigSettings[v.range].group\n      ) {\n        notToCopy.push(v.range);\n      }\n    });\n\n    // don't copy over visualChannel range\n    const currentConfig = this.config;\n    const copied = this.copyLayerConfig(currentConfig, configToCopy, {\n      shallowCopy,\n      notToCopy\n    });\n\n    this.updateLayerConfig(copied);\n    // validate visualChannel field type and scale types\n    Object.keys(this.visualChannels).forEach(channel => {\n      this.validateVisualChannel(channel);\n    });\n  }\n\n  /*\n   * Recursively copy config over to an empty layer\n   * when received saved config, or copy config over from a different layer type\n   * make sure to only copy over value to existing keys\n   * @param {object} currentConfig - existing config to be override\n   * @param {object} configToCopy - new Config to copy over\n   * @param {string[]} shallowCopy - array of properties to not to be deep copied\n   * @param {string[]} notToCopy - array of properties not to copy\n   * @returns {object} - copied config\n   */\n  copyLayerConfig(currentConfig, configToCopy, {shallowCopy = [], notToCopy = []} = {}) {\n    const copied = {};\n    Object.keys(currentConfig).forEach(key => {\n      if (\n        isPlainObject(currentConfig[key]) &&\n        isPlainObject(configToCopy[key]) &&\n        !shallowCopy.includes(key) &&\n        !notToCopy.includes(key)\n      ) {\n        // recursively assign object value\n        copied[key] = this.copyLayerConfig(currentConfig[key], configToCopy[key], {\n          shallowCopy,\n          notToCopy\n        });\n      } else if (notNullorUndefined(configToCopy[key]) && !notToCopy.includes(key)) {\n        // copy\n        copied[key] = configToCopy[key];\n      } else {\n        // keep existing\n        copied[key] = currentConfig[key];\n      }\n    });\n\n    return copied;\n  }\n\n  registerVisConfig(layerVisConfigs) {\n    Object.keys(layerVisConfigs).forEach(item => {\n      if (typeof item === 'string' && LAYER_VIS_CONFIGS[layerVisConfigs[item]]) {\n        // if assigned one of default LAYER_CONFIGS\n        this.config.visConfig[item] = LAYER_VIS_CONFIGS[layerVisConfigs[item]].defaultValue;\n        this.visConfigSettings[item] = LAYER_VIS_CONFIGS[layerVisConfigs[item]];\n      } else if (['type', 'defaultValue'].every(p => layerVisConfigs[item].hasOwnProperty(p))) {\n        // if provided customized visConfig, and has type && defaultValue\n        // TODO: further check if customized visConfig is valid\n        this.config.visConfig[item] = layerVisConfigs[item].defaultValue;\n        this.visConfigSettings[item] = layerVisConfigs[item];\n      }\n    });\n  }\n\n  getLayerColumns() {\n    const columnValidators = this.columnValidators || {};\n    const required = this.requiredLayerColumns.reduce(\n      (accu, key) => ({\n        ...accu,\n        [key]: columnValidators[key]\n          ? {value: null, fieldIdx: -1, validator: columnValidators[key]}\n          : {value: null, fieldIdx: -1}\n      }),\n      {}\n    );\n    const optional = this.optionalColumns.reduce(\n      (accu, key) => ({\n        ...accu,\n        [key]: {value: null, fieldIdx: -1, optional: true}\n      }),\n      {}\n    );\n\n    return {...required, ...optional};\n  }\n\n  updateLayerConfig(newConfig) {\n    this.config = {...this.config, ...newConfig};\n    return this;\n  }\n\n  updateLayerVisConfig(newVisConfig) {\n    this.config.visConfig = {...this.config.visConfig, ...newVisConfig};\n    return this;\n  }\n\n  updateLayerColorUI(prop, newConfig) {\n    const {colorUI: previous, visConfig} = this.config;\n\n    if (!isPlainObject(newConfig) || typeof prop !== 'string') {\n      return this;\n    }\n\n    const colorUIProp = Object.entries(newConfig).reduce((accu, [key, value]) => {\n      return {\n        ...accu,\n        [key]: isPlainObject(accu[key]) && isPlainObject(value) ? {...accu[key], ...value} : value\n      };\n    }, previous[prop] || DEFAULT_COLOR_UI);\n\n    const colorUI = {\n      ...previous,\n      [prop]: colorUIProp\n    };\n\n    this.updateLayerConfig({colorUI});\n    // if colorUI[prop] is colorRange\n    const isColorRange = visConfig[prop] && visConfig[prop].colors;\n\n    if (isColorRange) {\n      this.updateColorUIByColorRange(newConfig, prop);\n      this.updateColorRangeByColorUI(newConfig, previous, prop);\n      this.updateCustomPalette(newConfig, previous, prop);\n    }\n\n    return this;\n  }\n\n  updateCustomPalette(newConfig, previous, prop) {\n    if (!newConfig.colorRangeConfig || !newConfig.colorRangeConfig.custom) {\n      return;\n    }\n\n    const {colorUI, visConfig} = this.config;\n\n    if (!visConfig[prop]) return;\n    const {colors} = visConfig[prop];\n    const customPalette = {\n      ...colorUI[prop].customPalette,\n      name: 'Custom Palette',\n      colors: [...colors]\n    };\n    this.updateLayerConfig({\n      colorUI: {\n        ...colorUI,\n        [prop]: {\n          ...colorUI[prop],\n          customPalette\n        }\n      }\n    });\n  }\n  /**\n   * if open dropdown and prop is color range\n   * Automatically set colorRangeConfig's step and reversed\n   * @param {*} newConfig\n   * @param {*} prop\n   */\n  updateColorUIByColorRange(newConfig, prop) {\n    if (typeof newConfig.showDropdown !== 'number') return;\n\n    const {colorUI, visConfig} = this.config;\n    this.updateLayerConfig({\n      colorUI: {\n        ...colorUI,\n        [prop]: {\n          ...colorUI[prop],\n          colorRangeConfig: {\n            ...colorUI[prop].colorRangeConfig,\n            steps: visConfig[prop].colors.length,\n            reversed: Boolean(visConfig[prop].reversed)\n          }\n        }\n      }\n    });\n  }\n\n  updateColorRangeByColorUI(newConfig, previous, prop) {\n    // only update colorRange if changes in UI is made to 'reversed', 'steps' or steps\n    const shouldUpdate =\n      newConfig.colorRangeConfig &&\n      ['reversed', 'steps'].some(\n        key =>\n          newConfig.colorRangeConfig.hasOwnProperty(key) &&\n          newConfig.colorRangeConfig[key] !==\n            (previous[prop] || DEFAULT_COLOR_UI).colorRangeConfig[key]\n      );\n    if (!shouldUpdate) return;\n\n    const {colorUI, visConfig} = this.config;\n    const {steps, reversed} = colorUI[prop].colorRangeConfig;\n    const colorRange = visConfig[prop];\n    // find based on step or reversed\n    let update;\n    if (newConfig.colorRangeConfig.hasOwnProperty('steps')) {\n      const group = getColorGroupByName(colorRange);\n\n      if (group) {\n        const sameGroup = COLOR_RANGES.filter(cr => getColorGroupByName(cr) === group);\n\n        update = sameGroup.find(cr => cr.colors.length === steps);\n\n        if (update && colorRange.reversed) {\n          update = reverseColorRange(true, update);\n        }\n      }\n    }\n\n    if (newConfig.colorRangeConfig.hasOwnProperty('reversed')) {\n      update = reverseColorRange(reversed, update || colorRange);\n    }\n\n    if (update) {\n      this.updateLayerVisConfig({[prop]: update});\n    }\n  }\n\n  /**\n   * Check whether layer has all columns\n   * @returns {boolean} yes or no\n   */\n  hasAllColumns() {\n    const {columns} = this.config;\n    return (\n      (columns &&\n      Object.values(columns).every(v => {\n        return Boolean(v.optional || (v.value && v.fieldIdx > -1));\n      }))\n    );\n  }\n\n  /**\n   * Check whether layer has data\n   *\n   * @param {Array | Object} layerData\n   * @returns {boolean} yes or no\n   */\n  hasLayerData(layerData) {\n    if (!layerData) {\n      return false;\n    }\n    return Boolean(layerData.data && layerData.data.length);\n  }\n\n  isValidToSave() {\n    return this.type && this.hasAllColumns();\n  }\n\n  shouldRenderLayer(data) {\n    return (\n      (this.type &&\n      this.hasAllColumns() &&\n      this.hasLayerData(data) &&\n      typeof this.renderLayer === 'function')\n    );\n  }\n\n  getColorScale(colorScale, colorDomain, colorRange) {\n    if (Array.isArray(colorRange.colorMap)) {\n      const cMap = new Map();\n      colorRange.colorMap.forEach(([k, v]) => {\n        cMap.set(k, typeof v === 'string' ? hexToRgb(v) : v);\n      });\n\n      // @ts-ignore d3 scale\n      const scale = SCALE_FUNC[SCALE_TYPES.ordinal]()\n        .domain(cMap.keys())\n        .range(cMap.values())\n        .unknown(cMap.get(UNKNOWN_COLOR_KEY) || NO_VALUE_COLOR);\n      return scale;\n    }\n\n    return this.getVisChannelScale(colorScale, colorDomain, colorRange.colors.map(hexToRgb));\n  }\n\n  /**\n   * Mapping from visual channels to deck.gl accesors\n   * @param {Object} param Parameters\n   * @param {Function} param.dataAccessor Access kepler.gl layer data from deck.gl layer\n   * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} param.dataContainer DataContainer to use use with dataAccessor\n   * @return {Object} attributeAccessors - deck.gl layer attribute accessors\n   */\n  getAttributeAccessors({dataAccessor = defaultDataAccessor, dataContainer}) {\n    const attributeAccessors = {};\n\n    Object.keys(this.visualChannels).forEach(channel => {\n      const {\n        field,\n        fixed,\n        scale,\n        domain,\n        range,\n        accessor,\n        defaultValue,\n        getAttributeValue,\n        nullValue,\n        channelScaleType\n      } = this.visualChannels[channel];\n\n      const shouldGetScale = this.config[field];\n\n      if (shouldGetScale) {\n        const args = [this.config[scale], this.config[domain], this.config.visConfig[range]];\n        const isFixed = fixed && this.config.visConfig[fixed];\n\n        const scaleFunction =\n          channelScaleType === CHANNEL_SCALES.color\n            ? this.getColorScale(...args)\n            : this.getVisChannelScale(...args, isFixed);\n\n        attributeAccessors[accessor] = d =>\n          this.getEncodedChannelValue(\n            scaleFunction,\n            dataAccessor(dataContainer)(d),\n            this.config[field],\n            nullValue\n          );\n      } else if (typeof getAttributeValue === 'function') {\n        attributeAccessors[accessor] = getAttributeValue(this.config);\n      } else {\n        attributeAccessors[accessor] =\n          typeof defaultValue === 'function' ? defaultValue(this.config) : defaultValue;\n      }\n\n      if (!attributeAccessors[accessor]) {\n        Console.warn(`Failed to provide accessor function for ${accessor || channel}`);\n      }\n    });\n\n    return attributeAccessors;\n  }\n\n  getVisChannelScale(scale, domain, range, fixed) {\n    // @ts-ignore d3-scale type\n    return SCALE_FUNC[fixed ? 'linear' : scale]()\n      .domain(domain)\n      .range(fixed ? domain : range);\n  }\n\n  /**\n   * Get longitude and latitude bounds of the data.\n   * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} dataContainer DataContainer to calculate bounds for.\n   * @param {(d: {index: number}, dc: import('utils/table-utils/data-container-interface').DataContainerInterface) => number[]} getPosition Access kepler.gl layer data from deck.gl layer\n   * @return {number[]|null} bounds of the data.\n   */\n  getPointsBounds(dataContainer, getPosition) {\n    // no need to loop through the entire dataset\n    // get a sample of data to calculate bounds\n    const sampleData =\n      dataContainer.numRows() > MAX_SAMPLE_SIZE\n        ? getSampleData(dataContainer, MAX_SAMPLE_SIZE)\n        : dataContainer;\n\n    const points = sampleData.mapIndex(getPosition);\n\n    const latBounds = getLatLngBounds(points, 1, [-90, 90]);\n    const lngBounds = getLatLngBounds(points, 0, [-180, 180]);\n\n    if (!latBounds || !lngBounds) {\n      return null;\n    }\n\n    return [lngBounds[0], latBounds[0], lngBounds[1], latBounds[1]];\n  }\n\n  getChangedTriggers(dataUpdateTriggers) {\n    const triggerChanged = diffUpdateTriggers(dataUpdateTriggers, this._oldDataUpdateTriggers);\n    this._oldDataUpdateTriggers = dataUpdateTriggers;\n\n    return triggerChanged;\n  }\n\n  getEncodedChannelValue(\n    scale,\n    data,\n    field,\n    nullValue = NO_VALUE_COLOR,\n    getValue = defaultGetFieldValue\n  ) {\n    const {type} = field;\n    const value = getValue(field, data);\n\n    if (!notNullorUndefined(value)) {\n      return nullValue;\n    }\n\n    let attributeValue;\n    if (type === ALL_FIELD_TYPES.timestamp) {\n      // shouldn't need to convert here\n      // scale Function should take care of it\n      attributeValue = scale(new Date(value));\n    } else {\n      attributeValue = scale(value);\n    }\n\n    if (!notNullorUndefined(attributeValue)) {\n      attributeValue = nullValue;\n    }\n\n    return attributeValue;\n  }\n\n  updateMeta(meta) {\n    this.meta = {...this.meta, ...meta};\n  }\n\n  getDataUpdateTriggers({filteredIndex, id, allData}) {\n    const {columns} = this.config;\n\n    return {\n      getData: {datasetId: id, allData, columns, filteredIndex},\n      getMeta: {datasetId: id, allData, columns},\n      ...(this.config.textLabel || []).reduce(\n        (accu, tl, i) => ({\n          ...accu,\n          [`getLabelCharacterSet-${i}`]: tl.field ? tl.field.name : null\n        }),\n        {}\n      )\n    };\n  }\n\n  updateData(datasets, oldLayerData) {\n    if (!this.config.dataId) {\n      return {};\n    }\n    const layerDataset = datasets[this.config.dataId];\n    const {dataContainer} = layerDataset;\n\n    const getPosition = this.getPositionAccessor(dataContainer);\n    const dataUpdateTriggers = this.getDataUpdateTriggers(layerDataset);\n    const triggerChanged = this.getChangedTriggers(dataUpdateTriggers);\n\n    if (triggerChanged.getMeta) {\n      this.updateLayerMeta(dataContainer, getPosition);\n    }\n\n    let data = [];\n\n    if (!triggerChanged.getData && oldLayerData && oldLayerData.data) {\n      // same data\n      data = oldLayerData.data;\n    } else {\n      data = this.calculateDataAttribute(layerDataset, getPosition);\n    }\n\n    return {data, triggerChanged};\n  }\n\n  /**\n   * helper function to update one layer domain when state.data changed\n   * if state.data change is due ot update filter, newFiler will be passed\n   * called by updateAllLayerDomainData\n   * @param {Object} datasets\n   * @param {Object} newFilter\n   * @returns {object} layer\n   */\n  updateLayerDomain(datasets, newFilter) {\n    const table = this.getDataset(datasets);\n    if (!table) {\n      return this;\n    }\n    Object.values(this.visualChannels).forEach(channel => {\n      const {scale} = channel;\n      const scaleType = this.config[scale];\n      // ordinal domain is based on dataContainer, if only filter changed\n      // no need to update ordinal domain\n      if (!newFilter || scaleType !== SCALE_TYPES.ordinal) {\n        const {domain} = channel;\n        const updatedDomain = this.calculateLayerDomain(table, channel);\n        this.updateLayerConfig({[domain]: updatedDomain});\n      }\n    });\n\n    return this;\n  }\n\n  getDataset(datasets) {\n    return this.config.dataId ? datasets[this.config.dataId] : null;\n  }\n\n  /**\n   * Validate visual channel field and scales based on supported field & scale type\n   * @param channel\n   */\n  validateVisualChannel(channel) {\n    this.validateFieldType(channel);\n    this.validateScale(channel);\n  }\n\n  /**\n   * Validate field type based on channelScaleType\n   */\n  validateFieldType(channel) {\n    const visualChannel = this.visualChannels[channel];\n    const {field, channelScaleType, supportedFieldTypes} = visualChannel;\n\n    if (this.config[field]) {\n      // if field is selected, check if field type is supported\n      const channelSupportedFieldTypes =\n        supportedFieldTypes || CHANNEL_SCALE_SUPPORTED_FIELDS[channelScaleType];\n\n      if (!channelSupportedFieldTypes.includes(this.config[field].type)) {\n        // field type is not supported, set it back to null\n        // set scale back to default\n        this.updateLayerConfig({[field]: null});\n      }\n    }\n  }\n\n  /**\n   * Validate scale type based on aggregation\n   */\n  validateScale(channel) {\n    const visualChannel = this.visualChannels[channel];\n    const {scale} = visualChannel;\n    if (!scale) {\n      // visualChannel doesn't have scale\n      return;\n    }\n    const scaleOptions = this.getScaleOptions(channel);\n    // check if current selected scale is\n    // supported, if not, change to default\n    if (!scaleOptions.includes(this.config[scale])) {\n      this.updateLayerConfig({[scale]: scaleOptions[0]});\n    }\n  }\n\n  /**\n   * Get scale options based on current field\n   * @param {string} channel\n   * @returns {string[]}\n   */\n  getScaleOptions(channel) {\n    const visualChannel = this.visualChannels[channel];\n    const {field, scale, channelScaleType} = visualChannel;\n\n    return this.config[field]\n      ? FIELD_OPTS[this.config[field].type].scale[channelScaleType]\n      : [this.getDefaultLayerConfig()[scale]];\n  }\n\n  updateLayerVisualChannel(dataset, channel) {\n    const visualChannel = this.visualChannels[channel];\n    this.validateVisualChannel(channel);\n    // calculate layer channel domain\n    const updatedDomain = this.calculateLayerDomain(dataset, visualChannel);\n    this.updateLayerConfig({[visualChannel.domain]: updatedDomain});\n  }\n\n  getVisualChannelUpdateTriggers() {\n    const updateTriggers = {};\n    Object.values(this.visualChannels).forEach(visualChannel => {\n      // field range scale domain\n      const {accessor, field, scale, domain, range, defaultValue, fixed} = visualChannel;\n\n      updateTriggers[accessor] = {\n        [field]: this.config[field],\n        [scale]: this.config[scale],\n        [domain]: this.config[domain],\n        [range]: this.config.visConfig[range],\n        defaultValue: typeof defaultValue === 'function' ? defaultValue(this.config) : defaultValue,\n        ...(fixed ? {[fixed]: this.config.visConfig[fixed]} : {})\n      };\n    });\n    return updateTriggers;\n  }\n\n  calculateLayerDomain(dataset, visualChannel) {\n    const {scale} = visualChannel;\n    const scaleType = this.config[scale];\n\n    const field = this.config[visualChannel.field];\n    if (!field) {\n      // if colorField or sizeField were set back to null\n      return defaultDomain;\n    }\n\n    return dataset.getColumnLayerDomain(field, scaleType) || defaultDomain;\n  }\n\n  hasHoveredObject(objectInfo) {\n    return this.isLayerHovered(objectInfo) && objectInfo.object ? objectInfo.object : null;\n  }\n\n  isLayerHovered(objectInfo) {\n    return objectInfo?.picked && objectInfo?.layer?.props?.id === this.id;\n  }\n\n  getRadiusScaleByZoom(mapState, fixedRadius) {\n    const radiusChannel = Object.values(this.visualChannels).find(vc => vc.property === 'radius');\n\n    if (!radiusChannel) {\n      return 1;\n    }\n\n    const field = radiusChannel.field;\n    const fixed = fixedRadius === undefined ? this.config.visConfig.fixedRadius : fixedRadius;\n    const {radius} = this.config.visConfig;\n\n    // @ts-ignore\n    return fixed ? 1 : (this.config[field] ? 1 : radius) * this.getZoomFactor(mapState);\n  }\n\n  shouldCalculateLayerData(props) {\n    return props.some(p => !this.noneLayerDataAffectingProps.includes(p));\n  }\n\n  getBrushingExtensionProps(interactionConfig, brushingTarget) {\n    const {brush} = interactionConfig;\n\n    return {\n      // brushing\n      autoHighlight: !brush.enabled,\n      brushingRadius: brush.config.size * 1000,\n      brushingTarget: brushingTarget || 'source',\n      brushingEnabled: brush.enabled\n    };\n  }\n\n  getDefaultDeckLayerProps({idx, gpuFilter, mapState, visible}) {\n    return {\n      id: this.id,\n      idx,\n      coordinateSystem: COORDINATE_SYSTEM.LNGLAT,\n      pickable: true,\n      wrapLongitude: true,\n      parameters: {depthTest: Boolean(mapState.dragRotate || this.config.visConfig.enable3d)},\n      hidden: this.config.hidden,\n      // visconfig\n      opacity: this.config.visConfig.opacity,\n      highlightColor: this.config.highlightColor,\n      // data filtering\n      extensions: [dataFilterExtension],\n      filterRange: gpuFilter ? gpuFilter.filterRange : undefined,\n\n      // layer should be visible and if splitMap, shown in to one of panel\n      visible: this.config.isVisible && visible\n    };\n  }\n\n  getDefaultHoverLayerProps() {\n    return {\n      id: `${this.id}-hovered`,\n      pickable: false,\n      wrapLongitude: true,\n      coordinateSystem: COORDINATE_SYSTEM.LNGLAT\n    };\n  }\n\n  renderTextLabelLayer({getPosition, getPixelOffset, updateTriggers, sharedProps}, renderOpts) {\n    const {data, mapState} = renderOpts;\n    const {textLabel} = this.config;\n\n    return data.textLabels.reduce((accu, d, i) => {\n      if (d.getText) {\n        accu.push(\n          new TextLayer({\n            ...sharedProps,\n            id: `${this.id}-label-${textLabel[i].field?.name}`,\n            data: data.data,\n            getText: d.getText,\n            getPosition,\n            characterSet: d.characterSet,\n            getPixelOffset: getPixelOffset(textLabel[i]),\n            getSize: 1,\n            sizeScale: textLabel[i].size,\n            getTextAnchor: textLabel[i].anchor,\n            getAlignmentBaseline: textLabel[i].alignment,\n            getColor: textLabel[i].color,\n            parameters: {\n              // text will always show on top of all layers\n              depthTest: false\n            },\n\n            getFilterValue: data.getFilterValue,\n            updateTriggers: {\n              ...updateTriggers,\n              getText: textLabel[i].field?.name,\n              getPixelOffset: {\n                ...updateTriggers.getRadius,\n                mapState,\n                anchor: textLabel[i].anchor,\n                alignment: textLabel[i].alignment\n              },\n              getTextAnchor: textLabel[i].anchor,\n              getAlignmentBaseline: textLabel[i].alignment,\n              getColor: textLabel[i].color\n            }\n          })\n        );\n      }\n      return accu;\n    }, []);\n  }\n\n  calculateDataAttribute(keplerTable, getPosition) {\n    // implemented in subclasses\n    return [];\n  }\n\n  updateLayerMeta(dataContainer, getPosition) {\n    // implemented in subclasses\n  }\n\n  getPositionAccessor(dataContainer) {\n    // implemented in subclasses\n    return () => null;\n  }\n}\n\nexport default Layer;\n"]},"metadata":{},"sourceType":"script"}