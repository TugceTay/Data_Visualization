{"ast":null,"code":"import { isWebGL, createGLContext, instrumentGLContext, resizeGLContext, resetParameters } from '@luma.gl/gltools';\nimport { requestAnimationFrame, cancelAnimationFrame, Query, lumaStats, Framebuffer, log, assert } from '@luma.gl/webgl';\nimport { isBrowser } from '@probe.gl/env';\nconst isPage = isBrowser() && typeof document !== 'undefined';\nlet statIdCounter = 0;\nexport default class AnimationLoop {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      onCreateContext = opts => createGLContext(opts),\n      onAddHTML = null,\n      onInitialize = () => {},\n      onRender = () => {},\n      onFinalize = () => {},\n      onError,\n      gl = null,\n      glOptions = {},\n      debug = false,\n      createFramebuffer = false,\n      autoResizeViewport = true,\n      autoResizeDrawingBuffer = true,\n      stats = lumaStats.get(\"animation-loop-\".concat(statIdCounter++))\n    } = props;\n    let {\n      useDevicePixels = true\n    } = props;\n    if ('useDevicePixelRatio' in props) {\n      log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n      useDevicePixels = props.useDevicePixelRatio;\n    }\n    this.props = {\n      onCreateContext,\n      onAddHTML,\n      onInitialize,\n      onRender,\n      onFinalize,\n      onError,\n      gl,\n      glOptions,\n      debug,\n      createFramebuffer\n    };\n    this.gl = gl;\n    this.needsRedraw = null;\n    this.timeline = null;\n    this.stats = stats;\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n    this._initialized = false;\n    this._running = false;\n    this._animationFrameId = null;\n    this._nextFramePromise = null;\n    this._resolveNextFrame = null;\n    this._cpuStartTime = 0;\n    this.setProps({\n      autoResizeViewport,\n      autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this._pageLoadPromise = null;\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n  delete() {\n    this.stop();\n    this._setDisplay(null);\n  }\n  setNeedsRedraw(reason) {\n    assert(typeof reason === 'string');\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n  setProps(props) {\n    if ('autoResizeViewport' in props) {\n      this.autoResizeViewport = props.autoResizeViewport;\n    }\n    if ('autoResizeDrawingBuffer' in props) {\n      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;\n    }\n    if ('useDevicePixels' in props) {\n      this.useDevicePixels = props.useDevicePixels;\n    }\n    return this;\n  }\n  start() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this._running) {\n      return this;\n    }\n    this._running = true;\n    const startPromise = this._getPageLoadPromise().then(() => {\n      if (!this._running || this._initialized) {\n        return null;\n      }\n      this._createWebGLContext(opts);\n      this._createFramebuffer();\n      this._startEventHandling();\n      this._initializeCallbackData();\n      this._updateCallbackData();\n      this._resizeCanvasDrawingBuffer();\n      this._resizeViewport();\n      this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n      this._initialized = true;\n      return this.onInitialize(this.animationProps);\n    }).then(appContext => {\n      if (this._running) {\n        this._addCallbackData(appContext || {});\n        if (appContext !== false) {\n          this._startLoop();\n        }\n      }\n    });\n    if (this.props.onError) {\n      startPromise.catch(this.props.onError);\n    }\n    return this;\n  }\n  redraw() {\n    if (this.isContextLost()) {\n      return this;\n    }\n    this._beginTimers();\n    this._setupFrame();\n    this._updateCallbackData();\n    this._renderFrame(this.animationProps);\n    this._clearNeedsRedraw();\n    if (this.offScreen && this.gl.commit) {\n      this.gl.commit();\n    }\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n    this._endTimers();\n    return this;\n  }\n  stop() {\n    if (this._running) {\n      this._finalizeCallbackData();\n      this._cancelAnimationFrame(this._animationFrameId);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._animationFrameId = null;\n      this._running = false;\n    }\n    return this;\n  }\n  attachTimeline(timeline) {\n    this.timeline = timeline;\n    return this.timeline;\n  }\n  detachTimeline() {\n    this.timeline = null;\n  }\n  waitForRender() {\n    this.setNeedsRedraw('waitForRender');\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n    return this._nextFramePromise;\n  }\n  async toDataURL() {\n    this.setNeedsRedraw('toDataURL');\n    await this.waitForRender();\n    return this.gl.canvas.toDataURL();\n  }\n  isContextLost() {\n    return this.gl.isContextLost();\n  }\n  onCreateContext() {\n    return this.props.onCreateContext(...arguments);\n  }\n  onInitialize() {\n    return this.props.onInitialize(...arguments);\n  }\n  onRender() {\n    return this.props.onRender(...arguments);\n  }\n  onFinalize() {\n    return this.props.onFinalize(...arguments);\n  }\n  getHTMLControlValue(id) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const element = document.getElementById(id);\n    return element ? Number(element.value) : defaultValue;\n  }\n  setViewParameters() {\n    log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();\n    return this;\n  }\n  _startLoop() {\n    const renderFrame = () => {\n      if (!this._running) {\n        return;\n      }\n      this.redraw();\n      this._animationFrameId = this._requestAnimationFrame(renderFrame);\n    };\n    this._cancelAnimationFrame(this._animationFrameId);\n    this._animationFrameId = this._requestAnimationFrame(renderFrame);\n  }\n  _getPageLoadPromise() {\n    if (!this._pageLoadPromise) {\n      this._pageLoadPromise = isPage ? new Promise((resolve, reject) => {\n        if (isPage && document.readyState === 'complete') {\n          resolve(document);\n          return;\n        }\n        window.addEventListener('load', () => {\n          resolve(document);\n        });\n      }) : Promise.resolve({});\n    }\n    return this._pageLoadPromise;\n  }\n  _setDisplay(display) {\n    if (this.display) {\n      this.display.delete();\n      this.display.animationLoop = null;\n    }\n    if (display) {\n      display.animationLoop = this;\n    }\n    this.display = display;\n  }\n  _cancelAnimationFrame(animationFrameId) {\n    if (this.display && this.display.cancelAnimationFrame) {\n      return this.display.cancelAnimationFrame(animationFrameId);\n    }\n    return cancelAnimationFrame(animationFrameId);\n  }\n  _requestAnimationFrame(renderFrameCallback) {\n    if (this._running) {\n      if (this.display && this.display.requestAnimationFrame) {\n        return this.display.requestAnimationFrame(renderFrameCallback);\n      }\n      return requestAnimationFrame(renderFrameCallback);\n    }\n    return undefined;\n  }\n  _renderFrame() {\n    if (this.display) {\n      this.display._renderFrame(...arguments);\n      return;\n    }\n    this.onRender(...arguments);\n  }\n  _clearNeedsRedraw() {\n    this.needsRedraw = null;\n  }\n  _setupFrame() {\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n    this._resizeFramebuffer();\n  }\n  _initializeCallbackData() {\n    this.animationProps = {\n      gl: this.gl,\n      stop: this.stop,\n      canvas: this.gl.canvas,\n      framebuffer: this.framebuffer,\n      useDevicePixels: this.useDevicePixels,\n      needsRedraw: null,\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n      time: 0,\n      _timeline: this.timeline,\n      _loop: this,\n      _animationLoop: this,\n      _mousePosition: null\n    };\n  }\n  _updateCallbackData() {\n    const {\n      width,\n      height,\n      aspect\n    } = this._getSizeAndAspect();\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n    this.animationProps.needsRedraw = this.needsRedraw;\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);\n    this.animationProps.tock++;\n    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;\n    this.animationProps._offScreen = this.offScreen;\n  }\n  _finalizeCallbackData() {\n    this.onFinalize(this.animationProps);\n  }\n  _addCallbackData(appContext) {\n    if (typeof appContext === 'object' && appContext !== null) {\n      this.animationProps = Object.assign({}, this.animationProps, appContext);\n    }\n  }\n  _createWebGLContext(opts) {\n    this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;\n    opts = Object.assign({}, opts, this.props.glOptions);\n    this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);\n    if (!isWebGL(this.gl)) {\n      throw new Error('AnimationLoop.onCreateContext - illegal context returned');\n    }\n    resetParameters(this.gl);\n    this._createInfoDiv();\n  }\n  _createInfoDiv() {\n    if (this.gl.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      wrapperDiv.appendChild(this.gl.canvas);\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n  _getSizeAndAspect() {\n    const width = this.gl.drawingBufferWidth;\n    const height = this.gl.drawingBufferHeight;\n    let aspect = 1;\n    const {\n      canvas\n    } = this.gl;\n    if (canvas && canvas.clientHeight) {\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n    return {\n      width,\n      height,\n      aspect\n    };\n  }\n  _resizeViewport() {\n    if (this.autoResizeViewport) {\n      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n    }\n  }\n  _resizeCanvasDrawingBuffer() {\n    if (this.autoResizeDrawingBuffer) {\n      resizeGLContext(this.gl, {\n        useDevicePixels: this.useDevicePixels\n      });\n    }\n  }\n  _createFramebuffer() {\n    if (this.props.createFramebuffer) {\n      this.framebuffer = new Framebuffer(this.gl);\n    }\n  }\n  _resizeFramebuffer() {\n    if (this.framebuffer) {\n      this.framebuffer.resize({\n        width: this.gl.drawingBufferWidth,\n        height: this.gl.drawingBufferHeight\n      });\n    }\n  }\n  _beginTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n    if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {\n      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    }\n    if (this._gpuTimeQuery) {\n      this._gpuTimeQuery.beginTimeElapsedQuery();\n    }\n    this.cpuTime.timeStart();\n  }\n  _endTimers() {\n    this.cpuTime.timeEnd();\n    if (this._gpuTimeQuery) {\n      this._gpuTimeQuery.end();\n    }\n  }\n  _startEventHandling() {\n    const {\n      canvas\n    } = this.gl;\n    if (canvas) {\n      canvas.addEventListener('mousemove', this._onMousemove);\n      canvas.addEventListener('mouseleave', this._onMouseleave);\n    }\n  }\n  _onMousemove(e) {\n    this.animationProps._mousePosition = [e.offsetX, e.offsetY];\n  }\n  _onMouseleave(e) {\n    this.animationProps._mousePosition = null;\n  }\n}","map":{"version":3,"sources":["../../../src/lib/animation-loop.js"],"names":["isWebGL","createGLContext","instrumentGLContext","resizeGLContext","resetParameters","requestAnimationFrame","cancelAnimationFrame","Query","lumaStats","Framebuffer","log","assert","isBrowser","isPage","document","statIdCounter","AnimationLoop","constructor","props","onCreateContext","opts","onAddHTML","onInitialize","onRender","onFinalize","onError","gl","glOptions","debug","createFramebuffer","autoResizeViewport","autoResizeDrawingBuffer","stats","get","useDevicePixels","deprecated","useDevicePixelRatio","needsRedraw","timeline","cpuTime","gpuTime","frameRate","_initialized","_running","_animationFrameId","_nextFramePromise","_resolveNextFrame","_cpuStartTime","setProps","start","bind","stop","_pageLoadPromise","_onMousemove","_onMouseleave","delete","_setDisplay","setNeedsRedraw","reason","startPromise","_getPageLoadPromise","then","_createWebGLContext","_createFramebuffer","_startEventHandling","_initializeCallbackData","_updateCallbackData","_resizeCanvasDrawingBuffer","_resizeViewport","_gpuTimeQuery","isSupported","animationProps","appContext","_addCallbackData","_startLoop","catch","redraw","isContextLost","_beginTimers","_setupFrame","_renderFrame","_clearNeedsRedraw","offScreen","commit","_endTimers","_finalizeCallbackData","_cancelAnimationFrame","attachTimeline","detachTimeline","waitForRender","Promise","resolve","toDataURL","canvas","getHTMLControlValue","id","defaultValue","element","getElementById","Number","value","setViewParameters","removed","renderFrame","_requestAnimationFrame","reject","readyState","window","addEventListener","display","animationLoop","animationFrameId","renderFrameCallback","undefined","_resizeFramebuffer","framebuffer","startTime","Date","now","engineTime","tick","tock","time","_timeline","_loop","_animationLoop","_mousePosition","width","height","aspect","_getSizeAndAspect","update","Math","floor","getTime","_offScreen","Object","assign","OffscreenCanvas","Error","_createInfoDiv","wrapperDiv","createElement","body","appendChild","style","position","div","left","bottom","background","html","innerHTML","drawingBufferWidth","drawingBufferHeight","clientHeight","clientWidth","viewport","resize","timeEnd","timeStart","isResultAvailable","isTimerDisjoint","addTime","getTimerMilliseconds","beginTimeElapsedQuery","end","e","offsetX","offsetY"],"mappings":"AAAA,SACEA,OADF,EAEEC,eAFF,EAGEC,mBAHF,EAIEC,eAJF,EAKEC,eALF,QAMO,kBANP;AAQA,SACEC,qBADF,EAEEC,oBAFF,EAGEC,KAHF,EAIEC,SAJF,EAMEC,WANF,EAOEC,GAPF,EAQEC,MARF,QASO,gBATP;AAWA,SAAQC,SAAR,QAAwB,eAAxB;AAEA,MAAMC,MAAM,GAAGD,SAAS,EAAA,IAAM,OAAOE,QAAP,KAAoB,WAAlD;AAEA,IAAIC,aAAa,GAAG,CAApB;AAEA,eAAe,MAAMC,aAAN,CAAoB;EAIjCC,WAAW,GAAa;IAAA,IAAZC,KAAY,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;IACtB,MAAM;MACJC,eAAe,GAAGC,IAAI,IAAInB,eAAe,CAACmB,IAAD,CADrC;MAEJC,SAAS,GAAG,IAFR;MAGJC,YAAY,GAAG,MAAM,CAAE,CAHnB;MAIJC,QAAQ,GAAG,MAAM,CAAE,CAJf;MAKJC,UAAU,GAAG,MAAM,CAAE,CALjB;MAMJC,OANI;MAQJC,EAAE,GAAG,IARD;MASJC,SAAS,GAAG,CAAA,CATR;MAUJC,KAAK,GAAG,KAVJ;MAYJC,iBAAiB,GAAG,KAZhB;MAeJC,kBAAkB,GAAG,IAfjB;MAgBJC,uBAAuB,GAAG,IAhBtB;MAiBJC,KAAK,GAAGxB,SAAS,CAACyB,GAAVzB,CAAAA,iBAAAA,CAAAA,MAAAA,CAAgCO,aAAa,EAA7CP,CAAAA;IAjBJ,CAAA,GAkBFU,KAlBJ;IAoBA,IAAI;MAACgB,eAAe,GAAG;IAAnB,CAAA,GAA2BhB,KAA/B;IAEA,IAAI,qBAAA,IAAyBA,KAA7B,EAAoC;MAClCR,GAAG,CAACyB,UAAJzB,CAAe,qBAAfA,EAAsC,iBAAtCA,CAAAA,EAAAA;MAEAwB,eAAe,GAAGhB,KAAK,CAACkB,mBAAxBF;IACD;IAED,IAAA,CAAKhB,KAAL,GAAa;MACXC,eADW;MAEXE,SAFW;MAGXC,YAHW;MAIXC,QAJW;MAKXC,UALW;MAMXC,OANW;MAQXC,EARW;MASXC,SATW;MAUXC,KAVW;MAWXC;IAXW,CAAb;IAeA,IAAA,CAAKH,EAAL,GAAUA,EAAV;IACA,IAAA,CAAKW,WAAL,GAAmB,IAAnB;IACA,IAAA,CAAKC,QAAL,GAAgB,IAAhB;IACA,IAAA,CAAKN,KAAL,GAAaA,KAAb;IACA,IAAA,CAAKO,OAAL,GAAe,IAAA,CAAKP,KAAL,CAAWC,GAAX,CAAe,UAAf,CAAf;IACA,IAAA,CAAKO,OAAL,GAAe,IAAA,CAAKR,KAAL,CAAWC,GAAX,CAAe,UAAf,CAAf;IACA,IAAA,CAAKQ,SAAL,GAAiB,IAAA,CAAKT,KAAL,CAAWC,GAAX,CAAe,YAAf,CAAjB;IAEA,IAAA,CAAKS,YAAL,GAAoB,KAApB;IACA,IAAA,CAAKC,QAAL,GAAgB,KAAhB;IACA,IAAA,CAAKC,iBAAL,GAAyB,IAAzB;IACA,IAAA,CAAKC,iBAAL,GAAyB,IAAzB;IACA,IAAA,CAAKC,iBAAL,GAAyB,IAAzB;IACA,IAAA,CAAKC,aAAL,GAAqB,CAArB;IAEA,IAAA,CAAKC,QAAL,CAAc;MACZlB,kBADY;MAEZC,uBAFY;MAGZG;IAHY,CAAd,CAAA;IAOA,IAAA,CAAKe,KAAL,GAAa,IAAA,CAAKA,KAAL,CAAWC,IAAX,CAAgB,IAAhB,CAAb;IACA,IAAA,CAAKC,IAAL,GAAY,IAAA,CAAKA,IAAL,CAAUD,IAAV,CAAe,IAAf,CAAZ;IAEA,IAAA,CAAKE,gBAAL,GAAwB,IAAxB;IAEA,IAAA,CAAKC,YAAL,GAAoB,IAAA,CAAKA,YAAL,CAAkBH,IAAlB,CAAuB,IAAvB,CAApB;IACA,IAAA,CAAKI,aAAL,GAAqB,IAAA,CAAKA,aAAL,CAAmBJ,IAAnB,CAAwB,IAAxB,CAArB;EACD;EAEDK,MAAM,GAAG;IACP,IAAA,CAAKJ,IAAL,EAAA;IACA,IAAA,CAAKK,WAAL,CAAiB,IAAjB,CAAA;EACD;EAEDC,cAAc,CAACC,MAAD,EAAS;IACrB/C,MAAM,CAAC,OAAO+C,MAAP,KAAkB,QAAnB,CAAN/C;IACA,IAAA,CAAK0B,WAAL,GAAmB,IAAA,CAAKA,WAAL,IAAoBqB,MAAvC;IACA,OAAO,IAAP;EACD;EAEDV,QAAQ,CAAC9B,KAAD,EAAQ;IACd,IAAI,oBAAA,IAAwBA,KAA5B,EAAmC;MACjC,IAAA,CAAKY,kBAAL,GAA0BZ,KAAK,CAACY,kBAAhC;IACD;IACD,IAAI,yBAAA,IAA6BZ,KAAjC,EAAwC;MACtC,IAAA,CAAKa,uBAAL,GAA+Bb,KAAK,CAACa,uBAArC;IACD;IACD,IAAI,iBAAA,IAAqBb,KAAzB,EAAgC;MAC9B,IAAA,CAAKgB,eAAL,GAAuBhB,KAAK,CAACgB,eAA7B;IACD;IACD,OAAO,IAAP;EACD;EAIDe,KAAK,GAAY;IAAA,IAAX7B,IAAW,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;IACf,IAAI,IAAA,CAAKuB,QAAT,EAAmB;MACjB,OAAO,IAAP;IACD;IACD,IAAA,CAAKA,QAAL,GAAgB,IAAhB;IAGA,MAAMgB,YAAY,GAAG,IAAA,CAAKC,mBAAL,EAAA,CAClBC,IADkB,CACb,MAAM;MACV,IAAI,CAAC,IAAA,CAAKlB,QAAN,IAAkB,IAAA,CAAKD,YAA3B,EAAyC;QACvC,OAAO,IAAP;MACD;MAGD,IAAA,CAAKoB,mBAAL,CAAyB1C,IAAzB,CAAA;MACA,IAAA,CAAK2C,kBAAL,EAAA;MACA,IAAA,CAAKC,mBAAL,EAAA;MAGA,IAAA,CAAKC,uBAAL,EAAA;MACA,IAAA,CAAKC,mBAAL,EAAA;MAGA,IAAA,CAAKC,0BAAL,EAAA;MACA,IAAA,CAAKC,eAAL,EAAA;MAEA,IAAA,CAAKC,aAAL,GAAqB9D,KAAK,CAAC+D,WAAN/D,CAAkB,IAAA,CAAKmB,EAAvBnB,EAA2B,CAAC,QAAD,CAA3BA,CAAAA,GAAyC,IAAIA,KAAJ,CAAU,IAAA,CAAKmB,EAAf,CAAzCnB,GAA8D,IAAnF;MAEA,IAAA,CAAKmC,YAAL,GAAoB,IAApB;MAGA,OAAO,IAAA,CAAKpB,YAAL,CAAkB,IAAA,CAAKiD,cAAvB,CAAP;IACD,CAzBkB,CAAA,CA0BlBV,IA1BkB,CA0BbW,UAAU,IAAI;MAClB,IAAI,IAAA,CAAK7B,QAAT,EAAmB;QACjB,IAAA,CAAK8B,gBAAL,CAAsBD,UAAU,IAAI,CAAA,CAApC,CAAA;QACA,IAAIA,UAAU,KAAK,KAAnB,EAA0B;UACxB,IAAA,CAAKE,UAAL,EAAA;QACD;MACF;IACF,CAjCkB,CAArB;IAmCA,IAAI,IAAA,CAAKxD,KAAL,CAAWO,OAAf,EAAwB;MACtBkC,YAAY,CAACgB,KAAbhB,CAAmB,IAAA,CAAKzC,KAAL,CAAWO,OAA9BkC,CAAAA;IACD;IAED,OAAO,IAAP;EACD;EAGDiB,MAAM,GAAG;IACP,IAAI,IAAA,CAAKC,aAAL,EAAJ,EAA0B;MACxB,OAAO,IAAP;IACD;IAED,IAAA,CAAKC,YAAL,EAAA;IAEA,IAAA,CAAKC,WAAL,EAAA;IACA,IAAA,CAAKb,mBAAL,EAAA;IAEA,IAAA,CAAKc,YAAL,CAAkB,IAAA,CAAKT,cAAvB,CAAA;IAGA,IAAA,CAAKU,iBAAL,EAAA;IAIA,IAAI,IAAA,CAAKC,SAAL,IAAkB,IAAA,CAAKxD,EAAL,CAAQyD,MAA9B,EAAsC;MACpC,IAAA,CAAKzD,EAAL,CAAQyD,MAAR,EAAA;IACD;IAED,IAAI,IAAA,CAAKrC,iBAAT,EAA4B;MAC1B,IAAA,CAAKA,iBAAL,CAAuB,IAAvB,CAAA;MACA,IAAA,CAAKD,iBAAL,GAAyB,IAAzB;MACA,IAAA,CAAKC,iBAAL,GAAyB,IAAzB;IACD;IAED,IAAA,CAAKsC,UAAL,EAAA;IAEA,OAAO,IAAP;EACD;EAGDjC,IAAI,GAAG;IAEL,IAAI,IAAA,CAAKR,QAAT,EAAmB;MACjB,IAAA,CAAK0C,qBAAL,EAAA;MACA,IAAA,CAAKC,qBAAL,CAA2B,IAAA,CAAK1C,iBAAhC,CAAA;MACA,IAAA,CAAKC,iBAAL,GAAyB,IAAzB;MACA,IAAA,CAAKC,iBAAL,GAAyB,IAAzB;MACA,IAAA,CAAKF,iBAAL,GAAyB,IAAzB;MACA,IAAA,CAAKD,QAAL,GAAgB,KAAhB;IACD;IACD,OAAO,IAAP;EACD;EAED4C,cAAc,CAACjD,QAAD,EAAW;IACvB,IAAA,CAAKA,QAAL,GAAgBA,QAAhB;IAEA,OAAO,IAAA,CAAKA,QAAZ;EACD;EAEDkD,cAAc,GAAG;IACf,IAAA,CAAKlD,QAAL,GAAgB,IAAhB;EACD;EAEDmD,aAAa,GAAG;IACd,IAAA,CAAKhC,cAAL,CAAoB,eAApB,CAAA;IAEA,IAAI,CAAC,IAAA,CAAKZ,iBAAV,EAA6B;MAC3B,IAAA,CAAKA,iBAAL,GAAyB,IAAI6C,OAAJ,CAAYC,OAAO,IAAI;QAC9C,IAAA,CAAK7C,iBAAL,GAAyB6C,OAAzB;MACD,CAFwB,CAAzB;IAGD;IACD,OAAO,IAAA,CAAK9C,iBAAZ;EACD;EAEc,MAAT+C,SAAS,GAAG;IAChB,IAAA,CAAKnC,cAAL,CAAoB,WAApB,CAAA;IAEA,MAAM,IAAA,CAAKgC,aAAL,EAAN;IAEA,OAAO,IAAA,CAAK/D,EAAL,CAAQmE,MAAR,CAAeD,SAAf,EAAP;EACD;EAEDf,aAAa,GAAG;IACd,OAAO,IAAA,CAAKnD,EAAL,CAAQmD,aAAR,EAAP;EACD;EAED1D,eAAe,GAAU;IACvB,OAAO,IAAA,CAAKD,KAAL,CAAWC,eAAX,CAA2B,GAAA,SAA3B,CAAP;EACD;EAEDG,YAAY,GAAU;IACpB,OAAO,IAAA,CAAKJ,KAAL,CAAWI,YAAX,CAAwB,GAAA,SAAxB,CAAP;EACD;EAEDC,QAAQ,GAAU;IAChB,OAAO,IAAA,CAAKL,KAAL,CAAWK,QAAX,CAAoB,GAAA,SAApB,CAAP;EACD;EAEDC,UAAU,GAAU;IAClB,OAAO,IAAA,CAAKN,KAAL,CAAWM,UAAX,CAAsB,GAAA,SAAtB,CAAP;EACD;EAIDsE,mBAAmB,CAACC,EAAD,EAAuB;IAAA,IAAlBC,YAAkB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAH,CAAG;IACxC,MAAMC,OAAO,GAAGnF,QAAQ,CAACoF,cAATpF,CAAwBiF,EAAxBjF,CAAhB;IAEA,OAAOmF,OAAO,GAAGE,MAAM,CAACF,OAAO,CAACG,KAAT,CAAT,GAA2BJ,YAAzC;EACD;EAGDK,iBAAiB,GAAG;IAClB3F,GAAG,CAAC4F,OAAJ5F,CAAY,iCAAZA,EAA+C,wBAA/CA,CAAAA,EAAAA;IACA,OAAO,IAAP;EACD;EAIDgE,UAAU,GAAG;IACX,MAAM6B,WAAW,GAAG,MAAM;MACxB,IAAI,CAAC,IAAA,CAAK5D,QAAV,EAAoB;QAClB;MACD;MACD,IAAA,CAAKiC,MAAL,EAAA;MACA,IAAA,CAAKhC,iBAAL,GAAyB,IAAA,CAAK4D,sBAAL,CAA4BD,WAA5B,CAAzB;IACD,CAND;IASA,IAAA,CAAKjB,qBAAL,CAA2B,IAAA,CAAK1C,iBAAhC,CAAA;IACA,IAAA,CAAKA,iBAAL,GAAyB,IAAA,CAAK4D,sBAAL,CAA4BD,WAA5B,CAAzB;EACD;EAID3C,mBAAmB,GAAG;IACpB,IAAI,CAAC,IAAA,CAAKR,gBAAV,EAA4B;MAC1B,IAAA,CAAKA,gBAAL,GAAwBvC,MAAM,GAC1B,IAAI6E,OAAJ,CAAY,CAACC,OAAD,EAAUc,MAAV,KAAqB;QAC/B,IAAI5F,MAAM,IAAIC,QAAQ,CAAC4F,UAAT5F,KAAwB,UAAtC,EAAkD;UAChD6E,OAAO,CAAC7E,QAAD,CAAP6E;UACA;QACD;QACDgB,MAAM,CAACC,gBAAPD,CAAwB,MAAxBA,EAAgC,MAAM;UACpChB,OAAO,CAAC7E,QAAD,CAAP6E;QACD,CAFDgB,CAAAA;MAGD,CARD,CAD0B,GAU1BjB,OAAO,CAACC,OAARD,CAAgB,CAAA,CAAhBA,CAVJ;IAWD;IACD,OAAO,IAAA,CAAKtC,gBAAZ;EACD;EAEDI,WAAW,CAACqD,OAAD,EAAU;IACnB,IAAI,IAAA,CAAKA,OAAT,EAAkB;MAChB,IAAA,CAAKA,OAAL,CAAatD,MAAb,EAAA;MACA,IAAA,CAAKsD,OAAL,CAAaC,aAAb,GAA6B,IAA7B;IACD;IAGD,IAAID,OAAJ,EAAa;MACXA,OAAO,CAACC,aAARD,GAAwB,IAAxBA;IACD;IAED,IAAA,CAAKA,OAAL,GAAeA,OAAf;EACD;EAEDvB,qBAAqB,CAACyB,gBAAD,EAAmB;IAEtC,IAAI,IAAA,CAAKF,OAAL,IAAgB,IAAA,CAAKA,OAAL,CAAavG,oBAAjC,EAAuD;MACrD,OAAO,IAAA,CAAKuG,OAAL,CAAavG,oBAAb,CAAkCyG,gBAAlC,CAAP;IACD;IAED,OAAOzG,oBAAoB,CAACyG,gBAAD,CAA3B;EACD;EAEDP,sBAAsB,CAACQ,mBAAD,EAAsB;IAC1C,IAAI,IAAA,CAAKrE,QAAT,EAAmB;MAEjB,IAAI,IAAA,CAAKkE,OAAL,IAAgB,IAAA,CAAKA,OAAL,CAAaxG,qBAAjC,EAAwD;QACtD,OAAO,IAAA,CAAKwG,OAAL,CAAaxG,qBAAb,CAAmC2G,mBAAnC,CAAP;MACD;MAED,OAAO3G,qBAAqB,CAAC2G,mBAAD,CAA5B;IACD;IACD,OAAOC,SAAP;EACD;EAIDjC,YAAY,GAAU;IAEpB,IAAI,IAAA,CAAK6B,OAAT,EAAkB;MAChB,IAAA,CAAKA,OAAL,CAAa7B,YAAb,CAA0B,GAAA,SAA1B,CAAA;MACA;IACD;IAGD,IAAA,CAAKzD,QAAL,CAAc,GAAA,SAAd,CAAA;EAED;EAED0D,iBAAiB,GAAG;IAClB,IAAA,CAAK5C,WAAL,GAAmB,IAAnB;EACD;EAED0C,WAAW,GAAG;IACZ,IAAA,CAAKZ,0BAAL,EAAA;IACA,IAAA,CAAKC,eAAL,EAAA;IACA,IAAA,CAAK8C,kBAAL,EAAA;EACD;EAGDjD,uBAAuB,GAAG;IACxB,IAAA,CAAKM,cAAL,GAAsB;MACpB7C,EAAE,EAAE,IAAA,CAAKA,EADW;MAGpByB,IAAI,EAAE,IAAA,CAAKA,IAHS;MAIpB0C,MAAM,EAAE,IAAA,CAAKnE,EAAL,CAAQmE,MAJI;MAKpBsB,WAAW,EAAE,IAAA,CAAKA,WALE;MAQpBjF,eAAe,EAAE,IAAA,CAAKA,eARF;MASpBG,WAAW,EAAE,IATO;MAYpB+E,SAAS,EAAEC,IAAI,CAACC,GAALD,EAZS;MAapBE,UAAU,EAAE,CAbQ;MAcpBC,IAAI,EAAE,CAdc;MAepBC,IAAI,EAAE,CAfc;MAkBpBC,IAAI,EAAE,CAlBc;MAqBpBC,SAAS,EAAE,IAAA,CAAKrF,QArBI;MAsBpBsF,KAAK,EAAE,IAtBa;MAuBpBC,cAAc,EAAE,IAvBI;MAwBpBC,cAAc,EAAE;IAxBI,CAAtB;EA0BD;EAGD5D,mBAAmB,GAAG;IACpB,MAAM;MAAC6D,KAAD;MAAQC,MAAR;MAAgBC;IAAhB,CAAA,GAA0B,IAAA,CAAKC,iBAAL,EAAhC;IACA,IAAIH,KAAK,KAAK,IAAA,CAAKxD,cAAL,CAAoBwD,KAA9BA,IAAuCC,MAAM,KAAK,IAAA,CAAKzD,cAAL,CAAoByD,MAA1E,EAAkF;MAChF,IAAA,CAAKvE,cAAL,CAAoB,wBAApB,CAAA;IACD;IACD,IAAIwE,MAAM,KAAK,IAAA,CAAK1D,cAAL,CAAoB0D,MAAnC,EAA2C;MACzC,IAAA,CAAKxE,cAAL,CAAoB,+BAApB,CAAA;IACD;IAED,IAAA,CAAKc,cAAL,CAAoBwD,KAApB,GAA4BA,KAA5B;IACA,IAAA,CAAKxD,cAAL,CAAoByD,MAApB,GAA6BA,MAA7B;IACA,IAAA,CAAKzD,cAAL,CAAoB0D,MAApB,GAA6BA,MAA7B;IAEA,IAAA,CAAK1D,cAAL,CAAoBlC,WAApB,GAAkC,IAAA,CAAKA,WAAvC;IAGA,IAAA,CAAKkC,cAAL,CAAoBgD,UAApB,GAAiCF,IAAI,CAACC,GAALD,EAAAA,GAAa,IAAA,CAAK9C,cAAL,CAAoB6C,SAAlE;IAEA,IAAI,IAAA,CAAK9E,QAAT,EAAmB;MACjB,IAAA,CAAKA,QAAL,CAAc6F,MAAd,CAAqB,IAAA,CAAK5D,cAAL,CAAoBgD,UAAzC,CAAA;IACD;IAED,IAAA,CAAKhD,cAAL,CAAoBiD,IAApB,GAA2BY,IAAI,CAACC,KAALD,CAAY,IAAA,CAAK7D,cAAL,CAAoBmD,IAApB,GAA2B,IAA5B,GAAoC,EAA/CU,CAA3B;IACA,IAAA,CAAK7D,cAAL,CAAoBkD,IAApB,EAAA;IAGA,IAAA,CAAKlD,cAAL,CAAoBmD,IAApB,GAA2B,IAAA,CAAKpF,QAAL,GACvB,IAAA,CAAKA,QAAL,CAAcgG,OAAd,EADuB,GAEvB,IAAA,CAAK/D,cAAL,CAAoBgD,UAFxB;IAKA,IAAA,CAAKhD,cAAL,CAAoBgE,UAApB,GAAiC,IAAA,CAAKrD,SAAtC;EACD;EAEDG,qBAAqB,GAAG;IAEtB,IAAA,CAAK7D,UAAL,CAAgB,IAAA,CAAK+C,cAArB,CAAA;EAED;EAGDE,gBAAgB,CAACD,UAAD,EAAa;IAC3B,IAAI,OAAOA,UAAP,KAAsB,QAAtB,IAAkCA,UAAU,KAAK,IAArD,EAA2D;MACzD,IAAA,CAAKD,cAAL,GAAsBiE,MAAM,CAACC,MAAPD,CAAc,CAAA,CAAdA,EAAkB,IAAA,CAAKjE,cAAvBiE,EAAuChE,UAAvCgE,CAAtB;IACD;EACF;EAGD1E,mBAAmB,CAAC1C,IAAD,EAAO;IACxB,IAAA,CAAK8D,SAAL,GACE9D,IAAI,CAACyE,MAALzE,IACA,OAAOsH,eAAP,KAA2B,WAD3BtH,IAEAA,IAAI,CAACyE,MAALzE,YAAuBsH,eAHzB;IAMAtH,IAAI,GAAGoH,MAAM,CAACC,MAAPD,CAAc,CAAA,CAAdA,EAAkBpH,IAAlBoH,EAAwB,IAAA,CAAKtH,KAAL,CAAWS,SAAnC6G,CAAPpH;IACA,IAAA,CAAKM,EAAL,GAAU,IAAA,CAAKR,KAAL,CAAWQ,EAAX,GAAgBxB,mBAAmB,CAAC,IAAA,CAAKgB,KAAL,CAAWQ,EAAZ,EAAgBN,IAAhB,CAAnC,GAA2D,IAAA,CAAKD,eAAL,CAAqBC,IAArB,CAArE;IAEA,IAAI,CAACpB,OAAO,CAAC,IAAA,CAAK0B,EAAN,CAAZ,EAAuB;MACrB,MAAM,IAAIiH,KAAJ,CAAU,0DAAV,CAAN;IACD;IAGDvI,eAAe,CAAC,IAAA,CAAKsB,EAAN,CAAftB;IAEA,IAAA,CAAKwI,cAAL,EAAA;EACD;EAEDA,cAAc,GAAG;IACf,IAAI,IAAA,CAAKlH,EAAL,CAAQmE,MAAR,IAAkB,IAAA,CAAK3E,KAAL,CAAWG,SAAjC,EAA4C;MAC1C,MAAMwH,UAAU,GAAG/H,QAAQ,CAACgI,aAAThI,CAAuB,KAAvBA,CAAnB;MACAA,QAAQ,CAACiI,IAATjI,CAAckI,WAAdlI,CAA0B+H,UAA1B/H,CAAAA;MACA+H,UAAU,CAACI,KAAXJ,CAAiBK,QAAjBL,GAA4B,UAA5BA;MACA,MAAMM,GAAG,GAAGrI,QAAQ,CAACgI,aAAThI,CAAuB,KAAvBA,CAAZ;MACAqI,GAAG,CAACF,KAAJE,CAAUD,QAAVC,GAAqB,UAArBA;MACAA,GAAG,CAACF,KAAJE,CAAUC,IAAVD,GAAiB,MAAjBA;MACAA,GAAG,CAACF,KAAJE,CAAUE,MAAVF,GAAmB,MAAnBA;MACAA,GAAG,CAACF,KAAJE,CAAUpB,KAAVoB,GAAkB,OAAlBA;MACAA,GAAG,CAACF,KAAJE,CAAUG,UAAVH,GAAuB,OAAvBA;MACAN,UAAU,CAACG,WAAXH,CAAuB,IAAA,CAAKnH,EAAL,CAAQmE,MAA/BgD,CAAAA;MACAA,UAAU,CAACG,WAAXH,CAAuBM,GAAvBN,CAAAA;MACA,MAAMU,IAAI,GAAG,IAAA,CAAKrI,KAAL,CAAWG,SAAX,CAAqB8H,GAArB,CAAb;MACA,IAAII,IAAJ,EAAU;QACRJ,GAAG,CAACK,SAAJL,GAAgBI,IAAhBJ;MACD;IACF;EACF;EAEDjB,iBAAiB,GAAG;IAElB,MAAMH,KAAK,GAAG,IAAA,CAAKrG,EAAL,CAAQ+H,kBAAtB;IACA,MAAMzB,MAAM,GAAG,IAAA,CAAKtG,EAAL,CAAQgI,mBAAvB;IAGA,IAAIzB,MAAM,GAAG,CAAb;IACA,MAAM;MAACpC;IAAD,CAAA,GAAW,IAAA,CAAKnE,EAAtB;IAEA,IAAImE,MAAM,IAAIA,MAAM,CAAC8D,YAArB,EAAmC;MACjC1B,MAAM,GAAGpC,MAAM,CAAC+D,WAAP/D,GAAqBA,MAAM,CAAC8D,YAArC1B;IACD,CAFD,MAEO,IAAIF,KAAK,GAAG,CAARA,IAAaC,MAAM,GAAG,CAA1B,EAA6B;MAClCC,MAAM,GAAGF,KAAK,GAAGC,MAAjBC;IACD;IAED,OAAO;MAACF,KAAD;MAAQC,MAAR;MAAgBC;IAAhB,CAAP;EACD;EAGD7D,eAAe,GAAG;IAChB,IAAI,IAAA,CAAKtC,kBAAT,EAA6B;MAC3B,IAAA,CAAKJ,EAAL,CAAQmI,QAAR,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,IAAA,CAAKnI,EAAL,CAAQ+H,kBAA/B,EAAmD,IAAA,CAAK/H,EAAL,CAAQgI,mBAA3D,CAAA;IACD;EACF;EAIDvF,0BAA0B,GAAG;IAC3B,IAAI,IAAA,CAAKpC,uBAAT,EAAkC;MAChC5B,eAAe,CAAC,IAAA,CAAKuB,EAAN,EAAU;QAACQ,eAAe,EAAE,IAAA,CAAKA;MAAvB,CAAV,CAAf/B;IACD;EACF;EAGD4D,kBAAkB,GAAG;IAEnB,IAAI,IAAA,CAAK7C,KAAL,CAAWW,iBAAf,EAAkC;MAChC,IAAA,CAAKsF,WAAL,GAAmB,IAAI1G,WAAJ,CAAgB,IAAA,CAAKiB,EAArB,CAAnB;IACD;EACF;EAEDwF,kBAAkB,GAAG;IACnB,IAAI,IAAA,CAAKC,WAAT,EAAsB;MACpB,IAAA,CAAKA,WAAL,CAAiB2C,MAAjB,CAAwB;QACtB/B,KAAK,EAAE,IAAA,CAAKrG,EAAL,CAAQ+H,kBADO;QAEtBzB,MAAM,EAAE,IAAA,CAAKtG,EAAL,CAAQgI;MAFM,CAAxB,CAAA;IAID;EACF;EAED5E,YAAY,GAAG;IACb,IAAA,CAAKrC,SAAL,CAAesH,OAAf,EAAA;IACA,IAAA,CAAKtH,SAAL,CAAeuH,SAAf,EAAA;IAKA,IACE,IAAA,CAAK3F,aAAL,IACA,IAAA,CAAKA,aAAL,CAAmB4F,iBAAnB,EADA,IAEA,CAAC,IAAA,CAAK5F,aAAL,CAAmB6F,eAAnB,EAHH,EAIE;MACA,IAAA,CAAKlI,KAAL,CAAWC,GAAX,CAAe,UAAf,CAAA,CAA2BkI,OAA3B,CAAmC,IAAA,CAAK9F,aAAL,CAAmB+F,oBAAnB,EAAnC,CAAA;IACD;IAED,IAAI,IAAA,CAAK/F,aAAT,EAAwB;MAEtB,IAAA,CAAKA,aAAL,CAAmBgG,qBAAnB,EAAA;IACD;IAED,IAAA,CAAK9H,OAAL,CAAayH,SAAb,EAAA;EACD;EAED5E,UAAU,GAAG;IACX,IAAA,CAAK7C,OAAL,CAAawH,OAAb,EAAA;IAEA,IAAI,IAAA,CAAK1F,aAAT,EAAwB;MAEtB,IAAA,CAAKA,aAAL,CAAmBiG,GAAnB,EAAA;IACD;EACF;EAIDtG,mBAAmB,GAAG;IACpB,MAAM;MAAC6B;IAAD,CAAA,GAAW,IAAA,CAAKnE,EAAtB;IACA,IAAImE,MAAJ,EAAY;MACVA,MAAM,CAACe,gBAAPf,CAAwB,WAAxBA,EAAqC,IAAA,CAAKxC,YAA1CwC,CAAAA;MACAA,MAAM,CAACe,gBAAPf,CAAwB,YAAxBA,EAAsC,IAAA,CAAKvC,aAA3CuC,CAAAA;IACD;EACF;EAEDxC,YAAY,CAACkH,CAAD,EAAI;IACd,IAAA,CAAKhG,cAAL,CAAoBuD,cAApB,GAAqC,CAACyC,CAAC,CAACC,OAAH,EAAYD,CAAC,CAACE,OAAd,CAArC;EACD;EACDnH,aAAa,CAACiH,CAAD,EAAI;IACf,IAAA,CAAKhG,cAAL,CAAoBuD,cAApB,GAAqC,IAArC;EACD;AA9jBgC","sourcesContent":["import {\n  isWebGL,\n  createGLContext,\n  instrumentGLContext,\n  resizeGLContext,\n  resetParameters\n} from '@luma.gl/gltools';\n\nimport {\n  requestAnimationFrame,\n  cancelAnimationFrame,\n  Query,\n  lumaStats,\n  // TODO - remove dependency on framebuffer (bundle size impact)\n  Framebuffer,\n  log,\n  assert\n} from '@luma.gl/webgl';\n\nimport {isBrowser} from '@probe.gl/env';\n\nconst isPage = isBrowser() && typeof document !== 'undefined';\n\nlet statIdCounter = 0;\n\nexport default class AnimationLoop {\n  /*\n   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n   */\n  constructor(props = {}) {\n    const {\n      onCreateContext = opts => createGLContext(opts),\n      onAddHTML = null,\n      onInitialize = () => {},\n      onRender = () => {},\n      onFinalize = () => {},\n      onError,\n\n      gl = null,\n      glOptions = {},\n      debug = false,\n\n      createFramebuffer = false,\n\n      // view parameters\n      autoResizeViewport = true,\n      autoResizeDrawingBuffer = true,\n      stats = lumaStats.get(`animation-loop-${statIdCounter++}`)\n    } = props;\n\n    let {useDevicePixels = true} = props;\n\n    if ('useDevicePixelRatio' in props) {\n      log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n      // @ts-ignore\n      useDevicePixels = props.useDevicePixelRatio;\n    }\n\n    this.props = {\n      onCreateContext,\n      onAddHTML,\n      onInitialize,\n      onRender,\n      onFinalize,\n      onError,\n\n      gl,\n      glOptions,\n      debug,\n      createFramebuffer\n    };\n\n    // state\n    this.gl = gl;\n    this.needsRedraw = null;\n    this.timeline = null;\n    this.stats = stats;\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n\n    this._initialized = false;\n    this._running = false;\n    this._animationFrameId = null;\n    this._nextFramePromise = null;\n    this._resolveNextFrame = null;\n    this._cpuStartTime = 0;\n\n    this.setProps({\n      autoResizeViewport,\n      autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n\n    // Bind methods\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n\n    this._pageLoadPromise = null;\n\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n\n  delete() {\n    this.stop();\n    this._setDisplay(null);\n  }\n\n  setNeedsRedraw(reason) {\n    assert(typeof reason === 'string');\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n\n  setProps(props) {\n    if ('autoResizeViewport' in props) {\n      this.autoResizeViewport = props.autoResizeViewport;\n    }\n    if ('autoResizeDrawingBuffer' in props) {\n      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;\n    }\n    if ('useDevicePixels' in props) {\n      this.useDevicePixels = props.useDevicePixels;\n    }\n    return this;\n  }\n\n  // Starts a render loop if not already running\n  // @param {Object} context - contains frame specific info (E.g. tick, width, height, etc)\n  start(opts = {}) {\n    if (this._running) {\n      return this;\n    }\n    this._running = true;\n    // console.debug(`Starting ${this.constructor.name}`);\n    // Wait for start promise before rendering frame\n    const startPromise = this._getPageLoadPromise()\n      .then(() => {\n        if (!this._running || this._initialized) {\n          return null;\n        }\n\n        // Create the WebGL context\n        this._createWebGLContext(opts);\n        this._createFramebuffer();\n        this._startEventHandling();\n\n        // Initialize the callback data\n        this._initializeCallbackData();\n        this._updateCallbackData();\n\n        // Default viewport setup, in case onInitialize wants to render\n        this._resizeCanvasDrawingBuffer();\n        this._resizeViewport();\n\n        this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n\n        this._initialized = true;\n\n        // Note: onIntialize can return a promise (in case it needs to load resources)\n        return this.onInitialize(this.animationProps);\n      })\n      .then(appContext => {\n        if (this._running) {\n          this._addCallbackData(appContext || {});\n          if (appContext !== false) {\n            this._startLoop();\n          }\n        }\n      });\n\n    if (this.props.onError) {\n      startPromise.catch(this.props.onError);\n    }\n\n    return this;\n  }\n\n  // Redraw now\n  redraw() {\n    if (this.isContextLost()) {\n      return this;\n    }\n\n    this._beginTimers();\n\n    this._setupFrame();\n    this._updateCallbackData();\n\n    this._renderFrame(this.animationProps);\n\n    // clear needsRedraw flag\n    this._clearNeedsRedraw();\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/commit\n    // Chrome's offscreen canvas does not require gl.commit\n    if (this.offScreen && this.gl.commit) {\n      this.gl.commit();\n    }\n\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n\n    this._endTimers();\n\n    return this;\n  }\n\n  // Stops a render loop if already running, finalizing\n  stop() {\n    // console.debug(`Stopping ${this.constructor.name}`);\n    if (this._running) {\n      this._finalizeCallbackData();\n      this._cancelAnimationFrame(this._animationFrameId);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._animationFrameId = null;\n      this._running = false;\n    }\n    return this;\n  }\n\n  attachTimeline(timeline) {\n    this.timeline = timeline;\n\n    return this.timeline;\n  }\n\n  detachTimeline() {\n    this.timeline = null;\n  }\n\n  waitForRender() {\n    this.setNeedsRedraw('waitForRender');\n\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n    return this._nextFramePromise;\n  }\n\n  async toDataURL() {\n    this.setNeedsRedraw('toDataURL');\n\n    await this.waitForRender();\n\n    return this.gl.canvas.toDataURL();\n  }\n\n  isContextLost() {\n    return this.gl.isContextLost();\n  }\n\n  onCreateContext(...args) {\n    return this.props.onCreateContext(...args);\n  }\n\n  onInitialize(...args) {\n    return this.props.onInitialize(...args);\n  }\n\n  onRender(...args) {\n    return this.props.onRender(...args);\n  }\n\n  onFinalize(...args) {\n    return this.props.onFinalize(...args);\n  }\n\n  // DEPRECATED/REMOVED METHODS\n\n  getHTMLControlValue(id, defaultValue = 1) {\n    const element = document.getElementById(id);\n    // @ts-ignore Not all html elements have value\n    return element ? Number(element.value) : defaultValue;\n  }\n\n  // Update parameters\n  setViewParameters() {\n    log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _startLoop() {\n    const renderFrame = () => {\n      if (!this._running) {\n        return;\n      }\n      this.redraw();\n      this._animationFrameId = this._requestAnimationFrame(renderFrame);\n    };\n\n    // cancel any pending renders to ensure only one loop can ever run\n    this._cancelAnimationFrame(this._animationFrameId);\n    this._animationFrameId = this._requestAnimationFrame(renderFrame);\n  }\n\n  // PRIVATE METHODS\n\n  _getPageLoadPromise() {\n    if (!this._pageLoadPromise) {\n      this._pageLoadPromise = isPage\n        ? new Promise((resolve, reject) => {\n            if (isPage && document.readyState === 'complete') {\n              resolve(document);\n              return;\n            }\n            window.addEventListener('load', () => {\n              resolve(document);\n            });\n          })\n        : Promise.resolve({});\n    }\n    return this._pageLoadPromise;\n  }\n\n  _setDisplay(display) {\n    if (this.display) {\n      this.display.delete();\n      this.display.animationLoop = null;\n    }\n\n    // store animation loop on the display\n    if (display) {\n      display.animationLoop = this;\n    }\n\n    this.display = display;\n  }\n\n  _cancelAnimationFrame(animationFrameId) {\n    // E.g. VR display has a separate animation frame to sync with headset\n    if (this.display && this.display.cancelAnimationFrame) {\n      return this.display.cancelAnimationFrame(animationFrameId);\n    }\n\n    return cancelAnimationFrame(animationFrameId);\n  }\n\n  _requestAnimationFrame(renderFrameCallback) {\n    if (this._running) {\n      // E.g. VR display has a separate animation frame to sync with headset\n      if (this.display && this.display.requestAnimationFrame) {\n        return this.display.requestAnimationFrame(renderFrameCallback);\n      }\n\n      return requestAnimationFrame(renderFrameCallback);\n    }\n    return undefined;\n  }\n\n  // Called on each frame, can be overridden to call onRender multiple times\n  // to support e.g. stereoscopic rendering\n  _renderFrame(...args) {\n    // Allow e.g. VR display to render multiple frames.\n    if (this.display) {\n      this.display._renderFrame(...args);\n      return;\n    }\n\n    // call callback\n    this.onRender(...args);\n    // end callback\n  }\n\n  _clearNeedsRedraw() {\n    this.needsRedraw = null;\n  }\n\n  _setupFrame() {\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n    this._resizeFramebuffer();\n  }\n\n  // Initialize the  object that will be passed to app callbacks\n  _initializeCallbackData() {\n    this.animationProps = {\n      gl: this.gl,\n\n      stop: this.stop,\n      canvas: this.gl.canvas,\n      framebuffer: this.framebuffer,\n\n      // Initial values\n      useDevicePixels: this.useDevicePixels,\n      needsRedraw: null,\n\n      // Animation props\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n\n      // Timeline time for back compatibility\n      time: 0,\n\n      // Experimental\n      _timeline: this.timeline,\n      _loop: this,\n      _animationLoop: this,\n      _mousePosition: null // Event props\n    };\n  }\n\n  // Update the context object that will be passed to app callbacks\n  _updateCallbackData() {\n    const {width, height, aspect} = this._getSizeAndAspect();\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n\n    this.animationProps.needsRedraw = this.needsRedraw;\n\n    // Update time properties\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n\n    this.animationProps.tick = Math.floor((this.animationProps.time / 1000) * 60);\n    this.animationProps.tock++;\n\n    // For back compatibility\n    this.animationProps.time = this.timeline\n      ? this.timeline.getTime()\n      : this.animationProps.engineTime;\n\n    // experimental\n    this.animationProps._offScreen = this.offScreen;\n  }\n\n  _finalizeCallbackData() {\n    // call callback\n    this.onFinalize(this.animationProps);\n    // end callback\n  }\n\n  // Add application's data to the app context object\n  _addCallbackData(appContext) {\n    if (typeof appContext === 'object' && appContext !== null) {\n      this.animationProps = Object.assign({}, this.animationProps, appContext);\n    }\n  }\n\n  // Either uses supplied or existing context, or calls provided callback to create one\n  _createWebGLContext(opts) {\n    this.offScreen =\n      opts.canvas &&\n      typeof OffscreenCanvas !== 'undefined' &&\n      opts.canvas instanceof OffscreenCanvas;\n\n    // Create the WebGL context if necessary\n    opts = Object.assign({}, opts, this.props.glOptions);\n    this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);\n\n    if (!isWebGL(this.gl)) {\n      throw new Error('AnimationLoop.onCreateContext - illegal context returned');\n    }\n\n    // Reset the WebGL context.\n    resetParameters(this.gl);\n\n    this._createInfoDiv();\n  }\n\n  _createInfoDiv() {\n    if (this.gl.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      wrapperDiv.appendChild(this.gl.canvas);\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n\n  _getSizeAndAspect() {\n    // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n    const width = this.gl.drawingBufferWidth;\n    const height = this.gl.drawingBufferHeight;\n\n    // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html\n    let aspect = 1;\n    const {canvas} = this.gl;\n\n    if (canvas && canvas.clientHeight) {\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n\n    return {width, height, aspect};\n  }\n\n  // Default viewport setup\n  _resizeViewport() {\n    if (this.autoResizeViewport) {\n      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n    }\n  }\n\n  // Resize the render buffer of the canvas to match canvas client size\n  // Optionally multiplying with devicePixel ratio\n  _resizeCanvasDrawingBuffer() {\n    if (this.autoResizeDrawingBuffer) {\n      resizeGLContext(this.gl, {useDevicePixels: this.useDevicePixels});\n    }\n  }\n\n  // TBD - deprecated?\n  _createFramebuffer() {\n    // Setup default framebuffer\n    if (this.props.createFramebuffer) {\n      this.framebuffer = new Framebuffer(this.gl);\n    }\n  }\n\n  _resizeFramebuffer() {\n    if (this.framebuffer) {\n      this.framebuffer.resize({\n        width: this.gl.drawingBufferWidth,\n        height: this.gl.drawingBufferHeight\n      });\n    }\n  }\n\n  _beginTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n\n    // Check if timer for last frame has completed.\n    // GPU timer results are never available in the same\n    // frame they are captured.\n    if (\n      this._gpuTimeQuery &&\n      this._gpuTimeQuery.isResultAvailable() &&\n      !this._gpuTimeQuery.isTimerDisjoint()\n    ) {\n      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    }\n\n    if (this._gpuTimeQuery) {\n      // GPU time query start\n      this._gpuTimeQuery.beginTimeElapsedQuery();\n    }\n\n    this.cpuTime.timeStart();\n  }\n\n  _endTimers() {\n    this.cpuTime.timeEnd();\n\n    if (this._gpuTimeQuery) {\n      // GPU time query end. Results will be available on next frame.\n      this._gpuTimeQuery.end();\n    }\n  }\n\n  // Event handling\n\n  _startEventHandling() {\n    const {canvas} = this.gl;\n    if (canvas) {\n      canvas.addEventListener('mousemove', this._onMousemove);\n      canvas.addEventListener('mouseleave', this._onMouseleave);\n    }\n  }\n\n  _onMousemove(e) {\n    this.animationProps._mousePosition = [e.offsetX, e.offsetY];\n  }\n  _onMouseleave(e) {\n    this.animationProps._mousePosition = null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}