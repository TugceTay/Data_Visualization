{"ast":null,"code":"import getShaderName from './get-shader-name';\nimport getShaderTypeName from './get-shader-type-name';\nexport default function formatGLSLCompilerError(errLog, src, shaderType) {\n  const {\n    shaderName,\n    errors,\n    warnings\n  } = parseGLSLCompilerError(errLog, src, shaderType);\n  return \"GLSL compilation error in \".concat(shaderName, \"\\n\\n\").concat(errors, \"\\n\").concat(warnings);\n}\nexport function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {\n  const errorStrings = errLog.split(/\\r?\\n/);\n  const errors = {};\n  const warnings = {};\n  const name = shaderName || getShaderName(src) || '(unnamed)';\n  const shaderDescription = \"\".concat(getShaderTypeName(shaderType), \" shader \").concat(name);\n  for (let i = 0; i < errorStrings.length; i++) {\n    const errorString = errorStrings[i];\n    if (errorString.length <= 1) {\n      continue;\n    }\n    const segments = errorString.split(':');\n    const type = segments[0];\n    const line = parseInt(segments[2], 10);\n    if (isNaN(line)) {\n      throw new Error(\"GLSL compilation error in \".concat(shaderDescription, \": \").concat(errLog));\n    }\n    if (type !== 'WARNING') {\n      errors[line] = errorString;\n    } else {\n      warnings[line] = errorString;\n    }\n  }\n  const lines = addLineNumbers(src);\n  return {\n    shaderName: shaderDescription,\n    errors: formatErrors(errors, lines),\n    warnings: formatErrors(warnings, lines)\n  };\n}\nfunction formatErrors(errors, lines) {\n  let message = '';\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {\n      continue;\n    }\n    message += \"\".concat(line, \"\\n\");\n    if (errors[i + 1]) {\n      const error = errors[i + 1];\n      const segments = error.split(':', 3);\n      const type = segments[0];\n      const column = parseInt(segments[1], 10) || 0;\n      const err = error.substring(segments.join(':').length + 1).trim();\n      message += padLeft(\"^^^ \".concat(type, \": \").concat(err, \"\\n\\n\"), column);\n    }\n  }\n  return message;\n}\nfunction addLineNumbers(string) {\n  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ': ';\n  const lines = string.split(/\\r?\\n/);\n  const maxDigits = String(lines.length + start - 1).length;\n  return lines.map((line, i) => {\n    const lineNumber = String(i + start);\n    const digits = lineNumber.length;\n    const prefix = padLeft(lineNumber, maxDigits - digits);\n    return prefix + delim + line;\n  });\n}\nfunction padLeft(string, digits) {\n  let result = '';\n  for (let i = 0; i < digits; ++i) {\n    result += ' ';\n  }\n  return \"\".concat(result).concat(string);\n}","map":{"version":3,"sources":["../../../src/glsl-utils/format-glsl-error.js"],"names":["getShaderName","getShaderTypeName","formatGLSLCompilerError","errLog","src","shaderType","shaderName","errors","warnings","parseGLSLCompilerError","errorStrings","split","name","shaderDescription","i","length","errorString","segments","type","line","parseInt","isNaN","Error","lines","addLineNumbers","formatErrors","message","error","column","err","substring","join","trim","padLeft","string","start","delim","maxDigits","String","map","lineNumber","digits","prefix","result"],"mappings":"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","sourcesContent":["// TODO - formatGLSLCompilerError should not depend on this\nimport getShaderName from './get-shader-name';\nimport getShaderTypeName from './get-shader-type-name';\n\n// Formats GLSL compiler error log into single string\nexport default function formatGLSLCompilerError(errLog, src, shaderType) {\n  const {shaderName, errors, warnings} = parseGLSLCompilerError(errLog, src, shaderType);\n  return `GLSL compilation error in ${shaderName}\\n\\n${errors}\\n${warnings}`;\n}\n\n/**\n * Parse a GLSL compiler error log into a string showing the source code around each error.\n * Based on https://github.com/wwwtyro/gl-format-compiler-error (public domain)\n */\n/* eslint-disable no-continue, max-statements */\nexport function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {\n  const errorStrings = errLog.split(/\\r?\\n/);\n  const errors = {};\n  const warnings = {};\n\n  // Patch the shader name\n  const name = shaderName || getShaderName(src) || '(unnamed)';\n  const shaderDescription = `${getShaderTypeName(shaderType)} shader ${name}`;\n\n  // Parse the error - note: browser and driver dependent\n  for (let i = 0; i < errorStrings.length; i++) {\n    const errorString = errorStrings[i];\n    if (errorString.length <= 1) {\n      continue;\n    }\n    const segments = errorString.split(':');\n    const type = segments[0];\n    const line = parseInt(segments[2], 10);\n    if (isNaN(line)) {\n      throw new Error(`GLSL compilation error in ${shaderDescription}: ${errLog}`);\n    }\n    if (type !== 'WARNING') {\n      errors[line] = errorString;\n    } else {\n      warnings[line] = errorString;\n    }\n  }\n\n  // Format the error inline with the code\n  const lines = addLineNumbers(src);\n\n  return {\n    shaderName: shaderDescription,\n    errors: formatErrors(errors, lines),\n    warnings: formatErrors(warnings, lines)\n  };\n}\n\n// helper function, outputs annotated errors or warnings\nfunction formatErrors(errors, lines) {\n  let message = '';\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {\n      continue;\n    }\n    message += `${line}\\n`;\n    if (errors[i + 1]) {\n      const error = errors[i + 1];\n      const segments = error.split(':', 3);\n      const type = segments[0];\n      const column = parseInt(segments[1], 10) || 0;\n      const err = error.substring(segments.join(':').length + 1).trim();\n      message += padLeft(`^^^ ${type}: ${err}\\n\\n`, column);\n    }\n  }\n  return message;\n}\n\n/**\n * Prepends line numbers to each line of a string.\n * The line numbers will be left-padded with spaces to ensure an\n * aligned layout when rendered using monospace fonts.\n * @param {String} string - multi-line string to add line numbers to\n * @param {Number} start=1 - number of spaces to add\n * @param {String} delim =': ' - injected between line number and original line\n * @return {String[]} strings - array of string, one per line, with line numbers added\n */\nfunction addLineNumbers(string, start = 1, delim = ': ') {\n  const lines = string.split(/\\r?\\n/);\n  const maxDigits = String(lines.length + start - 1).length;\n  return lines.map((line, i) => {\n    const lineNumber = String(i + start);\n    const digits = lineNumber.length;\n    const prefix = padLeft(lineNumber, maxDigits - digits);\n    return prefix + delim + line;\n  });\n}\n\n/**\n * Pads a string with a number of spaces (space characters) to the left\n * @param {String} string - string to pad\n * @param {Number} digits - number of spaces to add\n * @return {String} string - The padded string\n */\nfunction padLeft(string, digits) {\n  let result = '';\n  for (let i = 0; i < digits; ++i) {\n    result += ' ';\n  }\n  return `${result}${string}`;\n}\n"]},"metadata":{},"sourceType":"module"}