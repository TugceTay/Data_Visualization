{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Transform } from '@luma.gl/core';\nimport GPUInterpolationTransition from '../../transitions/gpu-interpolation-transition';\nimport GPUSpringTransition from '../../transitions/gpu-spring-transition';\nimport log from '../../utils/log';\nvar TRANSITION_TYPES = {\n  interpolation: GPUInterpolationTransition,\n  spring: GPUSpringTransition\n};\nvar AttributeTransitionManager = function () {\n  function AttributeTransitionManager(gl, _ref) {\n    var id = _ref.id,\n      timeline = _ref.timeline;\n    _classCallCheck(this, AttributeTransitionManager);\n    this.id = id;\n    this.gl = gl;\n    this.timeline = timeline;\n    this.transitions = {};\n    this.needsRedraw = false;\n    this.numInstances = 1;\n    if (Transform.isSupported(gl)) {\n      this.isSupported = true;\n    } else if (gl) {\n      log.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();\n    }\n  }\n  _createClass(AttributeTransitionManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      for (var attributeName in this.transitions) {\n        this._removeTransition(attributeName);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(_ref2) {\n      var attributes = _ref2.attributes,\n        _ref2$transitions = _ref2.transitions,\n        transitions = _ref2$transitions === void 0 ? {} : _ref2$transitions,\n        numInstances = _ref2.numInstances;\n      this.numInstances = numInstances || 1;\n      if (!this.isSupported) {\n        return;\n      }\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        var settings = attribute.getTransitionSetting(transitions);\n        if (!settings) continue;\n        this._updateAttribute(attributeName, attribute, settings);\n      }\n      for (var _attributeName in this.transitions) {\n        var _attribute = attributes[_attributeName];\n        if (!_attribute || !_attribute.getTransitionSetting(transitions)) {\n          this._removeTransition(_attributeName);\n        }\n      }\n    }\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(attributeName) {\n      var transition = this.transitions[attributeName];\n      return transition && transition.inProgress;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      var animatedAttributes = {};\n      for (var attributeName in this.transitions) {\n        var transition = this.transitions[attributeName];\n        if (transition.inProgress) {\n          animatedAttributes[attributeName] = transition.attributeInTransition;\n        }\n      }\n      return animatedAttributes;\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (!this.isSupported || this.numInstances === 0) {\n        return false;\n      }\n      for (var attributeName in this.transitions) {\n        var updated = this.transitions[attributeName].update();\n        if (updated) {\n          this.needsRedraw = true;\n        }\n      }\n      var needsRedraw = this.needsRedraw;\n      this.needsRedraw = false;\n      return needsRedraw;\n    }\n  }, {\n    key: \"_removeTransition\",\n    value: function _removeTransition(attributeName) {\n      this.transitions[attributeName].cancel();\n      delete this.transitions[attributeName];\n    }\n  }, {\n    key: \"_updateAttribute\",\n    value: function _updateAttribute(attributeName, attribute, settings) {\n      var transition = this.transitions[attributeName];\n      var isNew = !transition || transition.type !== settings.type;\n      if (isNew) {\n        if (transition) {\n          this._removeTransition(attributeName);\n        }\n        var TransitionType = TRANSITION_TYPES[settings.type];\n        if (TransitionType) {\n          this.transitions[attributeName] = new TransitionType({\n            attribute: attribute,\n            timeline: this.timeline,\n            gl: this.gl\n          });\n        } else {\n          log.error(\"unsupported transition type '\".concat(settings.type, \"'\"))();\n          isNew = false;\n        }\n      }\n      if (isNew || attribute.needsRedraw()) {\n        this.needsRedraw = true;\n        this.transitions[attributeName].start(settings, this.numInstances);\n      }\n    }\n  }]);\n  return AttributeTransitionManager;\n}();\nexport { AttributeTransitionManager as default };","map":{"version":3,"sources":["../../../../src/lib/attribute/attribute-transition-manager.js"],"names":["Transform","GPUInterpolationTransition","GPUSpringTransition","log","TRANSITION_TYPES","interpolation","spring","AttributeTransitionManager","gl","id","timeline","transitions","needsRedraw","numInstances","isSupported","warn","attributeName","_removeTransition","attributes","attribute","settings","getTransitionSetting","_updateAttribute","transition","inProgress","animatedAttributes","attributeInTransition","updated","update","cancel","isNew","type","TransitionType","error","start"],"mappings":"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","sourcesContent":["import {Transform} from '@luma.gl/core';\nimport GPUInterpolationTransition from '../../transitions/gpu-interpolation-transition';\nimport GPUSpringTransition from '../../transitions/gpu-spring-transition';\nimport log from '../../utils/log';\n\nconst TRANSITION_TYPES = {\n  interpolation: GPUInterpolationTransition,\n  spring: GPUSpringTransition\n};\n\nexport default class AttributeTransitionManager {\n  constructor(gl, {id, timeline}) {\n    this.id = id;\n    this.gl = gl;\n    this.timeline = timeline;\n\n    this.transitions = {};\n    this.needsRedraw = false;\n    this.numInstances = 1;\n\n    if (Transform.isSupported(gl)) {\n      this.isSupported = true;\n    } else if (gl) {\n      // This class may be instantiated without a WebGL context (e.g. web worker)\n      log.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();\n    }\n  }\n\n  finalize() {\n    for (const attributeName in this.transitions) {\n      this._removeTransition(attributeName);\n    }\n  }\n\n  /* Public methods */\n\n  // Called when attribute manager updates\n  // Check the latest attributes for updates.\n  update({attributes, transitions = {}, numInstances}) {\n    // Transform class will crash if elementCount is 0\n    this.numInstances = numInstances || 1;\n\n    if (!this.isSupported) {\n      return;\n    }\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const settings = attribute.getTransitionSetting(transitions);\n\n      // this attribute might not support transitions?\n      if (!settings) continue; // eslint-disable-line no-continue\n      this._updateAttribute(attributeName, attribute, settings);\n    }\n\n    for (const attributeName in this.transitions) {\n      const attribute = attributes[attributeName];\n      if (!attribute || !attribute.getTransitionSetting(transitions)) {\n        // Animated attribute has been removed\n        this._removeTransition(attributeName);\n      }\n    }\n  }\n\n  // Returns `true` if attribute is transition-enabled\n  hasAttribute(attributeName) {\n    const transition = this.transitions[attributeName];\n    return transition && transition.inProgress;\n  }\n\n  // Get all the animated attributes\n  getAttributes() {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.transitions) {\n      const transition = this.transitions[attributeName];\n      if (transition.inProgress) {\n        animatedAttributes[attributeName] = transition.attributeInTransition;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  /* eslint-disable max-statements */\n  // Called every render cycle, run transform feedback\n  // Returns `true` if anything changes\n  run() {\n    if (!this.isSupported || this.numInstances === 0) {\n      return false;\n    }\n\n    for (const attributeName in this.transitions) {\n      const updated = this.transitions[attributeName].update();\n      if (updated) {\n        this.needsRedraw = true;\n      }\n    }\n\n    const needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n    return needsRedraw;\n  }\n  /* eslint-enable max-statements */\n\n  /* Private methods */\n  _removeTransition(attributeName) {\n    this.transitions[attributeName].cancel();\n    delete this.transitions[attributeName];\n  }\n\n  // Check an attributes for updates\n  // Returns a transition object if a new transition is triggered.\n  _updateAttribute(attributeName, attribute, settings) {\n    const transition = this.transitions[attributeName];\n    // an attribute can change transition type when it updates\n    // let's remove the transition when that happens so we can create the new transition type\n    // TODO: when switching transition types, make sure to carry over the attribute's\n    // previous buffers, currentLength, startIndices, etc, to be used as the starting point\n    // for the next transition\n    let isNew = !transition || transition.type !== settings.type;\n    if (isNew) {\n      if (transition) {\n        this._removeTransition(attributeName);\n      }\n\n      const TransitionType = TRANSITION_TYPES[settings.type];\n      if (TransitionType) {\n        this.transitions[attributeName] = new TransitionType({\n          attribute,\n          timeline: this.timeline,\n          gl: this.gl\n        });\n      } else {\n        log.error(`unsupported transition type '${settings.type}'`)();\n        isNew = false;\n      }\n    }\n\n    if (isNew || attribute.needsRedraw()) {\n      this.needsRedraw = true;\n      this.transitions[attributeName].start(settings, this.numInstances);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}