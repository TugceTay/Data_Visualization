{"ast":null,"code":"export function cssToDeviceRatio(gl) {\n  const {\n    luma\n  } = gl;\n  if (gl.canvas && luma) {\n    const {\n      clientWidth\n    } = luma.canvasSizeInfo;\n    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;\n  }\n  return 1;\n}\nexport function cssToDevicePixels(gl, cssPixel) {\n  let yInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const ratio = cssToDeviceRatio(gl);\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  return scalePixels(cssPixel, ratio, width, height, yInvert);\n}\nexport function getDevicePixelRatio(useDevicePixels) {\n  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;\n  if (Number.isFinite(useDevicePixels)) {\n    return useDevicePixels <= 0 ? 1 : useDevicePixels;\n  }\n  return useDevicePixels ? windowRatio : 1;\n}\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const x = scaleX(pixel[0], ratio, width);\n  let y = scaleY(pixel[1], ratio, height, yInvert);\n  let t = scaleX(pixel[0] + 1, ratio, width);\n  const xHigh = t === width - 1 ? t : t - 1;\n  t = scaleY(pixel[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    t = t === 0 ? t : t + 1;\n    yHigh = y;\n    y = t;\n  } else {\n    yHigh = t === height - 1 ? t : t - 1;\n  }\n  return {\n    x,\n    y,\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\nfunction scaleX(x, ratio, width) {\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\nfunction scaleY(y, ratio, height, yInvert) {\n  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);\n}","map":{"version":3,"sources":["../../../src/utils/device-pixels.js"],"names":["cssToDeviceRatio","gl","luma","canvas","clientWidth","canvasSizeInfo","drawingBufferWidth","cssToDevicePixels","cssPixel","yInvert","ratio","width","height","drawingBufferHeight","scalePixels","getDevicePixelRatio","useDevicePixels","windowRatio","window","devicePixelRatio","Number","isFinite","pixel","x","scaleX","y","scaleY","t","xHigh","yHigh","Math","max","r","min","round"],"mappings":"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","sourcesContent":["/** @typedef {import('./device-pixels')} types */\n\n/**\n * Returns multiplier need to convert CSS size to Device size\n * @type {types['cssToDeviceRatio']}\n */\nexport function cssToDeviceRatio(gl) {\n  // @ts-ignore\n  const {luma} = gl;\n\n  if (gl.canvas && luma) {\n    // For headless gl we might have used custom width and height\n    // hence use cached clientWidth\n    const {clientWidth} = luma.canvasSizeInfo;\n    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;\n  }\n  // use default device pixel ratio\n  return 1;\n}\n\n/**\n * Maps CSS pixel position to device pixel position\n * @type {types['cssToDevicePixels']}\n */\nexport function cssToDevicePixels(gl, cssPixel, yInvert = true) {\n  const ratio = cssToDeviceRatio(gl);\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  return scalePixels(cssPixel, ratio, width, height, yInvert);\n}\n\n// HELPER METHOD\n\n/**\n * Calulates device pixel ratio, used during context creation\n * @type {types['getDevicePixelRatio']}\n */\nexport function getDevicePixelRatio(useDevicePixels) {\n  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;\n  if (Number.isFinite(useDevicePixels)) {\n    // @ts-ignore Can no longer be boolean after previous line\n    return useDevicePixels <= 0 ? 1 : useDevicePixels;\n  }\n  return useDevicePixels ? windowRatio : 1;\n}\n\n// PRIVATE\n\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const x = scaleX(pixel[0], ratio, width);\n  let y = scaleY(pixel[1], ratio, height, yInvert);\n\n  // Find boundaries of next pixel to provide valid range of device pixel locaitons\n\n  let t = scaleX(pixel[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n\n  t = scaleY(pixel[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x, ratio, width) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y, ratio, height, yInvert) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert\n    ? Math.max(0, height - 1 - Math.round(y * ratio))\n    : Math.min(Math.round(y * ratio), height - 1);\n}\n"]},"metadata":{},"sourceType":"module"}