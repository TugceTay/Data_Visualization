{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { getBlobOrSVGDataUrl } from './svg-utils';\nexport default function parseToImage(_x, _x2, _x3) {\n  return _parseToImage.apply(this, arguments);\n}\nfunction _parseToImage() {\n  _parseToImage = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(arrayBuffer, options, url) {\n    var blobOrDataUrl, URL, objectUrl;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n            URL = self.URL || self.webkitURL;\n            objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n            _context.prev = 3;\n            _context.next = 6;\n            return loadToImage(objectUrl || blobOrDataUrl, options);\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n          case 7:\n            _context.prev = 7;\n            if (objectUrl) {\n              URL.revokeObjectURL(objectUrl);\n            }\n            return _context.finish(7);\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3,, 7, 10]]);\n  }));\n  return _parseToImage.apply(this, arguments);\n}\nexport function loadToImage(_x4, _x5) {\n  return _loadToImage.apply(this, arguments);\n}\nfunction _loadToImage() {\n  _loadToImage = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(url, options) {\n    var image;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            image = new Image();\n            image.src = url;\n            if (!(options.image && options.image.decode && image.decode)) {\n              _context2.next = 6;\n              break;\n            }\n            _context2.next = 5;\n            return image.decode();\n          case 5:\n            return _context2.abrupt(\"return\", image);\n          case 6:\n            _context2.next = 8;\n            return new Promise(function (resolve, reject) {\n              try {\n                image.onload = function () {\n                  return resolve(image);\n                };\n                image.onerror = function (err) {\n                  return reject(new Error(\"Could not load image \".concat(url, \": \").concat(err)));\n                };\n              } catch (error) {\n                reject(error);\n              }\n            });\n          case 8:\n            return _context2.abrupt(\"return\", _context2.sent);\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadToImage.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-to-image.js"],"names":["getBlobOrSVGDataUrl","parseToImage","arrayBuffer","options","url","blobOrDataUrl","URL","self","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","image","Image","src","decode","Promise","resolve","reject","onload","onerror","Error","err","error"],"mappings":"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","sourcesContent":["/* global self, Image */\nimport {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(arrayBuffer, options, url) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = err => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}