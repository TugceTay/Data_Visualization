{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateMapboxLayers = generateMapboxLayers;\nexports.updateMapboxLayers = updateMapboxLayers;\nexports.geoJsonFromData = geoJsonFromData;\nexports.gpuFilterToMapboxFilter = gpuFilterToMapboxFilter;\nexports.prefixGpuField = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _baseLayer = require(\"./base-layer\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n/** @typedef {import(\"geojson\").FeatureCollection} FeatureCollection */\n\n/** @typedef {import(\"geojson\").Feature} Feature */\n\n/**\n * This function will convert layers to mapbox layers\n * @param {Array<Object>} layers the layers to be converted\n * @param {Array<Object>} layerData extra layer information\n * @param {Array<Number>} layerOrder the order by which we should convert layers\n * @param {Object} layersToRender {[id]: true | false} object whether each layer should be rendered\n * @returns {Object} {[id]: layer}\n */\nfunction generateMapboxLayers() {\n  var layers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var layerData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var layerOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var layersToRender = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (layerData.length > 0) {\n    return layerOrder.slice().reverse().filter(function (idx) {\n      return layers[idx].overlayType === _baseLayer.OVERLAY_TYPE.mapboxgl && layersToRender[layers[idx].id];\n    }).reduce(function (accu, index) {\n      var layer = layers[index];\n      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, layer.id, {\n        id: layer.id,\n        data: layerData[index].data,\n        isVisible: layer.config.isVisible,\n        config: layerData[index].config,\n        hidden: layer.config.hidden,\n        sourceId: layerData[index].config.source\n      }));\n    }, {});\n  }\n  return {};\n}\n/**\n * Update mapbox layers on the given map\n * @param {Object} map\n * @param {Object} newLayers Map of new mapbox layers to be displayed\n * @param {Object} oldLayers Map of the old layers to be compare with the current ones to detect deleted layers\n *                  {layerId: sourceId}\n */\n\nfunction updateMapboxLayers(map) {\n  var newLayers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var oldLayers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  // delete no longer existed old layers\n  if (oldLayers) {\n    checkAndRemoveOldLayers(map, oldLayers, newLayers);\n  } // insert or update new layer\n\n  Object.values(newLayers).forEach(function (overlay) {\n    var layerId = overlay.id,\n      config = overlay.config,\n      data = overlay.data,\n      sourceId = overlay.sourceId,\n      isVisible = overlay.isVisible;\n    if (!data && !config) {\n      return;\n    }\n    var _ref = oldLayers && oldLayers[layerId] || {},\n      oldData = _ref.data,\n      oldConfig = _ref.config;\n    if (data && data !== oldData) {\n      updateSourceData(map, sourceId, data);\n    } // compare with previous configs\n\n    if (oldConfig !== config) {\n      updateLayerConfig(map, layerId, config, isVisible);\n    }\n  });\n}\nfunction checkAndRemoveOldLayers(map, oldLayers, newLayers) {\n  Object.keys(oldLayers).forEach(function (layerId) {\n    if (!newLayers[layerId]) {\n      map.removeLayer(layerId);\n    }\n  });\n}\nfunction updateLayerConfig(map, layerId, config, isVisible) {\n  var mapboxLayer = map.getLayer(layerId);\n  if (mapboxLayer) {\n    // check if layer already is set\n    // remove it if exists\n    map.removeLayer(layerId);\n  }\n  map.addLayer(config);\n  map.setLayoutProperty(layerId, 'visibility', isVisible ? 'visible' : 'none');\n}\nfunction updateSourceData(map, sourceId, data) {\n  var source = map.getSource(sourceId);\n  if (!source) {\n    map.addSource(sourceId, {\n      type: 'geojson',\n      data: data\n    });\n  } else {\n    source.setData(data);\n  }\n}\n/**\n *\n * @param filteredIndex\n * @param getGeometry {({index: number}) => any}\n * @param getProperties {({index: number}) => any}\n * @returns FeatureCollection\n */\n\nfunction geoJsonFromData() {\n  var filteredIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var getGeometry = arguments.length > 1 ? arguments[1] : undefined;\n  var getProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (d) {};\n  var geojson = {\n    type: 'FeatureCollection',\n    /** @type {Feature[]} */\n    features: []\n  };\n  for (var i = 0; i < filteredIndex.length; i++) {\n    var index = filteredIndex[i];\n    var rowIndex = {\n      index: index\n    };\n    var geometry = getGeometry(rowIndex);\n    if (geometry) {\n      geojson.features.push({\n        type: 'Feature',\n        properties: _objectSpread({\n          index: index\n        }, getProperties(rowIndex)),\n        geometry: geometry\n      });\n    }\n  }\n  return geojson;\n}\nvar prefixGpuField = function prefixGpuField(name) {\n  return \"gpu:\".concat(name);\n};\nexports.prefixGpuField = prefixGpuField;\nfunction gpuFilterToMapboxFilter(gpuFilter) {\n  var filterRange = gpuFilter.filterRange,\n    filterValueUpdateTriggers = gpuFilter.filterValueUpdateTriggers;\n  var hasFilter = Object.values(filterValueUpdateTriggers).filter(function (d) {\n    return d;\n  });\n  if (!hasFilter.length) {\n    return null;\n  }\n  var condition = ['all']; // [\">=\", key, value]\n  // [\"<=\", key, value]\n\n  var expressions = Object.values(filterValueUpdateTriggers).reduce(function (accu, name, i) {\n    return name ? [].concat((0, _toConsumableArray2[\"default\"])(accu), [['>=', prefixGpuField(name), filterRange[i][0]], ['<=', prefixGpuField(name), filterRange[i][1]]]) : accu;\n  }, condition);\n  return expressions;\n}","map":{"version":3,"sources":["../../src/layers/mapbox-utils.js"],"names":["generateMapboxLayers","layers","layerData","layerOrder","layersToRender","length","slice","reverse","filter","idx","overlayType","OVERLAY_TYPE","mapboxgl","id","reduce","accu","index","layer","data","isVisible","config","hidden","sourceId","source","updateMapboxLayers","map","newLayers","oldLayers","checkAndRemoveOldLayers","Object","values","forEach","layerId","overlay","oldData","oldConfig","updateSourceData","updateLayerConfig","keys","removeLayer","mapboxLayer","getLayer","addLayer","setLayoutProperty","getSource","addSource","type","setData","geoJsonFromData","filteredIndex","getGeometry","getProperties","geojson","features","i","rowIndex","geometry","push","properties","prefixGpuField","name","gpuFilterToMapboxFilter","gpuFilter","filterRange","filterValueUpdateTriggers","hasFilter","d","condition","expressions"],"mappings":";;;;;;;;;;;;;AAoBA,IAAA,UAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,oBAAT,GAKL;EAAA,IAJAC,MAIA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAJS,EAIT;EAAA,IAHAC,SAGA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAHY,EAGZ;EAAA,IAFAC,UAEA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAFa,EAEb;EAAA,IADAC,cACA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADiB,CAAA,CACjB;EACA,IAAIF,SAAS,CAACG,MAAVH,GAAmB,CAAvB,EAA0B;IACxB,OAAO,UAAU,CACdI,KADI,EAAA,CAEJC,OAFI,EAAA,CAGJC,MAHI,CAIH,UAAA,GAAG,EAAA;MAAA,OAAIP,MAAM,CAACQ,GAAD,CAANR,CAAYS,WAAZT,KAA4BU,UAAAA,CAAAA,YAAAA,CAAaC,QAAzCX,IAAqDG,cAAc,CAACH,MAAM,CAACQ,GAAD,CAANR,CAAYY,EAAb,CAAvE;IAAA,CAJA,CAAA,CAMJC,MANI,CAMG,UAACC,IAAD,EAAOC,KAAP,EAAiB;MACvB,IAAMC,KAAK,GAAGhB,MAAM,CAACe,KAAD,CAApB;MACA,OAAA,aAAA,CAAA,aAAA,CAAA,CAAA,CAAA,EACKD,IADL,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,gBAAA,CAAA,SAAA,CAAA,EAAA,CAAA,CAAA,EAEGE,KAAK,CAACJ,EAFT,EAEc;QACVA,EAAE,EAAEI,KAAK,CAACJ,EADA;QAEVK,IAAI,EAAEhB,SAAS,CAACc,KAAD,CAATd,CAAiBgB,IAFb;QAGVC,SAAS,EAAEF,KAAK,CAACG,MAANH,CAAaE,SAHd;QAIVC,MAAM,EAAElB,SAAS,CAACc,KAAD,CAATd,CAAiBkB,MAJf;QAKVC,MAAM,EAAEJ,KAAK,CAACG,MAANH,CAAaI,MALX;QAMVC,QAAQ,EAAEpB,SAAS,CAACc,KAAD,CAATd,CAAiBkB,MAAjBlB,CAAwBqB;MANxB,CAFd,CAAA,CAAA;IAWD,CAnBI,EAmBF,CAAA,CAnBE,CAAP;EAoBD;EAED,OAAO,CAAA,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,SAASC,kBAAT,CAA4BC,GAA5B,EAAmE;EAAA,IAAlCC,SAAkC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAtB,CAAA,CAAsB;EAAA,IAAlBC,SAAkB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAN,IAAM;;EACxE;EACA,IAAIA,SAAJ,EAAe;IACbC,uBAAuB,CAACH,GAAD,EAAME,SAAN,EAAiBD,SAAjB,CAAvBE;EACD,CAJuE,CAMxE;;EACAC,MAAM,CAACC,MAAPD,CAAcH,SAAdG,CAAAA,CAAyBE,OAAzBF,CAAiC,UAAA,OAAO,EAAI;IAAA,IAC/BG,OAD+B,GACeC,OADf,CACnCpB,EADmC;MACtBO,MADsB,GACea,OADf,CACtBb,MADsB;MACdF,IADc,GACee,OADf,CACdf,IADc;MACRI,QADQ,GACeW,OADf,CACRX,QADQ;MACEH,SADF,GACec,OADf,CACEd,SADF;IAE1C,IAAI,CAACD,IAAD,IAAS,CAACE,MAAd,EAAsB;MACpB;IACD;IAJyC,IAAA,IAAA,GAMEO,SAAS,IAAIA,SAAS,CAACK,OAAD,CAAvB,IAAqC,CAAA,CANtC;MAM7BE,OAN6B,GAAA,IAAA,CAMnChB,IANmC;MAMZiB,SANY,GAAA,IAAA,CAMpBf,MANoB;IAQ1C,IAAIF,IAAI,IAAIA,IAAI,KAAKgB,OAArB,EAA8B;MAC5BE,gBAAgB,CAACX,GAAD,EAAMH,QAAN,EAAgBJ,IAAhB,CAAhBkB;IACD,CAVyC,CAY1C;;IACA,IAAID,SAAS,KAAKf,MAAlB,EAA0B;MACxBiB,iBAAiB,CAACZ,GAAD,EAAMO,OAAN,EAAeZ,MAAf,EAAuBD,SAAvB,CAAjBkB;IACD;EACF,CAhBDR,CAAAA;AAiBD;AAED,SAASD,uBAAT,CAAiCH,GAAjC,EAAsCE,SAAtC,EAAiDD,SAAjD,EAA4D;EAC1DG,MAAM,CAACS,IAAPT,CAAYF,SAAZE,CAAAA,CAAuBE,OAAvBF,CAA+B,UAAA,OAAO,EAAI;IACxC,IAAI,CAACH,SAAS,CAACM,OAAD,CAAd,EAAyB;MACvBP,GAAG,CAACc,WAAJd,CAAgBO,OAAhBP,CAAAA;IACD;EACF,CAJDI,CAAAA;AAKD;AAED,SAASQ,iBAAT,CAA2BZ,GAA3B,EAAgCO,OAAhC,EAAyCZ,MAAzC,EAAiDD,SAAjD,EAA4D;EAC1D,IAAMqB,WAAW,GAAGf,GAAG,CAACgB,QAAJhB,CAAaO,OAAbP,CAApB;EAEA,IAAIe,WAAJ,EAAiB;IACf;IACA;IACAf,GAAG,CAACc,WAAJd,CAAgBO,OAAhBP,CAAAA;EACD;EAEDA,GAAG,CAACiB,QAAJjB,CAAaL,MAAbK,CAAAA;EACAA,GAAG,CAACkB,iBAAJlB,CAAsBO,OAAtBP,EAA+B,YAA/BA,EAA6CN,SAAS,GAAG,SAAH,GAAe,MAArEM,CAAAA;AACD;AAED,SAASW,gBAAT,CAA0BX,GAA1B,EAA+BH,QAA/B,EAAyCJ,IAAzC,EAA+C;EAC7C,IAAMK,MAAM,GAAGE,GAAG,CAACmB,SAAJnB,CAAcH,QAAdG,CAAf;EAEA,IAAI,CAACF,MAAL,EAAa;IACXE,GAAG,CAACoB,SAAJpB,CAAcH,QAAdG,EAAwB;MACtBqB,IAAI,EAAE,SADgB;MAEtB5B,IAAI,EAAJA;IAFsB,CAAxBO,CAAAA;EAID,CALD,MAKO;IACLF,MAAM,CAACwB,OAAPxB,CAAeL,IAAfK,CAAAA;EACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,SAASyB,eAAT,GAAmF;EAAA,IAA1DC,aAA0D,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAA1C,EAA0C;EAAA,IAAtCC,WAAsC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;EAAA,IAAzBC,aAAyB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAT,UAAA,CAAC,EAAI,CAAE,CAAE;EACxF,IAAMC,OAAO,GAAG;IACdN,IAAI,EAAE,mBADQ;IAEd;IACAO,QAAQ,EAAE;EAHI,CAAhB;EAMA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,aAAa,CAAC5C,MAAlC,EAA0CiD,CAAC,EAA3C,EAA+C;IAC7C,IAAMtC,KAAK,GAAGiC,aAAa,CAACK,CAAD,CAA3B;IACA,IAAMC,QAAQ,GAAG;MAACvC,KAAK,EAALA;IAAD,CAAjB;IACA,IAAMwC,QAAQ,GAAGN,WAAW,CAACK,QAAD,CAA5B;IAEA,IAAIC,QAAJ,EAAc;MACZJ,OAAO,CAACC,QAARD,CAAiBK,IAAjBL,CAAsB;QACpBN,IAAI,EAAE,SADc;QAEpBY,UAAU,EAAA,aAAA,CAAA;UACR1C,KAAK,EAALA;QADQ,CAAA,EAELmC,aAAa,CAACI,QAAD,CAFR,CAFU;QAMpBC,QAAQ,EAARA;MANoB,CAAtBJ,CAAAA;IAQD;EACF;EAED,OAAOA,OAAP;AACD;AAEM,IAAMO,cAAc,GAAG,SAAjBA,cAAiB,CAAA,IAAI,EAAA;EAAA,OAAA,MAAA,CAAA,MAAA,CAAWC,IAAX,CAAA;AAAA,CAA3B;;AAEA,SAASC,uBAAT,CAAiCC,SAAjC,EAA4C;EAAA,IAC1CC,WAD0C,GACAD,SADA,CAC1CC,WAD0C;IAC7BC,yBAD6B,GACAF,SADA,CAC7BE,yBAD6B;EAGjD,IAAMC,SAAS,GAAG,MAAM,CAACnC,MAAP,CAAckC,yBAAd,CAAA,CAAyCxD,MAAzC,CAAgD,UAAA,CAAC,EAAA;IAAA,OAAI0D,CAAJ;EAAA,CAAjD,CAAlB;EAEA,IAAI,CAACD,SAAS,CAAC5D,MAAf,EAAuB;IACrB,OAAO,IAAP;EACD;EAED,IAAM8D,SAAS,GAAG,CAAC,KAAD,CAAlB,CATiD,CAWjD;EACA;;EACA,IAAMC,WAAW,GAAG,MAAM,CAACtC,MAAP,CAAckC,yBAAd,CAAA,CAAyClD,MAAzC,CAClB,UAACC,IAAD,EAAO6C,IAAP,EAAaN,CAAb,EAAA;IAAA,OACEM,IAAI,GAAA,EAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAA,mBAAA,CAAA,SAAA,CAAA,EAEK7C,IAFL,CAAA,EAAA,CAGE,CAAC,IAAD,EAAO4C,cAAc,CAACC,IAAD,CAArB,EAA6BG,WAAW,CAACT,CAAD,CAAXS,CAAe,CAAfA,CAA7B,CAHF,EAIE,CAAC,IAAD,EAAOJ,cAAc,CAACC,IAAD,CAArB,EAA6BG,WAAW,CAACT,CAAD,CAAXS,CAAe,CAAfA,CAA7B,CAJF,CAAA,CAAA,GAMAhD,IAPN;EAAA,CADkB,EASlBoD,SATkB,CAApB;EAYA,OAAOC,WAAP;AACD","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {OVERLAY_TYPE} from './base-layer';\n\n/** @typedef {import(\"geojson\").FeatureCollection} FeatureCollection */\n/** @typedef {import(\"geojson\").Feature} Feature */\n\n/**\n * This function will convert layers to mapbox layers\n * @param {Array<Object>} layers the layers to be converted\n * @param {Array<Object>} layerData extra layer information\n * @param {Array<Number>} layerOrder the order by which we should convert layers\n * @param {Object} layersToRender {[id]: true | false} object whether each layer should be rendered\n * @returns {Object} {[id]: layer}\n */\nexport function generateMapboxLayers(\n  layers = [],\n  layerData = [],\n  layerOrder = [],\n  layersToRender = {}\n) {\n  if (layerData.length > 0) {\n    return layerOrder\n      .slice()\n      .reverse()\n      .filter(\n        idx => layers[idx].overlayType === OVERLAY_TYPE.mapboxgl && layersToRender[layers[idx].id]\n      )\n      .reduce((accu, index) => {\n        const layer = layers[index];\n        return {\n          ...accu,\n          [layer.id]: {\n            id: layer.id,\n            data: layerData[index].data,\n            isVisible: layer.config.isVisible,\n            config: layerData[index].config,\n            hidden: layer.config.hidden,\n            sourceId: layerData[index].config.source\n          }\n        };\n      }, {});\n  }\n\n  return {};\n}\n\n/**\n * Update mapbox layers on the given map\n * @param {Object} map\n * @param {Object} newLayers Map of new mapbox layers to be displayed\n * @param {Object} oldLayers Map of the old layers to be compare with the current ones to detect deleted layers\n *                  {layerId: sourceId}\n */\nexport function updateMapboxLayers(map, newLayers = {}, oldLayers = null) {\n  // delete no longer existed old layers\n  if (oldLayers) {\n    checkAndRemoveOldLayers(map, oldLayers, newLayers);\n  }\n\n  // insert or update new layer\n  Object.values(newLayers).forEach(overlay => {\n    const {id: layerId, config, data, sourceId, isVisible} = overlay;\n    if (!data && !config) {\n      return;\n    }\n\n    const {data: oldData, config: oldConfig} = (oldLayers && oldLayers[layerId]) || {};\n\n    if (data && data !== oldData) {\n      updateSourceData(map, sourceId, data);\n    }\n\n    // compare with previous configs\n    if (oldConfig !== config) {\n      updateLayerConfig(map, layerId, config, isVisible);\n    }\n  });\n}\n\nfunction checkAndRemoveOldLayers(map, oldLayers, newLayers) {\n  Object.keys(oldLayers).forEach(layerId => {\n    if (!newLayers[layerId]) {\n      map.removeLayer(layerId);\n    }\n  });\n}\n\nfunction updateLayerConfig(map, layerId, config, isVisible) {\n  const mapboxLayer = map.getLayer(layerId);\n\n  if (mapboxLayer) {\n    // check if layer already is set\n    // remove it if exists\n    map.removeLayer(layerId);\n  }\n\n  map.addLayer(config);\n  map.setLayoutProperty(layerId, 'visibility', isVisible ? 'visible' : 'none');\n}\n\nfunction updateSourceData(map, sourceId, data) {\n  const source = map.getSource(sourceId);\n\n  if (!source) {\n    map.addSource(sourceId, {\n      type: 'geojson',\n      data\n    });\n  } else {\n    source.setData(data);\n  }\n}\n\n/**\n *\n * @param filteredIndex\n * @param getGeometry {({index: number}) => any}\n * @param getProperties {({index: number}) => any}\n * @returns FeatureCollection\n */\nexport function geoJsonFromData(filteredIndex = [], getGeometry, getProperties = d => {}) {\n  const geojson = {\n    type: 'FeatureCollection',\n    /** @type {Feature[]} */\n    features: []\n  };\n\n  for (let i = 0; i < filteredIndex.length; i++) {\n    const index = filteredIndex[i];\n    const rowIndex = {index};\n    const geometry = getGeometry(rowIndex);\n\n    if (geometry) {\n      geojson.features.push({\n        type: 'Feature',\n        properties: {\n          index,\n          ...getProperties(rowIndex)\n        },\n        geometry\n      });\n    }\n  }\n\n  return geojson;\n}\n\nexport const prefixGpuField = name => `gpu:${name}`;\n\nexport function gpuFilterToMapboxFilter(gpuFilter) {\n  const {filterRange, filterValueUpdateTriggers} = gpuFilter;\n\n  const hasFilter = Object.values(filterValueUpdateTriggers).filter(d => d);\n\n  if (!hasFilter.length) {\n    return null;\n  }\n\n  const condition = ['all'];\n\n  // [\">=\", key, value]\n  // [\"<=\", key, value]\n  const expressions = Object.values(filterValueUpdateTriggers).reduce(\n    (accu, name, i) =>\n      name\n        ? [\n            ...accu,\n            ['>=', prefixGpuField(name), filterRange[i][0]],\n            ['<=', prefixGpuField(name), filterRange[i][1]]\n          ]\n        : accu,\n    condition\n  );\n\n  return expressions;\n}\n"]},"metadata":{},"sourceType":"script"}