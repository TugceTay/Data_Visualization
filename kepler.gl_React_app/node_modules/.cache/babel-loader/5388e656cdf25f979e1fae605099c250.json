{"ast":null,"code":"import * as mat4 from 'gl-matrix/mat4';\nimport * as vec4 from 'gl-matrix/vec4';\nimport { COORDINATE_SYSTEM, PROJECTION_MODE } from '../../lib/constants';\nimport memoize from '../../utils/memoize';\nimport assert from '../../utils/assert';\nvar ZERO_VECTOR = [0, 0, 0, 0];\nvar VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nvar DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];\nvar DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];\nvar getMemoizedViewportUniforms = memoize(calculateViewportUniforms);\nexport function getOffsetOrigin(viewport, coordinateSystem) {\n  var coordinateOrigin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_COORDINATE_ORIGIN;\n  var shaderCoordinateOrigin = coordinateOrigin;\n  var geospatialOrigin;\n  var offsetMode = true;\n  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n    geospatialOrigin = coordinateOrigin;\n  } else {\n    geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;\n  }\n  switch (viewport.projectionMode) {\n    case PROJECTION_MODE.WEB_MERCATOR:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        offsetMode = false;\n      }\n      break;\n    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        shaderCoordinateOrigin = geospatialOrigin;\n      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];\n        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);\n        shaderCoordinateOrigin[0] -= coordinateOrigin[0];\n        shaderCoordinateOrigin[1] -= coordinateOrigin[1];\n        shaderCoordinateOrigin[2] -= coordinateOrigin[2];\n      }\n      break;\n    case PROJECTION_MODE.IDENTITY:\n      shaderCoordinateOrigin = viewport.position.map(Math.fround);\n      break;\n    case PROJECTION_MODE.GLOBE:\n      offsetMode = false;\n      break;\n    default:\n      offsetMode = false;\n  }\n  shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;\n  return {\n    geospatialOrigin: geospatialOrigin,\n    shaderCoordinateOrigin: shaderCoordinateOrigin,\n    offsetMode: offsetMode\n  };\n}\nfunction calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {\n  var viewMatrixUncentered = viewport.viewMatrixUncentered,\n    projectionMatrix = viewport.projectionMatrix;\n  var viewMatrix = viewport.viewMatrix,\n    viewProjectionMatrix = viewport.viewProjectionMatrix;\n  var projectionCenter = ZERO_VECTOR;\n  var cameraPosCommon = viewport.cameraPosition;\n  var _getOffsetOrigin = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin),\n    geospatialOrigin = _getOffsetOrigin.geospatialOrigin,\n    shaderCoordinateOrigin = _getOffsetOrigin.shaderCoordinateOrigin,\n    offsetMode = _getOffsetOrigin.offsetMode;\n  if (offsetMode) {\n    var positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n    cameraPosCommon = [cameraPosCommon[0] - positionCommonSpace[0], cameraPosCommon[1] - positionCommonSpace[1], cameraPosCommon[2] - positionCommonSpace[2]];\n    positionCommonSpace[3] = 1;\n    projectionCenter = vec4.transformMat4([], positionCommonSpace, viewProjectionMatrix);\n    viewMatrix = viewMatrixUncentered || viewMatrix;\n    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n  }\n  return {\n    viewMatrix: viewMatrix,\n    viewProjectionMatrix: viewProjectionMatrix,\n    projectionCenter: projectionCenter,\n    cameraPosCommon: cameraPosCommon,\n    shaderCoordinateOrigin: shaderCoordinateOrigin,\n    geospatialOrigin: geospatialOrigin\n  };\n}\nexport function getUniformsFromViewport() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    viewport = _ref.viewport,\n    _ref$devicePixelRatio = _ref.devicePixelRatio,\n    devicePixelRatio = _ref$devicePixelRatio === void 0 ? 1 : _ref$devicePixelRatio,\n    _ref$modelMatrix = _ref.modelMatrix,\n    modelMatrix = _ref$modelMatrix === void 0 ? null : _ref$modelMatrix,\n    _ref$coordinateSystem = _ref.coordinateSystem,\n    coordinateSystem = _ref$coordinateSystem === void 0 ? COORDINATE_SYSTEM.DEFAULT : _ref$coordinateSystem,\n    coordinateOrigin = _ref.coordinateOrigin,\n    _ref$autoWrapLongitud = _ref.autoWrapLongitude,\n    autoWrapLongitude = _ref$autoWrapLongitud === void 0 ? false : _ref$autoWrapLongitud,\n    projectionMode = _ref.projectionMode,\n    positionOrigin = _ref.positionOrigin;\n  assert(viewport);\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;\n  }\n  var uniforms = getMemoizedViewportUniforms({\n    viewport: viewport,\n    devicePixelRatio: devicePixelRatio,\n    coordinateSystem: coordinateSystem,\n    coordinateOrigin: coordinateOrigin\n  });\n  uniforms.project_uWrapLongitude = autoWrapLongitude;\n  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;\n  return uniforms;\n}\nfunction calculateViewportUniforms(_ref2) {\n  var viewport = _ref2.viewport,\n    devicePixelRatio = _ref2.devicePixelRatio,\n    coordinateSystem = _ref2.coordinateSystem,\n    coordinateOrigin = _ref2.coordinateOrigin;\n  var _calculateMatrixAndOf = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin),\n    projectionCenter = _calculateMatrixAndOf.projectionCenter,\n    viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,\n    cameraPosCommon = _calculateMatrixAndOf.cameraPosCommon,\n    shaderCoordinateOrigin = _calculateMatrixAndOf.shaderCoordinateOrigin,\n    geospatialOrigin = _calculateMatrixAndOf.geospatialOrigin;\n  var distanceScales = viewport.getDistanceScales();\n  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];\n  var uniforms = {\n    project_uCoordinateSystem: coordinateSystem,\n    project_uProjectionMode: viewport.projectionMode,\n    project_uCoordinateOrigin: shaderCoordinateOrigin,\n    project_uCenter: projectionCenter,\n    project_uAntimeridian: (viewport.longitude || 0) - 180,\n    project_uViewportSize: viewportSize,\n    project_uDevicePixelRatio: devicePixelRatio,\n    project_uFocalDistance: viewport.focalDistance || 1,\n    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,\n    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,\n    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,\n    project_uScale: viewport.scale,\n    project_uViewProjectionMatrix: viewProjectionMatrix,\n    project_uCameraPosition: cameraPosCommon\n  };\n  if (geospatialOrigin) {\n    var distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);\n    switch (coordinateSystem) {\n      case COORDINATE_SYSTEM.METER_OFFSETS:\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;\n        break;\n      case COORDINATE_SYSTEM.LNGLAT:\n      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;\n        break;\n      case COORDINATE_SYSTEM.CARTESIAN:\n        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];\n        uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];\n        break;\n      default:\n        break;\n    }\n  }\n  return uniforms;\n}","map":{"version":3,"sources":["../../../../src/shaderlib/project/viewport-uniforms.js"],"names":["mat4","vec4","COORDINATE_SYSTEM","PROJECTION_MODE","memoize","assert","ZERO_VECTOR","VECTOR_TO_POINT_MATRIX","IDENTITY_MATRIX","DEFAULT_PIXELS_PER_UNIT2","DEFAULT_COORDINATE_ORIGIN","getMemoizedViewportUniforms","calculateViewportUniforms","getOffsetOrigin","viewport","coordinateSystem","coordinateOrigin","shaderCoordinateOrigin","geospatialOrigin","offsetMode","LNGLAT_OFFSETS","METER_OFFSETS","isGeospatial","Math","fround","longitude","latitude","projectionMode","WEB_MERCATOR","LNGLAT","CARTESIAN","WEB_MERCATOR_AUTO_OFFSET","center","unprojectPosition","IDENTITY","position","map","GLOBE","calculateMatrixAndOffset","viewMatrixUncentered","projectionMatrix","viewMatrix","viewProjectionMatrix","projectionCenter","cameraPosCommon","cameraPosition","positionCommonSpace","projectPosition","transformMat4","multiply","getUniformsFromViewport","devicePixelRatio","modelMatrix","DEFAULT","autoWrapLongitude","positionOrigin","uniforms","project_uWrapLongitude","project_uModelMatrix","distanceScales","getDistanceScales","viewportSize","width","height","project_uCoordinateSystem","project_uProjectionMode","project_uCoordinateOrigin","project_uCenter","project_uAntimeridian","project_uViewportSize","project_uDevicePixelRatio","project_uFocalDistance","focalDistance","project_uCommonUnitsPerMeter","unitsPerMeter","project_uCommonUnitsPerWorldUnit","project_uCommonUnitsPerWorldUnit2","project_uScale","scale","project_uViewProjectionMatrix","project_uCameraPosition","distanceScalesAtOrigin","unitsPerMeter2","unitsPerDegree","unitsPerDegree2"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable complexity */\n\nimport * as mat4 from 'gl-matrix/mat4';\nimport * as vec4 from 'gl-matrix/vec4';\n\nimport {COORDINATE_SYSTEM, PROJECTION_MODE} from '../../lib/constants';\n\nimport memoize from '../../utils/memoize';\nimport assert from '../../utils/assert';\n\n// To quickly set a vector to zero\nconst ZERO_VECTOR = [0, 0, 0, 0];\n// 4x4 matrix that drops 4th component of vector\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nconst DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];\nconst DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];\n\nconst getMemoizedViewportUniforms = memoize(calculateViewportUniforms);\n\nexport function getOffsetOrigin(\n  viewport,\n  coordinateSystem,\n  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN\n) {\n  let shaderCoordinateOrigin = coordinateOrigin;\n  let geospatialOrigin;\n  let offsetMode = true;\n\n  if (\n    coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS\n  ) {\n    geospatialOrigin = coordinateOrigin;\n  } else {\n    geospatialOrigin = viewport.isGeospatial\n      ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0]\n      : null;\n  }\n\n  switch (viewport.projectionMode) {\n    case PROJECTION_MODE.WEB_MERCATOR:\n      if (\n        coordinateSystem === COORDINATE_SYSTEM.LNGLAT ||\n        coordinateSystem === COORDINATE_SYSTEM.CARTESIAN\n      ) {\n        offsetMode = false;\n      }\n      break;\n\n    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        // viewport center in world space\n        shaderCoordinateOrigin = geospatialOrigin;\n      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        // viewport center in common space\n        shaderCoordinateOrigin = [\n          Math.fround(viewport.center[0]),\n          Math.fround(viewport.center[1]),\n          0\n        ];\n        // Geospatial origin (wgs84) must match shaderCoordinateOrigin (common)\n        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);\n        shaderCoordinateOrigin[0] -= coordinateOrigin[0];\n        shaderCoordinateOrigin[1] -= coordinateOrigin[1];\n        shaderCoordinateOrigin[2] -= coordinateOrigin[2];\n      }\n      break;\n\n    case PROJECTION_MODE.IDENTITY:\n      shaderCoordinateOrigin = viewport.position.map(Math.fround);\n      break;\n\n    case PROJECTION_MODE.GLOBE:\n      offsetMode = false;\n      break;\n\n    default:\n      // Unknown projection mode\n      offsetMode = false;\n  }\n\n  shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;\n\n  return {geospatialOrigin, shaderCoordinateOrigin, offsetMode};\n}\n\n// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,\n// has lower performance but provides error checking.\nfunction calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {\n  const {viewMatrixUncentered, projectionMatrix} = viewport;\n  let {viewMatrix, viewProjectionMatrix} = viewport;\n\n  let projectionCenter = ZERO_VECTOR;\n  let cameraPosCommon = viewport.cameraPosition;\n  const {geospatialOrigin, shaderCoordinateOrigin, offsetMode} = getOffsetOrigin(\n    viewport,\n    coordinateSystem,\n    coordinateOrigin\n  );\n\n  if (offsetMode) {\n    // Calculate transformed projectionCenter (using 64 bit precision JS)\n    // This is the key to offset mode precision\n    // (avoids doing this addition in 32 bit precision in GLSL)\n    const positionCommonSpace = viewport.projectPosition(\n      geospatialOrigin || shaderCoordinateOrigin\n    );\n\n    cameraPosCommon = [\n      cameraPosCommon[0] - positionCommonSpace[0],\n      cameraPosCommon[1] - positionCommonSpace[1],\n      cameraPosCommon[2] - positionCommonSpace[2]\n    ];\n\n    positionCommonSpace[3] = 1;\n\n    // projectionCenter = new Matrix4(viewProjectionMatrix)\n    //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n    projectionCenter = vec4.transformMat4([], positionCommonSpace, viewProjectionMatrix);\n\n    // Always apply uncentered projection matrix if available (shader adds center)\n    viewMatrix = viewMatrixUncentered || viewMatrix;\n\n    // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n    // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)\n    //   .multiplyRight(VECTOR_TO_POINT_MATRIX);\n    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n  }\n\n  return {\n    viewMatrix,\n    viewProjectionMatrix,\n    projectionCenter,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  };\n}\n\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\nexport function getUniformsFromViewport({\n  viewport,\n  devicePixelRatio = 1,\n  modelMatrix = null,\n  // Match Layer.defaultProps\n  coordinateSystem = COORDINATE_SYSTEM.DEFAULT,\n  coordinateOrigin,\n  autoWrapLongitude = false,\n  // Deprecated\n  projectionMode,\n  positionOrigin\n} = {}) {\n  assert(viewport);\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial\n      ? COORDINATE_SYSTEM.LNGLAT\n      : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  const uniforms = getMemoizedViewportUniforms({\n    viewport,\n    devicePixelRatio,\n    coordinateSystem,\n    coordinateOrigin\n  });\n\n  uniforms.project_uWrapLongitude = autoWrapLongitude;\n  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;\n\n  return uniforms;\n}\n\nfunction calculateViewportUniforms({\n  viewport,\n  devicePixelRatio,\n  coordinateSystem,\n  coordinateOrigin\n}) {\n  const {\n    projectionCenter,\n    viewProjectionMatrix,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);\n\n  // Calculate projection pixels per unit\n  const distanceScales = viewport.getDistanceScales();\n\n  const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];\n\n  const uniforms = {\n    // Projection mode values\n    project_uCoordinateSystem: coordinateSystem,\n    project_uProjectionMode: viewport.projectionMode,\n    project_uCoordinateOrigin: shaderCoordinateOrigin,\n    project_uCenter: projectionCenter,\n    project_uAntimeridian: (viewport.longitude || 0) - 180,\n\n    // Screen size\n    project_uViewportSize: viewportSize,\n    project_uDevicePixelRatio: devicePixelRatio,\n\n    // Distance at which screen pixels are projected\n    project_uFocalDistance: viewport.focalDistance || 1,\n    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,\n    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,\n    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,\n    project_uScale: viewport.scale, // This is the mercator scale (2 ** zoom)\n\n    project_uViewProjectionMatrix: viewProjectionMatrix,\n\n    // This is for lighting calculations\n    project_uCameraPosition: cameraPosCommon\n  };\n\n  if (geospatialOrigin) {\n    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);\n    switch (coordinateSystem) {\n      case COORDINATE_SYSTEM.METER_OFFSETS:\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;\n        break;\n\n      case COORDINATE_SYSTEM.LNGLAT:\n      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;\n        break;\n\n      // a.k.a \"preprojected\" positions\n      case COORDINATE_SYSTEM.CARTESIAN:\n        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];\n        uniforms.project_uCommonUnitsPerWorldUnit2 = [\n          0,\n          0,\n          distanceScalesAtOrigin.unitsPerMeter2[2]\n        ];\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return uniforms;\n}\n"]},"metadata":{},"sourceType":"module"}