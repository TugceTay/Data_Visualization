{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.defaultRadius = exports.defaultLineWidth = exports.defaultElevation = exports.featureAccessor = exports.geoJsonRequiredColumns = exports.geojsonVisConfigs = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.uniq\"));\nvar _typeAnalyzer = require(\"type-analyzer\");\nvar _baseLayer = _interopRequireWildcard(require(\"../base-layer\"));\nvar _layers = require(\"@deck.gl/layers\");\nvar _geojsonUtils = require(\"./geojson-utils\");\nvar _geojsonLayerIcon = _interopRequireDefault(require(\"./geojson-layer-icon\"));\nvar _defaultSettings = require(\"../../constants/default-settings\");\nvar _layerFactory = require(\"../layer-factory\");\nvar _SUPPORTED_ANALYZER_T;\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar SUPPORTED_ANALYZER_TYPES = (_SUPPORTED_ANALYZER_T = {}, (0, _defineProperty2[\"default\"])(_SUPPORTED_ANALYZER_T, _typeAnalyzer.DATA_TYPES.GEOMETRY, true), (0, _defineProperty2[\"default\"])(_SUPPORTED_ANALYZER_T, _typeAnalyzer.DATA_TYPES.GEOMETRY_FROM_STRING, true), (0, _defineProperty2[\"default\"])(_SUPPORTED_ANALYZER_T, _typeAnalyzer.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING, true), _SUPPORTED_ANALYZER_T);\nvar geojsonVisConfigs = {\n  opacity: 'opacity',\n  strokeOpacity: _objectSpread(_objectSpread({}, _layerFactory.LAYER_VIS_CONFIGS.opacity), {}, {\n    property: 'strokeOpacity'\n  }),\n  thickness: _objectSpread(_objectSpread({}, _layerFactory.LAYER_VIS_CONFIGS.thickness), {}, {\n    defaultValue: 0.5\n  }),\n  strokeColor: 'strokeColor',\n  colorRange: 'colorRange',\n  strokeColorRange: 'strokeColorRange',\n  radius: 'radius',\n  sizeRange: 'strokeWidthRange',\n  radiusRange: 'radiusRange',\n  heightRange: 'elevationRange',\n  elevationScale: 'elevationScale',\n  enableElevationZoomFactor: 'enableElevationZoomFactor',\n  stroked: 'stroked',\n  filled: 'filled',\n  enable3d: 'enable3d',\n  wireframe: 'wireframe'\n};\nexports.geojsonVisConfigs = geojsonVisConfigs;\nvar geoJsonRequiredColumns = ['geojson'];\nexports.geoJsonRequiredColumns = geoJsonRequiredColumns;\nvar featureAccessor = function featureAccessor(_ref) {\n  var geojson = _ref.geojson;\n  return function (dc) {\n    return function (d) {\n      return dc.valueAt(d.index, geojson.fieldIdx);\n    };\n  };\n}; // access feature properties from geojson sub layer\n\nexports.featureAccessor = featureAccessor;\nvar defaultElevation = 500;\nexports.defaultElevation = defaultElevation;\nvar defaultLineWidth = 1;\nexports.defaultLineWidth = defaultLineWidth;\nvar defaultRadius = 1;\nexports.defaultRadius = defaultRadius;\nvar GeoJsonLayer = /*#__PURE__*/function (_Layer) {\n  (0, _inherits2[\"default\"])(GeoJsonLayer, _Layer);\n  var _super = _createSuper(GeoJsonLayer);\n  function GeoJsonLayer(props) {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, GeoJsonLayer);\n    _this = _super.call(this, props);\n    _this.dataToFeature = [];\n    _this.registerVisConfig(geojsonVisConfigs);\n    _this.getPositionAccessor = function (dataContainer) {\n      return featureAccessor(_this.config.columns)(dataContainer);\n    };\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(GeoJsonLayer, [{\n    key: \"type\",\n    get: function get() {\n      return 'geojson';\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Polygon';\n    }\n  }, {\n    key: \"layerIcon\",\n    get: function get() {\n      return _geojsonLayerIcon[\"default\"];\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return geoJsonRequiredColumns;\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      var visualChannels = (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(GeoJsonLayer.prototype), \"visualChannels\", this);\n      return {\n        color: _objectSpread(_objectSpread({}, visualChannels.color), {}, {\n          accessor: 'getFillColor',\n          condition: function condition(config) {\n            return config.visConfig.filled;\n          },\n          nullValue: visualChannels.color.nullValue,\n          getAttributeValue: function getAttributeValue(config) {\n            return function (d) {\n              return d.properties.fillColor || config.color;\n            };\n          },\n          // used this to get updateTriggers\n          defaultValue: function defaultValue(config) {\n            return config.color;\n          }\n        }),\n        strokeColor: {\n          property: 'strokeColor',\n          field: 'strokeColorField',\n          scale: 'strokeColorScale',\n          domain: 'strokeColorDomain',\n          range: 'strokeColorRange',\n          key: 'strokeColor',\n          channelScaleType: _defaultSettings.CHANNEL_SCALES.color,\n          accessor: 'getLineColor',\n          condition: function condition(config) {\n            return config.visConfig.stroked;\n          },\n          nullValue: visualChannels.color.nullValue,\n          getAttributeValue: function getAttributeValue(config) {\n            return function (d) {\n              return d.properties.lineColor || config.visConfig.strokeColor || config.color;\n            };\n          },\n          // used this to get updateTriggers\n          defaultValue: function defaultValue(config) {\n            return config.visConfig.strokeColor || config.color;\n          }\n        },\n        size: _objectSpread(_objectSpread({}, visualChannels.size), {}, {\n          property: 'stroke',\n          accessor: 'getLineWidth',\n          condition: function condition(config) {\n            return config.visConfig.stroked;\n          },\n          nullValue: 0,\n          getAttributeValue: function getAttributeValue() {\n            return function (d) {\n              return d.properties.lineWidth || defaultLineWidth;\n            };\n          }\n        }),\n        height: {\n          property: 'height',\n          field: 'heightField',\n          scale: 'heightScale',\n          domain: 'heightDomain',\n          range: 'heightRange',\n          key: 'height',\n          channelScaleType: _defaultSettings.CHANNEL_SCALES.size,\n          accessor: 'getElevation',\n          condition: function condition(config) {\n            return config.visConfig.enable3d;\n          },\n          nullValue: 0,\n          getAttributeValue: function getAttributeValue() {\n            return function (d) {\n              return d.properties.elevation || defaultElevation;\n            };\n          }\n        },\n        radius: {\n          property: 'radius',\n          field: 'radiusField',\n          scale: 'radiusScale',\n          domain: 'radiusDomain',\n          range: 'radiusRange',\n          key: 'radius',\n          channelScaleType: _defaultSettings.CHANNEL_SCALES.radius,\n          accessor: 'getRadius',\n          nullValue: 0,\n          getAttributeValue: function getAttributeValue() {\n            return function (d) {\n              return d.properties.radius || defaultRadius;\n            };\n          }\n        }\n      };\n    }\n  }, {\n    key: \"getDefaultLayerConfig\",\n    value: function getDefaultLayerConfig() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(GeoJsonLayer.prototype), \"getDefaultLayerConfig\", this).call(this, props)), {}, {\n        // add height visual channel\n        heightField: null,\n        heightDomain: [0, 1],\n        heightScale: 'linear',\n        // add radius visual channel\n        radiusField: null,\n        radiusDomain: [0, 1],\n        radiusScale: 'linear',\n        // add stroke color visual channel\n        strokeColorField: null,\n        strokeColorDomain: [0, 1],\n        strokeColorScale: 'quantile'\n      });\n    }\n  }, {\n    key: \"getHoverData\",\n    value: function getHoverData(object, dataContainer) {\n      // index of dataContainer is saved to feature.properties\n      return dataContainer.row(object.properties.index);\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(_ref2, getPosition) {\n      var _this2 = this;\n      var dataContainer = _ref2.dataContainer,\n        filteredIndex = _ref2.filteredIndex;\n      return filteredIndex.map(function (i) {\n        return _this2.dataToFeature[i];\n      }).filter(function (d) {\n        return d;\n      });\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, oldLayerData) {\n      var _datasets$this$config = datasets[this.config.dataId],\n        gpuFilter = _datasets$this$config.gpuFilter,\n        dataContainer = _datasets$this$config.dataContainer;\n      var _this$updateData = this.updateData(datasets, oldLayerData),\n        data = _this$updateData.data;\n      var customFilterValueAccessor = function customFilterValueAccessor(dc, d, fieldIndex) {\n        return dc.valueAt(d.properties.index, fieldIndex);\n      };\n      var indexAccessor = function indexAccessor(f) {\n        return f.properties.index;\n      };\n      var dataAccessor = function dataAccessor(dc) {\n        return function (d) {\n          return {\n            index: d.properties.index\n          };\n        };\n      };\n      var accessors = this.getAttributeAccessors({\n        dataAccessor: dataAccessor,\n        dataContainer: dataContainer\n      });\n      return _objectSpread({\n        data: data,\n        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(indexAccessor, customFilterValueAccessor)\n      }, accessors);\n    }\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer) {\n      var getFeature = this.getPositionAccessor(dataContainer);\n      this.dataToFeature = (0, _geojsonUtils.getGeojsonDataMaps)(dataContainer, getFeature); // get bounds from features\n\n      var bounds = (0, _geojsonUtils.getGeojsonBounds)(this.dataToFeature); // if any of the feature has properties.radius set to be true\n\n      var fixedRadius = Boolean(this.dataToFeature.find(function (d) {\n        return d && d.properties && d.properties.radius;\n      })); // keep a record of what type of geometry the collection has\n\n      var featureTypes = (0, _geojsonUtils.getGeojsonFeatureTypes)(this.dataToFeature);\n      this.updateMeta({\n        bounds: bounds,\n        fixedRadius: fixedRadius,\n        featureTypes: featureTypes\n      });\n    }\n  }, {\n    key: \"setInitialLayerConfig\",\n    value: function setInitialLayerConfig(_ref3) {\n      var dataContainer = _ref3.dataContainer;\n      this.updateLayerMeta(dataContainer);\n      var featureTypes = this.meta.featureTypes; // default settings is stroke: true, filled: false\n\n      if (featureTypes && featureTypes.polygon) {\n        // set both fill and stroke to true\n        return this.updateLayerVisConfig({\n          filled: true,\n          stroked: true,\n          strokeColor: _baseLayer.colorMaker.next().value\n        });\n      } else if (featureTypes && featureTypes.point) {\n        // set fill to true if detect point\n        return this.updateLayerVisConfig({\n          filled: true,\n          stroked: false\n        });\n      }\n      return this;\n    }\n  }, {\n    key: \"renderLayer\",\n    value: function renderLayer(opts) {\n      var data = opts.data,\n        gpuFilter = opts.gpuFilter,\n        objectHovered = opts.objectHovered,\n        mapState = opts.mapState,\n        interactionConfig = opts.interactionConfig;\n      var _this$meta = this.meta,\n        fixedRadius = _this$meta.fixedRadius,\n        featureTypes = _this$meta.featureTypes;\n      var radiusScale = this.getRadiusScaleByZoom(mapState, fixedRadius);\n      var zoomFactor = this.getZoomFactor(mapState);\n      var eleZoomFactor = this.getElevationZoomFactor(mapState);\n      var visConfig = this.config.visConfig;\n      var layerProps = {\n        lineWidthScale: visConfig.thickness * zoomFactor * 8,\n        elevationScale: visConfig.elevationScale * eleZoomFactor,\n        pointRadiusScale: radiusScale,\n        lineMiterLimit: 4\n      };\n      var updateTriggers = _objectSpread(_objectSpread({}, this.getVisualChannelUpdateTriggers()), {}, {\n        getFilterValue: gpuFilter.filterValueUpdateTriggers\n      });\n      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n      var opaOverwrite = {\n        opacity: visConfig.strokeOpacity\n      };\n      var pickable = interactionConfig.tooltip.enabled;\n      var hoveredObject = this.hasHoveredObject(objectHovered);\n      return [new _layers.GeoJsonLayer(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), layerProps), data), {}, {\n        pickable: pickable,\n        highlightColor: _defaultSettings.HIGHLIGH_COLOR_3D,\n        autoHighlight: visConfig.enable3d && pickable,\n        stroked: visConfig.stroked,\n        filled: visConfig.filled,\n        extruded: visConfig.enable3d,\n        wireframe: visConfig.wireframe,\n        wrapLongitude: false,\n        lineMiterLimit: 2,\n        rounded: true,\n        updateTriggers: updateTriggers,\n        _subLayerProps: _objectSpread(_objectSpread(_objectSpread({}, featureTypes.polygon ? {\n          'polygons-stroke': opaOverwrite\n        } : {}), featureTypes.line ? {\n          'line-strings': opaOverwrite\n        } : {}), featureTypes.point ? {\n          points: {\n            lineOpacity: visConfig.strokeOpacity\n          }\n        } : {})\n      }))].concat((0, _toConsumableArray2[\"default\"])(hoveredObject && !visConfig.enable3d ? [new _layers.GeoJsonLayer(_objectSpread(_objectSpread(_objectSpread({}, this.getDefaultHoverLayerProps()), layerProps), {}, {\n        wrapLongitude: false,\n        data: [hoveredObject],\n        getLineWidth: data.getLineWidth,\n        getRadius: data.getRadius,\n        getElevation: data.getElevation,\n        getLineColor: this.config.highlightColor,\n        getFillColor: this.config.highlightColor,\n        // always draw outline\n        stroked: true,\n        filled: false\n      }))] : []));\n    }\n  }], [{\n    key: \"findDefaultLayerProps\",\n    value: function findDefaultLayerProps(_ref4) {\n      var _this3 = this;\n      var label = _ref4.label,\n        _ref4$fields = _ref4.fields,\n        fields = _ref4$fields === void 0 ? [] : _ref4$fields;\n      var geojsonColumns = fields.filter(function (f) {\n        return f.type === 'geojson' && SUPPORTED_ANALYZER_TYPES[f.analyzerType];\n      }).map(function (f) {\n        return f.name;\n      });\n      var defaultColumns = {\n        geojson: (0, _lodash[\"default\"])([].concat((0, _toConsumableArray2[\"default\"])(_defaultSettings.GEOJSON_FIELDS.geojson), (0, _toConsumableArray2[\"default\"])(geojsonColumns)))\n      };\n      var foundColumns = this.findDefaultColumnField(defaultColumns, fields);\n      if (!foundColumns || !foundColumns.length) {\n        return {\n          props: []\n        };\n      }\n      return {\n        props: foundColumns.map(function (columns) {\n          return {\n            label: typeof label === 'string' && label.replace(/\\.[^/.]+$/, '') || _this3.type,\n            columns: columns,\n            isVisible: true\n          };\n        })\n      };\n    }\n  }]);\n  return GeoJsonLayer;\n}(_baseLayer[\"default\"]);\nexports[\"default\"] = GeoJsonLayer;","map":{"version":3,"sources":["../../../src/layers/geojson-layer/geojson-layer.js"],"names":["SUPPORTED_ANALYZER_TYPES","DATA_TYPES","GEOMETRY","GEOMETRY_FROM_STRING","PAIR_GEOMETRY_FROM_STRING","geojsonVisConfigs","opacity","strokeOpacity","LAYER_VIS_CONFIGS","property","thickness","defaultValue","strokeColor","colorRange","strokeColorRange","radius","sizeRange","radiusRange","heightRange","elevationScale","enableElevationZoomFactor","stroked","filled","enable3d","wireframe","geoJsonRequiredColumns","featureAccessor","geojson","dc","valueAt","d","index","fieldIdx","defaultElevation","defaultLineWidth","defaultRadius","GeoJsonLayer","Layer","props","dataToFeature","registerVisConfig","getPositionAccessor","config","columns","dataContainer","GeojsonLayerIcon","visualChannels","color","accessor","condition","visConfig","nullValue","getAttributeValue","properties","fillColor","field","scale","domain","range","key","channelScaleType","CHANNEL_SCALES","lineColor","size","lineWidth","height","elevation","label","fields","geojsonColumns","filter","f","type","analyzerType","map","name","defaultColumns","GEOJSON_FIELDS","foundColumns","findDefaultColumnField","length","replace","isVisible","heightField","heightDomain","heightScale","radiusField","radiusDomain","radiusScale","strokeColorField","strokeColorDomain","strokeColorScale","object","row","filteredIndex","getPosition","i","datasets","oldLayerData","gpuFilter","dataId","data","updateData","customFilterValueAccessor","fieldIndex","indexAccessor","dataAccessor","accessors","getAttributeAccessors","getFilterValue","filterValueAccessor","getFeature","bounds","fixedRadius","Boolean","find","featureTypes","updateMeta","updateLayerMeta","meta","polygon","updateLayerVisConfig","colorMaker","next","value","point","opts","objectHovered","mapState","interactionConfig","getRadiusScaleByZoom","zoomFactor","getZoomFactor","eleZoomFactor","getElevationZoomFactor","layerProps","lineWidthScale","pointRadiusScale","lineMiterLimit","updateTriggers","getVisualChannelUpdateTriggers","filterValueUpdateTriggers","defaultLayerProps","getDefaultDeckLayerProps","opaOverwrite","pickable","tooltip","enabled","hoveredObject","hasHoveredObject","DeckGLGeoJsonLayer","highlightColor","HIGHLIGH_COLOR_3D","autoHighlight","extruded","wrapLongitude","rounded","_subLayerProps","line","points","lineOpacity","getDefaultHoverLayerProps","getLineWidth","getRadius","getElevation","getLineColor","getFillColor"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport uniq from 'lodash.uniq';\nimport {DATA_TYPES} from 'type-analyzer';\n\nimport Layer, {colorMaker} from '../base-layer';\nimport {GeoJsonLayer as DeckGLGeoJsonLayer} from '@deck.gl/layers';\nimport {getGeojsonDataMaps, getGeojsonBounds, getGeojsonFeatureTypes} from './geojson-utils';\nimport GeojsonLayerIcon from './geojson-layer-icon';\nimport {GEOJSON_FIELDS, HIGHLIGH_COLOR_3D, CHANNEL_SCALES} from 'constants/default-settings';\nimport {LAYER_VIS_CONFIGS} from 'layers/layer-factory';\n\nconst SUPPORTED_ANALYZER_TYPES = {\n  [DATA_TYPES.GEOMETRY]: true,\n  [DATA_TYPES.GEOMETRY_FROM_STRING]: true,\n  [DATA_TYPES.PAIR_GEOMETRY_FROM_STRING]: true\n};\n\nexport const geojsonVisConfigs = {\n  opacity: 'opacity',\n  strokeOpacity: {\n    ...LAYER_VIS_CONFIGS.opacity,\n    property: 'strokeOpacity'\n  },\n  thickness: {\n    ...LAYER_VIS_CONFIGS.thickness,\n    defaultValue: 0.5\n  },\n  strokeColor: 'strokeColor',\n  colorRange: 'colorRange',\n  strokeColorRange: 'strokeColorRange',\n  radius: 'radius',\n\n  sizeRange: 'strokeWidthRange',\n  radiusRange: 'radiusRange',\n  heightRange: 'elevationRange',\n  elevationScale: 'elevationScale',\n  enableElevationZoomFactor: 'enableElevationZoomFactor',\n  stroked: 'stroked',\n  filled: 'filled',\n  enable3d: 'enable3d',\n  wireframe: 'wireframe'\n};\n\nexport const geoJsonRequiredColumns = ['geojson'];\nexport const featureAccessor = ({geojson}) => dc => d => dc.valueAt(d.index, geojson.fieldIdx);\n\n// access feature properties from geojson sub layer\nexport const defaultElevation = 500;\nexport const defaultLineWidth = 1;\nexport const defaultRadius = 1;\n\nexport default class GeoJsonLayer extends Layer {\n  constructor(props) {\n    super(props);\n\n    this.dataToFeature = [];\n    this.registerVisConfig(geojsonVisConfigs);\n    this.getPositionAccessor = dataContainer => featureAccessor(this.config.columns)(dataContainer);\n  }\n\n  get type() {\n    return 'geojson';\n  }\n\n  get name() {\n    return 'Polygon';\n  }\n\n  get layerIcon() {\n    return GeojsonLayerIcon;\n  }\n\n  get requiredLayerColumns() {\n    return geoJsonRequiredColumns;\n  }\n\n  get visualChannels() {\n    const visualChannels = super.visualChannels;\n    return {\n      color: {\n        ...visualChannels.color,\n        accessor: 'getFillColor',\n        condition: config => config.visConfig.filled,\n        nullValue: visualChannels.color.nullValue,\n        getAttributeValue: config => d => d.properties.fillColor || config.color,\n        // used this to get updateTriggers\n        defaultValue: config => config.color\n      },\n      strokeColor: {\n        property: 'strokeColor',\n        field: 'strokeColorField',\n        scale: 'strokeColorScale',\n        domain: 'strokeColorDomain',\n        range: 'strokeColorRange',\n        key: 'strokeColor',\n        channelScaleType: CHANNEL_SCALES.color,\n        accessor: 'getLineColor',\n        condition: config => config.visConfig.stroked,\n        nullValue: visualChannels.color.nullValue,\n        getAttributeValue: config => d =>\n          d.properties.lineColor || config.visConfig.strokeColor || config.color,\n        // used this to get updateTriggers\n        defaultValue: config => config.visConfig.strokeColor || config.color\n      },\n      size: {\n        ...visualChannels.size,\n        property: 'stroke',\n        accessor: 'getLineWidth',\n        condition: config => config.visConfig.stroked,\n        nullValue: 0,\n        getAttributeValue: () => d => d.properties.lineWidth || defaultLineWidth\n      },\n      height: {\n        property: 'height',\n        field: 'heightField',\n        scale: 'heightScale',\n        domain: 'heightDomain',\n        range: 'heightRange',\n        key: 'height',\n        channelScaleType: CHANNEL_SCALES.size,\n        accessor: 'getElevation',\n        condition: config => config.visConfig.enable3d,\n        nullValue: 0,\n        getAttributeValue: () => d => d.properties.elevation || defaultElevation\n      },\n      radius: {\n        property: 'radius',\n        field: 'radiusField',\n        scale: 'radiusScale',\n        domain: 'radiusDomain',\n        range: 'radiusRange',\n        key: 'radius',\n        channelScaleType: CHANNEL_SCALES.radius,\n        accessor: 'getRadius',\n        nullValue: 0,\n        getAttributeValue: () => d => d.properties.radius || defaultRadius\n      }\n    };\n  }\n\n  static findDefaultLayerProps({label, fields = []}) {\n    const geojsonColumns = fields\n      .filter(f => f.type === 'geojson' && SUPPORTED_ANALYZER_TYPES[f.analyzerType])\n      .map(f => f.name);\n\n    const defaultColumns = {\n      geojson: uniq([...GEOJSON_FIELDS.geojson, ...geojsonColumns])\n    };\n\n    const foundColumns = this.findDefaultColumnField(defaultColumns, fields);\n    if (!foundColumns || !foundColumns.length) {\n      return {props: []};\n    }\n\n    return {\n      props: foundColumns.map(columns => ({\n        label: (typeof label === 'string' && label.replace(/\\.[^/.]+$/, '')) || this.type,\n        columns,\n        isVisible: true\n      }))\n    };\n  }\n\n  getDefaultLayerConfig(props = {}) {\n    return {\n      ...super.getDefaultLayerConfig(props),\n\n      // add height visual channel\n      heightField: null,\n      heightDomain: [0, 1],\n      heightScale: 'linear',\n\n      // add radius visual channel\n      radiusField: null,\n      radiusDomain: [0, 1],\n      radiusScale: 'linear',\n\n      // add stroke color visual channel\n      strokeColorField: null,\n      strokeColorDomain: [0, 1],\n      strokeColorScale: 'quantile'\n    };\n  }\n\n  getHoverData(object, dataContainer) {\n    // index of dataContainer is saved to feature.properties\n    return dataContainer.row(object.properties.index);\n  }\n\n  calculateDataAttribute({dataContainer, filteredIndex}, getPosition) {\n    return filteredIndex.map(i => this.dataToFeature[i]).filter(d => d);\n  }\n\n  formatLayerData(datasets, oldLayerData) {\n    const {gpuFilter, dataContainer} = datasets[this.config.dataId];\n    const {data} = this.updateData(datasets, oldLayerData);\n\n    const customFilterValueAccessor = (dc, d, fieldIndex) => {\n      return dc.valueAt(d.properties.index, fieldIndex);\n    };\n    const indexAccessor = f => f.properties.index;\n\n    const dataAccessor = dc => d => ({index: d.properties.index});\n    const accessors = this.getAttributeAccessors({dataAccessor, dataContainer});\n\n    return {\n      data,\n      getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(\n        indexAccessor,\n        customFilterValueAccessor\n      ),\n      ...accessors\n    };\n  }\n\n  updateLayerMeta(dataContainer) {\n    const getFeature = this.getPositionAccessor(dataContainer);\n    this.dataToFeature = getGeojsonDataMaps(dataContainer, getFeature);\n\n    // get bounds from features\n    const bounds = getGeojsonBounds(this.dataToFeature);\n    // if any of the feature has properties.radius set to be true\n    const fixedRadius = Boolean(\n      this.dataToFeature.find(d => d && d.properties && d.properties.radius)\n    );\n\n    // keep a record of what type of geometry the collection has\n    const featureTypes = getGeojsonFeatureTypes(this.dataToFeature);\n\n    this.updateMeta({bounds, fixedRadius, featureTypes});\n  }\n\n  setInitialLayerConfig({dataContainer}) {\n    this.updateLayerMeta(dataContainer);\n\n    const {featureTypes} = this.meta;\n    // default settings is stroke: true, filled: false\n    if (featureTypes && featureTypes.polygon) {\n      // set both fill and stroke to true\n      return this.updateLayerVisConfig({\n        filled: true,\n        stroked: true,\n        strokeColor: colorMaker.next().value\n      });\n    } else if (featureTypes && featureTypes.point) {\n      // set fill to true if detect point\n      return this.updateLayerVisConfig({filled: true, stroked: false});\n    }\n\n    return this;\n  }\n\n  renderLayer(opts) {\n    const {data, gpuFilter, objectHovered, mapState, interactionConfig} = opts;\n\n    const {fixedRadius, featureTypes} = this.meta;\n    const radiusScale = this.getRadiusScaleByZoom(mapState, fixedRadius);\n    const zoomFactor = this.getZoomFactor(mapState);\n    const eleZoomFactor = this.getElevationZoomFactor(mapState);\n\n    const {visConfig} = this.config;\n\n    const layerProps = {\n      lineWidthScale: visConfig.thickness * zoomFactor * 8,\n      elevationScale: visConfig.elevationScale * eleZoomFactor,\n      pointRadiusScale: radiusScale,\n      lineMiterLimit: 4\n    };\n\n    const updateTriggers = {\n      ...this.getVisualChannelUpdateTriggers(),\n      getFilterValue: gpuFilter.filterValueUpdateTriggers\n    };\n\n    const defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n    const opaOverwrite = {\n      opacity: visConfig.strokeOpacity\n    };\n\n    const pickable = interactionConfig.tooltip.enabled;\n    const hoveredObject = this.hasHoveredObject(objectHovered);\n\n    return [\n      new DeckGLGeoJsonLayer({\n        ...defaultLayerProps,\n        ...layerProps,\n        ...data,\n        pickable,\n        highlightColor: HIGHLIGH_COLOR_3D,\n        autoHighlight: visConfig.enable3d && pickable,\n        stroked: visConfig.stroked,\n        filled: visConfig.filled,\n        extruded: visConfig.enable3d,\n        wireframe: visConfig.wireframe,\n        wrapLongitude: false,\n        lineMiterLimit: 2,\n        rounded: true,\n        updateTriggers,\n        _subLayerProps: {\n          ...(featureTypes.polygon ? {'polygons-stroke': opaOverwrite} : {}),\n          ...(featureTypes.line ? {'line-strings': opaOverwrite} : {}),\n          ...(featureTypes.point\n            ? {\n                points: {\n                  lineOpacity: visConfig.strokeOpacity\n                }\n              }\n            : {})\n        }\n      }),\n      ...(hoveredObject && !visConfig.enable3d\n        ? [\n            new DeckGLGeoJsonLayer({\n              ...this.getDefaultHoverLayerProps(),\n              ...layerProps,\n              wrapLongitude: false,\n              data: [hoveredObject],\n              getLineWidth: data.getLineWidth,\n              getRadius: data.getRadius,\n              getElevation: data.getElevation,\n              getLineColor: this.config.highlightColor,\n              getFillColor: this.config.highlightColor,\n              // always draw outline\n              stroked: true,\n              filled: false\n            })\n          ]\n        : [])\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}