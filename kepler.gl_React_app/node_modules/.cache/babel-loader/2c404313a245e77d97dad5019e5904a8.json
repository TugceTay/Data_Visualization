{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _DEFAULT_TEXTURE_PARA;\nimport { Layer, project32, picking } from '@deck.gl/core';\nimport { Model, Geometry, Texture2D } from '@luma.gl/core';\nimport createMesh from './create-mesh';\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\nvar DEFAULT_TEXTURE_PARAMETERS = (_DEFAULT_TEXTURE_PARA = {}, _defineProperty(_DEFAULT_TEXTURE_PARA, 10241, 9987), _defineProperty(_DEFAULT_TEXTURE_PARA, 10240, 9729), _defineProperty(_DEFAULT_TEXTURE_PARA, 10242, 33071), _defineProperty(_DEFAULT_TEXTURE_PARA, 10243, 33071), _DEFAULT_TEXTURE_PARA);\nvar defaultProps = {\n  image: {\n    type: 'object',\n    value: null,\n    async: true\n  },\n  bounds: {\n    type: 'array',\n    value: [1, 0, 0, 1],\n    compare: true\n  },\n  desaturate: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0\n  },\n  transparentColor: {\n    type: 'color',\n    value: [0, 0, 0, 0]\n  },\n  tintColor: {\n    type: 'color',\n    value: [255, 255, 255]\n  }\n};\nvar BitmapLayer = function (_Layer) {\n  _inherits(BitmapLayer, _Layer);\n  function BitmapLayer() {\n    _classCallCheck(this, BitmapLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(BitmapLayer).apply(this, arguments));\n  }\n  _createClass(BitmapLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return _get(_getPrototypeOf(BitmapLayer.prototype), \"getShaders\", this).call(this, {\n        vs: vs,\n        fs: fs,\n        modules: [project32, picking]\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n      var attributeManager = this.getAttributeManager();\n      attributeManager.remove(['instancePickingColors']);\n      var noAlloc = true;\n      attributeManager.add({\n        indices: {\n          size: 1,\n          isIndexed: true,\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.indices;\n          },\n          noAlloc: noAlloc\n        },\n        positions: {\n          size: 3,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.positions;\n          },\n          noAlloc: noAlloc\n        },\n        texCoords: {\n          size: 2,\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.texCoords;\n          },\n          noAlloc: noAlloc\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n        oldProps = _ref.oldProps,\n        changeFlags = _ref.changeFlags;\n      if (changeFlags.extensionsChanged) {\n        var gl = this.context.gl;\n        if (this.state.model) {\n          this.state.model[\"delete\"]();\n        }\n        this.setState({\n          model: this._getModel(gl)\n        });\n        this.getAttributeManager().invalidateAll();\n      }\n      if (props.image !== oldProps.image) {\n        this.loadTexture(props.image);\n      }\n      var attributeManager = this.getAttributeManager();\n      if (props.bounds !== oldProps.bounds) {\n        var oldMesh = this.state.mesh;\n        var mesh = this._createMesh();\n        this.state.model.setVertexCount(mesh.vertexCount);\n        for (var key in mesh) {\n          if (oldMesh && oldMesh[key] !== mesh[key]) {\n            attributeManager.invalidate(key);\n          }\n        }\n        this.setState({\n          mesh: mesh\n        });\n      }\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      _get(_getPrototypeOf(BitmapLayer.prototype), \"finalizeState\", this).call(this);\n      if (this.state.bitmapTexture) {\n        this.state.bitmapTexture[\"delete\"]();\n      }\n    }\n  }, {\n    key: \"_createMesh\",\n    value: function _createMesh() {\n      var bounds = this.props.bounds;\n      var normalizedBounds = bounds;\n      if (Number.isFinite(bounds[0])) {\n        normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];\n      }\n      return createMesh(normalizedBounds, this.context.viewport.resolution);\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      if (!gl) {\n        return null;\n      }\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 4,\n          vertexCount: 6\n        }),\n        isInstanced: false\n      }));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(opts) {\n      var uniforms = opts.uniforms;\n      var _this$state = this.state,\n        bitmapTexture = _this$state.bitmapTexture,\n        model = _this$state.model;\n      var _this$props = this.props,\n        image = _this$props.image,\n        desaturate = _this$props.desaturate,\n        transparentColor = _this$props.transparentColor,\n        tintColor = _this$props.tintColor;\n      if (bitmapTexture && image instanceof HTMLVideoElement && image.readyState > HTMLVideoElement.HAVE_METADATA) {\n        var sizeChanged = bitmapTexture.width !== image.videoWidth || bitmapTexture.height !== image.videoHeight;\n        if (sizeChanged) {\n          bitmapTexture.resize({\n            width: image.videoWidth,\n            height: image.videoHeight,\n            mipmaps: true\n          });\n          bitmapTexture.setSubImageData({\n            data: image,\n            paramters: DEFAULT_TEXTURE_PARAMETERS\n          });\n        } else {\n          bitmapTexture.setSubImageData({\n            data: image\n          });\n        }\n        bitmapTexture.generateMipmap();\n      }\n      if (bitmapTexture && model) {\n        model.setUniforms(Object.assign({}, uniforms, {\n          bitmapTexture: bitmapTexture,\n          desaturate: desaturate,\n          transparentColor: transparentColor.map(function (x) {\n            return x / 255;\n          }),\n          tintColor: tintColor.slice(0, 3).map(function (x) {\n            return x / 255;\n          })\n        })).draw();\n      }\n    }\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture(image) {\n      var gl = this.context.gl;\n      if (this.state.bitmapTexture) {\n        this.state.bitmapTexture[\"delete\"]();\n      }\n      if (image instanceof Texture2D) {\n        this.setState({\n          bitmapTexture: image\n        });\n      } else if (image instanceof HTMLVideoElement) {\n        this.setState({\n          bitmapTexture: new Texture2D(gl, {\n            width: 1,\n            height: 1,\n            parameters: DEFAULT_TEXTURE_PARAMETERS,\n            mipmaps: false\n          })\n        });\n      } else if (image) {\n        this.setState({\n          bitmapTexture: new Texture2D(gl, {\n            data: image,\n            parameters: DEFAULT_TEXTURE_PARAMETERS\n          })\n        });\n      }\n    }\n  }]);\n  return BitmapLayer;\n}(Layer);\nexport { BitmapLayer as default };\nBitmapLayer.layerName = 'BitmapLayer';\nBitmapLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/bitmap-layer/bitmap-layer.js"],"names":["Layer","project32","picking","Model","Geometry","Texture2D","createMesh","vs","fs","DEFAULT_TEXTURE_PARAMETERS","defaultProps","image","type","value","async","bounds","compare","desaturate","min","max","transparentColor","tintColor","BitmapLayer","modules","attributeManager","getAttributeManager","remove","noAlloc","add","indices","size","isIndexed","update","attribute","state","mesh","positions","fp64","use64bitPositions","texCoords","props","oldProps","changeFlags","extensionsChanged","gl","context","model","setState","_getModel","invalidateAll","loadTexture","oldMesh","_createMesh","setVertexCount","vertexCount","key","invalidate","bitmapTexture","normalizedBounds","Number","isFinite","viewport","resolution","assign","getShaders","id","geometry","drawMode","isInstanced","opts","uniforms","HTMLVideoElement","readyState","HAVE_METADATA","sizeChanged","width","videoWidth","height","videoHeight","resize","mipmaps","setSubImageData","data","paramters","generateMipmap","setUniforms","map","x","slice","draw","parameters","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global HTMLVideoElement */\nimport GL from '@luma.gl/constants';\nimport {Layer, project32, picking} from '@deck.gl/core';\nimport {Model, Geometry, Texture2D} from '@luma.gl/core';\nimport createMesh from './create-mesh';\n\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\n\nconst defaultProps = {\n  image: {type: 'object', value: null, async: true},\n  bounds: {type: 'array', value: [1, 0, 0, 1], compare: true},\n\n  desaturate: {type: 'number', min: 0, max: 1, value: 0},\n  // More context: because of the blending mode we're using for ground imagery,\n  // alpha is not effective when blending the bitmap layers with the base map.\n  // Instead we need to manually dim/blend rgb values with a background color.\n  transparentColor: {type: 'color', value: [0, 0, 0, 0]},\n  tintColor: {type: 'color', value: [255, 255, 255]}\n};\n\n/*\n * @class\n * @param {object} props\n * @param {number} props.transparentColor - color to interpret transparency to\n * @param {number} props.tintColor - color bias\n */\nexport default class BitmapLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n\n    attributeManager.remove(['instancePickingColors']);\n    const noAlloc = true;\n\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: attribute => (attribute.value = this.state.mesh.indices),\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        update: attribute => (attribute.value = this.state.mesh.positions),\n        noAlloc\n      },\n      texCoords: {\n        size: 2,\n        update: attribute => (attribute.value = this.state.mesh.texCoords),\n        noAlloc\n      }\n    });\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    // setup model first\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      this.getAttributeManager().invalidateAll();\n    }\n\n    if (props.image !== oldProps.image) {\n      this.loadTexture(props.image);\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (props.bounds !== oldProps.bounds) {\n      const oldMesh = this.state.mesh;\n      const mesh = this._createMesh();\n      this.state.model.setVertexCount(mesh.vertexCount);\n      for (const key in mesh) {\n        if (oldMesh && oldMesh[key] !== mesh[key]) {\n          attributeManager.invalidate(key);\n        }\n      }\n      this.setState({mesh});\n    }\n  }\n\n  finalizeState() {\n    super.finalizeState();\n\n    if (this.state.bitmapTexture) {\n      this.state.bitmapTexture.delete();\n    }\n  }\n\n  _createMesh() {\n    const {bounds} = this.props;\n\n    let normalizedBounds = bounds;\n    // bounds as [minX, minY, maxX, maxY]\n    if (Number.isFinite(bounds[0])) {\n      /*\n        (minX0, maxY3) ---- (maxX2, maxY3)\n               |                  |\n               |                  |\n               |                  |\n        (minX0, minY1) ---- (maxX2, minY1)\n     */\n      normalizedBounds = [\n        [bounds[0], bounds[1]],\n        [bounds[0], bounds[3]],\n        [bounds[2], bounds[3]],\n        [bounds[2], bounds[1]]\n      ];\n    }\n\n    return createMesh(normalizedBounds, this.context.viewport.resolution);\n  }\n\n  _getModel(gl) {\n    if (!gl) {\n      return null;\n    }\n\n    /*\n      0,0 --- 1,0\n       |       |\n      0,1 --- 1,1\n    */\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLES,\n          vertexCount: 6\n        }),\n        isInstanced: false\n      })\n    );\n  }\n\n  draw(opts) {\n    const {uniforms} = opts;\n    const {bitmapTexture, model} = this.state;\n    const {image, desaturate, transparentColor, tintColor} = this.props;\n\n    // Update video frame\n    if (\n      bitmapTexture &&\n      image instanceof HTMLVideoElement &&\n      image.readyState > HTMLVideoElement.HAVE_METADATA\n    ) {\n      const sizeChanged =\n        bitmapTexture.width !== image.videoWidth || bitmapTexture.height !== image.videoHeight;\n      if (sizeChanged) {\n        // note clears image and mipmaps when resizing\n        bitmapTexture.resize({width: image.videoWidth, height: image.videoHeight, mipmaps: true});\n        bitmapTexture.setSubImageData({\n          data: image,\n          paramters: DEFAULT_TEXTURE_PARAMETERS\n        });\n      } else {\n        bitmapTexture.setSubImageData({\n          data: image\n        });\n      }\n\n      bitmapTexture.generateMipmap();\n    }\n\n    // // TODO fix zFighting\n    // Render the image\n    if (bitmapTexture && model) {\n      model\n        .setUniforms(\n          Object.assign({}, uniforms, {\n            bitmapTexture,\n            desaturate,\n            transparentColor: transparentColor.map(x => x / 255),\n            tintColor: tintColor.slice(0, 3).map(x => x / 255)\n          })\n        )\n        .draw();\n    }\n  }\n\n  loadTexture(image) {\n    const {gl} = this.context;\n\n    if (this.state.bitmapTexture) {\n      this.state.bitmapTexture.delete();\n    }\n\n    if (image instanceof Texture2D) {\n      this.setState({bitmapTexture: image});\n    } else if (image instanceof HTMLVideoElement) {\n      // Initialize an empty texture while we wait for the video to load\n      this.setState({\n        bitmapTexture: new Texture2D(gl, {\n          width: 1,\n          height: 1,\n          parameters: DEFAULT_TEXTURE_PARAMETERS,\n          mipmaps: false\n        })\n      });\n    } else if (image) {\n      // Browser object: Image, ImageData, HTMLCanvasElement, ImageBitmap\n      this.setState({\n        bitmapTexture: new Texture2D(gl, {\n          data: image,\n          parameters: DEFAULT_TEXTURE_PARAMETERS\n        })\n      });\n    }\n  }\n}\n\nBitmapLayer.layerName = 'BitmapLayer';\nBitmapLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}