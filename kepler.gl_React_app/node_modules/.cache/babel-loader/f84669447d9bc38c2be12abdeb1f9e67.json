{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Effect from '../lib/effect';\nimport ScreenPass from '../passes/screen-pass';\nimport { normalizeShaderModule } from '@luma.gl/core';\nvar PostProcessEffect = function (_Effect) {\n  _inherits(PostProcessEffect, _Effect);\n  function PostProcessEffect(module) {\n    var _this;\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, PostProcessEffect);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PostProcessEffect).call(this, props));\n    _this.id = \"\".concat(module.name, \"-pass\");\n    normalizeShaderModule(module);\n    _this.module = module;\n    return _this;\n  }\n  _createClass(PostProcessEffect, [{\n    key: \"postRender\",\n    value: function postRender(gl, params) {\n      if (!this.passes) {\n        this.passes = createPasses(gl, this.module, this.id, this.props);\n      }\n      var target = params.target;\n      var inputBuffer = params.inputBuffer;\n      var outputBuffer = params.swapBuffer;\n      for (var index = 0; index < this.passes.length; index++) {\n        if (target && index === this.passes.length - 1) {\n          outputBuffer = target;\n        }\n        this.passes[index].render({\n          inputBuffer: inputBuffer,\n          outputBuffer: outputBuffer\n        });\n        var switchBuffer = outputBuffer;\n        outputBuffer = inputBuffer;\n        inputBuffer = switchBuffer;\n      }\n      return inputBuffer;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      if (this.passes) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n          for (var _iterator = this.passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var pass = _step.value;\n            pass[\"delete\"]();\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n        this.passes = null;\n      }\n    }\n  }]);\n  return PostProcessEffect;\n}(Effect);\nexport { PostProcessEffect as default };\nfunction createPasses(gl, module, id, moduleSettings) {\n  if (module.filter || module.sampler) {\n    var fs = getFragmentShaderForRenderPass(module);\n    var pass = new ScreenPass(gl, {\n      id: id,\n      module: module,\n      fs: fs,\n      moduleSettings: moduleSettings\n    });\n    return [pass];\n  }\n  var passes = module.passes || [];\n  return passes.map(function (pass, index) {\n    var fs = getFragmentShaderForRenderPass(module, pass);\n    var idn = \"\".concat(id, \"-\").concat(index);\n    return new ScreenPass(gl, {\n      id: idn,\n      module: module,\n      fs: fs,\n      moduleSettings: moduleSettings\n    });\n  });\n}\nvar FILTER_FS_TEMPLATE = function FILTER_FS_TEMPLATE(func) {\n  return \"uniform sampler2D texture;\\nuniform vec2 texSize;\\n\\nvarying vec2 position;\\nvarying vec2 coordinate;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec2 texCoord = coordinate;\\n\\n  gl_FragColor = texture2D(texture, texCoord);\\n  gl_FragColor = \".concat(func, \"(gl_FragColor, texSize, texCoord);\\n}\\n\");\n};\nvar SAMPLER_FS_TEMPLATE = function SAMPLER_FS_TEMPLATE(func) {\n  return \"uniform sampler2D texture;\\nuniform vec2 texSize;\\n\\nvarying vec2 position;\\nvarying vec2 coordinate;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec2 texCoord = coordinate;\\n\\n  gl_FragColor = \".concat(func, \"(texture, texSize, texCoord);\\n}\\n\");\n};\nfunction getFragmentShaderForRenderPass(module) {\n  var pass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : module;\n  if (pass.filter) {\n    var func = typeof pass.filter === 'string' ? pass.filter : \"\".concat(module.name, \"_filterColor\");\n    return FILTER_FS_TEMPLATE(func);\n  }\n  if (pass.sampler) {\n    var _func = typeof pass.sampler === 'string' ? pass.sampler : \"\".concat(module.name, \"_sampleColor\");\n    return SAMPLER_FS_TEMPLATE(_func);\n  }\n  return null;\n}","map":{"version":3,"sources":["../../../src/effects/post-process-effect.js"],"names":["Effect","ScreenPass","normalizeShaderModule","PostProcessEffect","module","props","id","name","gl","params","passes","createPasses","target","inputBuffer","outputBuffer","swapBuffer","index","length","render","switchBuffer","pass","moduleSettings","filter","sampler","fs","getFragmentShaderForRenderPass","map","idn","FILTER_FS_TEMPLATE","func","SAMPLER_FS_TEMPLATE"],"mappings":"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","sourcesContent":["import Effect from '../lib/effect';\nimport ScreenPass from '../passes/screen-pass';\nimport {normalizeShaderModule} from '@luma.gl/core';\n\nexport default class PostProcessEffect extends Effect {\n  constructor(module, props = {}) {\n    super(props);\n    this.id = `${module.name}-pass`;\n    normalizeShaderModule(module);\n    this.module = module;\n  }\n\n  postRender(gl, params) {\n    if (!this.passes) {\n      this.passes = createPasses(gl, this.module, this.id, this.props);\n    }\n\n    const {target} = params;\n    let inputBuffer = params.inputBuffer;\n    let outputBuffer = params.swapBuffer;\n\n    for (let index = 0; index < this.passes.length; index++) {\n      if (target && index === this.passes.length - 1) {\n        outputBuffer = target;\n      }\n      this.passes[index].render({inputBuffer, outputBuffer});\n      const switchBuffer = outputBuffer;\n      outputBuffer = inputBuffer;\n      inputBuffer = switchBuffer;\n    }\n    return inputBuffer;\n  }\n\n  cleanup() {\n    if (this.passes) {\n      for (const pass of this.passes) {\n        pass.delete();\n      }\n      this.passes = null;\n    }\n  }\n}\n\nfunction createPasses(gl, module, id, moduleSettings) {\n  if (module.filter || module.sampler) {\n    const fs = getFragmentShaderForRenderPass(module);\n    const pass = new ScreenPass(gl, {\n      id,\n      module,\n      fs,\n      moduleSettings\n    });\n    return [pass];\n  }\n\n  const passes = module.passes || [];\n  return passes.map((pass, index) => {\n    const fs = getFragmentShaderForRenderPass(module, pass);\n    const idn = `${id}-${index}`;\n\n    return new ScreenPass(gl, {\n      id: idn,\n      module,\n      fs,\n      moduleSettings\n    });\n  });\n}\n\nconst FILTER_FS_TEMPLATE = func => `\\\nuniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ${func}(gl_FragColor, texSize, texCoord);\n}\n`;\n\nconst SAMPLER_FS_TEMPLATE = func => `\\\nuniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ${func}(texture, texSize, texCoord);\n}\n`;\n\nfunction getFragmentShaderForRenderPass(module, pass = module) {\n  if (pass.filter) {\n    const func = typeof pass.filter === 'string' ? pass.filter : `${module.name}_filterColor`;\n    return FILTER_FS_TEMPLATE(func);\n  }\n\n  if (pass.sampler) {\n    const func = typeof pass.sampler === 'string' ? pass.sampler : `${module.name}_sampleColor`;\n    return SAMPLER_FS_TEMPLATE(func);\n  }\n\n  // console.error(`${module.name} no fragment shader generated`);\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}