{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getValueFunc = getValueFunc;\nexports.getScaleFunctor = getScaleFunctor;\nexports.getGetValue = getGetValue;\nexports.getDimensionSortedBins = getDimensionSortedBins;\nexports.getDimensionValueDomain = getDimensionValueDomain;\nexports.getDimensionScale = getDimensionScale;\nexports.getAggregatedData = getAggregatedData;\nexports[\"default\"] = exports.defaultDimensions = exports.defaultElevationDimension = exports.defaultColorDimension = exports.defaultAggregation = exports.DECK_AGGREGATION_MAP = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _aggregationLayers = require(\"@deck.gl/aggregation-layers\");\nvar _window = require(\"global/window\");\nvar _aggregateUtils = require(\"../../utils/aggregate-utils\");\nvar _defaultSettings = require(\"../../constants/default-settings\");\nvar _DECK_AGGREGATION_MAP;\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar DECK_AGGREGATION_MAP = (_DECK_AGGREGATION_MAP = {}, (0, _defineProperty2[\"default\"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.SUM, _defaultSettings.AGGREGATION_TYPES.sum), (0, _defineProperty2[\"default\"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MEAN, _defaultSettings.AGGREGATION_TYPES.average), (0, _defineProperty2[\"default\"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MIN, _defaultSettings.AGGREGATION_TYPES.minimum), (0, _defineProperty2[\"default\"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MAX, _defaultSettings.AGGREGATION_TYPES.maximum), _DECK_AGGREGATION_MAP);\nexports.DECK_AGGREGATION_MAP = DECK_AGGREGATION_MAP;\nfunction getValueFunc(aggregation, accessor) {\n  if (!aggregation || !_aggregationLayers.AGGREGATION_OPERATION[aggregation.toUpperCase()]) {\n    _window.console.warn(\"Aggregation \".concat(aggregation, \" is not supported\"));\n  }\n  var op = _aggregationLayers.AGGREGATION_OPERATION[aggregation.toUpperCase()] || _aggregationLayers.AGGREGATION_OPERATION.SUM;\n  var keplerOp = DECK_AGGREGATION_MAP[op];\n  return function (pts) {\n    return (0, _aggregateUtils.aggregate)(pts.map(accessor), keplerOp);\n  };\n}\nfunction getScaleFunctor(scaleType) {\n  if (!scaleType || !_defaultSettings.SCALE_FUNC[scaleType]) {\n    _window.console.warn(\"Scale \".concat(scaleType, \" is not supported\"));\n  }\n  return _defaultSettings.SCALE_FUNC[scaleType] || _defaultSettings.SCALE_FUNC.quantize;\n}\nfunction nop() {}\nfunction getGetValue(step, props, dimensionUpdater) {\n  var key = dimensionUpdater.key;\n  var _step$triggers = step.triggers,\n    value = _step$triggers.value,\n    weight = _step$triggers.weight,\n    aggregation = _step$triggers.aggregation;\n  var getValue = props[value.prop];\n  if (getValue === null) {\n    // If `getValue` is not provided from props, build it with aggregation and weight.\n    getValue = getValueFunc(props[aggregation.prop], props[weight.prop]);\n  }\n  if (getValue) {\n    this._setDimensionState(key, {\n      getValue: getValue\n    });\n  }\n}\nfunction getDimensionSortedBins(step, props, dimensionUpdater) {\n  var key = dimensionUpdater.key;\n  var getValue = this.state.dimensions[key].getValue;\n  var sortedBins = new _aggregationLayers._BinSorter(this.state.layerData.data || [], {\n    getValue: getValue,\n    filterData: props._filterData\n  });\n  this._setDimensionState(key, {\n    sortedBins: sortedBins\n  });\n}\nfunction getDimensionValueDomain(step, props, dimensionUpdater) {\n  var key = dimensionUpdater.key;\n  var _step$triggers2 = step.triggers,\n    lowerPercentile = _step$triggers2.lowerPercentile,\n    upperPercentile = _step$triggers2.upperPercentile,\n    scaleType = _step$triggers2.scaleType;\n  if (!this.state.dimensions[key].sortedBins) {\n    // the previous step should set sortedBins, if not, something went wrong\n    return;\n  } // for log and sqrt scale, returns linear domain by default\n  // TODO: support other scale function domain in bin sorter\n\n  var valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n  this._setDimensionState(key, {\n    valueDomain: valueDomain\n  });\n}\nfunction getDimensionScale(step, props, dimensionUpdater) {\n  var key = dimensionUpdater.key;\n  var _step$triggers3 = step.triggers,\n    domain = _step$triggers3.domain,\n    range = _step$triggers3.range,\n    scaleType = _step$triggers3.scaleType;\n  var onSet = step.onSet;\n  if (!this.state.dimensions[key].valueDomain) {\n    // the previous step should set valueDomain, if not, something went wrong\n    return;\n  }\n  var dimensionRange = props[range.prop];\n  var dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n  var scaleFunctor = getScaleFunctor(scaleType && props[scaleType.prop])();\n  var scaleFunc = scaleFunctor.domain(dimensionDomain).range(dimensionRange);\n  if ((0, _typeof2[\"default\"])(onSet) === 'object' && typeof props[onSet.props] === 'function') {\n    props[onSet.props](scaleFunc.domain());\n  }\n  this._setDimensionState(key, {\n    scaleFunc: scaleFunc\n  });\n}\nfunction normalizeResult() {\n  var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  // support previous hexagonAggregator API\n  if (result.hexagons) {\n    return Object.assign({\n      data: result.hexagons\n    }, result);\n  } else if (result.layerData) {\n    return Object.assign({\n      data: result.layerData\n    }, result);\n  }\n  return result;\n}\nfunction getAggregatedData(step, props, aggregation, aggregationParams) {\n  var aggr = step.triggers.aggregator;\n  var aggregator = props[aggr.prop]; // result should contain a data array and other props\n  // result = {data: [], ...other props}\n\n  var result = aggregator(props, aggregationParams);\n  this.setState({\n    layerData: normalizeResult(result)\n  });\n}\nvar defaultAggregation = {\n  key: 'position',\n  updateSteps: [{\n    key: 'aggregate',\n    triggers: {\n      cellSize: {\n        prop: 'cellSize'\n      },\n      position: {\n        prop: 'getPosition',\n        updateTrigger: 'getPosition'\n      },\n      aggregator: {\n        prop: 'gridAggregator'\n      }\n    },\n    updater: getAggregatedData\n  }]\n};\nexports.defaultAggregation = defaultAggregation;\nfunction getSubLayerAccessor(dimensionState, dimension, layerProps) {\n  return function (cell) {\n    var sortedBins = dimensionState.sortedBins,\n      scaleFunc = dimensionState.scaleFunc;\n    var bin = sortedBins.binMap[cell.index];\n    if (bin && bin.counts === 0) {\n      // no points left in bin after filtering\n      return dimension.nullValue;\n    }\n    var cv = bin && bin.value;\n    var domain = scaleFunc.domain();\n    var isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1]; // if cell value is outside domain, set alpha to 0\n\n    return isValueInDomain ? scaleFunc(cv) : dimension.nullValue;\n  };\n}\nvar defaultColorDimension = {\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  getPickingInfo: function getPickingInfo(dimensionState, cell) {\n    var sortedBins = dimensionState.sortedBins;\n    var colorValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n    return {\n      colorValue: colorValue\n    };\n  },\n  nullValue: [0, 0, 0, 0],\n  updateSteps: [{\n    key: 'getValue',\n    triggers: {\n      value: {\n        prop: 'getColorValue',\n        updateTrigger: 'getColorValue'\n      },\n      weight: {\n        prop: 'getColorWeight',\n        updateTrigger: 'getColorWeight'\n      },\n      aggregation: {\n        prop: 'colorAggregation'\n      }\n    },\n    updater: getGetValue\n  }, {\n    key: 'getBins',\n    triggers: {\n      _filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    },\n    updater: getDimensionSortedBins\n  }, {\n    key: 'getDomain',\n    triggers: {\n      lowerPercentile: {\n        prop: 'lowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'upperPercentile'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    },\n    updater: getDimensionValueDomain\n  }, {\n    key: 'getScaleFunc',\n    triggers: {\n      domain: {\n        prop: 'colorDomain'\n      },\n      range: {\n        prop: 'colorRange'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    },\n    onSet: {\n      props: 'onSetColorDomain'\n    },\n    updater: getDimensionScale\n  }],\n  getSubLayerAccessor: getSubLayerAccessor\n};\nexports.defaultColorDimension = defaultColorDimension;\nvar defaultElevationDimension = {\n  key: 'elevation',\n  accessor: 'getElevation',\n  getPickingInfo: function getPickingInfo(dimensionState, cell) {\n    var sortedBins = dimensionState.sortedBins;\n    var elevationValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n    return {\n      elevationValue: elevationValue\n    };\n  },\n  nullValue: -1,\n  updateSteps: [{\n    key: 'getValue',\n    triggers: {\n      value: {\n        prop: 'getElevationValue',\n        updateTrigger: 'getElevationValue'\n      },\n      weight: {\n        prop: 'getElevationWeight',\n        updateTrigger: 'getElevationWeight'\n      },\n      aggregation: {\n        prop: 'elevationAggregation'\n      }\n    },\n    updater: getGetValue\n  }, {\n    key: 'getBins',\n    triggers: {\n      _filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    },\n    updater: getDimensionSortedBins\n  }, {\n    key: 'getDomain',\n    triggers: {\n      lowerPercentile: {\n        prop: 'elevationLowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'elevationUpperPercentile'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    },\n    updater: getDimensionValueDomain\n  }, {\n    key: 'getScaleFunc',\n    triggers: {\n      domain: {\n        prop: 'elevationDomain'\n      },\n      range: {\n        prop: 'elevationRange'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    },\n    onSet: {\n      props: 'onSetElevationDomain'\n    },\n    updater: getDimensionScale\n  }],\n  getSubLayerAccessor: getSubLayerAccessor\n};\nexports.defaultElevationDimension = defaultElevationDimension;\nvar _defaultDimensions = [defaultColorDimension, defaultElevationDimension];\nexports.defaultDimensions = _defaultDimensions;\nvar CPUAggregator = /*#__PURE__*/function () {\n  function CPUAggregator() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck2[\"default\"])(this, CPUAggregator);\n    this.state = _objectSpread({\n      layerData: {},\n      dimensions: {// color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    }, opts.initialState);\n    this.dimensionUpdaters = {};\n    this.aggregationUpdater = {};\n    this._addDimension(opts.dimensions || _defaultDimensions);\n    this._addAggregation(opts.aggregation || defaultAggregation);\n  }\n  (0, _createClass2[\"default\"])(CPUAggregator, [{\n    key: \"updateAllDimensions\",\n    value: function updateAllDimensions(props) {\n      var dimensionChanges = []; // update all dimensions\n\n      for (var dim in this.dimensionUpdaters) {\n        var updaters = this._accumulateUpdaters(0, props, this.dimensionUpdaters[dim]);\n        dimensionChanges = dimensionChanges.concat(updaters);\n      }\n      dimensionChanges.forEach(function (f) {\n        return typeof f === 'function' && f();\n      });\n    }\n  }, {\n    key: \"updateAggregation\",\n    value: function updateAggregation(props, aggregationParams) {\n      var updaters = this._accumulateUpdaters(0, props, this.aggregationUpdater);\n      updaters.forEach(function (f) {\n        return typeof f === 'function' && f(aggregationParams);\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts, aggregationParams) {\n      var oldProps = opts.oldProps,\n        props = opts.props,\n        changeFlags = opts.changeFlags;\n      var dimensionChanges = [];\n      if (changeFlags.dataChanged) {\n        // if data changed update everything\n        this.updateAggregation(props, aggregationParams);\n        this.updateAllDimensions(props);\n        return this.state;\n      }\n      var aggregationChanges = this._getAggregationChanges(oldProps, props, changeFlags);\n      if (aggregationChanges && aggregationChanges.length) {\n        // get aggregatedData\n        aggregationChanges.forEach(function (f) {\n          return typeof f === 'function' && f(aggregationParams);\n        });\n        this.updateAllDimensions(props);\n      } else {\n        // only update dimensions\n        dimensionChanges = this._getDimensionChanges(oldProps, props, changeFlags) || [];\n        dimensionChanges.forEach(function (f) {\n          return typeof f === 'function' && f();\n        });\n      }\n      return this.state;\n    } // Update private state\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      this.state = Object.assign({}, this.state, updateObject);\n    } // Update private state.dimensions\n  }, {\n    key: \"_setDimensionState\",\n    value: function _setDimensionState(key, updateObject) {\n      this.setState({\n        dimensions: Object.assign({}, this.state.dimensions, (0, _defineProperty2[\"default\"])({}, key, Object.assign({}, this.state.dimensions[key], updateObject)))\n      });\n    }\n  }, {\n    key: \"_addAggregation\",\n    value: function _addAggregation(aggregation) {\n      this.aggregationUpdater = aggregation;\n    }\n  }, {\n    key: \"_addDimension\",\n    value: function _addDimension() {\n      var _this = this;\n      var dimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      dimensions.forEach(function (dimension) {\n        var key = dimension.key;\n        _this.dimensionUpdaters[key] = dimension;\n      });\n    }\n  }, {\n    key: \"_needUpdateStep\",\n    value: function _needUpdateStep(dimensionStep, oldProps, props, changeFlags) {\n      // whether need to update current dimension step\n      // dimension step is the value, domain, scaleFunction of each dimension\n      // each step is an object with properties links to layer prop and whether the prop is\n      // controlled by updateTriggers\n      return Object.values(dimensionStep.triggers).some(function (item) {\n        if (item.updateTrigger) {\n          // check based on updateTriggers change first\n          return changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);\n        } // fallback to direct comparison\n\n        return oldProps[item.prop] !== props[item.prop];\n      });\n    }\n  }, {\n    key: \"_accumulateUpdaters\",\n    value: function _accumulateUpdaters(step, props, dimension) {\n      var updaters = [];\n      for (var i = step; i < dimension.updateSteps.length; i++) {\n        if (typeof dimension.updateSteps[i].updater === 'function') {\n          updaters.push(dimension.updateSteps[i].updater.bind(this, dimension.updateSteps[i], props, dimension));\n        }\n      }\n      return updaters;\n    }\n  }, {\n    key: \"_getAllUpdaters\",\n    value: function _getAllUpdaters(dimension, oldProps, props, changeFlags) {\n      var _this2 = this;\n      var updaters = [];\n      var needUpdateStep = dimension.updateSteps.findIndex(function (step) {\n        return _this2._needUpdateStep(step, oldProps, props, changeFlags);\n      });\n      if (needUpdateStep > -1) {\n        updaters = updaters.concat(this._accumulateUpdaters(needUpdateStep, props, dimension));\n      }\n      return updaters;\n    }\n  }, {\n    key: \"_getAggregationChanges\",\n    value: function _getAggregationChanges(oldProps, props, changeFlags) {\n      var updaters = this._getAllUpdaters(this.aggregationUpdater, oldProps, props, changeFlags);\n      return updaters.length ? updaters : null;\n    }\n  }, {\n    key: \"_getDimensionChanges\",\n    value: function _getDimensionChanges(oldProps, props, changeFlags) {\n      var updaters = []; // get dimension to be updated\n\n      for (var key in this.dimensionUpdaters) {\n        // return the first triggered updater for each dimension\n        var dimension = this.dimensionUpdaters[key];\n        var dimensionUpdaters = this._getAllUpdaters(dimension, oldProps, props, changeFlags);\n        updaters = updaters.concat(dimensionUpdaters);\n      }\n      return updaters.length ? updaters : null;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers(props) {\n      var _this3 = this;\n      var _updateTriggers = props.updateTriggers || {};\n      var updateTriggers = {};\n      var _loop = function _loop(key) {\n        var _this3$dimensionUpdat = _this3.dimensionUpdaters[key],\n          accessor = _this3$dimensionUpdat.accessor,\n          updateSteps = _this3$dimensionUpdat.updateSteps; // fold dimension triggers into each accessor\n\n        updateTriggers[accessor] = {};\n        updateSteps.forEach(function (step) {\n          Object.values(step.triggers || []).forEach(function (_ref) {\n            var prop = _ref.prop,\n              updateTrigger = _ref.updateTrigger;\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              var fromProp = _updateTriggers[updateTrigger];\n              if ((0, _typeof2[\"default\"])(fromProp) === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          });\n        });\n      };\n      for (var key in this.dimensionUpdaters) {\n        _loop(key);\n      }\n      return updateTriggers;\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2, layerProps) {\n      var info = _ref2.info;\n      var isPicked = info.picked && info.index > -1;\n      var object = null;\n      if (isPicked) {\n        var cell = this.state.layerData.data[info.index];\n        var binInfo = {};\n        for (var key in this.dimensionUpdaters) {\n          var getPickingInfo = this.dimensionUpdaters[key].getPickingInfo;\n          if (typeof getPickingInfo === 'function') {\n            binInfo = Object.assign({}, binInfo, getPickingInfo(this.state.dimensions[key], cell, layerProps));\n          }\n        }\n        object = Object.assign(binInfo, cell, {\n          points: cell.filteredPoints || cell.points\n        });\n      } // add bin  and  to info\n\n      return Object.assign(info, {\n        picked: Boolean(object),\n        // override object with picked cell\n        object: object\n      });\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(dimensionKey, layerProps) {\n      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n        return nop;\n      }\n      return this.dimensionUpdaters[dimensionKey].getSubLayerAccessor(this.state.dimensions[dimensionKey], this.dimensionUpdaters[dimensionKey], layerProps);\n    }\n  }], [{\n    key: \"defaultDimensions\",\n    value: function defaultDimensions() {\n      return _defaultDimensions;\n    }\n  }]);\n  return CPUAggregator;\n}();\nexports[\"default\"] = CPUAggregator;\nCPUAggregator.getDimensionScale = getDimensionScale;","map":{"version":3,"sources":["../../../src/deckgl-layers/layer-utils/cpu-aggregator.js"],"names":["DECK_AGGREGATION_MAP","AGGREGATION_OPERATION","SUM","AGGREGATION_TYPES","sum","MEAN","average","MIN","minimum","MAX","maximum","getValueFunc","aggregation","accessor","toUpperCase","Console","warn","op","keplerOp","pts","map","getScaleFunctor","scaleType","SCALE_FUNC","quantize","nop","getGetValue","step","props","dimensionUpdater","key","value","weight","triggers","getValue","prop","_setDimensionState","getDimensionSortedBins","state","dimensions","sortedBins","BinSorter","layerData","data","filterData","_filterData","getDimensionValueDomain","lowerPercentile","upperPercentile","valueDomain","getValueDomainByScale","getDimensionScale","domain","range","onSet","dimensionRange","dimensionDomain","scaleFunctor","scaleFunc","normalizeResult","result","hexagons","assign","getAggregatedData","aggregationParams","aggregator","aggr","setState","defaultAggregation","updateSteps","cellSize","position","updateTrigger","updater","getSubLayerAccessor","dimensionState","dimension","layerProps","bin","binMap","cell","index","counts","nullValue","cv","isValueInDomain","length","defaultColorDimension","getPickingInfo","colorValue","defaultElevationDimension","elevationValue","defaultDimensions","CPUAggregator","opts","initialState","dimensionUpdaters","aggregationUpdater","_addDimension","_addAggregation","dimensionChanges","dim","updaters","_accumulateUpdaters","concat","forEach","f","oldProps","changeFlags","dataChanged","updateAggregation","updateAllDimensions","aggregationChanges","_getAggregationChanges","_getDimensionChanges","updateObject","Object","dimensionStep","values","some","item","updateTriggersChanged","all","i","push","bind","needUpdateStep","findIndex","_needUpdateStep","_getAllUpdaters","_updateTriggers","updateTriggers","fromProp","Array","isArray","undefined","info","isPicked","picked","object","binInfo","points","filteredPoints","Boolean","dimensionKey","hasOwnProperty"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\nimport {AGGREGATION_OPERATION, _BinSorter as BinSorter} from '@deck.gl/aggregation-layers';\nimport {console as Console} from 'global/window';\n\nimport {aggregate} from 'utils/aggregate-utils';\nimport {AGGREGATION_TYPES, SCALE_FUNC} from 'constants/default-settings';\n\nexport const DECK_AGGREGATION_MAP = {\n  [AGGREGATION_OPERATION.SUM]: AGGREGATION_TYPES.sum,\n  [AGGREGATION_OPERATION.MEAN]: AGGREGATION_TYPES.average,\n  [AGGREGATION_OPERATION.MIN]: AGGREGATION_TYPES.minimum,\n  [AGGREGATION_OPERATION.MAX]: AGGREGATION_TYPES.maximum\n};\n\nexport function getValueFunc(aggregation, accessor) {\n  if (!aggregation || !AGGREGATION_OPERATION[aggregation.toUpperCase()]) {\n    Console.warn(`Aggregation ${aggregation} is not supported`);\n  }\n\n  const op = AGGREGATION_OPERATION[aggregation.toUpperCase()] || AGGREGATION_OPERATION.SUM;\n  const keplerOp = DECK_AGGREGATION_MAP[op];\n\n  return pts => aggregate(pts.map(accessor), keplerOp);\n}\n\nexport function getScaleFunctor(scaleType) {\n  if (!scaleType || !SCALE_FUNC[scaleType]) {\n    Console.warn(`Scale ${scaleType} is not supported`);\n  }\n  return SCALE_FUNC[scaleType] || SCALE_FUNC.quantize;\n}\n\nfunction nop() {}\n\nexport function getGetValue(step, props, dimensionUpdater) {\n  const {key} = dimensionUpdater;\n  const {value, weight, aggregation} = step.triggers;\n\n  let getValue = props[value.prop];\n\n  if (getValue === null) {\n    // If `getValue` is not provided from props, build it with aggregation and weight.\n    getValue = getValueFunc(props[aggregation.prop], props[weight.prop]);\n  }\n\n  if (getValue) {\n    this._setDimensionState(key, {getValue});\n  }\n}\n\nexport function getDimensionSortedBins(step, props, dimensionUpdater) {\n  const {key} = dimensionUpdater;\n  const {getValue} = this.state.dimensions[key];\n\n  const sortedBins = new BinSorter(this.state.layerData.data || [], {\n    getValue,\n    filterData: props._filterData\n  });\n  this._setDimensionState(key, {sortedBins});\n}\n\nexport function getDimensionValueDomain(step, props, dimensionUpdater) {\n  const {key} = dimensionUpdater;\n  const {\n    triggers: {lowerPercentile, upperPercentile, scaleType}\n  } = step;\n\n  if (!this.state.dimensions[key].sortedBins) {\n    // the previous step should set sortedBins, if not, something went wrong\n    return;\n  }\n\n  // for log and sqrt scale, returns linear domain by default\n  // TODO: support other scale function domain in bin sorter\n  const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n    props[scaleType.prop],\n    [props[lowerPercentile.prop], props[upperPercentile.prop]]\n  );\n\n  this._setDimensionState(key, {valueDomain});\n}\n\nexport function getDimensionScale(step, props, dimensionUpdater) {\n  const {key} = dimensionUpdater;\n  const {domain, range, scaleType} = step.triggers;\n  const {onSet} = step;\n  if (!this.state.dimensions[key].valueDomain) {\n    // the previous step should set valueDomain, if not, something went wrong\n    return;\n  }\n\n  const dimensionRange = props[range.prop];\n  const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n\n  const scaleFunctor = getScaleFunctor(scaleType && props[scaleType.prop])();\n\n  const scaleFunc = scaleFunctor.domain(dimensionDomain).range(dimensionRange);\n\n  if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n    props[onSet.props](scaleFunc.domain());\n  }\n  this._setDimensionState(key, {scaleFunc});\n}\n\nfunction normalizeResult(result = {}) {\n  // support previous hexagonAggregator API\n  if (result.hexagons) {\n    return Object.assign({data: result.hexagons}, result);\n  } else if (result.layerData) {\n    return Object.assign({data: result.layerData}, result);\n  }\n\n  return result;\n}\n\nexport function getAggregatedData(step, props, aggregation, aggregationParams) {\n  const {\n    triggers: {aggregator: aggr}\n  } = step;\n  const aggregator = props[aggr.prop];\n\n  // result should contain a data array and other props\n  // result = {data: [], ...other props}\n  const result = aggregator(props, aggregationParams);\n  this.setState({\n    layerData: normalizeResult(result)\n  });\n}\n\nexport const defaultAggregation = {\n  key: 'position',\n  updateSteps: [\n    {\n      key: 'aggregate',\n      triggers: {\n        cellSize: {\n          prop: 'cellSize'\n        },\n        position: {\n          prop: 'getPosition',\n          updateTrigger: 'getPosition'\n        },\n        aggregator: {\n          prop: 'gridAggregator'\n        }\n      },\n      updater: getAggregatedData\n    }\n  ]\n};\n\nfunction getSubLayerAccessor(dimensionState, dimension, layerProps) {\n  return cell => {\n    const {sortedBins, scaleFunc} = dimensionState;\n    const bin = sortedBins.binMap[cell.index];\n\n    if (bin && bin.counts === 0) {\n      // no points left in bin after filtering\n      return dimension.nullValue;\n    }\n\n    const cv = bin && bin.value;\n    const domain = scaleFunc.domain();\n\n    const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n    // if cell value is outside domain, set alpha to 0\n    return isValueInDomain ? scaleFunc(cv) : dimension.nullValue;\n  };\n}\n\nexport const defaultColorDimension = {\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  getPickingInfo: (dimensionState, cell) => {\n    const {sortedBins} = dimensionState;\n    const colorValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n    return {colorValue};\n  },\n  nullValue: [0, 0, 0, 0],\n  updateSteps: [\n    {\n      key: 'getValue',\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        }\n      },\n      updater: getGetValue\n    },\n    {\n      key: 'getBins',\n      triggers: {\n        _filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      },\n      updater: getDimensionSortedBins\n    },\n    {\n      key: 'getDomain',\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {prop: 'colorScaleType'}\n      },\n      updater: getDimensionValueDomain\n    },\n    {\n      key: 'getScaleFunc',\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'},\n        scaleType: {prop: 'colorScaleType'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      },\n      updater: getDimensionScale\n    }\n  ],\n  getSubLayerAccessor\n};\n\nexport const defaultElevationDimension = {\n  key: 'elevation',\n  accessor: 'getElevation',\n  getPickingInfo: (dimensionState, cell) => {\n    const {sortedBins} = dimensionState;\n    const elevationValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n    return {elevationValue};\n  },\n  nullValue: -1,\n  updateSteps: [\n    {\n      key: 'getValue',\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        }\n      },\n      updater: getGetValue\n    },\n    {\n      key: 'getBins',\n      triggers: {\n        _filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      },\n      updater: getDimensionSortedBins\n    },\n    {\n      key: 'getDomain',\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {prop: 'elevationScaleType'}\n      },\n      updater: getDimensionValueDomain\n    },\n    {\n      key: 'getScaleFunc',\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'},\n        scaleType: {prop: 'elevationScaleType'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      },\n      updater: getDimensionScale\n    }\n  ],\n  getSubLayerAccessor\n};\n\nexport const defaultDimensions = [defaultColorDimension, defaultElevationDimension];\n\nexport default class CPUAggregator {\n  constructor(opts = {}) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      },\n      ...opts.initialState\n    };\n    this.dimensionUpdaters = {};\n    this.aggregationUpdater = {};\n\n    this._addDimension(opts.dimensions || defaultDimensions);\n    this._addAggregation(opts.aggregation || defaultAggregation);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateAllDimensions(props) {\n    let dimensionChanges = [];\n    // update all dimensions\n    for (const dim in this.dimensionUpdaters) {\n      const updaters = this._accumulateUpdaters(0, props, this.dimensionUpdaters[dim]);\n      dimensionChanges = dimensionChanges.concat(updaters);\n    }\n\n    dimensionChanges.forEach(f => typeof f === 'function' && f());\n  }\n\n  updateAggregation(props, aggregationParams) {\n    const updaters = this._accumulateUpdaters(0, props, this.aggregationUpdater);\n    updaters.forEach(f => typeof f === 'function' && f(aggregationParams));\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    let dimensionChanges = [];\n\n    if (changeFlags.dataChanged) {\n      // if data changed update everything\n      this.updateAggregation(props, aggregationParams);\n      this.updateAllDimensions(props);\n\n      return this.state;\n    }\n\n    const aggregationChanges = this._getAggregationChanges(oldProps, props, changeFlags);\n\n    if (aggregationChanges && aggregationChanges.length) {\n      // get aggregatedData\n      aggregationChanges.forEach(f => typeof f === 'function' && f(aggregationParams));\n      this.updateAllDimensions(props);\n    } else {\n      // only update dimensions\n      dimensionChanges = this._getDimensionChanges(oldProps, props, changeFlags) || [];\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n    }\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = Object.assign({}, this.state, updateObject);\n  }\n\n  // Update private state.dimensions\n  _setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: Object.assign({}, this.state.dimensions, {\n        [key]: Object.assign({}, this.state.dimensions[key], updateObject)\n      })\n    });\n  }\n\n  _addAggregation(aggregation) {\n    this.aggregationUpdater = aggregation;\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = dimension;\n    });\n  }\n\n  _needUpdateStep(dimensionStep, oldProps, props, changeFlags) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        return (\n          changeFlags.updateTriggersChanged &&\n          (changeFlags.updateTriggersChanged.all ||\n            changeFlags.updateTriggersChanged[item.updateTrigger])\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  _accumulateUpdaters(step, props, dimension) {\n    const updaters = [];\n    for (let i = step; i < dimension.updateSteps.length; i++) {\n      if (typeof dimension.updateSteps[i].updater === 'function') {\n        updaters.push(\n          dimension.updateSteps[i].updater.bind(this, dimension.updateSteps[i], props, dimension)\n        );\n      }\n    }\n\n    return updaters;\n  }\n\n  _getAllUpdaters(dimension, oldProps, props, changeFlags) {\n    let updaters = [];\n    const needUpdateStep = dimension.updateSteps.findIndex(step =>\n      this._needUpdateStep(step, oldProps, props, changeFlags)\n    );\n\n    if (needUpdateStep > -1) {\n      updaters = updaters.concat(this._accumulateUpdaters(needUpdateStep, props, dimension));\n    }\n\n    return updaters;\n  }\n\n  _getAggregationChanges(oldProps, props, changeFlags) {\n    const updaters = this._getAllUpdaters(this.aggregationUpdater, oldProps, props, changeFlags);\n    return updaters.length ? updaters : null;\n  }\n\n  _getDimensionChanges(oldProps, props, changeFlags) {\n    let updaters = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const dimension = this.dimensionUpdaters[key];\n      const dimensionUpdaters = this._getAllUpdaters(dimension, oldProps, props, changeFlags);\n      updaters = updaters.concat(dimensionUpdaters);\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {accessor, updateSteps} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      updateSteps.forEach(step => {\n        Object.values(step.triggers || []).forEach(({prop, updateTrigger}) => {\n          if (updateTrigger) {\n            // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n            // and updateTriggers is passed in from layer prop\n            // fold the updateTriggers into accessor\n            const fromProp = _updateTriggers[updateTrigger];\n            if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n              // if updateTrigger is an object spread it\n              Object.assign(updateTriggers[accessor], fromProp);\n            } else if (fromProp !== undefined) {\n              updateTriggers[accessor][prop] = fromProp;\n            }\n          } else {\n            // if prop is not based on updateTrigger\n            updateTriggers[accessor][prop] = props[prop];\n          }\n        });\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getPickingInfo({info}, layerProps) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      const cell = this.state.layerData.data[info.index];\n\n      let binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {getPickingInfo} = this.dimensionUpdaters[key];\n        if (typeof getPickingInfo === 'function') {\n          binInfo = Object.assign(\n            {},\n            binInfo,\n            getPickingInfo(this.state.dimensions[key], cell, layerProps)\n          );\n        }\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // add bin  and  to info\n    return Object.assign(info, {\n      picked: Boolean(object),\n      // override object with picked cell\n      object\n    });\n  }\n\n  getAccessor(dimensionKey, layerProps) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].getSubLayerAccessor(\n      this.state.dimensions[dimensionKey],\n      this.dimensionUpdaters[dimensionKey],\n      layerProps\n    );\n  }\n}\n\nCPUAggregator.getDimensionScale = getDimensionScale;\n"]},"metadata":{},"sourceType":"script"}