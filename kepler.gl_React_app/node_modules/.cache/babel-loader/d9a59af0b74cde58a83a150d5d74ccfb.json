{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Framebuffer, Texture2D, isWebGL2, readPixelsToArray, cssToDeviceRatio, cssToDevicePixels } from '@luma.gl/core';\nimport assert from '../utils/assert';\nimport log from '../utils/log';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport { getClosestObject, getUniqueObjects } from './picking/query-object';\nimport { processPickInfo, getLayerPickingInfo } from './picking/pick-info';\nvar DeckPicker = function () {\n  function DeckPicker(gl) {\n    _classCallCheck(this, DeckPicker);\n    this.gl = gl;\n    this.pickingFBO = null;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.layerFilter = null;\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n    this._onError = null;\n  }\n  _createClass(DeckPicker, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('layerFilter' in props) {\n        this.layerFilter = props.layerFilter;\n      }\n      if ('onError' in props) {\n        this._onError = props.onError;\n      }\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      if (this.pickingFBO) {\n        this.pickingFBO[\"delete\"]();\n      }\n      if (this.depthFBO) {\n        this.depthFBO.color[\"delete\"]();\n        this.depthFBO[\"delete\"]();\n      }\n    }\n  }, {\n    key: \"pickObject\",\n    value: function pickObject(opts) {\n      return this._pickClosestObject(opts);\n    }\n  }, {\n    key: \"pickObjects\",\n    value: function pickObjects(opts) {\n      return this._pickVisibleObjects(opts);\n    }\n  }, {\n    key: \"getLastPickedObject\",\n    value: function getLastPickedObject(_ref) {\n      var x = _ref.x,\n        y = _ref.y,\n        layers = _ref.layers,\n        viewports = _ref.viewports;\n      var lastPickedInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.lastPickedInfo.info;\n      var lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n      var layer = lastPickedLayerId ? layers.find(function (l) {\n        return l.id === lastPickedLayerId;\n      }) : null;\n      var coordinate = viewports[0] && viewports[0].unproject([x, y]);\n      var info = {\n        x: x,\n        y: y,\n        coordinate: coordinate,\n        lngLat: coordinate,\n        layer: layer\n      };\n      if (layer) {\n        return Object.assign({}, lastPickedInfo, info);\n      }\n      return Object.assign(info, {\n        color: null,\n        object: null,\n        index: -1\n      });\n    }\n  }, {\n    key: \"_resizeBuffer\",\n    value: function _resizeBuffer() {\n      var gl = this.gl;\n      if (!this.pickingFBO) {\n        this.pickingFBO = new Framebuffer(gl);\n        if (Framebuffer.isSupported(gl, {\n          colorBufferFloat: true\n        })) {\n          this.depthFBO = new Framebuffer(gl);\n          this.depthFBO.attach(_defineProperty({}, 36064, new Texture2D(gl, {\n            format: isWebGL2(gl) ? 34836 : 6408,\n            type: 5126\n          })));\n        }\n      }\n      this.pickingFBO.resize({\n        width: gl.canvas.width,\n        height: gl.canvas.height\n      });\n      if (this.depthFBO) {\n        this.depthFBO.resize({\n          width: gl.canvas.width,\n          height: gl.canvas.height\n        });\n      }\n      return this.pickingFBO;\n    }\n  }, {\n    key: \"_getPickable\",\n    value: function _getPickable(layers) {\n      var pickableLayers = layers.filter(function (layer) {\n        return layer.isPickable() && !layer.isComposite;\n      });\n      if (pickableLayers.length > 255) {\n        log.warn('Too many pickable layers, only picking the first 255')();\n        return pickableLayers.slice(0, 255);\n      }\n      return pickableLayers;\n    }\n  }, {\n    key: \"_pickClosestObject\",\n    value: function _pickClosestObject(_ref2) {\n      var layers = _ref2.layers,\n        viewports = _ref2.viewports,\n        x = _ref2.x,\n        y = _ref2.y,\n        _ref2$radius = _ref2.radius,\n        radius = _ref2$radius === void 0 ? 0 : _ref2$radius,\n        _ref2$depth = _ref2.depth,\n        depth = _ref2$depth === void 0 ? 1 : _ref2$depth,\n        _ref2$mode = _ref2.mode,\n        mode = _ref2$mode === void 0 ? 'query' : _ref2$mode,\n        unproject3D = _ref2.unproject3D,\n        onViewportActive = _ref2.onViewportActive;\n      layers = this._getPickable(layers);\n      this._resizeBuffer();\n      var pixelRatio = cssToDeviceRatio(this.gl);\n      var devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n      var devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];\n      var deviceRadius = Math.round(radius * pixelRatio);\n      var _this$pickingFBO = this.pickingFBO,\n        width = _this$pickingFBO.width,\n        height = _this$pickingFBO.height;\n      var deviceRect = this._getPickingRect({\n        deviceX: devicePixel[0],\n        deviceY: devicePixel[1],\n        deviceRadius: deviceRadius,\n        deviceWidth: width,\n        deviceHeight: height\n      });\n      var infos;\n      var result = [];\n      var affectedLayers = {};\n      for (var i = 0; i < depth; i++) {\n        var pickedColors = deviceRect && this._drawAndSample({\n          layers: layers,\n          viewports: viewports,\n          onViewportActive: onViewportActive,\n          deviceRect: deviceRect,\n          pass: \"picking:\".concat(mode),\n          redrawReason: mode\n        });\n        var pickInfo = getClosestObject({\n          pickedColors: pickedColors,\n          layers: layers,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius: deviceRadius,\n          deviceRect: deviceRect\n        });\n        var z = void 0;\n        if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n          var zValues = this._drawAndSample({\n            layers: [pickInfo.pickedLayer],\n            viewports: viewports,\n            onViewportActive: onViewportActive,\n            deviceRect: {\n              x: pickInfo.pickedX,\n              y: pickInfo.pickedY,\n              width: 1,\n              height: 1\n            },\n            pass: \"picking:\".concat(mode),\n            redrawReason: 'pick-z',\n            pickZ: true\n          });\n          z = zValues[0] * viewports[0].distanceScales.metersPerUnit[2] + viewports[0].position[2];\n        }\n        if (pickInfo.pickedColor && i + 1 < depth) {\n          var layerId = pickInfo.pickedColor[3] - 1;\n          affectedLayers[layerId] = true;\n          layers[layerId].clearPickingColor(pickInfo.pickedColor);\n        }\n        infos = processPickInfo({\n          pickInfo: pickInfo,\n          lastPickedInfo: this.lastPickedInfo,\n          mode: mode,\n          layers: layers,\n          viewports: viewports,\n          x: x,\n          y: y,\n          z: z,\n          pixelRatio: pixelRatio\n        });\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n          for (var _iterator = infos.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var info = _step.value;\n            if (info.layer) {\n              result.push(info);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n        if (!pickInfo.pickedColor) {\n          break;\n        }\n      }\n      for (var _layerId in affectedLayers) {\n        layers[_layerId].restorePickingColors();\n      }\n      return {\n        result: result,\n        emptyInfo: infos && infos.get(null)\n      };\n    }\n  }, {\n    key: \"_pickVisibleObjects\",\n    value: function _pickVisibleObjects(_ref3) {\n      var layers = _ref3.layers,\n        viewports = _ref3.viewports,\n        x = _ref3.x,\n        y = _ref3.y,\n        _ref3$width = _ref3.width,\n        width = _ref3$width === void 0 ? 1 : _ref3$width,\n        _ref3$height = _ref3.height,\n        height = _ref3$height === void 0 ? 1 : _ref3$height,\n        _ref3$mode = _ref3.mode,\n        mode = _ref3$mode === void 0 ? 'query' : _ref3$mode,\n        onViewportActive = _ref3.onViewportActive;\n      layers = this._getPickable(layers);\n      this._resizeBuffer();\n      var pixelRatio = cssToDeviceRatio(this.gl);\n      var leftTop = cssToDevicePixels(this.gl, [x, y], true);\n      var deviceLeft = leftTop.x;\n      var deviceTop = leftTop.y + leftTop.height;\n      var rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n      var deviceRight = rightBottom.x + rightBottom.width;\n      var deviceBottom = rightBottom.y;\n      var deviceRect = {\n        x: deviceLeft,\n        y: deviceBottom,\n        width: deviceRight - deviceLeft,\n        height: deviceTop - deviceBottom\n      };\n      var pickedColors = this._drawAndSample({\n        layers: layers,\n        viewports: viewports,\n        onViewportActive: onViewportActive,\n        deviceRect: deviceRect,\n        pass: \"picking:\".concat(mode),\n        redrawReason: mode\n      });\n      var pickInfos = getUniqueObjects({\n        pickedColors: pickedColors,\n        layers: layers\n      });\n      var uniqueInfos = new Map();\n      pickInfos.forEach(function (pickInfo) {\n        var info = {\n          color: pickInfo.pickedColor,\n          layer: null,\n          index: pickInfo.pickedObjectIndex,\n          picked: true,\n          x: x,\n          y: y,\n          width: width,\n          height: height,\n          pixelRatio: pixelRatio\n        };\n        info = getLayerPickingInfo({\n          layer: pickInfo.pickedLayer,\n          info: info,\n          mode: mode\n        });\n        if (!uniqueInfos.has(info.object)) {\n          uniqueInfos.set(info.object, info);\n        }\n      });\n      return Array.from(uniqueInfos.values());\n    }\n  }, {\n    key: \"_drawAndSample\",\n    value: function _drawAndSample(_ref4) {\n      var layers = _ref4.layers,\n        viewports = _ref4.viewports,\n        onViewportActive = _ref4.onViewportActive,\n        deviceRect = _ref4.deviceRect,\n        pass = _ref4.pass,\n        redrawReason = _ref4.redrawReason,\n        pickZ = _ref4.pickZ;\n      assert(deviceRect.width > 0 && deviceRect.height > 0);\n      if (layers.length < 1) {\n        return null;\n      }\n      var pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n      this.pickLayersPass.render({\n        layers: layers,\n        layerFilter: this.layerFilter,\n        onError: this._onError,\n        viewports: viewports,\n        onViewportActive: onViewportActive,\n        pickingFBO: pickingFBO,\n        deviceRect: deviceRect,\n        pass: pass,\n        redrawReason: redrawReason,\n        pickZ: pickZ\n      });\n      var x = deviceRect.x,\n        y = deviceRect.y,\n        width = deviceRect.width,\n        height = deviceRect.height;\n      var pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n      readPixelsToArray(pickingFBO, {\n        sourceX: x,\n        sourceY: y,\n        sourceWidth: width,\n        sourceHeight: height,\n        target: pickedColors\n      });\n      return pickedColors;\n    }\n  }, {\n    key: \"_getPickingRect\",\n    value: function _getPickingRect(_ref5) {\n      var deviceX = _ref5.deviceX,\n        deviceY = _ref5.deviceY,\n        deviceRadius = _ref5.deviceRadius,\n        deviceWidth = _ref5.deviceWidth,\n        deviceHeight = _ref5.deviceHeight;\n      var x = Math.max(0, deviceX - deviceRadius);\n      var y = Math.max(0, deviceY - deviceRadius);\n      var width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n      var height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n      if (width <= 0 || height <= 0) {\n        return null;\n      }\n      return {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      };\n    }\n  }]);\n  return DeckPicker;\n}();\nexport { DeckPicker as default };","map":{"version":3,"sources":["../../../src/lib/deck-picker.js"],"names":["Framebuffer","Texture2D","isWebGL2","readPixelsToArray","cssToDeviceRatio","cssToDevicePixels","assert","log","PickLayersPass","getClosestObject","getUniqueObjects","processPickInfo","getLayerPickingInfo","DeckPicker","gl","pickingFBO","pickLayersPass","layerFilter","lastPickedInfo","index","layerId","info","_onError","props","onError","depthFBO","color","opts","_pickClosestObject","_pickVisibleObjects","x","y","layers","viewports","lastPickedLayerId","layer","id","find","l","coordinate","unproject","lngLat","Object","assign","object","isSupported","colorBufferFloat","attach","format","type","resize","width","canvas","height","pickableLayers","filter","isPickable","isComposite","length","warn","slice","radius","depth","mode","unproject3D","onViewportActive","_getPickable","_resizeBuffer","pixelRatio","devicePixelRange","devicePixel","Math","floor","deviceRadius","round","deviceRect","_getPickingRect","deviceX","deviceY","deviceWidth","deviceHeight","infos","result","affectedLayers","i","pickedColors","_drawAndSample","pass","redrawReason","pickInfo","z","pickedLayer","zValues","pickedX","pickedY","pickZ","distanceScales","metersPerUnit","position","pickedColor","clearPickingColor","values","push","restorePickingColors","emptyInfo","get","leftTop","deviceLeft","deviceTop","rightBottom","deviceRight","deviceBottom","pickInfos","uniqueInfos","Map","forEach","pickedObjectIndex","picked","has","set","Array","from","render","Float32Array","Uint8Array","sourceX","sourceY","sourceWidth","sourceHeight","target","max","min"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Framebuffer,\n  Texture2D,\n  isWebGL2,\n  readPixelsToArray,\n  cssToDeviceRatio,\n  cssToDevicePixels\n} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport assert from '../utils/assert';\nimport log from '../utils/log';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport {getClosestObject, getUniqueObjects} from './picking/query-object';\nimport {processPickInfo, getLayerPickingInfo} from './picking/pick-info';\n\nexport default class DeckPicker {\n  constructor(gl) {\n    this.gl = gl;\n    this.pickingFBO = null;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.layerFilter = null;\n    this.lastPickedInfo = {\n      // For callback tracking and auto highlight\n      index: -1,\n      layerId: null,\n      info: null\n    };\n    this._onError = null;\n  }\n\n  setProps(props) {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n\n    if ('onError' in props) {\n      this._onError = props.onError;\n    }\n  }\n\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.delete();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.color.delete();\n      this.depthFBO.delete();\n    }\n  }\n\n  // Pick the closest info at given coordinate\n  pickObject(opts) {\n    return this._pickClosestObject(opts);\n  }\n\n  // Get all unique infos within a bounding box\n  pickObjects(opts) {\n    return this._pickVisibleObjects(opts);\n  }\n\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({x, y, layers, viewports}, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const coordinate = viewports[0] && viewports[0].unproject([x, y]);\n\n    const info = {\n      x,\n      y,\n      coordinate,\n      // TODO remove the lngLat prop after compatibility check\n      lngLat: coordinate,\n      layer\n    };\n\n    if (layer) {\n      return Object.assign({}, lastPickedInfo, info);\n    }\n    return Object.assign(info, {color: null, object: null, index: -1});\n  }\n\n  // Private\n  _resizeBuffer() {\n    const {gl} = this;\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = new Framebuffer(gl);\n      if (Framebuffer.isSupported(gl, {colorBufferFloat: true})) {\n        this.depthFBO = new Framebuffer(gl);\n        this.depthFBO.attach({\n          [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n            format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n            type: GL.FLOAT\n          })\n        });\n      }\n    }\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    this.pickingFBO.resize({width: gl.canvas.width, height: gl.canvas.height});\n    if (this.depthFBO) {\n      this.depthFBO.resize({width: gl.canvas.width, height: gl.canvas.height});\n    }\n    return this.pickingFBO;\n  }\n\n  // picking can only handle up to 255 layers. Drop non-pickable/invisible layers from the list.\n  _getPickable(layers) {\n    const pickableLayers = layers.filter(layer => layer.isPickable() && !layer.isComposite);\n    if (pickableLayers.length > 255) {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      return pickableLayers.slice(0, 255);\n    }\n    return pickableLayers;\n  }\n\n  // Pick the closest object at the given (x,y) coordinate\n  // eslint-disable-next-line max-statements,complexity\n  _pickClosestObject({\n    layers,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive\n  }) {\n    layers = this._getPickable(layers);\n\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n    const devicePixel = [\n      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n    ];\n\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {width, height} = this.pickingFBO;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    let infos;\n    const result = [];\n    const affectedLayers = {};\n\n    for (let i = 0; i < depth; i++) {\n      const pickedColors =\n        deviceRect &&\n        this._drawAndSample({\n          layers,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          pass: `picking:${mode}`,\n          redrawReason: mode\n        });\n\n      const pickInfo = getClosestObject({\n        pickedColors,\n        layers,\n        deviceX: devicePixel[0],\n        deviceY: devicePixel[1],\n        deviceRadius,\n        deviceRect\n      });\n\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const zValues = this._drawAndSample({\n          layers: [pickInfo.pickedLayer],\n          viewports,\n          onViewportActive,\n          deviceRect: {x: pickInfo.pickedX, y: pickInfo.pickedY, width: 1, height: 1},\n          pass: `picking:${mode}`,\n          redrawReason: 'pick-z',\n          pickZ: true\n        });\n        // picked value is in common space (pixels) from the camera target (viewport.position)\n        // convert it to meters from the ground\n        z = zValues[0] * viewports[0].distanceScales.metersPerUnit[2] + viewports[0].position[2];\n      }\n\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedColor && i + 1 < depth) {\n        const layerId = pickInfo.pickedColor[3] - 1;\n        affectedLayers[layerId] = true;\n        layers[layerId].clearPickingColor(pickInfo.pickedColor);\n      }\n\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    // reset only affected buffers\n    for (const layerId in affectedLayers) {\n      layers[layerId].restorePickingColors();\n    }\n\n    return {result, emptyInfo: infos && infos.get(null)};\n  }\n\n  // Pick all objects within the given bounding box\n  _pickVisibleObjects({\n    layers,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    onViewportActive\n  }) {\n    layers = this._getPickable(layers);\n\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const leftTop = cssToDevicePixels(this.gl, [x, y], true);\n\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n\n    // take right and bottom (y inverted in device pixels) from end location\n    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedColors = this._drawAndSample({\n      layers,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      pass: `picking:${mode}`,\n      redrawReason: mode\n    });\n\n    const pickInfos = getUniqueObjects({pickedColors, layers});\n\n    // Only return unique infos, identified by info.object\n    const uniqueInfos = new Map();\n\n    pickInfos.forEach(pickInfo => {\n      let info = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        width,\n        height,\n        pixelRatio\n      };\n\n      info = getLayerPickingInfo({layer: pickInfo.pickedLayer, info, mode});\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    });\n\n    return Array.from(uniqueInfos.values());\n  }\n\n  // returns pickedColor or null if no pickable layers found.\n  _drawAndSample({layers, viewports, onViewportActive, deviceRect, pass, redrawReason, pickZ}) {\n    assert(deviceRect.width > 0 && deviceRect.height > 0);\n\n    if (layers.length < 1) {\n      return null;\n    }\n\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n\n    this.pickLayersPass.render({\n      layers,\n      layerFilter: this.layerFilter,\n      onError: this._onError,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      pass,\n      redrawReason,\n      pickZ\n    });\n\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {x, y, width, height} = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    readPixelsToArray(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n\n    return pickedColors;\n  }\n\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  _getPickingRect({deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight}) {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {x, y, width, height};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}