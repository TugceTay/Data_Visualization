{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Vector3 } from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport { INTERSECTION } from '../../constants';\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\nexport default class BoundingSphere {\n  constructor() {\n    let center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    let radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n    _defineProperty(this, \"center\", void 0);\n    _defineProperty(this, \"radius\", void 0);\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n  fromCenterRadius(center, radius) {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n  fromCornerPoints(corner, oppositeCorner) {\n    oppositeCorner = scratchVector.from(oppositeCorner);\n    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n  equals(right) {\n    return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;\n  }\n  clone() {\n    return new BoundingSphere(this.center, this.radius);\n  }\n  union(boundingSphere) {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n    const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n    if (leftRadius >= centerSeparation + rightRadius) {\n      return this.clone();\n    }\n    if (rightRadius >= centerSeparation + leftRadius) {\n      return boundingSphere.clone();\n    }\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n    scratchVector2.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n    return this;\n  }\n  expand(point) {\n    const scratchPoint = scratchVector.from(point);\n    const radius = scratchPoint.subtract(this.center).magnitude();\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n    return this;\n  }\n  transform(transform) {\n    this.center.transform(transform);\n    const scale = mat4.getScaling(scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n  distanceSquaredTo(point) {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n  distanceTo(point) {\n    const scratchPoint = scratchVector.from(point);\n    const delta = scratchPoint.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n  intersectPlane(plane) {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n    return INTERSECTION.INSIDE;\n  }\n}","map":{"version":3,"sources":["../../../../src/lib/bounding-volumes/bounding-sphere.ts"],"names":["Vector3","mat4","INTERSECTION","scratchVector","scratchVector2","BoundingSphere","constructor","center","radius","fromCenterRadius","from","fromCornerPoints","corner","oppositeCorner","add","scale","distance","equals","right","Boolean","clone","union","boundingSphere","leftCenter","leftRadius","rightCenter","rightRadius","toRightCenter","copy","subtract","centerSeparation","magnitude","halfDistanceBetweenTangentPoints","expand","point","scratchPoint","transform","getScaling","Math","max","distanceSquaredTo","d","distanceTo","delta","len","intersectPlane","plane","normal","distanceToPlane","dot","OUTSIDE","INTERSECTING","INSIDE"],"mappings":";AAGA,SAAsBA,OAAtB,QAAoC,eAApC;AACA,OAAO,KAAKC,IAAZ,MAAsB,gBAAtB;AACA,SAAQC,YAAR,QAA2B,iBAA3B;AAIA,MAAMC,aAAa,GAAG,IAAIH,OAAJ,EAAtB;AACA,MAAMI,cAAc,GAAG,IAAIJ,OAAJ,EAAvB;AAGA,eAAe,MAAMK,cAAN,CAA+C;EAK5DC,WAAW,GAA8D;IAAA,IAA7DC,MAAyB,uEAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAA7B;IAAA,IAAwCC,MAAc,uEAAG,GAAzD;IAA8D,eAAA,CAAA,IAAA,EAAA,QAAA,EAAA,KAAA,CAAA,CAAA;IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,EAAA,KAAA,CAAA,CAAA;IACvE,IAAA,CAAKA,MAAL,GAAc,CAAC,CAAf;IACA,IAAA,CAAKD,MAAL,GAAc,IAAIP,OAAJ,EAAd;IACA,IAAA,CAAKS,gBAAL,CAAsBF,MAAtB,EAA8BC,MAA9B,CAAA;EACD;EAGDC,gBAAgB,CAACF,MAAD,EAA4BC,MAA5B,EAAkD;IAChE,IAAA,CAAKD,MAAL,CAAYG,IAAZ,CAAiBH,MAAjB,CAAA;IACA,IAAA,CAAKC,MAAL,GAAcA,MAAd;IACA,OAAO,IAAP;EACD;EAMDG,gBAAgB,CAACC,MAAD,EAA4BC,cAA5B,EAAqE;IACnFA,cAAc,GAAGV,aAAa,CAACO,IAAdP,CAAmBU,cAAnBV,CAAjBU;IACA,IAAA,CAAKN,MAAL,GAAc,IAAIP,OAAJ,EAAA,CAAcU,IAAd,CAAmBE,MAAnB,CAAA,CAA2BE,GAA3B,CAA+BD,cAA/B,CAAA,CAA+CE,KAA/C,CAAqD,GAArD,CAAd;IACA,IAAA,CAAKP,MAAL,GAAc,IAAA,CAAKD,MAAL,CAAYS,QAAZ,CAAqBH,cAArB,CAAd;IACA,OAAO,IAAP;EACD;EAGDI,MAAM,CAACC,KAAD,EAAiC;IACrC,OACE,IAAA,KAASA,KAAT,IACCC,OAAO,CAACD,KAAD,CAAPC,IAAkB,IAAA,CAAKZ,MAAL,CAAYU,MAAZ,CAAmBC,KAAK,CAACX,MAAzB,CAAlBY,IAAsD,IAAA,CAAKX,MAAL,KAAgBU,KAAK,CAACV,MAF/E;EAID;EAGDY,KAAK,GAAmB;IACtB,OAAO,IAAIf,cAAJ,CAAmB,IAAA,CAAKE,MAAxB,EAAgC,IAAA,CAAKC,MAArC,CAAP;EACD;EAGDa,KAAK,CAACC,cAAD,EAAiD;IACpD,MAAMC,UAAU,GAAG,IAAA,CAAKhB,MAAxB;IACA,MAAMiB,UAAU,GAAG,IAAA,CAAKhB,MAAxB;IACA,MAAMiB,WAAW,GAAGH,cAAc,CAACf,MAAnC;IACA,MAAMmB,WAAW,GAAGJ,cAAc,CAACd,MAAnC;IAEA,MAAMmB,aAAa,GAAGxB,aAAa,CAACyB,IAAdzB,CAAmBsB,WAAnBtB,CAAAA,CAAgC0B,QAAhC1B,CAAyCoB,UAAzCpB,CAAtB;IACA,MAAM2B,gBAAgB,GAAGH,aAAa,CAACI,SAAdJ,EAAzB;IAEA,IAAIH,UAAU,IAAIM,gBAAgB,GAAGJ,WAArC,EAAkD;MAEhD,OAAO,IAAA,CAAKN,KAAL,EAAP;IACD;IAED,IAAIM,WAAW,IAAII,gBAAgB,GAAGN,UAAtC,EAAkD;MAEhD,OAAOF,cAAc,CAACF,KAAfE,EAAP;IACD;IAGD,MAAMU,gCAAgC,GAAG,CAACR,UAAU,GAAGM,gBAAbN,GAAgCE,WAAjC,IAAgD,GAAzF;IAGAtB,cAAc,CACXwB,IADHxB,CACQuB,aADRvB,CAAAA,CAEGW,KAFHX,CAES,CAAC,CAACoB,UAAD,GAAcQ,gCAAf,IAAmDF,gBAF5D1B,CAAAA,CAGGU,GAHHV,CAGOmB,UAHPnB,CAAAA;IAKA,IAAA,CAAKG,MAAL,CAAYqB,IAAZ,CAAiBxB,cAAjB,CAAA;IACA,IAAA,CAAKI,MAAL,GAAcwB,gCAAd;IAEA,OAAO,IAAP;EACD;EAGDC,MAAM,CAACC,KAAD,EAAiC;IACrC,MAAMC,YAAY,GAAGhC,aAAa,CAACO,IAAdP,CAAmB+B,KAAnB/B,CAArB;IACA,MAAMK,MAAM,GAAG2B,YAAY,CAACN,QAAbM,CAAsB,IAAA,CAAK5B,MAA3B4B,CAAAA,CAAmCJ,SAAnCI,EAAf;IACA,IAAI3B,MAAM,GAAG,IAAA,CAAKA,MAAlB,EAA0B;MACxB,IAAA,CAAKA,MAAL,GAAcA,MAAd;IACD;IACD,OAAO,IAAP;EACD;EAUD4B,SAAS,CAACA,SAAD,EAAqC;IAC5C,IAAA,CAAK7B,MAAL,CAAY6B,SAAZ,CAAsBA,SAAtB,CAAA;IACA,MAAMrB,KAAK,GAAGd,IAAI,CAACoC,UAALpC,CAAgBE,aAAhBF,EAA+BmC,SAA/BnC,CAAd;IACA,IAAA,CAAKO,MAAL,GAAc8B,IAAI,CAACC,GAALD,CAASvB,KAAK,CAAC,CAAD,CAAduB,EAAmBA,IAAI,CAACC,GAALD,CAASvB,KAAK,CAAC,CAAD,CAAduB,EAAmBvB,KAAK,CAAC,CAAD,CAAxBuB,CAAnBA,CAAAA,GAAmD,IAAA,CAAK9B,MAAtE;IACA,OAAO,IAAP;EACD;EAGDgC,iBAAiB,CAACN,KAAD,EAAwC;IACvD,MAAMO,CAAC,GAAG,IAAA,CAAKC,UAAL,CAAgBR,KAAhB,CAAV;IACA,OAAOO,CAAC,GAAGA,CAAX;EACD;EAGDC,UAAU,CAACR,KAAD,EAAwC;IAChD,MAAMC,YAAY,GAAGhC,aAAa,CAACO,IAAdP,CAAmB+B,KAAnB/B,CAArB;IACA,MAAMwC,KAAK,GAAGR,YAAY,CAACN,QAAbM,CAAsB,IAAA,CAAK5B,MAA3B4B,CAAd;IACA,OAAOG,IAAI,CAACC,GAALD,CAAS,CAATA,EAAYK,KAAK,CAACC,GAAND,EAAAA,GAAc,IAAA,CAAKnC,MAA/B8B,CAAP;EACD;EAGDO,cAAc,CAACC,KAAD,EAAuB;IACnC,MAAMvC,MAAM,GAAG,IAAA,CAAKA,MAApB;IACA,MAAMC,MAAM,GAAG,IAAA,CAAKA,MAApB;IACA,MAAMuC,MAAM,GAAGD,KAAK,CAACC,MAArB;IACA,MAAMC,eAAe,GAAGD,MAAM,CAACE,GAAPF,CAAWxC,MAAXwC,CAAAA,GAAqBD,KAAK,CAAC9B,QAAnD;IAGA,IAAIgC,eAAe,GAAG,CAACxC,MAAvB,EAA+B;MAC7B,OAAON,YAAY,CAACgD,OAApB;IACD;IAED,IAAIF,eAAe,GAAGxC,MAAtB,EAA8B;MAC5B,OAAON,YAAY,CAACiD,YAApB;IACD;IAED,OAAOjD,YAAY,CAACkD,MAApB;EACD;AApI2D","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {NumericArray, Vector3} from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport {INTERSECTION} from '../../constants';\nimport {BoundingVolume} from './bounding-volume';\nimport Plane from '../plane';\n\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\n\n/** A BoundingSphere */\nexport default class BoundingSphere implements BoundingVolume {\n  center: Vector3;\n  radius: number;\n\n  /** Creates a bounding sphere */\n  constructor(center: readonly number[] = [0, 0, 0], radius: number = 0.0) {\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  /** Sets the bounding sphere from `center` and `radius`. */\n  fromCenterRadius(center: readonly number[], radius: number): this {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  /**\n   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n   * tightly and fully encompasses the box.\n   */\n  fromCornerPoints(corner: readonly number[], oppositeCorner: readonly number[]): this {\n    oppositeCorner = scratchVector.from(oppositeCorner);\n    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  /** Compares the provided BoundingSphere component wise */\n  equals(right: BoundingSphere): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.radius === right.radius)\n    );\n  }\n\n  /** Duplicates a BoundingSphere instance. */\n  clone(): BoundingSphere {\n    return new BoundingSphere(this.center, this.radius);\n  }\n\n  /** Computes a bounding sphere that contains both the left and right bounding spheres. */\n  union(boundingSphere: BoundingSphere): BoundingSphere {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n\n    const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      // Left sphere wins.\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      // Right sphere wins.\n      return boundingSphere.clone();\n    }\n\n    // There are two tangent points, one on far side of each sphere.\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n    // Compute the center point halfway between the two tangent points.\n    scratchVector2\n      .copy(toRightCenter)\n      .scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation)\n      .add(leftCenter);\n\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n\n    return this;\n  }\n\n  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */\n  expand(point: readonly number[]): this {\n    const scratchPoint = scratchVector.from(point);\n    const radius = scratchPoint.subtract(this.center).magnitude();\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n    return this;\n  }\n\n  // BoundingVolume interface\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param sphere The bounding sphere to apply the transformation to.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns self.\n   */\n  transform(transform: readonly number[]): this {\n    this.center.transform(transform);\n    const scale = mat4.getScaling(scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */\n  distanceSquaredTo(point: Readonly<NumericArray>): number {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */\n  distanceTo(point: Readonly<NumericArray>): number {\n    const scratchPoint = scratchVector.from(point);\n    const delta = scratchPoint.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n\n  /** Determines which side of a plane a sphere is located. */\n  intersectPlane(plane: Plane): number {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    // The center point is negative side of the plane normal\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n    // The center point and radius is positive side of the plane\n    return INTERSECTION.INSIDE;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}