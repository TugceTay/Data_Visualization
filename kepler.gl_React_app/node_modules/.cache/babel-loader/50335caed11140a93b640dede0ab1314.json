{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findDefaultLayer = findDefaultLayer;\nexports.calculateLayerData = calculateLayerData;\nexports.getLayerHoverProp = getLayerHoverProp;\nexports.renderDeckGlLayer = renderDeckGlLayer;\nexports.isLayerRenderable = isLayerRenderable;\nexports.isLayerVisible = isLayerVisible;\nexports.prepareLayersForDeck = prepareLayersForDeck;\nexports.prepareLayersToRender = prepareLayersToRender;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _baseLayer = require(\"../layers/base-layer\");\nvar _defaultSettings = require(\"../constants/default-settings\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n/**\n * Find default layers from fields\n * @type {typeof import('./layer-utils').findDefaultLayer}\n */\nfunction findDefaultLayer(dataset, layerClasses) {\n  if (!dataset) {\n    return [];\n  }\n  var layerProps = Object.keys(layerClasses).reduce(function (previous, lc) {\n    var result = typeof layerClasses[lc].findDefaultLayerProps === 'function' ? layerClasses[lc].findDefaultLayerProps(dataset, previous) : {\n      props: []\n    };\n    var props = Array.isArray(result) ? result : result.props || [];\n    var foundLayers = result.foundLayers || previous;\n    return foundLayers.concat(props.map(function (p) {\n      return _objectSpread(_objectSpread({}, p), {}, {\n        type: lc,\n        dataId: dataset.id\n      });\n    }));\n  }, []); // go through all layerProps to create layer\n\n  return layerProps.map(function (props) {\n    var layer = new layerClasses[props.type](props);\n    return typeof layer.setInitialLayerConfig === 'function' && dataset.dataContainer ? layer.setInitialLayerConfig(dataset) : layer;\n  });\n}\n/**\n * calculate layer data based on layer type, col Config,\n * return updated layer if colorDomain, dataMap has changed\n * @type {typeof import('./layer-utils').calculateLayerData}\n */\n\nfunction calculateLayerData(layer, state, oldLayerData) {\n  var type = layer.type;\n  if (!type || !layer.hasAllColumns() || !layer.config.dataId) {\n    return {\n      layer: layer,\n      layerData: {}\n    };\n  }\n  var layerData = layer.formatLayerData(state.datasets, oldLayerData);\n  return {\n    layerData: layerData,\n    layer: layer\n  };\n}\n/**\n * Calculate props passed to LayerHoverInfo\n * @type {typeof import('./layer-utils').getLayerHoverProp}\n */\n\nfunction getLayerHoverProp(_ref) {\n  var interactionConfig = _ref.interactionConfig,\n    hoverInfo = _ref.hoverInfo,\n    layers = _ref.layers,\n    layersToRender = _ref.layersToRender,\n    datasets = _ref.datasets;\n  if (interactionConfig.tooltip.enabled && hoverInfo && hoverInfo.picked) {\n    // if anything hovered\n    var object = hoverInfo.object,\n      overlay = hoverInfo.layer; // deckgl layer to kepler-gl layer\n\n    var layer = layers[overlay.props.idx];\n    if (object && layer && layer.getHoverData && layersToRender[layer.id]) {\n      // if layer is visible and have hovered data\n      var dataId = layer.config.dataId;\n      if (!dataId) {\n        return null;\n      }\n      var _datasets$dataId = datasets[dataId],\n        dataContainer = _datasets$dataId.dataContainer,\n        fields = _datasets$dataId.fields;\n      var data = layer.getHoverData(object, dataContainer, fields);\n      var fieldsToShow = interactionConfig.tooltip.config.fieldsToShow[dataId];\n      return {\n        data: data,\n        fields: fields,\n        fieldsToShow: fieldsToShow,\n        layer: layer\n      };\n    }\n  }\n  return null;\n}\nfunction renderDeckGlLayer(props, layerCallbacks, idx) {\n  var datasets = props.datasets,\n    layers = props.layers,\n    layerData = props.layerData,\n    hoverInfo = props.hoverInfo,\n    clicked = props.clicked,\n    mapState = props.mapState,\n    interactionConfig = props.interactionConfig,\n    animationConfig = props.animationConfig,\n    mapLayers = props.mapLayers;\n  var layer = layers[idx];\n  var data = layerData[idx];\n  var _ref2 = datasets[layer.config.dataId] || {},\n    gpuFilter = _ref2.gpuFilter;\n  var objectHovered = clicked || hoverInfo;\n  var visible = !mapLayers || mapLayers && mapLayers[layer.id]; // Layer is Layer class\n\n  return layer.renderLayer({\n    data: data,\n    gpuFilter: gpuFilter,\n    idx: idx,\n    interactionConfig: interactionConfig,\n    layerCallbacks: layerCallbacks,\n    mapState: mapState,\n    animationConfig: animationConfig,\n    objectHovered: objectHovered,\n    visible: visible\n  });\n}\nfunction isLayerRenderable(layer, layerData) {\n  return layer.id !== _defaultSettings.GEOCODER_LAYER_ID && layer.shouldRenderLayer(layerData);\n}\nfunction isLayerVisible(layer, mapLayers) {\n  return layer.config.isVisible && (\n  // if layer.id is not in mapLayers, don't render it\n  !mapLayers || mapLayers && mapLayers[layer.id]);\n} // Prepare a dict of layers rendered by the deck.gl\n// Note, isVisible: false layer is passed to deck.gl here\n// return {[id]: true \\ false}\n\nfunction prepareLayersForDeck(layers, layerData) {\n  return layers.reduce(function (accu, layer, idx) {\n    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, layer.id, isLayerRenderable(layer, layerData[idx]) && layer.overlayType === _baseLayer.OVERLAY_TYPE.deckgl));\n  }, {});\n} // Prepare a dict of rendered layers rendered in the map\n// This includes only the visibile layers for single map view and split map view\n// return {[id]: true \\ false}\n\nfunction prepareLayersToRender(layers, layerData, mapLayers) {\n  return layers.reduce(function (accu, layer, idx) {\n    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, layer.id, isLayerRenderable(layer, layerData[idx]) && isLayerVisible(layer, mapLayers)));\n  }, {});\n}","map":{"version":3,"sources":["../../src/utils/layer-utils.js"],"names":["findDefaultLayer","dataset","layerClasses","layerProps","keys","reduce","previous","lc","result","findDefaultLayerProps","props","Array","isArray","foundLayers","concat","map","p","type","dataId","id","layer","setInitialLayerConfig","dataContainer","calculateLayerData","state","oldLayerData","hasAllColumns","config","layerData","formatLayerData","datasets","getLayerHoverProp","interactionConfig","hoverInfo","layers","layersToRender","tooltip","enabled","picked","object","overlay","idx","getHoverData","fields","data","fieldsToShow","renderDeckGlLayer","layerCallbacks","clicked","mapState","animationConfig","mapLayers","gpuFilter","objectHovered","visible","renderLayer","isLayerRenderable","GEOCODER_LAYER_ID","shouldRenderLayer","isLayerVisible","isVisible","prepareLayersForDeck","accu","overlayType","OVERLAY_TYPE","deckgl","prepareLayersToRender"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {OVERLAY_TYPE} from 'layers/base-layer';\nimport {GEOCODER_LAYER_ID} from 'constants/default-settings';\n\n/**\n * Find default layers from fields\n * @type {typeof import('./layer-utils').findDefaultLayer}\n */\nexport function findDefaultLayer(dataset, layerClasses) {\n  if (!dataset) {\n    return [];\n  }\n  const layerProps = Object.keys(layerClasses).reduce((previous, lc) => {\n    const result =\n      typeof layerClasses[lc].findDefaultLayerProps === 'function'\n        ? layerClasses[lc].findDefaultLayerProps(dataset, previous)\n        : {props: []};\n\n    const props = Array.isArray(result) ? result : result.props || [];\n    const foundLayers = result.foundLayers || previous;\n\n    return foundLayers.concat(\n      props.map(p => ({\n        ...p,\n        type: lc,\n        dataId: dataset.id\n      }))\n    );\n  }, []);\n\n  // go through all layerProps to create layer\n  return layerProps.map(props => {\n    const layer = new layerClasses[props.type](props);\n    return typeof layer.setInitialLayerConfig === 'function' && dataset.dataContainer\n      ? layer.setInitialLayerConfig(dataset)\n      : layer;\n  });\n}\n\n/**\n * calculate layer data based on layer type, col Config,\n * return updated layer if colorDomain, dataMap has changed\n * @type {typeof import('./layer-utils').calculateLayerData}\n */\nexport function calculateLayerData(layer, state, oldLayerData) {\n  const {type} = layer;\n\n  if (!type || !layer.hasAllColumns() || !layer.config.dataId) {\n    return {layer, layerData: {}};\n  }\n\n  const layerData = layer.formatLayerData(state.datasets, oldLayerData);\n  return {layerData, layer};\n}\n\n/**\n * Calculate props passed to LayerHoverInfo\n * @type {typeof import('./layer-utils').getLayerHoverProp}\n */\nexport function getLayerHoverProp({\n  interactionConfig,\n  hoverInfo,\n  layers,\n  layersToRender,\n  datasets\n}) {\n  if (interactionConfig.tooltip.enabled && hoverInfo && hoverInfo.picked) {\n    // if anything hovered\n    const {object, layer: overlay} = hoverInfo;\n\n    // deckgl layer to kepler-gl layer\n    const layer = layers[overlay.props.idx];\n\n    if (object && layer && layer.getHoverData && layersToRender[layer.id]) {\n      // if layer is visible and have hovered data\n      const {\n        config: {dataId}\n      } = layer;\n      if (!dataId) {\n        return null;\n      }\n      const {dataContainer, fields} = datasets[dataId];\n      const data = layer.getHoverData(object, dataContainer, fields);\n      const fieldsToShow = interactionConfig.tooltip.config.fieldsToShow[dataId];\n\n      return {\n        data,\n        fields,\n        fieldsToShow,\n        layer\n      };\n    }\n  }\n\n  return null;\n}\n\nexport function renderDeckGlLayer(props, layerCallbacks, idx) {\n  const {\n    datasets,\n    layers,\n    layerData,\n    hoverInfo,\n    clicked,\n    mapState,\n    interactionConfig,\n    animationConfig,\n    mapLayers\n  } = props;\n  const layer = layers[idx];\n  const data = layerData[idx];\n  const {gpuFilter} = datasets[layer.config.dataId] || {};\n  const objectHovered = clicked || hoverInfo;\n  const visible = !mapLayers || (mapLayers && mapLayers[layer.id]);\n  // Layer is Layer class\n  return layer.renderLayer({\n    data,\n    gpuFilter,\n    idx,\n    interactionConfig,\n    layerCallbacks,\n    mapState,\n    animationConfig,\n    objectHovered,\n    visible\n  });\n}\n\nexport function isLayerRenderable(layer, layerData) {\n  return layer.id !== GEOCODER_LAYER_ID && layer.shouldRenderLayer(layerData);\n}\n\nexport function isLayerVisible(layer, mapLayers) {\n  return (\n    layer.config.isVisible &&\n    // if layer.id is not in mapLayers, don't render it\n    (!mapLayers || (mapLayers && mapLayers[layer.id]))\n  );\n}\n\n// Prepare a dict of layers rendered by the deck.gl\n// Note, isVisible: false layer is passed to deck.gl here\n// return {[id]: true \\ false}\nexport function prepareLayersForDeck(layers, layerData) {\n  return layers.reduce(\n    (accu, layer, idx) => ({\n      ...accu,\n      [layer.id]:\n        isLayerRenderable(layer, layerData[idx]) && layer.overlayType === OVERLAY_TYPE.deckgl\n    }),\n    {}\n  );\n}\n\n// Prepare a dict of rendered layers rendered in the map\n// This includes only the visibile layers for single map view and split map view\n// return {[id]: true \\ false}\nexport function prepareLayersToRender(layers, layerData, mapLayers) {\n  return layers.reduce(\n    (accu, layer, idx) => ({\n      ...accu,\n      [layer.id]: isLayerRenderable(layer, layerData[idx]) && isLayerVisible(layer, mapLayers)\n    }),\n    {}\n  );\n}\n"]},"metadata":{},"sourceType":"script"}