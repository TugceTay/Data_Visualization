{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport BinSorter from './utils/bin-sorter';\nimport { pointToDensityGridDataCPU } from './cpu-grid-layer/grid-aggregator';\nvar GridAggregationLayer = function (_AggregationLayer) {\n  _inherits(GridAggregationLayer, _AggregationLayer);\n  function GridAggregationLayer() {\n    _classCallCheck(this, GridAggregationLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(GridAggregationLayer).apply(this, arguments));\n  }\n  _createClass(GridAggregationLayer, [{\n    key: \"initializeState\",\n    value: function initializeState(_ref) {\n      var dimensions = _ref.dimensions;\n      var gl = this.context.gl;\n      _get(_getPrototypeOf(GridAggregationLayer.prototype), \"initializeState\", this).call(this, dimensions);\n      this.setState({\n        layerData: {},\n        gpuGridAggregator: new GPUGridAggregator(gl, {\n          id: \"\".concat(this.id, \"-gpu-aggregator\")\n        }),\n        cpuGridAggregator: pointToDensityGridDataCPU\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      _get(_getPrototypeOf(GridAggregationLayer.prototype), \"updateState\", this).call(this, opts);\n      this.updateAggregationState(opts);\n      var _this$state = this.state,\n        aggregationDataDirty = _this$state.aggregationDataDirty,\n        aggregationWeightsDirty = _this$state.aggregationWeightsDirty,\n        gpuAggregation = _this$state.gpuAggregation;\n      if (this.getNumInstances() <= 0) {\n        return;\n      }\n      var aggregationDirty = false;\n      if (aggregationDataDirty || gpuAggregation && aggregationWeightsDirty) {\n        this._updateAggregation(opts);\n        aggregationDirty = true;\n      }\n      if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n        this._updateWeightBins();\n        this._uploadAggregationResults();\n        aggregationDirty = true;\n      }\n      this.setState({\n        aggregationDirty: aggregationDirty\n      });\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      var count = this.state.weights.count;\n      if (count && count.aggregationBuffer) {\n        count.aggregationBuffer[\"delete\"]();\n      }\n      var gpuGridAggregator = this.state.gpuGridAggregator;\n      if (gpuGridAggregator) {\n        gpuGridAggregator[\"delete\"]();\n      }\n      _get(_getPrototypeOf(GridAggregationLayer.prototype), \"finalizeState\", this).call(this);\n    }\n  }, {\n    key: \"updateShaders\",\n    value: function updateShaders(shaders) {\n      if (this.state.gpuAggregation) {\n        this.state.gpuGridAggregator.updateShaders(shaders);\n      }\n    }\n  }, {\n    key: \"updateAggregationState\",\n    value: function updateAggregationState(opts) {\n      log.assert(false);\n    }\n  }, {\n    key: \"allocateResources\",\n    value: function allocateResources(numRow, numCol) {\n      if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n        var dataBytes = numCol * numRow * 4 * 4;\n        var gl = this.context.gl;\n        var weights = this.state.weights;\n        for (var name in weights) {\n          var weight = weights[name];\n          if (weight.aggregationBuffer) {\n            weight.aggregationBuffer[\"delete\"]();\n          }\n          weight.aggregationBuffer = new Buffer(gl, {\n            byteLength: dataBytes,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: \"updateResults\",\n    value: function updateResults(_ref2) {\n      var aggregationData = _ref2.aggregationData,\n        maxMinData = _ref2.maxMinData,\n        maxData = _ref2.maxData,\n        minData = _ref2.minData;\n      var count = this.state.weights.count;\n      if (count) {\n        count.aggregationData = aggregationData;\n        count.maxMinData = maxMinData;\n        count.maxData = maxData;\n        count.minData = minData;\n      }\n    }\n  }, {\n    key: \"_updateAggregation\",\n    value: function _updateAggregation(opts) {\n      var _this$state2 = this.state,\n        cpuGridAggregator = _this$state2.cpuGridAggregator,\n        gpuGridAggregator = _this$state2.gpuGridAggregator,\n        gridOffset = _this$state2.gridOffset,\n        posOffset = _this$state2.posOffset,\n        _this$state2$translat = _this$state2.translation,\n        translation = _this$state2$translat === void 0 ? [0, 0] : _this$state2$translat,\n        _this$state2$scaling = _this$state2.scaling,\n        scaling = _this$state2$scaling === void 0 ? [0, 0, 0] : _this$state2$scaling,\n        boundingBox = _this$state2.boundingBox,\n        projectPoints = _this$state2.projectPoints,\n        gpuAggregation = _this$state2.gpuAggregation,\n        numCol = _this$state2.numCol,\n        numRow = _this$state2.numRow;\n      var props = opts.props;\n      var viewport = this.context.viewport;\n      var attributes = this.getAttributes();\n      var vertexCount = this.getNumInstances();\n      if (!gpuAggregation) {\n        var result = cpuGridAggregator(props, {\n          gridOffset: gridOffset,\n          projectPoints: projectPoints,\n          attributes: attributes,\n          viewport: viewport,\n          posOffset: posOffset,\n          boundingBox: boundingBox\n        });\n        this.setState({\n          layerData: result\n        });\n      } else {\n        var weights = this.state.weights;\n        gpuGridAggregator.run({\n          weights: weights,\n          cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n          numCol: numCol,\n          numRow: numRow,\n          translation: translation,\n          scaling: scaling,\n          vertexCount: vertexCount,\n          projectPoints: projectPoints,\n          attributes: attributes,\n          moduleSettings: this.getModuleSettings()\n        });\n      }\n    }\n  }, {\n    key: \"_updateWeightBins\",\n    value: function _updateWeightBins() {\n      var getValue = this.state.getValue;\n      var sortedBins = new BinSorter(this.state.layerData.data || [], {\n        getValue: getValue\n      });\n      this.setState({\n        sortedBins: sortedBins\n      });\n    }\n  }, {\n    key: \"_uploadAggregationResults\",\n    value: function _uploadAggregationResults() {\n      var _this$state3 = this.state,\n        numCol = _this$state3.numCol,\n        numRow = _this$state3.numRow;\n      var data = this.state.layerData.data;\n      var _this$state$sortedBin = this.state.sortedBins,\n        aggregatedBins = _this$state$sortedBin.aggregatedBins,\n        minValue = _this$state$sortedBin.minValue,\n        maxValue = _this$state$sortedBin.maxValue,\n        totalCount = _this$state$sortedBin.totalCount;\n      var ELEMENTCOUNT = 4;\n      var aggregationSize = numCol * numRow * ELEMENTCOUNT;\n      var aggregationData = new Float32Array(aggregationSize).fill(0);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = aggregatedBins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var bin = _step.value;\n          var _data$bin$i = data[bin.i],\n            lonIdx = _data$bin$i.lonIdx,\n            latIdx = _data$bin$i.latIdx;\n          var value = bin.value,\n            counts = bin.counts;\n          var cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n          aggregationData[cellIndex] = value;\n          aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      var maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n      var maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n      var minData = new Float32Array([minValue, 0, 0, totalCount]);\n      this.updateResults({\n        aggregationData: aggregationData,\n        maxMinData: maxMinData,\n        maxData: maxData,\n        minData: minData\n      });\n    }\n  }]);\n  return GridAggregationLayer;\n}(AggregationLayer);\nexport { GridAggregationLayer as default };\nGridAggregationLayer.layerName = 'GridAggregationLayer';","map":{"version":3,"sources":["../../src/grid-aggregation-layer.js"],"names":["AggregationLayer","GPUGridAggregator","Buffer","log","BinSorter","pointToDensityGridDataCPU","GridAggregationLayer","dimensions","gl","context","setState","layerData","gpuGridAggregator","id","cpuGridAggregator","opts","updateAggregationState","aggregationDataDirty","aggregationWeightsDirty","gpuAggregation","state","getNumInstances","aggregationDirty","_updateAggregation","_updateWeightBins","_uploadAggregationResults","count","weights","aggregationBuffer","shaders","updateShaders","assert","numRow","numCol","dataBytes","name","weight","byteLength","accessor","size","type","divisor","aggregationData","maxMinData","maxData","minData","gridOffset","posOffset","translation","scaling","boundingBox","projectPoints","props","viewport","attributes","getAttributes","vertexCount","result","run","cellSize","xOffset","yOffset","moduleSettings","getModuleSettings","getValue","sortedBins","data","aggregatedBins","minValue","maxValue","totalCount","ELEMENTCOUNT","aggregationSize","Float32Array","fill","bin","lonIdx","latIdx","i","value","counts","cellIndex","updateResults","layerName"],"mappings":";;;;;;AAoBA,OAAOA,gBAAP,MAA6B,qBAA7B;AACA,OAAOC,iBAAP,MAA8B,kDAA9B;AACA,SAAQC,MAAR,QAAqB,eAArB;AACA,SAAQC,GAAR,QAAkB,eAAlB;AAEA,OAAOC,SAAP,MAAsB,oBAAtB;AACA,SAAQC,yBAAR,QAAwC,kCAAxC;IAEqBC,oB;;;;;;;;0CACW;MAAA,IAAbC,UAAa,GAAA,IAAA,CAAbA,UAAa;MAAA,IACrBC,EADqB,GACf,IAAA,CAAKC,OADU,CACrBD,EADqB;MAE5B,IAAA,CAAA,eAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,EAAA,iBAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAsBD,UAAtB,CAAA;MACA,IAAA,CAAKG,QAAL,CAAc;QAEZC,SAAS,EAAE,CAAA,CAFC;QAGZC,iBAAiB,EAAE,IAAIX,iBAAJ,CAAsBO,EAAtB,EAA0B;UAACK,EAAE,EAAA,EAAA,CAAA,MAAA,CAAK,IAAA,CAAKA,EAAV,EAAA,iBAAA;QAAH,CAA1B,CAHP;QAIZC,iBAAiB,EAAET;MAJP,CAAd,CAAA;IAMD;;;gCAEWU,I,EAAM;MAEhB,IAAA,CAAA,eAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,EAAA,aAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAkBA,IAAlB,CAAA;MAEA,IAAA,CAAKC,sBAAL,CAA4BD,IAA5B,CAAA;MAJgB,IAAA,WAAA,GAMwD,IAAA,CAAKK,KAN7D;QAMTH,oBANS,GAAA,WAAA,CAMTA,oBANS;QAMaC,uBANb,GAAA,WAAA,CAMaA,uBANb;QAMsCC,cANtC,GAAA,WAAA,CAMsCA,cANtC;MAOhB,IAAI,IAAA,CAAKE,eAAL,EAAA,IAA0B,CAA9B,EAAiC;QAC/B;MACD;MACD,IAAIC,gBAAgB,GAAG,KAAvB;MAMA,IAAIL,oBAAoB,IAAKE,cAAc,IAAID,uBAA/C,EAAyE;QACvE,IAAA,CAAKK,kBAAL,CAAwBR,IAAxB,CAAA;QACAO,gBAAgB,GAAG,IAAnBA;MACD;MAED,IAAI,CAACH,cAAD,KAAoBF,oBAAoB,IAAIC,uBAA5C,CAAJ,EAA0E;QACxE,IAAA,CAAKM,iBAAL,EAAA;QACA,IAAA,CAAKC,yBAAL,EAAA;QACAH,gBAAgB,GAAG,IAAnBA;MACD;MAED,IAAA,CAAKZ,QAAL,CAAc;QAACY,gBAAgB,EAAhBA;MAAD,CAAd,CAAA;IACD;;;oCAEe;MAAA,IACPI,KADO,GACE,IAAA,CAAKN,KAAL,CAAWO,OADb,CACPD,KADO;MAEd,IAAIA,KAAK,IAAIA,KAAK,CAACE,iBAAnB,EAAsC;QACpCF,KAAK,CAACE,iBAANF,CAAAA,QAAAA,CAAAA,EAAAA;MACD;MAJa,IAKPd,iBALO,GAKc,IAAA,CAAKQ,KALnB,CAKPR,iBALO;MAMd,IAAIA,iBAAJ,EAAuB;QACrBA,iBAAiB,CAAA,QAAA,CAAjBA,EAAAA;MACD;MACD,IAAA,CAAA,eAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,EAAA,eAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;IACD;;;kCAEaiB,O,EAAS;MACrB,IAAI,IAAA,CAAKT,KAAL,CAAWD,cAAf,EAA+B;QAC7B,IAAA,CAAKC,KAAL,CAAWR,iBAAX,CAA6BkB,aAA7B,CAA2CD,OAA3C,CAAA;MACD;IACF;;;2CAIsBd,I,EAAM;MAE3BZ,GAAG,CAAC4B,MAAJ5B,CAAW,KAAXA,CAAAA;IACD;;;sCAEiB6B,M,EAAQC,M,EAAQ;MAChC,IAAI,IAAA,CAAKb,KAAL,CAAWY,MAAX,KAAsBA,MAAtB,IAAgC,IAAA,CAAKZ,KAAL,CAAWa,MAAX,KAAsBA,MAA1D,EAAkE;QAChE,IAAMC,SAAS,GAAGD,MAAM,GAAGD,MAATC,GAAkB,CAAlBA,GAAsB,CAAxC;QACA,IAAMzB,EAAE,GAAG,IAAA,CAAKC,OAAL,CAAaD,EAAxB;QAFgE,IAGzDmB,OAHyD,GAG9C,IAAA,CAAKP,KAHyC,CAGzDO,OAHyD;QAIhE,KAAK,IAAMQ,IAAX,IAAmBR,OAAnB,EAA4B;UAC1B,IAAMS,MAAM,GAAGT,OAAO,CAACQ,IAAD,CAAtB;UACA,IAAIC,MAAM,CAACR,iBAAX,EAA8B;YAC5BQ,MAAM,CAACR,iBAAPQ,CAAAA,QAAAA,CAAAA,EAAAA;UACD;UACDA,MAAM,CAACR,iBAAPQ,GAA2B,IAAIlC,MAAJ,CAAWM,EAAX,EAAe;YACxC6B,UAAU,EAAEH,SAD4B;YAExCI,QAAQ,EAAE;cACRC,IAAI,EAAE,CADE;cAERC,IAAI,EAAA,IAFI;cAGRC,OAAO,EAAE;YAHD;UAF8B,CAAf,CAA3BL;QAQD;MACF;IACF;;;yCAE8D;MAAA,IAAhDM,eAAgD,GAAA,KAAA,CAAhDA,eAAgD;QAA/BC,UAA+B,GAAA,KAAA,CAA/BA,UAA+B;QAAnBC,OAAmB,GAAA,KAAA,CAAnBA,OAAmB;QAAVC,OAAU,GAAA,KAAA,CAAVA,OAAU;MAAA,IACtDnB,KADsD,GAC7C,IAAA,CAAKN,KAAL,CAAWO,OADkC,CACtDD,KADsD;MAE7D,IAAIA,KAAJ,EAAW;QACTA,KAAK,CAACgB,eAANhB,GAAwBgB,eAAxBhB;QACAA,KAAK,CAACiB,UAANjB,GAAmBiB,UAAnBjB;QACAA,KAAK,CAACkB,OAANlB,GAAgBkB,OAAhBlB;QACAA,KAAK,CAACmB,OAANnB,GAAgBmB,OAAhBnB;MACD;IACF;;;uCAIkBX,I,EAAM;MAAA,IAAA,YAAA,GAanB,IAAA,CAAKK,KAbc;QAErBN,iBAFqB,GAAA,YAAA,CAErBA,iBAFqB;QAGrBF,iBAHqB,GAAA,YAAA,CAGrBA,iBAHqB;QAIrBkC,UAJqB,GAAA,YAAA,CAIrBA,UAJqB;QAKrBC,SALqB,GAAA,YAAA,CAKrBA,SALqB;QAAA,qBAAA,GAAA,YAAA,CAMrBC,WANqB;QAMrBA,WANqB,GAAA,qBAAA,KAAA,KAAA,CAAA,GAMP,CAAC,CAAD,EAAI,CAAJ,CANO,GAAA,qBAAA;QAAA,oBAAA,GAAA,YAAA,CAOrBC,OAPqB;QAOrBA,OAPqB,GAAA,oBAAA,KAAA,KAAA,CAAA,GAOX,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAPW,GAAA,oBAAA;QAQrBC,WARqB,GAAA,YAAA,CAQrBA,WARqB;QASrBC,aATqB,GAAA,YAAA,CASrBA,aATqB;QAUrBhC,cAVqB,GAAA,YAAA,CAUrBA,cAVqB;QAWrBc,MAXqB,GAAA,YAAA,CAWrBA,MAXqB;QAYrBD,MAZqB,GAAA,YAAA,CAYrBA,MAZqB;MAAA,IAchBoB,KAdgB,GAcPrC,IAdO,CAchBqC,KAdgB;MAAA,IAehBC,QAfgB,GAeJ,IAAA,CAAK5C,OAfD,CAehB4C,QAfgB;MAgBvB,IAAMC,UAAU,GAAG,IAAA,CAAKC,aAAL,EAAnB;MACA,IAAMC,WAAW,GAAG,IAAA,CAAKnC,eAAL,EAApB;MAEA,IAAI,CAACF,cAAL,EAAqB;QACnB,IAAMsC,MAAM,GAAG3C,iBAAiB,CAACsC,KAAD,EAAQ;UACtCN,UAAU,EAAVA,UADsC;UAEtCK,aAAa,EAAbA,aAFsC;UAGtCG,UAAU,EAAVA,UAHsC;UAItCD,QAAQ,EAARA,QAJsC;UAKtCN,SAAS,EAATA,SALsC;UAMtCG,WAAW,EAAXA;QANsC,CAAR,CAAhC;QAQA,IAAA,CAAKxC,QAAL,CAAc;UACZC,SAAS,EAAE8C;QADC,CAAd,CAAA;MAGD,CAZD,MAYO;QAAA,IACE9B,OADF,GACa,IAAA,CAAKP,KADlB,CACEO,OADF;QAELf,iBAAiB,CAAC8C,GAAlB9C,CAAsB;UACpBe,OAAO,EAAPA,OADoB;UAEpBgC,QAAQ,EAAE,CAACb,UAAU,CAACc,OAAZ,EAAqBd,UAAU,CAACe,OAAhC,CAFU;UAGpB5B,MAAM,EAANA,MAHoB;UAIpBD,MAAM,EAANA,MAJoB;UAKpBgB,WAAW,EAAXA,WALoB;UAMpBC,OAAO,EAAPA,OANoB;UAOpBO,WAAW,EAAXA,WAPoB;UAQpBL,aAAa,EAAbA,aARoB;UASpBG,UAAU,EAAVA,UAToB;UAUpBQ,cAAc,EAAE,IAAA,CAAKC,iBAAL;QAVI,CAAtBnD,CAAAA;MAYD;IACF;;;wCAEmB;MAAA,IACXoD,QADW,GACC,IAAA,CAAK5C,KADN,CACX4C,QADW;MAGlB,IAAMC,UAAU,GAAG,IAAI7D,SAAJ,CAAc,IAAA,CAAKgB,KAAL,CAAWT,SAAX,CAAqBuD,IAArB,IAA6B,EAA3C,EAA+C;QAACF,QAAQ,EAARA;MAAD,CAA/C,CAAnB;MACA,IAAA,CAAKtD,QAAL,CAAc;QAACuD,UAAU,EAAVA;MAAD,CAAd,CAAA;IACD;;;gDAE2B;MAAA,IAAA,YAAA,GACD,IAAA,CAAK7C,KADJ;QACnBa,MADmB,GAAA,YAAA,CACnBA,MADmB;QACXD,MADW,GAAA,YAAA,CACXA,MADW;MAAA,IAEnBkC,IAFmB,GAEX,IAAA,CAAK9C,KAAL,CAAWT,SAFA,CAEnBuD,IAFmB;MAAA,IAAA,qBAAA,GAG+B,IAAA,CAAK9C,KAAL,CAAW6C,UAH1C;QAGnBE,cAHmB,GAAA,qBAAA,CAGnBA,cAHmB;QAGHC,QAHG,GAAA,qBAAA,CAGHA,QAHG;QAGOC,QAHP,GAAA,qBAAA,CAGOA,QAHP;QAGiBC,UAHjB,GAAA,qBAAA,CAGiBA,UAHjB;MAK1B,IAAMC,YAAY,GAAG,CAArB;MACA,IAAMC,eAAe,GAAGvC,MAAM,GAAGD,MAATC,GAAkBsC,YAA1C;MACA,IAAM7B,eAAe,GAAG,IAAI+B,YAAJ,CAAiBD,eAAjB,CAAA,CAAkCE,IAAlC,CAAuC,CAAvC,CAAxB;MAP0B,IAAA,yBAAA,GAAA,IAAA;MAAA,IAAA,iBAAA,GAAA,KAAA;MAAA,IAAA,cAAA,GAAA,SAAA;MAAA,IAAA;QAQ1B,KAAA,IAAA,SAAA,GAAkBP,cAAlB,CAAA,MAAA,CAAA,QAAA,CAAA,EAAA,EAAA,KAAA,EAAA,EAAA,yBAAA,GAAA,CAAA,KAAA,GAAA,SAAA,CAAA,IAAA,EAAA,EAAA,IAAA,CAAA,EAAA,yBAAA,GAAA,IAAA,EAAkC;UAAA,IAAvBQ,GAAuB,GAAA,KAAA,CAAA,KAAA;UAAA,IAAA,WAAA,GACPT,IAAI,CAACS,GAAG,CAACG,CAAL,CADG;YACzBF,MADyB,GAAA,WAAA,CACzBA,MADyB;YACjBC,MADiB,GAAA,WAAA,CACjBA,MADiB;UAAA,IAEzBE,KAFyB,GAERJ,GAFQ,CAEzBI,KAFyB;YAElBC,MAFkB,GAERL,GAFQ,CAElBK,MAFkB;UAGhC,IAAMC,SAAS,GAAG,CAACL,MAAM,GAAGC,MAAM,GAAG5C,MAAnB,IAA6BsC,YAA/C;UACA7B,eAAe,CAACuC,SAAD,CAAfvC,GAA6BqC,KAA7BrC;UACAA,eAAe,CAACuC,SAAS,GAAGV,YAAZU,GAA2B,CAA5B,CAAfvC,GAAgDsC,MAAhDtC;QACD;MAdyB,CAAA,CAAA,OAAA,GAAA,EAAA;QAAA,iBAAA,GAAA,IAAA;QAAA,cAAA,GAAA,GAAA;MAAA,CAAA,SAAA;QAAA,IAAA;UAAA,IAAA,CAAA,yBAAA,IAAA,SAAA,CAAA,QAAA,CAAA,IAAA,IAAA,EAAA;YAAA,SAAA,CAAA,QAAA,CAAA,EAAA;UAAA;QAAA,CAAA,SAAA;UAAA,IAAA,iBAAA,EAAA;YAAA,MAAA,cAAA;UAAA;QAAA;MAAA;MAe1B,IAAMC,UAAU,GAAG,IAAI8B,YAAJ,CAAiB,CAACJ,QAAD,EAAW,CAAX,EAAc,CAAd,EAAiBD,QAAjB,CAAjB,CAAnB;MACA,IAAMxB,OAAO,GAAG,IAAI6B,YAAJ,CAAiB,CAACJ,QAAD,EAAW,CAAX,EAAc,CAAd,EAAiBC,UAAjB,CAAjB,CAAhB;MACA,IAAMzB,OAAO,GAAG,IAAI4B,YAAJ,CAAiB,CAACL,QAAD,EAAW,CAAX,EAAc,CAAd,EAAiBE,UAAjB,CAAjB,CAAhB;MACA,IAAA,CAAKY,aAAL,CAAmB;QAACxC,eAAe,EAAfA,eAAD;QAAkBC,UAAU,EAAVA,UAAlB;QAA8BC,OAAO,EAAPA,OAA9B;QAAuCC,OAAO,EAAPA;MAAvC,CAAnB,CAAA;IACD;;;EA/K+C7C,gB;SAA7BM,oB;AAkLrBA,oBAAoB,CAAC6E,SAArB7E,GAAiC,sBAAjCA","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {Buffer} from '@luma.gl/core';\nimport {log} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport BinSorter from './utils/bin-sorter';\nimport {pointToDensityGridDataCPU} from './cpu-grid-layer/grid-aggregator';\n\nexport default class GridAggregationLayer extends AggregationLayer {\n  initializeState({dimensions}) {\n    const {gl} = this.context;\n    super.initializeState(dimensions);\n    this.setState({\n      // CPU aggregation results\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {id: `${this.id}-gpu-aggregator`}),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts) {\n    // get current attributes\n    super.updateState(opts);\n\n    this.updateAggregationState(opts);\n\n    const {aggregationDataDirty, aggregationWeightsDirty, gpuAggregation} = this.state;\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n    let aggregationDirty = false;\n    // CPU aggregation is two steps\n    // 1. Create bins (based on cellSize and position) 2. Aggregate weights for each bin\n    // For GPU aggregation both above steps are combined into one step\n\n    // step-1\n    if (aggregationDataDirty || (gpuAggregation && aggregationWeightsDirty)) {\n      this._updateAggregation(opts);\n      aggregationDirty = true;\n    }\n    // step-2 (Applicalbe for CPU aggregation only)\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n      this._uploadAggregationResults();\n      aggregationDirty = true;\n    }\n\n    this.setState({aggregationDirty});\n  }\n\n  finalizeState() {\n    const {count} = this.state.weights;\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n    const {gpuGridAggregator} = this.state;\n    if (gpuGridAggregator) {\n      gpuGridAggregator.delete();\n    }\n    super.finalizeState();\n  }\n\n  updateShaders(shaders) {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  // Methods that can be overriden by subclasses for customizations\n\n  updateAggregationState(opts) {\n    // Sublayers should implement this method.\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {weights} = this.state;\n      for (const name in weights) {\n        const weight = weights[name];\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: GL.FLOAT,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults({aggregationData, maxMinData, maxData, minData}) {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  // Private\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {props} = opts;\n    const {viewport} = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {weights} = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {getValue} = this.state;\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {getValue});\n    this.setState({sortedBins});\n  }\n\n  _uploadAggregationResults() {\n    const {numCol, numRow} = this.state;\n    const {data} = this.state.layerData;\n    const {aggregatedBins, minValue, maxValue, totalCount} = this.state.sortedBins;\n\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n    for (const bin of aggregatedBins) {\n      const {lonIdx, latIdx} = data[bin.i];\n      const {value, counts} = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({aggregationData, maxMinData, maxData, minData});\n  }\n}\n\nGridAggregationLayer.layerName = 'GridAggregationLayer';\n"]},"metadata":{},"sourceType":"module"}