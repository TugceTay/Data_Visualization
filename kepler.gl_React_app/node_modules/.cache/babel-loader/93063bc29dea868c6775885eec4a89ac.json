{"ast":null,"code":"import { whichButtons, getOffsetPosition } from './event-utils';\nconst DEFAULT_OPTIONS = {\n  srcElement: 'root',\n  priority: 0\n};\nexport default class EventRegistrar {\n  constructor(eventManager) {\n    /**\n     * Handles hammerjs event\n     */\n    this.handleEvent = event => {\n      if (this.isEmpty()) {\n        return;\n      }\n      const mjolnirEvent = this._normalizeEvent(event);\n      let target = event.srcEvent.target;\n      while (target && target !== mjolnirEvent.rootElement) {\n        this._emit(mjolnirEvent, target);\n        if (mjolnirEvent.handled) {\n          return;\n        }\n        target = target.parentNode;\n      }\n      this._emit(mjolnirEvent, 'root');\n    };\n    this.eventManager = eventManager;\n    this.handlers = [];\n    // Element -> handler map\n    this.handlersByElement = new Map();\n    this._active = false;\n  }\n  // Returns true if there are no non-passive handlers\n  isEmpty() {\n    return !this._active;\n  }\n  add(type, handler, options) {\n    let once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n    let opts = DEFAULT_OPTIONS;\n    if (typeof options === 'string' || options && options.addEventListener) {\n      // is DOM element, backward compatibility\n      // @ts-ignore\n      opts = {\n        ...DEFAULT_OPTIONS,\n        srcElement: options\n      };\n    } else if (options) {\n      opts = {\n        ...DEFAULT_OPTIONS,\n        ...options\n      };\n    }\n    let entries = handlersByElement.get(opts.srcElement);\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n    const entry = {\n      type,\n      handler,\n      srcElement: opts.srcElement,\n      priority: opts.priority\n    };\n    if (once) {\n      entry.once = true;\n    }\n    if (passive) {\n      entry.passive = true;\n    }\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n    // Sort handlers by descending priority\n    // Handlers with the same priority are excuted in the order of registration\n    let insertPosition = entries.length - 1;\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n      insertPosition--;\n    }\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n  remove(type, handler) {\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n    this._active = handlers.some(entry => !entry.passive);\n  }\n  /**\n   * Invoke handlers on a particular element\n   */\n  _emit(event, srcElement) {\n    const entries = this.handlersByElement.get(srcElement);\n    if (entries) {\n      let immediatePropagationStopped = false;\n      // Prevents the current event from bubbling up\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      // Prevent any remaining listeners from being called\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove = [];\n      for (let i = 0; i < entries.length; i++) {\n        const {\n          type,\n          handler,\n          once\n        } = entries[i];\n        handler({\n          ...event,\n          // @ts-ignore\n          type,\n          stopPropagation,\n          stopImmediatePropagation\n        });\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {\n          type,\n          handler\n        } = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n  _normalizeEvent(event) {\n    const rootElement = this.eventManager.getElement();\n    return {\n      ...event,\n      ...whichButtons(event),\n      ...getOffsetPosition(event, rootElement),\n      preventDefault: () => {\n        event.srcEvent.preventDefault();\n      },\n      stopImmediatePropagation: null,\n      stopPropagation: null,\n      handled: false,\n      rootElement\n    };\n  }\n}","map":{"version":3,"sources":["../../../src/utils/event-registrar.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { whichButtons, getOffsetPosition } from './event-utils';\nconst DEFAULT_OPTIONS = {\n    srcElement: 'root',\n    priority: 0\n};\nexport default class EventRegistrar {\n    constructor(eventManager) {\n        /**\n         * Handles hammerjs event\n         */\n        this.handleEvent = (event) => {\n            if (this.isEmpty()) {\n                return;\n            }\n            const mjolnirEvent = this._normalizeEvent(event);\n            let target = event.srcEvent.target;\n            while (target && target !== mjolnirEvent.rootElement) {\n                this._emit(mjolnirEvent, target);\n                if (mjolnirEvent.handled) {\n                    return;\n                }\n                target = target.parentNode;\n            }\n            this._emit(mjolnirEvent, 'root');\n        };\n        this.eventManager = eventManager;\n        this.handlers = [];\n        // Element -> handler map\n        this.handlersByElement = new Map();\n        this._active = false;\n    }\n    // Returns true if there are no non-passive handlers\n    isEmpty() {\n        return !this._active;\n    }\n    add(type, handler, options, once = false, passive = false) {\n        const { handlers, handlersByElement } = this;\n        let opts = DEFAULT_OPTIONS;\n        if (typeof options === 'string' || (options && options.addEventListener)) {\n            // is DOM element, backward compatibility\n            // @ts-ignore\n            opts = { ...DEFAULT_OPTIONS, srcElement: options };\n        }\n        else if (options) {\n            opts = { ...DEFAULT_OPTIONS, ...options };\n        }\n        let entries = handlersByElement.get(opts.srcElement);\n        if (!entries) {\n            entries = [];\n            handlersByElement.set(opts.srcElement, entries);\n        }\n        const entry = {\n            type,\n            handler,\n            srcElement: opts.srcElement,\n            priority: opts.priority\n        };\n        if (once) {\n            entry.once = true;\n        }\n        if (passive) {\n            entry.passive = true;\n        }\n        handlers.push(entry);\n        this._active = this._active || !entry.passive;\n        // Sort handlers by descending priority\n        // Handlers with the same priority are excuted in the order of registration\n        let insertPosition = entries.length - 1;\n        while (insertPosition >= 0) {\n            if (entries[insertPosition].priority >= entry.priority) {\n                break;\n            }\n            insertPosition--;\n        }\n        entries.splice(insertPosition + 1, 0, entry);\n    }\n    remove(type, handler) {\n        const { handlers, handlersByElement } = this;\n        for (let i = handlers.length - 1; i >= 0; i--) {\n            const entry = handlers[i];\n            if (entry.type === type && entry.handler === handler) {\n                handlers.splice(i, 1);\n                const entries = handlersByElement.get(entry.srcElement);\n                entries.splice(entries.indexOf(entry), 1);\n                if (entries.length === 0) {\n                    handlersByElement.delete(entry.srcElement);\n                }\n            }\n        }\n        this._active = handlers.some(entry => !entry.passive);\n    }\n    /**\n     * Invoke handlers on a particular element\n     */\n    _emit(event, srcElement) {\n        const entries = this.handlersByElement.get(srcElement);\n        if (entries) {\n            let immediatePropagationStopped = false;\n            // Prevents the current event from bubbling up\n            const stopPropagation = () => {\n                event.handled = true;\n            };\n            // Prevent any remaining listeners from being called\n            const stopImmediatePropagation = () => {\n                event.handled = true;\n                immediatePropagationStopped = true;\n            };\n            const entriesToRemove = [];\n            for (let i = 0; i < entries.length; i++) {\n                const { type, handler, once } = entries[i];\n                handler({\n                    ...event,\n                    // @ts-ignore\n                    type,\n                    stopPropagation,\n                    stopImmediatePropagation\n                });\n                if (once) {\n                    entriesToRemove.push(entries[i]);\n                }\n                if (immediatePropagationStopped) {\n                    break;\n                }\n            }\n            for (let i = 0; i < entriesToRemove.length; i++) {\n                const { type, handler } = entriesToRemove[i];\n                this.remove(type, handler);\n            }\n        }\n    }\n    /**\n     * Normalizes hammerjs and custom events to have predictable fields.\n     */\n    _normalizeEvent(event) {\n        const rootElement = this.eventManager.getElement();\n        return {\n            ...event,\n            ...whichButtons(event),\n            ...getOffsetPosition(event, rootElement),\n            preventDefault: () => {\n                event.srcEvent.preventDefault();\n            },\n            stopImmediatePropagation: null,\n            stopPropagation: null,\n            handled: false,\n            rootElement\n        };\n    }\n}\n//# sourceMappingURL=event-registrar.js.map"]},"metadata":{},"sourceType":"module"}