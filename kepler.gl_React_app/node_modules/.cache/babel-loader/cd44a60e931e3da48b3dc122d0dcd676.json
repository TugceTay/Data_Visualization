{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { Model, Transform, FEATURES, hasFeatures, isWebGL2, readPixelsToBuffer, withParameters } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { log, project32, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { DEFAULT_RUN_PARAMS, MAX_32_BIT_FLOAT, MIN_BLEND_EQUATION, MAX_BLEND_EQUATION, MAX_MIN_BLEND_EQUATION, EQUATION_MAP, DEFAULT_WEIGHT_PARAMS, PIXEL_SIZE } from './gpu-grid-aggregator-constants';\nimport { AGGREGATION_OPERATION } from '../aggregation-operation-utils';\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport { getFloatTexture, getFramebuffer } from './../resource-utils.js';\nvar BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nvar ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\nvar REQUIRED_FEATURES = [FEATURES.WEBGL2, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.FLOAT_BLEND, FEATURES.TEXTURE_FLOAT];\nvar GPUGridAggregator = function () {\n  _createClass(GPUGridAggregator, null, [{\n    key: \"getAggregationData\",\n    value: function getAggregationData(_ref) {\n      var aggregationData = _ref.aggregationData,\n        maxData = _ref.maxData,\n        minData = _ref.minData,\n        maxMinData = _ref.maxMinData,\n        pixelIndex = _ref.pixelIndex;\n      var index = pixelIndex * PIXEL_SIZE;\n      var results = {};\n      if (aggregationData) {\n        results.cellCount = aggregationData[index + 3];\n        results.cellWeight = aggregationData[index];\n      }\n      if (maxMinData) {\n        results.maxCellWieght = maxMinData[0];\n        results.minCellWeight = maxMinData[3];\n      } else {\n        if (maxData) {\n          results.maxCellWieght = maxData[0];\n          results.totalCount = maxData[3];\n        }\n        if (minData) {\n          results.minCellWeight = minData[0];\n          results.totalCount = maxData[3];\n        }\n      }\n      return results;\n    }\n  }, {\n    key: \"getCellData\",\n    value: function getCellData(_ref2) {\n      var countsData = _ref2.countsData,\n        _ref2$size = _ref2.size,\n        size = _ref2$size === void 0 ? 1 : _ref2$size;\n      var numCells = countsData.length / 4;\n      var cellWeights = new Float32Array(numCells * size);\n      var cellCounts = new Uint32Array(numCells);\n      for (var i = 0; i < numCells; i++) {\n        for (var sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n          cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n        }\n        cellCounts[i] = countsData[i * 4 + 3];\n      }\n      return {\n        cellCounts: cellCounts,\n        cellWeights: cellWeights\n      };\n    }\n  }, {\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return hasFeatures(gl, REQUIRED_FEATURES);\n    }\n  }]);\n  function GPUGridAggregator(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, GPUGridAggregator);\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n      resources: {},\n      results: {}\n    };\n    this._hasGPUSupport = isWebGL2(gl) && hasFeatures(this.gl, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.TEXTURE_FLOAT);\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n  _createClass(GPUGridAggregator, [{\n    key: \"delete\",\n    value: function _delete() {\n      var gridAggregationModel = this.gridAggregationModel,\n        allAggregationModel = this.allAggregationModel,\n        meanTransform = this.meanTransform;\n      var _this$state = this.state,\n        textures = _this$state.textures,\n        framebuffers = _this$state.framebuffers,\n        maxMinFramebuffers = _this$state.maxMinFramebuffers,\n        minFramebuffers = _this$state.minFramebuffers,\n        maxFramebuffers = _this$state.maxFramebuffers,\n        meanTextures = _this$state.meanTextures,\n        resources = _this$state.resources;\n      gridAggregationModel && gridAggregationModel[\"delete\"]();\n      allAggregationModel && allAggregationModel[\"delete\"]();\n      meanTransform && meanTransform[\"delete\"]();\n      deleteResources([framebuffers, textures, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources]);\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.setState({\n        results: {}\n      });\n      var aggregationParams = this._normalizeAggregationParams(opts);\n      if (!this._hasGPUSupport) {\n        log.log(1, 'GPUGridAggregator: not supported')();\n      }\n      return this._runAggregation(aggregationParams);\n    }\n  }, {\n    key: \"getData\",\n    value: function getData(weightId) {\n      var data = {};\n      var results = this.state.results;\n      if (!results[weightId].aggregationData) {\n        results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n      }\n      data.aggregationData = results[weightId].aggregationData;\n      for (var arrayName in ARRAY_BUFFER_MAP) {\n        var bufferName = ARRAY_BUFFER_MAP[arrayName];\n        if (results[weightId][arrayName] || results[weightId][bufferName]) {\n          results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();\n          data[arrayName] = results[weightId][arrayName];\n        }\n      }\n      return data;\n    }\n  }, {\n    key: \"updateShaders\",\n    value: function updateShaders() {\n      var shaderOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.setState({\n        shaderOptions: shaderOptions,\n        modelDirty: true\n      });\n    }\n  }, {\n    key: \"_normalizeAggregationParams\",\n    value: function _normalizeAggregationParams(opts) {\n      var aggregationParams = Object.assign({}, DEFAULT_RUN_PARAMS, opts);\n      var weights = aggregationParams.weights;\n      if (weights) {\n        aggregationParams.weights = normalizeWeightParams(weights);\n      }\n      return aggregationParams;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      Object.assign(this.state, updateObject);\n    }\n  }, {\n    key: \"_getAggregateData\",\n    value: function _getAggregateData(opts) {\n      var results = {};\n      var _this$state2 = this.state,\n        textures = _this$state2.textures,\n        framebuffers = _this$state2.framebuffers,\n        maxMinFramebuffers = _this$state2.maxMinFramebuffers,\n        minFramebuffers = _this$state2.minFramebuffers,\n        maxFramebuffers = _this$state2.maxFramebuffers,\n        resources = _this$state2.resources;\n      var weights = opts.weights;\n      for (var id in weights) {\n        results[id] = {};\n        var _weights$id = weights[id],\n          needMin = _weights$id.needMin,\n          needMax = _weights$id.needMax,\n          combineMaxMin = _weights$id.combineMaxMin;\n        results[id].aggregationTexture = textures[id];\n        results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n          target: weights[id].aggregationBuffer,\n          sourceType: 5126\n        });\n        if (needMin && needMax && combineMaxMin) {\n          results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n            target: weights[id].maxMinBuffer,\n            sourceType: 5126\n          });\n          results[id].maxMinTexture = resources[\"\".concat(id, \"-maxMinTexture\")];\n        } else {\n          if (needMin) {\n            results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n              target: weights[id].minBuffer,\n              sourceType: 5126\n            });\n            results[id].minTexture = resources[\"\".concat(id, \"-minTexture\")];\n          }\n          if (needMax) {\n            results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n              target: weights[id].maxBuffer,\n              sourceType: 5126\n            });\n            results[id].maxTexture = resources[\"\".concat(id, \"-maxTexture\")];\n          }\n        }\n      }\n      this._trackGPUResultBuffers(results, weights);\n      return results;\n    }\n  }, {\n    key: \"_renderAggregateData\",\n    value: function _renderAggregateData(opts) {\n      var cellSize = opts.cellSize,\n        projectPoints = opts.projectPoints,\n        attributes = opts.attributes,\n        moduleSettings = opts.moduleSettings,\n        numCol = opts.numCol,\n        numRow = opts.numRow,\n        weights = opts.weights,\n        translation = opts.translation,\n        scaling = opts.scaling;\n      var _this$state3 = this.state,\n        maxMinFramebuffers = _this$state3.maxMinFramebuffers,\n        minFramebuffers = _this$state3.minFramebuffers,\n        maxFramebuffers = _this$state3.maxFramebuffers;\n      var gridSize = [numCol, numRow];\n      var parameters = {\n        blend: true,\n        depthTest: false,\n        blendFunc: [1, 1]\n      };\n      var uniforms = {\n        cellSize: cellSize,\n        gridSize: gridSize,\n        projectPoints: projectPoints,\n        translation: translation,\n        scaling: scaling\n      };\n      for (var id in weights) {\n        var _weights$id2 = weights[id],\n          needMin = _weights$id2.needMin,\n          needMax = _weights$id2.needMax;\n        var combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n        this._renderToWeightsTexture({\n          id: id,\n          parameters: parameters,\n          moduleSettings: moduleSettings,\n          uniforms: uniforms,\n          gridSize: gridSize,\n          attributes: attributes,\n          weights: weights\n        });\n        if (combineMaxMin) {\n          this._renderToMaxMinTexture({\n            id: id,\n            parameters: Object.assign({}, parameters, {\n              blendEquation: MAX_MIN_BLEND_EQUATION\n            }),\n            gridSize: gridSize,\n            minOrMaxFb: maxMinFramebuffers[id],\n            clearParams: {\n              clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]\n            },\n            combineMaxMin: combineMaxMin\n          });\n        } else {\n          if (needMin) {\n            this._renderToMaxMinTexture({\n              id: id,\n              parameters: Object.assign({}, parameters, {\n                blendEquation: MIN_BLEND_EQUATION\n              }),\n              gridSize: gridSize,\n              minOrMaxFb: minFramebuffers[id],\n              clearParams: {\n                clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n              },\n              combineMaxMin: combineMaxMin\n            });\n          }\n          if (needMax) {\n            this._renderToMaxMinTexture({\n              id: id,\n              parameters: Object.assign({}, parameters, {\n                blendEquation: MAX_BLEND_EQUATION\n              }),\n              gridSize: gridSize,\n              minOrMaxFb: maxFramebuffers[id],\n              clearParams: {\n                clearColor: [0, 0, 0, 0]\n              },\n              combineMaxMin: combineMaxMin\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_renderToMaxMinTexture\",\n    value: function _renderToMaxMinTexture(opts) {\n      var id = opts.id,\n        parameters = opts.parameters,\n        gridSize = opts.gridSize,\n        minOrMaxFb = opts.minOrMaxFb,\n        combineMaxMin = opts.combineMaxMin,\n        _opts$clearParams = opts.clearParams,\n        clearParams = _opts$clearParams === void 0 ? {} : _opts$clearParams;\n      var framebuffers = this.state.framebuffers;\n      var gl = this.gl,\n        allAggregationModel = this.allAggregationModel;\n      withParameters(gl, _objectSpread({}, clearParams, {\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      }), function () {\n        gl.clear(16384);\n        allAggregationModel.draw({\n          parameters: parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize: gridSize,\n            combineMaxMin: combineMaxMin\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_renderToWeightsTexture\",\n    value: function _renderToWeightsTexture(opts) {\n      var id = opts.id,\n        parameters = opts.parameters,\n        moduleSettings = opts.moduleSettings,\n        uniforms = opts.uniforms,\n        gridSize = opts.gridSize,\n        weights = opts.weights;\n      var _this$state4 = this.state,\n        framebuffers = _this$state4.framebuffers,\n        equations = _this$state4.equations,\n        weightAttributes = _this$state4.weightAttributes;\n      var gl = this.gl,\n        gridAggregationModel = this.gridAggregationModel;\n      var operation = weights[id].operation;\n      var clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];\n      withParameters(gl, {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor: clearColor\n      }, function () {\n        gl.clear(16384);\n        var attributes = {\n          weights: weightAttributes[id]\n        };\n        gridAggregationModel.draw({\n          parameters: Object.assign({}, parameters, {\n            blendEquation: equations[id]\n          }),\n          moduleSettings: moduleSettings,\n          uniforms: uniforms,\n          attributes: attributes\n        });\n      });\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        var _this$state5 = this.state,\n          meanTextures = _this$state5.meanTextures,\n          textures = _this$state5.textures;\n        var transformOptions = {\n          _sourceTextures: {\n            aggregationValues: meanTextures[id]\n          },\n          _targetTexture: textures[id],\n          elementCount: textures[id].width * textures[id].height\n        };\n        if (this.meanTransform) {\n          this.meanTransform.update(transformOptions);\n        } else {\n          this.meanTransform = getMeanTransform(gl, transformOptions);\n        }\n        this.meanTransform.run({\n          parameters: {\n            blend: false,\n            depthTest: false\n          }\n        });\n        framebuffers[id].attach(_defineProperty({}, 36064, textures[id]));\n      }\n    }\n  }, {\n    key: \"_runAggregation\",\n    value: function _runAggregation(opts) {\n      this._updateModels(opts);\n      this._setupFramebuffers(opts);\n      this._renderAggregateData(opts);\n      var results = this._getAggregateData(opts);\n      this.setState({\n        results: results\n      });\n      return results;\n    }\n  }, {\n    key: \"_setupFramebuffers\",\n    value: function _setupFramebuffers(opts) {\n      var _this$state6 = this.state,\n        textures = _this$state6.textures,\n        framebuffers = _this$state6.framebuffers,\n        maxMinFramebuffers = _this$state6.maxMinFramebuffers,\n        minFramebuffers = _this$state6.minFramebuffers,\n        maxFramebuffers = _this$state6.maxFramebuffers,\n        meanTextures = _this$state6.meanTextures,\n        equations = _this$state6.equations;\n      var weights = opts.weights;\n      var numCol = opts.numCol,\n        numRow = opts.numRow;\n      var framebufferSize = {\n        width: numCol,\n        height: numRow\n      };\n      for (var id in weights) {\n        var _weights$id3 = weights[id],\n          needMin = _weights$id3.needMin,\n          needMax = _weights$id3.needMax,\n          combineMaxMin = _weights$id3.combineMaxMin,\n          operation = _weights$id3.operation;\n        textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.gl, {\n          id: \"\".concat(id, \"-texture\"),\n          width: numCol,\n          height: numRow\n        });\n        textures[id].resize(framebufferSize);\n        var texture = textures[id];\n        if (operation === AGGREGATION_OPERATION.MEAN) {\n          meanTextures[id] = meanTextures[id] || getFloatTexture(this.gl, {\n            id: \"\".concat(id, \"-mean-texture\"),\n            width: numCol,\n            height: numRow\n          });\n          meanTextures[id].resize(framebufferSize);\n          texture = meanTextures[id];\n        }\n        if (framebuffers[id]) {\n          framebuffers[id].attach(_defineProperty({}, 36064, texture));\n        } else {\n          framebuffers[id] = getFramebuffer(this.gl, {\n            id: \"\".concat(id, \"-fb\"),\n            width: numCol,\n            height: numRow,\n            texture: texture\n          });\n        }\n        framebuffers[id].resize(framebufferSize);\n        equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n        if (needMin || needMax) {\n          if (needMin && needMax && combineMaxMin) {\n            if (!maxMinFramebuffers[id]) {\n              texture = weights[id].maxMinTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxMinTexture\"));\n              maxMinFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-maxMinFb\"),\n                texture: texture\n              });\n            }\n          } else {\n            if (needMin) {\n              if (!minFramebuffers[id]) {\n                texture = weights[id].minTexture || this._getMinMaxTexture(\"\".concat(id, \"-minTexture\"));\n                minFramebuffers[id] = getFramebuffer(this.gl, {\n                  id: \"\".concat(id, \"-minFb\"),\n                  texture: texture\n                });\n              }\n            }\n            if (needMax) {\n              if (!maxFramebuffers[id]) {\n                texture = weights[id].maxTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxTexture\"));\n                maxFramebuffers[id] = getFramebuffer(this.gl, {\n                  id: \"\".concat(id, \"-maxFb\"),\n                  texture: texture\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_getMinMaxTexture\",\n    value: function _getMinMaxTexture(name) {\n      var resources = this.state.resources;\n      if (!resources[name]) {\n        resources[name] = getFloatTexture(this.gl, {\n          id: \"resourceName\"\n        });\n      }\n      return resources[name];\n    }\n  }, {\n    key: \"_setupModels\",\n    value: function _setupModels() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$numCol = _ref3.numCol,\n        numCol = _ref3$numCol === void 0 ? 0 : _ref3$numCol,\n        _ref3$numRow = _ref3.numRow,\n        numRow = _ref3$numRow === void 0 ? 0 : _ref3$numRow;\n      var gl = this.gl;\n      var shaderOptions = this.state.shaderOptions;\n      if (this.gridAggregationModel) {\n        this.gridAggregationModel[\"delete\"]();\n      }\n      this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n      if (!this.allAggregationModel) {\n        var instanceCount = numCol * numRow;\n        this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n      }\n    }\n  }, {\n    key: \"_setupWeightAttributes\",\n    value: function _setupWeightAttributes(opts) {\n      var weightAttributes = this.state.weightAttributes;\n      var weights = opts.weights;\n      for (var id in weights) {\n        weightAttributes[id] = opts.attributes[id];\n      }\n    }\n  }, {\n    key: \"_trackGPUResultBuffers\",\n    value: function _trackGPUResultBuffers(results, weights) {\n      var resources = this.state.resources;\n      for (var id in results) {\n        if (results[id]) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n          try {\n            for (var _iterator = BUFFER_NAMES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var bufferName = _step.value;\n              if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n                var name = \"gpu-result-\".concat(id, \"-\").concat(bufferName);\n                if (resources[name]) {\n                  resources[name][\"delete\"]();\n                }\n                resources[name] = results[id][bufferName];\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateModels\",\n    value: function _updateModels(opts) {\n      var vertexCount = opts.vertexCount,\n        attributes = opts.attributes,\n        numCol = opts.numCol,\n        numRow = opts.numRow;\n      var modelDirty = this.state.modelDirty;\n      if (modelDirty) {\n        this._setupModels(opts);\n        this.setState({\n          modelDirty: false\n        });\n      }\n      this._setupWeightAttributes(opts);\n      this.gridAggregationModel.setVertexCount(vertexCount);\n      this.gridAggregationModel.setAttributes(attributes);\n      this.allAggregationModel.setInstanceCount(numCol * numRow);\n    }\n  }]);\n  return GPUGridAggregator;\n}();\nexport { GPUGridAggregator as default };\nfunction normalizeWeightParams(weights) {\n  var result = {};\n  for (var id in weights) {\n    result[id] = Object.assign({}, DEFAULT_WEIGHT_PARAMS, weights[id]);\n  }\n  return result;\n}\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(function (obj) {\n    for (var name in obj) {\n      obj[name][\"delete\"]();\n    }\n  });\n}\nfunction getAggregationModel(gl, shaderOptions) {\n  var shaders = mergeShaders({\n    vs: AGGREGATE_TO_GRID_VS,\n    fs: AGGREGATE_TO_GRID_FS,\n    modules: [fp64arithmetic, project32]\n  }, shaderOptions);\n  return new Model(gl, _objectSpread({\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: 0\n  }, shaders));\n}\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: 0,\n    isInstanced: true,\n    instanceCount: instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, Object.assign({}, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues'\n  }, opts));\n}","map":{"version":3,"sources":["../../../../src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js"],"names":["Model","Transform","FEATURES","hasFeatures","isWebGL2","readPixelsToBuffer","withParameters","fp64arithmetic","log","project32","_mergeShaders","mergeShaders","DEFAULT_RUN_PARAMS","MAX_32_BIT_FLOAT","MIN_BLEND_EQUATION","MAX_BLEND_EQUATION","MAX_MIN_BLEND_EQUATION","EQUATION_MAP","DEFAULT_WEIGHT_PARAMS","PIXEL_SIZE","AGGREGATION_OPERATION","AGGREGATE_TO_GRID_VS","AGGREGATE_TO_GRID_FS","AGGREGATE_ALL_VS","AGGREGATE_ALL_FS","TRANSFORM_MEAN_VS","getFloatTexture","getFramebuffer","BUFFER_NAMES","ARRAY_BUFFER_MAP","maxData","minData","maxMinData","REQUIRED_FEATURES","WEBGL2","COLOR_ATTACHMENT_RGBA32F","BLEND_EQUATION_MINMAX","FLOAT_BLEND","TEXTURE_FLOAT","GPUGridAggregator","aggregationData","pixelIndex","index","results","cellCount","cellWeight","maxCellWieght","minCellWeight","totalCount","countsData","size","numCells","length","cellWeights","Float32Array","cellCounts","Uint32Array","i","sizeIndex","gl","opts","id","state","weightAttributes","textures","meanTextures","buffers","framebuffers","maxMinFramebuffers","minFramebuffers","maxFramebuffers","equations","resources","_hasGPUSupport","_setupModels","gridAggregationModel","allAggregationModel","meanTransform","deleteResources","setState","aggregationParams","_normalizeAggregationParams","_runAggregation","weightId","data","aggregationBuffer","getData","arrayName","bufferName","shaderOptions","modelDirty","Object","assign","weights","normalizeWeightParams","updateObject","needMin","needMax","combineMaxMin","aggregationTexture","target","sourceType","maxMinBuffer","maxMinTexture","minBuffer","minTexture","maxBuffer","maxTexture","_trackGPUResultBuffers","cellSize","projectPoints","attributes","moduleSettings","numCol","numRow","translation","scaling","gridSize","parameters","blend","depthTest","blendFunc","uniforms","_renderToWeightsTexture","_renderToMaxMinTexture","blendEquation","minOrMaxFb","clearParams","clearColor","framebuffer","viewport","clear","draw","uSampler","texture","operation","MIN","MEAN","transformOptions","_sourceTextures","aggregationValues","_targetTexture","elementCount","width","height","update","getMeanTransform","run","attach","_updateModels","_setupFramebuffers","_renderAggregateData","_getAggregateData","framebufferSize","resize","SUM","_getMinMaxTexture","name","getAggregationModel","instanceCount","getAllAggregationModel","vertexCount","_setupWeightAttributes","setVertexCount","setAttributes","setInstanceCount","result","Array","isArray","forEach","obj","shaders","vs","fs","modules","drawMode","isInstanced","position","_targetTextureVarying"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {\n  Model,\n  Transform,\n  FEATURES,\n  hasFeatures,\n  isWebGL2,\n  readPixelsToBuffer,\n  withParameters\n} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {log, project32, _mergeShaders as mergeShaders} from '@deck.gl/core';\n\nimport {\n  DEFAULT_RUN_PARAMS,\n  MAX_32_BIT_FLOAT,\n  MIN_BLEND_EQUATION,\n  MAX_BLEND_EQUATION,\n  MAX_MIN_BLEND_EQUATION,\n  EQUATION_MAP,\n  DEFAULT_WEIGHT_PARAMS,\n  PIXEL_SIZE\n} from './gpu-grid-aggregator-constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport {getFloatTexture, getFramebuffer} from './../resource-utils.js';\n\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.WEBGL2, // TODO: Remove after trannsform refactor\n  FEATURES.COLOR_ATTACHMENT_RGBA32F,\n  FEATURES.BLEND_EQUATION_MINMAX,\n  FEATURES.FLOAT_BLEND,\n  FEATURES.TEXTURE_FLOAT\n];\n\nexport default class GPUGridAggregator {\n  // Decode and return aggregation data of given pixel.\n  static getAggregationData({aggregationData, maxData, minData, maxMinData, pixelIndex}) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n\n  // Decodes and retuns counts and weights of all cells\n  static getCellData({countsData, size = 1}) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      // weights in RGB channels\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      // count in Alpha channel\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {cellCounts, cellWeights};\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  // DEBUG ONLY\n  // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {\n  //   if (aggregationBuffer) {\n  //     console.log('Aggregation Data:');\n  //     const agrData = aggregationBuffer.getData();\n  //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {\n  //       if (agrData[index + 3] > 0) {\n  //         console.log(\n  //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${\n  //             agrData[index + 2]\n  //           } count: ${agrData[index + 3]}`\n  //         );\n  //         limit--;\n  //       }\n  //     }\n  //   }\n  //   const obj = {minBuffer, maxBuffer, maxMinBuffer};\n  //   for (const key in obj) {\n  //     if (obj[key]) {\n  //       const data = obj[key].getData();\n  //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);\n  //     }\n  //   }\n  // }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      // per weight GPU resources\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n\n      // common resources to be deleted\n      resources: {},\n\n      // results\n      results: {}\n    };\n    this._hasGPUSupport =\n      isWebGL2(gl) && // gl_InstanceID usage in min/max calculation shaders\n      hasFeatures(\n        this.gl,\n        FEATURES.BLEND_EQUATION_MINMAX, // set min/max blend modes\n        FEATURES.COLOR_ATTACHMENT_RGBA32F, // render to float texture\n        FEATURES.TEXTURE_FLOAT // sample from a float texture\n      );\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  // Delete owned resources.\n  /* eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true }] */\n  delete() {\n    const {gridAggregationModel, allAggregationModel, meanTransform} = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n\n    gridAggregationModel && gridAggregationModel.delete();\n    allAggregationModel && allAggregationModel.delete();\n    meanTransform && meanTransform.delete();\n\n    deleteResources([\n      framebuffers,\n      textures,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    ]);\n  }\n\n  // Perform aggregation and retun the results\n  run(opts = {}) {\n    // reset results\n    this.setState({results: {}});\n    const aggregationParams = this._normalizeAggregationParams(opts);\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n    return this._runAggregation(aggregationParams);\n  }\n\n  // Reads aggregation data into JS Array object\n  // For WebGL1, data is available in JS Array objects already.\n  // For WebGL2, data is read from Buffer objects and cached for subsequent queries.\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      // cache the results if reading from the buffer (WebGL2 path)\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n\n    // Check for optional results\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        // cache the result\n        results[weightId][arrayName] =\n          results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n\n  updateShaders(shaderOptions = {}) {\n    this.setState({shaderOptions, modelDirty: true});\n  }\n\n  // PRIVATE\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = Object.assign({}, DEFAULT_RUN_PARAMS, opts);\n    const {weights} = aggregationParams;\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n    return aggregationParams;\n  }\n\n  // Update priveate state\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  // GPU Aggregation methods\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {weights} = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {needMin, needMax, combineMaxMin} = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer, // update if a buffer is provided\n        sourceType: GL.FLOAT\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer, // update if a buffer is provided\n          sourceType: GL.FLOAT\n        });\n        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].minTexture = resources[`${id}-minTexture`];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].maxTexture = resources[`${id}-maxTexture`];\n        }\n      }\n    }\n    this._trackGPUResultBuffers(results, weights);\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {maxMinFramebuffers, minFramebuffers, maxFramebuffers} = this.state;\n\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [GL.ONE, GL.ONE]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: Object.assign({}, parameters, {blendEquation: MAX_MIN_BLEND_EQUATION}),\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]},\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: Object.assign({}, parameters, {blendEquation: MIN_BLEND_EQUATION}),\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]},\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: Object.assign({}, parameters, {blendEquation: MAX_BLEND_EQUATION}),\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {clearColor: [0, 0, 0, 0]},\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  // render all aggregated grid-cells to generate Min, Max or MaxMin data texture\n  _renderToMaxMinTexture(opts) {\n    const {id, parameters, gridSize, minOrMaxFb, combineMaxMin, clearParams = {}} = opts;\n    const {framebuffers} = this.state;\n    const {gl, allAggregationModel} = this;\n\n    withParameters(\n      gl,\n      {\n        ...clearParams,\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        allAggregationModel.draw({\n          parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize,\n            combineMaxMin\n          }\n        });\n      }\n    );\n  }\n\n  // render all data points to aggregate weights\n  _renderToWeightsTexture(opts) {\n    const {id, parameters, moduleSettings, uniforms, gridSize, weights} = opts;\n    const {framebuffers, equations, weightAttributes} = this.state;\n    const {gl, gridAggregationModel} = this;\n    const {operation} = weights[id];\n\n    const clearColor =\n      operation === AGGREGATION_OPERATION.MIN\n        ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n        : [0, 0, 0, 0];\n    withParameters(\n      gl,\n      {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        const attributes = {weights: weightAttributes[id]};\n        gridAggregationModel.draw({\n          parameters: Object.assign({}, parameters, {blendEquation: equations[id]}),\n          moduleSettings,\n          uniforms,\n          attributes\n        });\n      }\n    );\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {meanTextures, textures} = this.state;\n      const transformOptions = {\n        _sourceTextures: {aggregationValues: meanTextures[id]}, // contains aggregated data\n        _targetTexture: textures[id], // store mean values,\n        elementCount: textures[id].width * textures[id].height\n      };\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n\n      // update framebuffer with mean results so readPixelsToBuffer returns mean values\n      framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: textures[id]});\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n    this._setupFramebuffers(opts);\n    this._renderAggregateData(opts);\n    const results = this._getAggregateData(opts);\n    this.setState({results});\n    return results;\n  }\n\n  // set up framebuffer for each weight\n  /* eslint-disable complexity, max-depth, max-statements*/\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {weights} = opts;\n    const {numCol, numRow} = opts;\n    const framebufferSize = {width: numCol, height: numRow};\n    for (const id in weights) {\n      const {needMin, needMax, combineMaxMin, operation} = weights[id];\n      textures[id] =\n        weights[id].aggregationTexture ||\n        textures[id] ||\n        getFloatTexture(this.gl, {id: `${id}-texture`, width: numCol, height: numRow});\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        // For MEAN, we first aggregatet into a temp texture\n        meanTextures[id] =\n          meanTextures[id] ||\n          getFloatTexture(this.gl, {id: `${id}-mean-texture`, width: numCol, height: numRow});\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: texture});\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: `${id}-fb`,\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n      // For min/max framebuffers will use default size 1X1\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {id: `${id}-maxMinFb`, texture});\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-minFb`,\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-maxFb`,\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable complexity, max-depth, max-statements */\n\n  _getMinMaxTexture(name) {\n    const {resources} = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {id: `resourceName`});\n    }\n    return resources[name];\n  }\n\n  _setupModels({numCol = 0, numRow = 0} = {}) {\n    const {gl} = this;\n    const {shaderOptions} = this.state;\n    if (this.gridAggregationModel) {\n      this.gridAggregationModel.delete();\n    }\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  // set up buffers for all weights\n  _setupWeightAttributes(opts) {\n    const {weightAttributes} = this.state;\n    const {weights} = opts;\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  // GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion.\n  /* eslint-disable max-depth */\n  _trackGPUResultBuffers(results, weights) {\n    const {resources} = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            // No result buffer is provided in weights object, `readPixelsToBuffer` has created a new Buffer object\n            // collect the new buffer for garabge collection\n            const name = `gpu-result-${id}-${bufferName}`;\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable max-depth */\n\n  _updateModels(opts) {\n    const {vertexCount, attributes, numCol, numRow} = opts;\n    const {modelDirty} = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n      this.setState({modelDirty: false});\n    }\n\n    // this maps color/elevation to weight name.\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n}\n\n// HELPER METHODS\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n  for (const id in weights) {\n    result[id] = Object.assign({}, DEFAULT_WEIGHT_PARAMS, weights[id]);\n  }\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders(\n    {\n      vs: AGGREGATE_TO_GRID_VS,\n      fs: AGGREGATE_TO_GRID_FS,\n      modules: [fp64arithmetic, project32]\n    },\n    shaderOptions\n  );\n\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(\n    gl,\n    Object.assign(\n      {},\n      {\n        vs: TRANSFORM_MEAN_VS,\n        _targetTextureVarying: 'meanValues'\n      },\n      opts\n    )\n  );\n}\n"]},"metadata":{},"sourceType":"module"}