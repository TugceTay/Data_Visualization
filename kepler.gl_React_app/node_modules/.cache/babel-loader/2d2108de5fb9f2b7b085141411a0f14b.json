{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport { createIterable, getAccessorFromBuffer } from '../../utils/iterable-utils';\nimport { fillArray } from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport { normalizeTransitionSettings } from './attribute-transition-utils';\nvar Attribute = function (_DataColumn) {\n  _inherits(Attribute, _DataColumn);\n  function Attribute(gl) {\n    var _this;\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Attribute);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Attribute).call(this, gl, opts));\n    var _opts$transition = opts.transition,\n      transition = _opts$transition === void 0 ? false : _opts$transition,\n      _opts$noAlloc = opts.noAlloc,\n      noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc,\n      _opts$update = opts.update,\n      update = _opts$update === void 0 ? null : _opts$update,\n      _opts$accessor = opts.accessor,\n      accessor = _opts$accessor === void 0 ? null : _opts$accessor,\n      _opts$transform = opts.transform,\n      transform = _opts$transform === void 0 ? null : _opts$transform,\n      _opts$startIndices = opts.startIndices,\n      startIndices = _opts$startIndices === void 0 ? null : _opts$startIndices;\n    Object.assign(_this.settings, {\n      transition: transition,\n      noAlloc: noAlloc,\n      update: update || accessor && _this._autoUpdater,\n      accessor: accessor,\n      transform: transform\n    });\n    Object.assign(_this.state, {\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL,\n      startIndices: startIndices\n    });\n    Object.seal(_this.settings);\n    Object.seal(_this.state);\n    _this._validateAttributeUpdaters();\n    return _this;\n  }\n  _createClass(Attribute, [{\n    key: \"needsUpdate\",\n    value: function needsUpdate() {\n      return this.state.needsUpdate;\n    }\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$clearChangedFlag = _ref.clearChangedFlags,\n        clearChangedFlags = _ref$clearChangedFlag === void 0 ? false : _ref$clearChangedFlag;\n      var needsRedraw = this.state.needsRedraw;\n      this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n      return needsRedraw;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers() {\n      var accessor = this.settings.accessor;\n      return [this.id].concat(typeof accessor !== 'function' && accessor || []);\n    }\n  }, {\n    key: \"supportsTransition\",\n    value: function supportsTransition() {\n      return Boolean(this.settings.transition);\n    }\n  }, {\n    key: \"getTransitionSetting\",\n    value: function getTransitionSetting(opts) {\n      var accessor = this.settings.accessor;\n      var layerSettings = this.settings.transition;\n      if (!this.supportsTransition()) {\n        return null;\n      }\n      var userSettings = Array.isArray(accessor) ? opts[accessor.find(function (a) {\n        return opts[a];\n      })] : opts[accessor];\n      return normalizeTransitionSettings(userSettings, layerSettings);\n    }\n  }, {\n    key: \"setNeedsUpdate\",\n    value: function setNeedsUpdate() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      var dataRange = arguments.length > 1 ? arguments[1] : undefined;\n      this.state.needsUpdate = this.state.needsUpdate || reason;\n      this.setNeedsRedraw(reason);\n      if (dataRange) {\n        var _dataRange$startRow = dataRange.startRow,\n          startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow,\n          _dataRange$endRow = dataRange.endRow,\n          endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;\n        this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n      } else {\n        this.state.updateRanges = range.FULL;\n      }\n    }\n  }, {\n    key: \"clearNeedsUpdate\",\n    value: function clearNeedsUpdate() {\n      this.state.needsUpdate = false;\n      this.state.updateRanges = range.EMPTY;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      this.state.needsRedraw = this.state.needsRedraw || reason;\n    }\n  }, {\n    key: \"update\",\n    value: function update(opts) {\n      this.setData(opts);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(numInstances) {\n      var state = this.state,\n        settings = this.settings;\n      if (settings.noAlloc) {\n        return false;\n      }\n      if (settings.update) {\n        assert(Number.isFinite(numInstances));\n        _get(_getPrototypeOf(Attribute.prototype), \"allocate\", this).call(this, {\n          numInstances: numInstances,\n          copy: state.updateRanges !== range.FULL\n        });\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(_ref2) {\n      var numInstances = _ref2.numInstances,\n        data = _ref2.data,\n        props = _ref2.props,\n        context = _ref2.context;\n      if (!this.needsUpdate()) {\n        return false;\n      }\n      var updateRanges = this.state.updateRanges,\n        _this$settings = this.settings,\n        update = _this$settings.update,\n        noAlloc = _this$settings.noAlloc;\n      var updated = true;\n      if (update) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n          for (var _iterator = updateRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              _startRow = _step$value[0],\n              _endRow = _step$value[1];\n            update.call(context, this, {\n              data: data,\n              startRow: _startRow,\n              endRow: _endRow,\n              props: props,\n              numInstances: numInstances\n            });\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n        if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {\n          this.setData({\n            value: this.value,\n            constant: this.constant\n          });\n        } else {\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n          try {\n            for (var _iterator2 = updateRanges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                startRow = _step2$value[0],\n                endRow = _step2$value[1];\n              var startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n              var endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;\n              _get(_getPrototypeOf(Attribute.prototype), \"updateSubBuffer\", this).call(this, {\n                startOffset: startOffset,\n                endOffset: endOffset\n              });\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                _iterator2[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n        this._checkAttributeArray();\n      } else {\n        updated = false;\n      }\n      this.clearNeedsUpdate();\n      this.setNeedsRedraw();\n      return updated;\n    }\n  }, {\n    key: \"setConstantValue\",\n    value: function setConstantValue(value) {\n      if (value === undefined || typeof value === 'function') {\n        return false;\n      }\n      var hasChanged = this.setData({\n        constant: true,\n        value: value\n      });\n      if (hasChanged) {\n        this.setNeedsRedraw();\n      }\n      this.clearNeedsUpdate();\n      return true;\n    }\n  }, {\n    key: \"setExternalBuffer\",\n    value: function setExternalBuffer(buffer) {\n      var state = this.state;\n      if (!buffer) {\n        state.lastExternalBuffer = null;\n        return false;\n      }\n      this.clearNeedsUpdate();\n      if (state.lastExternalBuffer === buffer) {\n        return true;\n      }\n      state.lastExternalBuffer = buffer;\n      this.setNeedsRedraw();\n      this.setData(buffer);\n      return true;\n    }\n  }, {\n    key: \"setBinaryValue\",\n    value: function setBinaryValue(buffer) {\n      var startIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var state = this.state,\n        settings = this.settings;\n      if (!buffer) {\n        state.binaryValue = null;\n        state.binaryAccessor = null;\n        return false;\n      }\n      if (settings.noAlloc) {\n        return false;\n      }\n      if (state.binaryValue === buffer) {\n        this.clearNeedsUpdate();\n        return true;\n      }\n      state.binaryValue = buffer;\n      this.setNeedsRedraw();\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {\n          value: buffer\n        };\n      }\n      var needsUpdate = settings.transform || startIndices !== this.startIndices;\n      if (needsUpdate) {\n        assert(ArrayBuffer.isView(buffer.value), \"invalid \".concat(settings.accessor));\n        var needsNormalize = buffer.size && buffer.size !== this.size;\n        state.binaryAccessor = getAccessorFromBuffer(buffer.value, {\n          size: buffer.size || this.size,\n          stride: buffer.stride,\n          offset: buffer.offset,\n          startIndices: startIndices,\n          nested: needsNormalize\n        });\n        return false;\n      }\n      this.clearNeedsUpdate();\n      this.setData(buffer);\n      return true;\n    }\n  }, {\n    key: \"getVertexOffset\",\n    value: function getVertexOffset(row) {\n      var startIndices = this.startIndices;\n      var vertexIndex = startIndices ? startIndices[row] : row;\n      return vertexIndex * this.size;\n    }\n  }, {\n    key: \"getShaderAttributes\",\n    value: function getShaderAttributes() {\n      var shaderAttributeDefs = this.settings.shaderAttributes || _defineProperty({}, this.id, null);\n      var shaderAttributes = {};\n      for (var shaderAttributeName in shaderAttributeDefs) {\n        Object.assign(shaderAttributes, _get(_getPrototypeOf(Attribute.prototype), \"getShaderAttributes\", this).call(this, shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));\n      }\n      return shaderAttributes;\n    }\n  }, {\n    key: \"_autoUpdater\",\n    value: function _autoUpdater(attribute, _ref4) {\n      var data = _ref4.data,\n        startRow = _ref4.startRow,\n        endRow = _ref4.endRow,\n        props = _ref4.props,\n        numInstances = _ref4.numInstances;\n      var settings = attribute.settings,\n        state = attribute.state,\n        value = attribute.value,\n        size = attribute.size,\n        startIndices = attribute.startIndices;\n      var accessor = settings.accessor,\n        transform = settings.transform;\n      var accessorFunc = state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n      assert(typeof accessorFunc === 'function', \"accessor \\\"\".concat(accessor, \"\\\" is not a function\"));\n      var i = attribute.getVertexOffset(startRow);\n      var _createIterable = createIterable(data, startRow, endRow),\n        iterable = _createIterable.iterable,\n        objectInfo = _createIterable.objectInfo;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n      try {\n        for (var _iterator3 = iterable[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var object = _step3.value;\n          objectInfo.index++;\n          var objectValue = accessorFunc(object, objectInfo);\n          if (transform) {\n            objectValue = transform.call(this, objectValue);\n          }\n          if (startIndices) {\n            var numVertices = (startIndices[objectInfo.index + 1] || numInstances) - startIndices[objectInfo.index];\n            if (objectValue && Array.isArray(objectValue[0])) {\n              var startIndex = i;\n              var _iteratorNormalCompletion4 = true;\n              var _didIteratorError4 = false;\n              var _iteratorError4 = undefined;\n              try {\n                for (var _iterator4 = objectValue[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                  var item = _step4.value;\n                  attribute._normalizeValue(item, value, startIndex);\n                  startIndex += size;\n                }\n              } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n                    _iterator4[\"return\"]();\n                  }\n                } finally {\n                  if (_didIteratorError4) {\n                    throw _iteratorError4;\n                  }\n                }\n              }\n            } else if (objectValue && objectValue.length > size) {\n              value.set(objectValue, i);\n            } else {\n              attribute._normalizeValue(objectValue, objectInfo.target, 0);\n              fillArray({\n                target: value,\n                source: objectInfo.target,\n                start: i,\n                count: numVertices\n              });\n            }\n            i += numVertices * size;\n          } else {\n            attribute._normalizeValue(objectValue, value, i);\n            i += size;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n      attribute.constant = false;\n    }\n  }, {\n    key: \"_validateAttributeUpdaters\",\n    value: function _validateAttributeUpdaters() {\n      var settings = this.settings;\n      var hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n      if (!hasUpdater) {\n        throw new Error(\"Attribute \".concat(this.id, \" missing update or accessor\"));\n      }\n    }\n  }, {\n    key: \"_checkAttributeArray\",\n    value: function _checkAttributeArray() {\n      var value = this.value;\n      var limit = Math.min(4, this.size);\n      if (value && value.length >= limit) {\n        var valid = true;\n        switch (limit) {\n          case 4:\n            valid = valid && Number.isFinite(value[3]);\n          case 3:\n            valid = valid && Number.isFinite(value[2]);\n          case 2:\n            valid = valid && Number.isFinite(value[1]);\n          case 1:\n            valid = valid && Number.isFinite(value[0]);\n            break;\n          default:\n            valid = false;\n        }\n        if (!valid) {\n          throw new Error(\"Illegal attribute generated for \".concat(this.id));\n        }\n      }\n    }\n  }, {\n    key: \"startIndices\",\n    get: function get() {\n      return this.state.startIndices;\n    },\n    set: function set(layout) {\n      this.state.startIndices = layout;\n    }\n  }]);\n  return Attribute;\n}(DataColumn);\nexport { Attribute as default };","map":{"version":3,"sources":["../../../../src/lib/attribute/attribute.js"],"names":["DataColumn","assert","createIterable","getAccessorFromBuffer","fillArray","range","normalizeTransitionSettings","Attribute","gl","opts","transition","noAlloc","update","accessor","transform","startIndices","Object","assign","settings","_autoUpdater","state","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","updateRanges","FULL","seal","_validateAttributeUpdaters","layout","clearChangedFlags","id","concat","Boolean","layerSettings","supportsTransition","userSettings","isArray","find","a","reason","dataRange","setNeedsRedraw","startRow","endRow","Infinity","add","EMPTY","setData","numInstances","Number","isFinite","copy","data","props","context","updated","call","value","constant","buffer","byteLength","byteOffset","startOffset","getVertexOffset","endOffset","length","size","_checkAttributeArray","clearNeedsUpdate","undefined","hasChanged","ArrayBuffer","isView","needsNormalize","stride","offset","nested","row","vertexIndex","shaderAttributeDefs","shaderAttributes","shaderAttributeName","attribute","accessorFunc","i","iterable","objectInfo","object","index","objectValue","numVertices","Array","startIndex","item","_normalizeValue","set","target","source","start","count","hasUpdater","Error","limit","Math","min","valid"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport {createIterable, getAccessorFromBuffer} from '../../utils/iterable-utils';\nimport {fillArray} from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport {normalizeTransitionSettings} from './attribute-transition-utils';\n\nexport default class Attribute extends DataColumn {\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    const {\n      // deck.gl fields\n      transition = false,\n      noAlloc = false,\n      update = null,\n      accessor = null,\n      transform = null,\n      startIndices = null\n    } = opts;\n\n    Object.assign(this.settings, {\n      transition,\n      noAlloc,\n      update: update || (accessor && this._autoUpdater),\n      accessor,\n      transform\n    });\n\n    Object.assign(this.state, {\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL,\n      startIndices\n    });\n\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices() {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false} = {}) {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers() {\n    const {accessor} = this.settings;\n\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n  }\n\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts) {\n    const {accessor} = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    if (!this.supportsTransition()) {\n      return null;\n    }\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor)\n      ? opts[accessor.find(a => opts[a])]\n      : opts[accessor];\n\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason = this.id, dataRange) {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {startRow = 0, endRow = Infinity} = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason = this.id) {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  update(opts) {\n    // backward compatibility\n    this.setData(opts);\n  }\n\n  allocate(numInstances) {\n    const {state, settings} = this;\n\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n\n    if (settings.update) {\n      assert(Number.isFinite(numInstances));\n      super.allocate({\n        numInstances,\n        copy: state.updateRanges !== range.FULL\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({numInstances, data, props, context}) {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {updateRanges},\n      settings: {update, noAlloc}\n    } = this;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {data, startRow, endRow, props, numInstances});\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (\n        this.constant ||\n        this.buffer.byteLength < this.value.byteLength + this.byteOffset\n      ) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow)\n            ? this.getVertexOffset(endRow)\n            : noAlloc || !Number.isFinite(numInstances)\n              ? this.value.length\n              : numInstances * this.size;\n\n          super.updateSubBuffer({startOffset, endOffset});\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n\n    return updated;\n  }\n\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value) {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({constant: true, value});\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer) {\n    const {state} = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(buffer, startIndices = null) {\n    const {state, settings} = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    if (ArrayBuffer.isView(buffer)) {\n      buffer = {value: buffer};\n    }\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      assert(ArrayBuffer.isView(buffer.value), `invalid ${settings.accessor}`);\n      const needsNormalize = buffer.size && buffer.size !== this.size;\n\n      state.binaryAccessor = getAccessorFromBuffer(buffer.value, {\n        size: buffer.size || this.size,\n        stride: buffer.stride,\n        offset: buffer.offset,\n        startIndices,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row) {\n    const {startIndices} = this;\n    const vertexIndex = startIndices ? startIndices[row] : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes() {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {[this.id]: null};\n    const shaderAttributes = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(\n        shaderAttributes,\n        super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])\n      );\n    }\n\n    return shaderAttributes;\n  }\n\n  /* eslint-disable max-depth, max-statements */\n  _autoUpdater(attribute, {data, startRow, endRow, props, numInstances}) {\n    const {settings, state, value, size, startIndices} = attribute;\n\n    const {accessor, transform} = settings;\n    const accessorFunc =\n      state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let i = attribute.getVertexOffset(startRow);\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices =\n          (startIndices[objectInfo.index + 1] || numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n        i += size;\n      }\n    }\n    attribute.constant = false;\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  // Validate deck.gl level fields\n  _validateAttributeUpdaters() {\n    const {settings} = this;\n\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  _checkAttributeArray() {\n    const {value} = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n  /* eslint-enable no-fallthrough */\n}\n"]},"metadata":{},"sourceType":"module"}