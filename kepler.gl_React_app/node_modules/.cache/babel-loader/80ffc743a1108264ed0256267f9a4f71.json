{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addDataToMapComposed = exports.loadFilesSuccessUpdater = exports.addDataToMapUpdater = exports.defaultAddDataToMapOptions = exports.isValidConfig = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _uiStateUpdaters = require(\"./ui-state-updaters\");\nvar _visStateUpdaters = require(\"./vis-state-updaters\");\nvar _mapStateUpdaters = require(\"./map-state-updaters\");\nvar _mapStyleUpdaters = require(\"./map-style-updaters\");\nvar _dataUtils = require(\"../utils/data-utils\");\nvar _utils = require(\"../utils/utils\");\nvar _fileHandler = require(\"../processors/file-handler\");\nvar _composerHelpers = require(\"./composer-helpers\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n// compose action to apply result multiple reducers, with the output of one\n\n/**\n * Some actions will affect the entire kepler.lg instance state.\n * The updaters for these actions is exported as `combinedUpdaters`. These updater take the entire instance state\n * as the first argument. Read more about [Using updaters](../advanced-usage/using-updaters.md)\n * @public\n * @example\n *\n * import keplerGlReducer, {combinedUpdaters} from 'kepler.gl/reducers';\n * // Root Reducer\n * const reducers = combineReducers({\n *  keplerGl: keplerGlReducer,\n *  app: appReducer\n * });\n *\n * const composedReducer = (state, action) => {\n *  switch (action.type) {\n *    // add data to map after receiving data from remote sources\n *    case 'LOAD_REMOTE_RESOURCE_SUCCESS':\n *      return {\n *        ...state,\n *        keplerGl: {\n *          ...state.keplerGl,\n *          // pass in kepler.gl instance state to combinedUpdaters\n *          map:  combinedUpdaters.addDataToMapUpdater(\n *           state.keplerGl.map,\n *           {\n *             payload: {\n *               datasets: action.datasets,\n *               options: {readOnly: true},\n *               config: action.config\n *              }\n *            }\n *          )\n *        }\n *      };\n *  }\n *  return reducers(state, action);\n * };\n *\n * export default composedReducer;\n */\n\n/* eslint-disable no-unused-vars */\n// @ts-ignore\nvar combinedUpdaters = null;\n/* eslint-enable no-unused-vars */\n\nvar isValidConfig = function isValidConfig(config) {\n  return (0, _utils.isPlainObject)(config) && (0, _utils.isPlainObject)(config.config) && config.version;\n};\nexports.isValidConfig = isValidConfig;\nvar defaultAddDataToMapOptions = {\n  centerMap: true,\n  keepExistingConfig: false,\n  autoCreateLayers: true\n};\n/**\n * Combine data and full configuration update in a single action\n *\n * @memberof combinedUpdaters\n * @param {Object} state kepler.gl instance state, containing all subreducer state\n * @param {Object} action\n * @param {Object} action.payload `{datasets, options, config}`\n * @param action.payload.datasets - ***required** datasets can be a dataset or an array of datasets\n * Each dataset object needs to have `info` and `data` property.\n * @param [action.payload.options] option object `{centerMap: true}`\n * @param [action.payload.config] map config\n * @param [action.payload.info] map info contains title and description\n * @returns nextState\n *\n * @typedef {Object} Dataset\n * @property info -info of a dataset\n * @property info.id - id of this dataset. If config is defined, `id` should matches the `dataId` in config.\n * @property info.label - A display name of this dataset\n * @property data - ***required** The data object, in a tabular format with 2 properties `fields` and `rows`\n * @property data.fields - ***required** Array of fields,\n * @property data.fields.name - ***required** Name of the field,\n * @property data.rows - ***required** Array of rows, in a tabular format with `fields` and `rows`\n *\n * @type {typeof import('./combined-updaters').addDataToMapUpdater}\n * @public\n */\n\nexports.defaultAddDataToMapOptions = defaultAddDataToMapOptions;\nvar addDataToMapUpdater = function addDataToMapUpdater(state, _ref) {\n  var payload = _ref.payload;\n  var datasets = payload.datasets,\n    config = payload.config,\n    info = payload.info;\n  var options = _objectSpread(_objectSpread({}, defaultAddDataToMapOptions), payload.options);\n  var parsedConfig = config;\n  if (isValidConfig(config)) {\n    // if passed in saved config\n    parsedConfig = state.visState.schema.parseSavedConfig(config);\n  }\n  var oldLayers = state.visState.layers;\n  var filterNewlyAddedLayers = function filterNewlyAddedLayers(layers) {\n    return layers.filter(function (nl) {\n      return !oldLayers.find(function (ol) {\n        return ol === nl;\n      });\n    });\n  }; // Returns undefined if not found, to make typescript happy\n\n  var findMapBoundsIfCentered = function findMapBoundsIfCentered(layers) {\n    var bounds = options.centerMap && (0, _dataUtils.findMapBounds)(layers);\n    return bounds ? bounds : undefined;\n  };\n  return (0, _composerHelpers.compose_)([(0, _composerHelpers.pick_)('visState')((0, _composerHelpers.apply_)(_visStateUpdaters.updateVisDataUpdater, {\n    datasets: datasets,\n    options: options,\n    config: parsedConfig\n  })), (0, _composerHelpers.if_)(info, (0, _composerHelpers.pick_)('visState')((0, _composerHelpers.apply_)(_visStateUpdaters.setMapInfoUpdater, {\n    info: info\n  }))), (0, _composerHelpers.with_)(function (_ref2) {\n    var visState = _ref2.visState;\n    return (0, _composerHelpers.pick_)('mapState')((0, _composerHelpers.apply_)(_mapStateUpdaters.receiveMapConfigUpdater, (0, _composerHelpers.payload_)({\n      config: parsedConfig,\n      options: options,\n      bounds: findMapBoundsIfCentered(filterNewlyAddedLayers(visState.layers))\n    })));\n  }), (0, _composerHelpers.pick_)('mapStyle')((0, _composerHelpers.apply_)(_mapStyleUpdaters.receiveMapConfigUpdater, (0, _composerHelpers.payload_)({\n    config: parsedConfig,\n    options: options\n  }))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.apply_)(_uiStateUpdaters.loadFilesSuccessUpdater, (0, _composerHelpers.payload_)(null))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.apply_)(_uiStateUpdaters.toggleModalUpdater, (0, _composerHelpers.payload_)(null))), (0, _composerHelpers.pick_)('uiState')((0, _composerHelpers.merge_)(options.hasOwnProperty('readOnly') ? {\n    readOnly: options.readOnly\n  } : {}))])(state);\n};\n/**\n * @type {typeof import('./combined-updaters').loadFilesSuccessUpdater}\n */\n\nexports.addDataToMapUpdater = addDataToMapUpdater;\nvar loadFilesSuccessUpdater = function loadFilesSuccessUpdater(state, action) {\n  // still more to load\n  var payloads = (0, _fileHandler.filesToDataPayload)(action.result);\n  var nextState = (0, _composerHelpers.compose_)([(0, _composerHelpers.pick_)('visState')((0, _composerHelpers.merge_)({\n    fileLoading: false,\n    fileLoadingProgress: {}\n  }))])(state); // make multiple add data to map calls\n\n  var stateWithData = (0, _composerHelpers.compose_)(payloads.map(function (p) {\n    return (0, _composerHelpers.apply_)(addDataToMapUpdater, (0, _composerHelpers.payload_)(p));\n  }))(nextState);\n  return stateWithData;\n};\nexports.loadFilesSuccessUpdater = loadFilesSuccessUpdater;\nvar addDataToMapComposed = addDataToMapUpdater;\nexports.addDataToMapComposed = addDataToMapComposed;","map":{"version":3,"sources":["../../src/reducers/combined-updaters.js"],"names":["combinedUpdaters","isValidConfig","config","version","defaultAddDataToMapOptions","centerMap","keepExistingConfig","autoCreateLayers","addDataToMapUpdater","state","payload","datasets","info","options","parsedConfig","visState","schema","parseSavedConfig","oldLayers","layers","filterNewlyAddedLayers","filter","find","ol","nl","findMapBoundsIfCentered","bounds","undefined","visStateUpdateVisDataUpdater","setMapInfoUpdater","stateMapConfigUpdater","styleMapConfigUpdater","uiStateLoadFilesSuccessUpdater","toggleModalUpdater","hasOwnProperty","readOnly","loadFilesSuccessUpdater","action","payloads","result","nextState","fileLoading","fileLoadingProgress","stateWithData","map","p","addDataToMapComposed"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  toggleModalUpdater,\n  loadFilesSuccessUpdater as uiStateLoadFilesSuccessUpdater\n} from './ui-state-updaters';\nimport {\n  updateVisDataUpdater as visStateUpdateVisDataUpdater,\n  setMapInfoUpdater\n} from './vis-state-updaters';\nimport {receiveMapConfigUpdater as stateMapConfigUpdater} from './map-state-updaters';\nimport {receiveMapConfigUpdater as styleMapConfigUpdater} from './map-style-updaters';\nimport {findMapBounds} from 'utils/data-utils';\nimport {isPlainObject} from 'utils/utils';\nimport {filesToDataPayload} from 'processors/file-handler';\nimport {payload_, apply_, with_, if_, compose_, merge_, pick_} from './composer-helpers';\n\n// compose action to apply result multiple reducers, with the output of one\n\n/**\n * Some actions will affect the entire kepler.lg instance state.\n * The updaters for these actions is exported as `combinedUpdaters`. These updater take the entire instance state\n * as the first argument. Read more about [Using updaters](../advanced-usage/using-updaters.md)\n * @public\n * @example\n *\n * import keplerGlReducer, {combinedUpdaters} from 'kepler.gl/reducers';\n * // Root Reducer\n * const reducers = combineReducers({\n *  keplerGl: keplerGlReducer,\n *  app: appReducer\n * });\n *\n * const composedReducer = (state, action) => {\n *  switch (action.type) {\n *    // add data to map after receiving data from remote sources\n *    case 'LOAD_REMOTE_RESOURCE_SUCCESS':\n *      return {\n *        ...state,\n *        keplerGl: {\n *          ...state.keplerGl,\n *          // pass in kepler.gl instance state to combinedUpdaters\n *          map:  combinedUpdaters.addDataToMapUpdater(\n *           state.keplerGl.map,\n *           {\n *             payload: {\n *               datasets: action.datasets,\n *               options: {readOnly: true},\n *               config: action.config\n *              }\n *            }\n *          )\n *        }\n *      };\n *  }\n *  return reducers(state, action);\n * };\n *\n * export default composedReducer;\n */\n\n/* eslint-disable no-unused-vars */\n// @ts-ignore\nconst combinedUpdaters = null;\n/* eslint-enable no-unused-vars */\n\nexport const isValidConfig = config =>\n  isPlainObject(config) && isPlainObject(config.config) && config.version;\n\nexport const defaultAddDataToMapOptions = {\n  centerMap: true,\n  keepExistingConfig: false,\n  autoCreateLayers: true\n};\n\n/**\n * Combine data and full configuration update in a single action\n *\n * @memberof combinedUpdaters\n * @param {Object} state kepler.gl instance state, containing all subreducer state\n * @param {Object} action\n * @param {Object} action.payload `{datasets, options, config}`\n * @param action.payload.datasets - ***required** datasets can be a dataset or an array of datasets\n * Each dataset object needs to have `info` and `data` property.\n * @param [action.payload.options] option object `{centerMap: true}`\n * @param [action.payload.config] map config\n * @param [action.payload.info] map info contains title and description\n * @returns nextState\n *\n * @typedef {Object} Dataset\n * @property info -info of a dataset\n * @property info.id - id of this dataset. If config is defined, `id` should matches the `dataId` in config.\n * @property info.label - A display name of this dataset\n * @property data - ***required** The data object, in a tabular format with 2 properties `fields` and `rows`\n * @property data.fields - ***required** Array of fields,\n * @property data.fields.name - ***required** Name of the field,\n * @property data.rows - ***required** Array of rows, in a tabular format with `fields` and `rows`\n *\n * @type {typeof import('./combined-updaters').addDataToMapUpdater}\n * @public\n */\nexport const addDataToMapUpdater = (state, {payload}) => {\n  const {datasets, config, info} = payload;\n\n  const options = {\n    ...defaultAddDataToMapOptions,\n    ...payload.options\n  };\n\n  let parsedConfig = config;\n\n  if (isValidConfig(config)) {\n    // if passed in saved config\n    parsedConfig = state.visState.schema.parseSavedConfig(config);\n  }\n  const oldLayers = state.visState.layers;\n  const filterNewlyAddedLayers = layers => layers.filter(nl => !oldLayers.find(ol => ol === nl));\n\n  // Returns undefined if not found, to make typescript happy\n  const findMapBoundsIfCentered = layers => {\n    const bounds = options.centerMap && findMapBounds(layers);\n    return bounds ? bounds : undefined;\n  };\n\n  return compose_([\n    pick_('visState')(\n      apply_(visStateUpdateVisDataUpdater, {\n        datasets,\n        options,\n        config: parsedConfig\n      })\n    ),\n\n    if_(info, pick_('visState')(apply_(setMapInfoUpdater, {info}))),\n\n    with_(({visState}) =>\n      pick_('mapState')(\n        apply_(\n          stateMapConfigUpdater,\n          payload_({\n            config: parsedConfig,\n            options,\n            bounds: findMapBoundsIfCentered(filterNewlyAddedLayers(visState.layers))\n          })\n        )\n      )\n    ),\n\n    pick_('mapStyle')(apply_(styleMapConfigUpdater, payload_({config: parsedConfig, options}))),\n\n    pick_('uiState')(apply_(uiStateLoadFilesSuccessUpdater, payload_(null))),\n\n    pick_('uiState')(apply_(toggleModalUpdater, payload_(null))),\n\n    pick_('uiState')(merge_(options.hasOwnProperty('readOnly') ? {readOnly: options.readOnly} : {}))\n  ])(state);\n};\n\n/**\n * @type {typeof import('./combined-updaters').loadFilesSuccessUpdater}\n */\nexport const loadFilesSuccessUpdater = (state, action) => {\n  // still more to load\n  const payloads = filesToDataPayload(action.result);\n  const nextState = compose_([\n    pick_('visState')(\n      merge_({\n        fileLoading: false,\n        fileLoadingProgress: {}\n      })\n    )\n  ])(state);\n  // make multiple add data to map calls\n  const stateWithData = compose_(payloads.map(p => apply_(addDataToMapUpdater, payload_(p))))(\n    nextState\n  );\n  return stateWithData;\n};\n\nexport const addDataToMapComposed = addDataToMapUpdater;\n"]},"metadata":{},"sourceType":"script"}