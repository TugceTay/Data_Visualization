{"ast":null,"code":"let channelHandles = 1;\nlet animationHandles = 1;\nexport class Timeline {\n  constructor() {\n    this.time = 0;\n    this.channels = new Map();\n    this.animations = new Map();\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n  addChannel(props) {\n    const {\n      delay = 0,\n      duration = Number.POSITIVE_INFINITY,\n      rate = 1,\n      repeat = 1\n    } = props;\n    const handle = channelHandles++;\n    const channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(handle, channel);\n    return handle;\n  }\n  removeChannel(handle) {\n    this.channels.delete(handle);\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === handle) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n  isFinished(handle) {\n    const channel = this.channels.get(handle);\n    if (channel === undefined) {\n      return false;\n    }\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n  getTime(handle) {\n    if (handle === undefined) {\n      return this.time;\n    }\n    const channel = this.channels.get(handle);\n    if (channel === undefined) {\n      return -1;\n    }\n    return channel.time;\n  }\n  setTime(time) {\n    this.time = Math.max(0, time);\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {\n        animation,\n        channel\n      } = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n  play() {\n    this.playing = true;\n  }\n  pause() {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n  reset() {\n    this.setTime(0);\n  }\n  attachAnimation(animation, channelHandle) {\n    const animationHandle = animationHandles++;\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n    animation.setTime(this.getTime(channelHandle));\n    return animationHandle;\n  }\n  detachAnimation(handle) {\n    this.animations.delete(handle);\n  }\n  update(engineTime) {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n  _setChannelTime(channel, time) {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}","map":{"version":3,"sources":["../../../src/animation/timeline.js"],"names":["channelHandles","animationHandles","Timeline","constructor","time","channels","Map","animations","playing","lastEngineTime","addChannel","props","delay","duration","Number","POSITIVE_INFINITY","rate","repeat","handle","channel","_setChannelTime","set","removeChannel","delete","animationHandle","animation","detachAnimation","isFinished","get","undefined","getTime","setTime","Math","max","values","animationData","play","pause","reset","attachAnimation","channelHandle","update","engineTime","offsetTime","totalDuration"],"mappings":"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","sourcesContent":["let channelHandles = 1;\nlet animationHandles = 1;\n\nexport class Timeline {\n  constructor() {\n    this.time = 0;\n    this.channels = new Map();\n    this.animations = new Map();\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  addChannel(props) {\n    const {delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1} = props;\n\n    const handle = channelHandles++;\n    const channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(handle, channel);\n\n    return handle;\n  }\n\n  removeChannel(handle) {\n    this.channels.delete(handle);\n\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === handle) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n\n  isFinished(handle) {\n    const channel = this.channels.get(handle);\n    if (channel === undefined) {\n      return false;\n    }\n\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n\n  getTime(handle) {\n    if (handle === undefined) {\n      return this.time;\n    }\n\n    const channel = this.channels.get(handle);\n\n    if (channel === undefined) {\n      return -1;\n    }\n\n    return channel.time;\n  }\n\n  setTime(time) {\n    this.time = Math.max(0, time);\n\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {animation, channel} = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n\n  play() {\n    this.playing = true;\n  }\n\n  pause() {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  reset() {\n    this.setTime(0);\n  }\n\n  attachAnimation(animation, channelHandle) {\n    const animationHandle = animationHandles++;\n\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n\n    animation.setTime(this.getTime(channelHandle));\n\n    return animationHandle;\n  }\n\n  detachAnimation(handle) {\n    this.animations.delete(handle);\n  }\n\n  update(engineTime) {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n\n  _setChannelTime(channel, time) {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    // Note(Tarek): Don't loop on final repeat.\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}