{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nvar LRUCache = function () {\n  function LRUCache() {\n    var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n    _classCallCheck(this, LRUCache);\n    this.limit = limit;\n    this.clear();\n  }\n  _createClass(LRUCache, [{\n    key: \"clear\",\n    value: function clear() {\n      this._cache = {};\n      this._order = [];\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var value = this._cache[key];\n      if (value) {\n        this._deleteOrder(key);\n        this._appendOrder(key);\n      }\n      return value;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      if (!this._cache[key]) {\n        if (Object.keys(this._cache).length === this.limit) {\n          this[\"delete\"](this._order[0]);\n        }\n        this._cache[key] = value;\n        this._appendOrder(key);\n      } else {\n        this[\"delete\"](key);\n        this._cache[key] = value;\n        this._appendOrder(key);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var value = this._cache[key];\n      if (value) {\n        this._deleteCache(key);\n        this._deleteOrder(key);\n      }\n    }\n  }, {\n    key: \"_deleteCache\",\n    value: function _deleteCache(key) {\n      delete this._cache[key];\n    }\n  }, {\n    key: \"_deleteOrder\",\n    value: function _deleteOrder(key) {\n      var index = this._order.findIndex(function (o) {\n        return o === key;\n      });\n      if (index >= 0) {\n        this._order.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"_appendOrder\",\n    value: function _appendOrder(key) {\n      this._order.push(key);\n    }\n  }]);\n  return LRUCache;\n}();\nexport { LRUCache as default };","map":{"version":3,"sources":["../../../src/text-layer/lru-cache.js"],"names":["LRUCache","limit","clear","_cache","_order","key","value","_deleteOrder","_appendOrder","Object","keys","length","_deleteCache","index","findIndex","o","splice","push"],"mappings":";;IAOqBA,Q;EACnB,SAAA,QAAA,GAAuB;IAAA,IAAXC,KAAW,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAH,CAAG;IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,CAAA;IACrB,IAAA,CAAKA,KAAL,GAAaA,KAAb;IAEA,IAAA,CAAKC,KAAL,EAAA;EACD;;;4BAEO;MACN,IAAA,CAAKC,MAAL,GAAc,CAAA,CAAd;MAEA,IAAA,CAAKC,MAAL,GAAc,EAAd;IACD;;;wBAEGC,G,EAAK;MACP,IAAMC,KAAK,GAAG,IAAA,CAAKH,MAAL,CAAYE,GAAZ,CAAd;MACA,IAAIC,KAAJ,EAAW;QAET,IAAA,CAAKC,YAAL,CAAkBF,GAAlB,CAAA;QACA,IAAA,CAAKG,YAAL,CAAkBH,GAAlB,CAAA;MACD;MACD,OAAOC,KAAP;IACD;;;wBAEGD,G,EAAKC,K,EAAO;MACd,IAAI,CAAC,IAAA,CAAKH,MAAL,CAAYE,GAAZ,CAAL,EAAuB;QAErB,IAAII,MAAM,CAACC,IAAPD,CAAY,IAAA,CAAKN,MAAjBM,CAAAA,CAAyBE,MAAzBF,KAAoC,IAAA,CAAKR,KAA7C,EAAoD;UAClD,IAAA,CAAA,QAAA,CAAA,CAAY,IAAA,CAAKG,MAAL,CAAY,CAAZ,CAAZ,CAAA;QACD;QAED,IAAA,CAAKD,MAAL,CAAYE,GAAZ,CAAA,GAAmBC,KAAnB;QACA,IAAA,CAAKE,YAAL,CAAkBH,GAAlB,CAAA;MACD,CARD,MAQO;QAEL,IAAA,CAAA,QAAA,CAAA,CAAYA,GAAZ,CAAA;QAEA,IAAA,CAAKF,MAAL,CAAYE,GAAZ,CAAA,GAAmBC,KAAnB;QACA,IAAA,CAAKE,YAAL,CAAkBH,GAAlB,CAAA;MACD;IACF;;;4BAEMA,G,EAAK;MACV,IAAMC,KAAK,GAAG,IAAA,CAAKH,MAAL,CAAYE,GAAZ,CAAd;MACA,IAAIC,KAAJ,EAAW;QACT,IAAA,CAAKM,YAAL,CAAkBP,GAAlB,CAAA;QACA,IAAA,CAAKE,YAAL,CAAkBF,GAAlB,CAAA;MACD;IACF;;;iCAEYA,G,EAAK;MAChB,OAAO,IAAA,CAAKF,MAAL,CAAYE,GAAZ,CAAP;IACD;;;iCAEYA,G,EAAK;MAChB,IAAMQ,KAAK,GAAG,IAAA,CAAKT,MAAL,CAAYU,SAAZ,CAAsB,UAAA,CAAC,EAAA;QAAA,OAAIC,CAAC,KAAKV,GAAV;MAAA,CAAvB,CAAd;MACA,IAAIQ,KAAK,IAAI,CAAb,EAAgB;QACd,IAAA,CAAKT,MAAL,CAAYY,MAAZ,CAAmBH,KAAnB,EAA0B,CAA1B,CAAA;MACD;IACF;;;iCAEYR,G,EAAK;MAChB,IAAA,CAAKD,MAAL,CAAYa,IAAZ,CAAiBZ,GAAjB,CAAA;IACD;;;;SA9DkBL,Q","sourcesContent":["/**\n * LRU Cache class with limit\n *\n * Update order for each get/set operation\n * Delete oldest when reach given limit\n */\n\nexport default class LRUCache {\n  constructor(limit = 5) {\n    this.limit = limit;\n\n    this.clear();\n  }\n\n  clear() {\n    this._cache = {};\n    // access/update order, first item is oldest, last item is newest\n    this._order = [];\n  }\n\n  get(key) {\n    const value = this._cache[key];\n    if (value) {\n      // update order\n      this._deleteOrder(key);\n      this._appendOrder(key);\n    }\n    return value;\n  }\n\n  set(key, value) {\n    if (!this._cache[key]) {\n      // if reach limit, delete the oldest\n      if (Object.keys(this._cache).length === this.limit) {\n        this.delete(this._order[0]);\n      }\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    } else {\n      // if found in cache, delete the old one, insert new one to the first of list\n      this.delete(key);\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    }\n  }\n\n  delete(key) {\n    const value = this._cache[key];\n    if (value) {\n      this._deleteCache(key);\n      this._deleteOrder(key);\n    }\n  }\n\n  _deleteCache(key) {\n    delete this._cache[key];\n  }\n\n  _deleteOrder(key) {\n    const index = this._order.findIndex(o => o === key);\n    if (index >= 0) {\n      this._order.splice(index, 1);\n    }\n  }\n\n  _appendOrder(key) {\n    this._order.push(key);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}