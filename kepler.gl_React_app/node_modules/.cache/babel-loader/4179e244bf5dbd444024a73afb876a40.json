{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { copyStringToDataView } from '@loaders.gl/loader-utils';\nimport { MAGIC_ARRAY } from '../constants';\nimport { encode3DTileHeader, encode3DTileByteLength } from './helpers/encode-3d-tile-header';\nexport function encodeBatchedModel3DTile(tile, dataView, byteOffset, options) {\n  var _tile = tile,\n    _tile$featuresLength = _tile.featuresLength,\n    featuresLength = _tile$featuresLength === void 0 ? 1 : _tile$featuresLength;\n  var featureTableJson = {\n    BATCH_LENGTH: featuresLength\n  };\n  var featureTableJsonString = JSON.stringify(featureTableJson);\n  var featureTableJsonByteLength = featureTableJsonString.length;\n  tile = _objectSpread({\n    magic: MAGIC_ARRAY.BATCHED_MODEL\n  }, tile);\n  var byteOffsetStart = byteOffset;\n  byteOffset = encode3DTileHeader(tile, dataView, byteOffset);\n  if (dataView) {\n    dataView.setUint32(12, featureTableJsonByteLength, true);\n    dataView.setUint32(16, 0, true);\n    dataView.setUint32(20, 0, true);\n    dataView.setUint32(24, 0, true);\n  }\n  byteOffset += 16;\n  byteOffset += copyStringToDataView(dataView, byteOffset, featureTableJsonString, featureTableJsonByteLength);\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n  return byteOffset;\n}","map":{"version":3,"sources":["../../../../src/lib/encoders/encode-3d-tile-batched-model.js"],"names":["copyStringToDataView","MAGIC_ARRAY","encode3DTileHeader","encode3DTileByteLength","encodeBatchedModel3DTile","tile","dataView","byteOffset","options","featuresLength","featureTableJson","BATCH_LENGTH","featureTableJsonString","JSON","stringify","featureTableJsonByteLength","length","magic","BATCHED_MODEL","byteOffsetStart","setUint32"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,SAAQA,oBAAR,QAAmC,0BAAnC;AACA,SAAQC,WAAR,QAA0B,cAA1B;AACA,SAAQC,kBAAR,EAA4BC,sBAA5B,QAAyD,iCAAzD;AAGA,OAAO,SAASC,wBAAT,CAAkCC,IAAlC,EAAwCC,QAAxC,EAAkDC,UAAlD,EAA8DC,OAA9D,EAAuE;EAAA,IAAA,KAAA,GAC/CH,IAD+C;IAAA,oBAAA,GAAA,KAAA,CACrEI,cADqE;IACrEA,cADqE,GAAA,oBAAA,KAAA,KAAA,CAAA,GACpD,CADoD,GAAA,oBAAA;EAG5E,IAAMC,gBAAgB,GAAG;IACvBC,YAAY,EAAEF;EADS,CAAzB;EAGA,IAAMG,sBAAsB,GAAGC,IAAI,CAACC,SAALD,CAAeH,gBAAfG,CAA/B;EACA,IAAME,0BAA0B,GAAGH,sBAAsB,CAACI,MAA1D;EAGAX,IAAI,GAAA,aAAA,CAAA;IAAIY,KAAK,EAAEhB,WAAW,CAACiB;EAAvB,CAAA,EAAyCb,IAAzC,CAAJA;EAEA,IAAMc,eAAe,GAAGZ,UAAxB;EAEAA,UAAU,GAAGL,kBAAkB,CAACG,IAAD,EAAOC,QAAP,EAAiBC,UAAjB,CAA/BA;EAEA,IAAID,QAAJ,EAAc;IACZA,QAAQ,CAACc,SAATd,CAAmB,EAAnBA,EAAuBS,0BAAvBT,EAAmD,IAAnDA,CAAAA;IACAA,QAAQ,CAACc,SAATd,CAAmB,EAAnBA,EAAuB,CAAvBA,EAA0B,IAA1BA,CAAAA;IACAA,QAAQ,CAACc,SAATd,CAAmB,EAAnBA,EAAuB,CAAvBA,EAA0B,IAA1BA,CAAAA;IACAA,QAAQ,CAACc,SAATd,CAAmB,EAAnBA,EAAuB,CAAvBA,EAA0B,IAA1BA,CAAAA;EACD;EACDC,UAAU,IAAI,EAAdA;EAGAA,UAAU,IAAIP,oBAAoB,CAChCM,QADgC,EAEhCC,UAFgC,EAGhCK,sBAHgC,EAIhCG,0BAJgC,CAAlCR;EASAJ,sBAAsB,CAACG,QAAD,EAAWa,eAAX,EAA4BZ,UAAU,GAAGY,eAAzC,CAAtBhB;EAEA,OAAOI,UAAP;AACD","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {copyStringToDataView} from '@loaders.gl/loader-utils';\nimport {MAGIC_ARRAY} from '../constants';\nimport {encode3DTileHeader, encode3DTileByteLength} from './helpers/encode-3d-tile-header';\n\n// Procedurally encode the tile array dataView for testing purposes\nexport function encodeBatchedModel3DTile(tile, dataView, byteOffset, options) {\n  const {featuresLength = 1} = tile;\n\n  const featureTableJson = {\n    BATCH_LENGTH: featuresLength\n  };\n  const featureTableJsonString = JSON.stringify(featureTableJson);\n  const featureTableJsonByteLength = featureTableJsonString.length;\n\n  // Add default magic for this tile type\n  tile = {magic: MAGIC_ARRAY.BATCHED_MODEL, ...tile};\n\n  const byteOffsetStart = byteOffset;\n\n  byteOffset = encode3DTileHeader(tile, dataView, byteOffset);\n\n  if (dataView) {\n    dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength\n    dataView.setUint32(16, 0, true); // featureTableBinaryByteLength\n    dataView.setUint32(20, 0, true); // batchTableJsonByteLength\n    dataView.setUint32(24, 0, true); // batchTableBinaryByteLength\n  }\n  byteOffset += 16;\n\n  // TODO feature table binary\n  byteOffset += copyStringToDataView(\n    dataView,\n    byteOffset,\n    featureTableJsonString,\n    featureTableJsonByteLength\n  );\n  // TODO batch table\n\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n\n  return byteOffset;\n}\n"]},"metadata":{},"sourceType":"module"}