{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar QUANTIZED_MESH_HEADER = new Map([['centerX', Float64Array.BYTES_PER_ELEMENT], ['centerY', Float64Array.BYTES_PER_ELEMENT], ['centerZ', Float64Array.BYTES_PER_ELEMENT], ['minHeight', Float32Array.BYTES_PER_ELEMENT], ['maxHeight', Float32Array.BYTES_PER_ELEMENT], ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]]);\nfunction decodeZigZag(value) {\n  return value >> 1 ^ -(value & 1);\n}\nfunction decodeHeader(dataView) {\n  var position = 0;\n  var header = {};\n  var _iterator = _createForOfIteratorHelper(QUANTIZED_MESH_HEADER),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        key = _step$value[0],\n        bytesCount = _step$value[1];\n      var getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n      header[key] = getter.call(dataView, position, true);\n      position += bytesCount;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    header: header,\n    headerEndPosition: position\n  };\n}\nfunction decodeVertexData(dataView, headerEndPosition) {\n  var position = headerEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = dataView.getUint32(position, true);\n  var vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  var elementArrayLength = vertexCount * bytesPerArrayElement;\n  var uArrayStartPosition = position;\n  var vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  var heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n  var u = 0;\n  var v = 0;\n  var height = 0;\n  for (var i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n  position += elementArrayLength * 3;\n  return {\n    vertexData: vertexData,\n    vertexDataEndPosition: position\n  };\n}\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex) {\n  var encoded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var indices;\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n  if (!encoded) {\n    return indices;\n  }\n  var highest = 0;\n  for (var i = 0; i < indices.length; ++i) {\n    var code = indices[i];\n    indices[i] = highest - code;\n    if (code === 0) {\n      ++highest;\n    }\n  }\n  return indices;\n}\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  var position = vertexDataEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = vertexData.length / elementsPerVertex;\n  var bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - position % bytesPerIndex;\n  }\n  var triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var triangleIndicesCount = triangleCount * 3;\n  var triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);\n  position += triangleIndicesCount * bytesPerIndex;\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices: triangleIndices\n  };\n}\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  var position = triangleIndicesEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = vertexData.length / elementsPerVertex;\n  var bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n  var westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n  var southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);\n  position += southVertexCount * bytesPerIndex;\n  var eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n  var northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);\n  position += northVertexCount * bytesPerIndex;\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices: westIndices,\n    southIndices: southIndices,\n    eastIndices: eastIndices,\n    northIndices: northIndices\n  };\n}\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);\n}\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);\n}\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  var extensions = {};\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {\n      extensions: extensions,\n      extensionsEndPosition: indicesEndPosition\n    };\n  }\n  var position = indicesEndPosition;\n  while (position < dataView.byteLength) {\n    var extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n    var extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    var extensionView = new DataView(dataView.buffer, position, extensionLength);\n    switch (extensionId) {\n      case 1:\n        {\n          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n          break;\n        }\n      case 2:\n        {\n          extensions.waterMask = decodeWaterMaskExtension(extensionView);\n          break;\n        }\n      default:\n        {}\n    }\n    position += extensionLength;\n  }\n  return {\n    extensions: extensions,\n    extensionsEndPosition: position\n  };\n}\nexport var DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\nvar DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\nexport default function decode(data, userOptions) {\n  var options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  var view = new DataView(data);\n  var _decodeHeader = decodeHeader(view),\n    header = _decodeHeader.header,\n    headerEndPosition = _decodeHeader.headerEndPosition;\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {\n      header: header\n    };\n  }\n  var _decodeVertexData = decodeVertexData(view, headerEndPosition),\n    vertexData = _decodeVertexData.vertexData,\n    vertexDataEndPosition = _decodeVertexData.vertexDataEndPosition;\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {\n      header: header,\n      vertexData: vertexData\n    };\n  }\n  var _decodeTriangleIndice = decodeTriangleIndices(view, vertexData, vertexDataEndPosition),\n    triangleIndices = _decodeTriangleIndice.triangleIndices,\n    triangleIndicesEndPosition = _decodeTriangleIndice.triangleIndicesEndPosition;\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {\n      header: header,\n      vertexData: vertexData,\n      triangleIndices: triangleIndices\n    };\n  }\n  var _decodeEdgeIndices = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition),\n    westIndices = _decodeEdgeIndices.westIndices,\n    southIndices = _decodeEdgeIndices.southIndices,\n    eastIndices = _decodeEdgeIndices.eastIndices,\n    northIndices = _decodeEdgeIndices.northIndices,\n    edgeIndicesEndPosition = _decodeEdgeIndices.edgeIndicesEndPosition;\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header: header,\n      vertexData: vertexData,\n      triangleIndices: triangleIndices,\n      westIndices: westIndices,\n      northIndices: northIndices,\n      eastIndices: eastIndices,\n      southIndices: southIndices\n    };\n  }\n  var _decodeExtensions = decodeExtensions(view, edgeIndicesEndPosition),\n    extensions = _decodeExtensions.extensions;\n  return {\n    header: header,\n    vertexData: vertexData,\n    triangleIndices: triangleIndices,\n    westIndices: westIndices,\n    northIndices: northIndices,\n    eastIndices: eastIndices,\n    southIndices: southIndices,\n    extensions: extensions\n  };\n}","map":{"version":3,"sources":["../../../src/lib/decode-quantized-mesh.js"],"names":["QUANTIZED_MESH_HEADER","Map","Float64Array","BYTES_PER_ELEMENT","Float32Array","decodeZigZag","value","decodeHeader","dataView","position","header","key","bytesCount","getter","getFloat64","getFloat32","call","headerEndPosition","decodeVertexData","elementsPerVertex","vertexCount","getUint32","vertexData","Uint16Array","Uint32Array","bytesPerArrayElement","elementArrayLength","uArrayStartPosition","vArrayStartPosition","heightArrayStartPosition","u","v","height","i","getUint16","vertexDataEndPosition","decodeIndex","buffer","indicesCount","bytesPerIndex","encoded","indices","highest","length","code","decodeTriangleIndices","triangleCount","triangleIndicesCount","triangleIndices","triangleIndicesEndPosition","decodeEdgeIndices","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","edgeIndicesEndPosition","decodeVertexNormalsExtension","extensionDataView","Uint8Array","byteOffset","byteLength","decodeWaterMaskExtension","slice","decodeExtensions","indicesEndPosition","extensions","extensionsEndPosition","extensionId","getUint8","extensionLength","extensionView","DataView","vertexNormals","waterMask","DECODING_STEPS","vertices","edgeIndices","DEFAULT_OPTIONS","maxDecodingStep","decode","data","userOptions","options","Object","assign","view"],"mappings":"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","sourcesContent":["// Copyright (C) 2018-2019 HERE Europe B.V.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst QUANTIZED_MESH_HEADER = new Map([\n  ['centerX', Float64Array.BYTES_PER_ELEMENT],\n  ['centerY', Float64Array.BYTES_PER_ELEMENT],\n  ['centerZ', Float64Array.BYTES_PER_ELEMENT],\n\n  ['minHeight', Float32Array.BYTES_PER_ELEMENT],\n  ['maxHeight', Float32Array.BYTES_PER_ELEMENT],\n\n  ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT],\n\n  ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]\n]);\n\nfunction decodeZigZag(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  let position = 0;\n  const header = {};\n\n  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n\n    header[key] = getter.call(dataView, position, true);\n    position += bytesCount;\n  }\n\n  return {header, headerEndPosition: position};\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  let position = headerEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = dataView.getUint32(position, true);\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  const elementArrayLength = vertexCount * bytesPerArrayElement;\n  const uArrayStartPosition = position;\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(\n      dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true)\n    );\n\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n\n  return {vertexData, vertexDataEndPosition: position};\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n  let indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  let highest = 0;\n\n  for (let i = 0; i < indices.length; ++i) {\n    const code = indices[i];\n\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - (position % bytesPerIndex);\n  }\n\n  const triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const triangleIndicesCount = triangleCount * 3;\n  const triangleIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    triangleIndicesCount,\n    bytesPerIndex\n  );\n  position += triangleIndicesCount * bytesPerIndex;\n\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  const westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n\n  const southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const southIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    southVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += southVertexCount * bytesPerIndex;\n\n  const eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n\n  const northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const northIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    northVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += northVertexCount * bytesPerIndex;\n\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(\n    extensionDataView.buffer,\n    extensionDataView.byteOffset,\n    extensionDataView.byteLength\n  );\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(\n    extensionDataView.byteOffset,\n    extensionDataView.byteOffset + extensionDataView.byteLength\n  );\n}\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  const extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {extensions, extensionsEndPosition: indicesEndPosition};\n  }\n\n  let position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n\n    const extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n\n    const extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1: {\n        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n\n        break;\n      }\n      case 2: {\n        extensions.waterMask = decodeWaterMaskExtension(extensionView);\n\n        break;\n      }\n      default: {\n        // console.warn(`Unknown extension with id ${extensionId}`)\n      }\n    }\n\n    position += extensionLength;\n  }\n\n  return {extensions, extensionsEndPosition: position};\n}\n\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\n\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\n\nexport default function decode(data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  const view = new DataView(data);\n  const {header, headerEndPosition} = decodeHeader(view);\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {header};\n  }\n\n  const {vertexData, vertexDataEndPosition} = decodeVertexData(view, headerEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {header, vertexData};\n  }\n\n  const {triangleIndices, triangleIndicesEndPosition} = decodeTriangleIndices(\n    view,\n    vertexData,\n    vertexDataEndPosition\n  );\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {header, vertexData, triangleIndices};\n  }\n\n  const {\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices,\n    edgeIndicesEndPosition\n  } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    };\n  }\n\n  const {extensions} = decodeExtensions(view, edgeIndicesEndPosition);\n\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  };\n}\n"]},"metadata":{},"sourceType":"module"}