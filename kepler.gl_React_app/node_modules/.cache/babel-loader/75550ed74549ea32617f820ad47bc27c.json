{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.pointVisConfigs = exports.pointOptionalColumns = exports.pointRequiredColumns = exports.pointPosAccessor = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _extensions = require(\"@deck.gl/extensions\");\nvar _layers = require(\"@deck.gl/layers\");\nvar _baseLayer = _interopRequireDefault(require(\"../base-layer\"));\nvar _colorUtils = require(\"../../utils/color-utils\");\nvar _datasetUtils = require(\"../../utils/dataset-utils\");\nvar _pointLayerIcon = _interopRequireDefault(require(\"./point-layer-icon\"));\nvar _defaultSettings = require(\"../../constants/default-settings\");\nvar _layerTextLabel = require(\"../layer-text-label\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar pointPosAccessor = function pointPosAccessor(_ref) {\n  var lat = _ref.lat,\n    lng = _ref.lng,\n    altitude = _ref.altitude;\n  return function (dc) {\n    return function (d) {\n      return [dc.valueAt(d.index, lng.fieldIdx), dc.valueAt(d.index, lat.fieldIdx), altitude && altitude.fieldIdx > -1 ? dc.valueAt(d.index, altitude.fieldIdx) : 0];\n    };\n  };\n};\nexports.pointPosAccessor = pointPosAccessor;\nvar pointRequiredColumns = ['lat', 'lng'];\nexports.pointRequiredColumns = pointRequiredColumns;\nvar pointOptionalColumns = ['altitude'];\nexports.pointOptionalColumns = pointOptionalColumns;\nvar brushingExtension = new _extensions.BrushingExtension();\nvar pointVisConfigs = {\n  radius: 'radius',\n  fixedRadius: 'fixedRadius',\n  opacity: 'opacity',\n  outline: 'outline',\n  thickness: 'thickness',\n  strokeColor: 'strokeColor',\n  colorRange: 'colorRange',\n  strokeColorRange: 'strokeColorRange',\n  radiusRange: 'radiusRange',\n  filled: {\n    type: 'boolean',\n    label: 'layer.fillColor',\n    defaultValue: true,\n    property: 'filled'\n  }\n};\nexports.pointVisConfigs = pointVisConfigs;\nvar PointLayer = /*#__PURE__*/function (_Layer) {\n  (0, _inherits2[\"default\"])(PointLayer, _Layer);\n  var _super = _createSuper(PointLayer);\n  function PointLayer(props) {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, PointLayer);\n    _this = _super.call(this, props);\n    _this.registerVisConfig(pointVisConfigs);\n    _this.getPositionAccessor = function (dataContainer) {\n      return pointPosAccessor(_this.config.columns)(dataContainer);\n    };\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(PointLayer, [{\n    key: \"type\",\n    get: function get() {\n      return 'point';\n    }\n  }, {\n    key: \"isAggregated\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"layerIcon\",\n    get: function get() {\n      return _pointLayerIcon[\"default\"];\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return pointRequiredColumns;\n    }\n  }, {\n    key: \"optionalColumns\",\n    get: function get() {\n      return pointOptionalColumns;\n    }\n  }, {\n    key: \"columnPairs\",\n    get: function get() {\n      return this.defaultPointColumnPairs;\n    }\n  }, {\n    key: \"noneLayerDataAffectingProps\",\n    get: function get() {\n      return [].concat((0, _toConsumableArray2[\"default\"])((0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(PointLayer.prototype), \"noneLayerDataAffectingProps\", this)), ['radius']);\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      return {\n        color: _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(PointLayer.prototype), \"visualChannels\", this).color), {}, {\n          accessor: 'getFillColor',\n          condition: function condition(config) {\n            return config.visConfig.filled;\n          },\n          defaultValue: function defaultValue(config) {\n            return config.color;\n          }\n        }),\n        strokeColor: {\n          property: 'strokeColor',\n          key: 'strokeColor',\n          field: 'strokeColorField',\n          scale: 'strokeColorScale',\n          domain: 'strokeColorDomain',\n          range: 'strokeColorRange',\n          channelScaleType: _defaultSettings.CHANNEL_SCALES.color,\n          accessor: 'getLineColor',\n          condition: function condition(config) {\n            return config.visConfig.outline;\n          },\n          defaultValue: function defaultValue(config) {\n            return config.visConfig.strokeColor || config.color;\n          }\n        },\n        size: _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(PointLayer.prototype), \"visualChannels\", this).size), {}, {\n          property: 'radius',\n          range: 'radiusRange',\n          fixed: 'fixedRadius',\n          channelScaleType: 'radius',\n          accessor: 'getRadius',\n          defaultValue: 1\n        })\n      };\n    }\n  }, {\n    key: \"setInitialLayerConfig\",\n    value: function setInitialLayerConfig(dataset) {\n      var defaultColorField = (0, _datasetUtils.findDefaultColorField)(dataset);\n      if (defaultColorField) {\n        this.updateLayerConfig({\n          colorField: defaultColorField\n        });\n        this.updateLayerVisualChannel(dataset, 'color');\n      }\n      return this;\n    }\n  }, {\n    key: \"getDefaultLayerConfig\",\n    value: function getDefaultLayerConfig() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(PointLayer.prototype), \"getDefaultLayerConfig\", this).call(this, props)), {}, {\n        // add stroke color visual channel\n        strokeColorField: null,\n        strokeColorDomain: [0, 1],\n        strokeColorScale: 'quantile'\n      });\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(_ref2, getPosition) {\n      var filteredIndex = _ref2.filteredIndex;\n      var data = [];\n      for (var i = 0; i < filteredIndex.length; i++) {\n        var index = filteredIndex[i];\n        var pos = getPosition({\n          index: index\n        }); // if doesn't have point lat or lng, do not add the point\n        // deck.gl can't handle position = null\n\n        if (pos.every(Number.isFinite)) {\n          data.push({\n            position: pos,\n            index: index\n          });\n        }\n      }\n      return data;\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, oldLayerData) {\n      var textLabel = this.config.textLabel;\n      var _datasets$this$config = datasets[this.config.dataId],\n        gpuFilter = _datasets$this$config.gpuFilter,\n        dataContainer = _datasets$this$config.dataContainer;\n      var _this$updateData = this.updateData(datasets, oldLayerData),\n        data = _this$updateData.data,\n        triggerChanged = _this$updateData.triggerChanged;\n      var getPosition = this.getPositionAccessor(dataContainer); // get all distinct characters in the text labels\n\n      var textLabels = (0, _layerTextLabel.formatTextLabelData)({\n        textLabel: textLabel,\n        triggerChanged: triggerChanged,\n        oldLayerData: oldLayerData,\n        data: data,\n        dataContainer: dataContainer\n      });\n      var accessors = this.getAttributeAccessors({\n        dataContainer: dataContainer\n      });\n      return _objectSpread({\n        data: data,\n        getPosition: getPosition,\n        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(),\n        textLabels: textLabels\n      }, accessors);\n    }\n    /* eslint-enable complexity */\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer) {\n      var getPosition = this.getPositionAccessor(dataContainer);\n      var bounds = this.getPointsBounds(dataContainer, getPosition);\n      this.updateMeta({\n        bounds: bounds\n      });\n    }\n  }, {\n    key: \"renderLayer\",\n    value: function renderLayer(opts) {\n      var _this$config$columns$;\n      var data = opts.data,\n        gpuFilter = opts.gpuFilter,\n        objectHovered = opts.objectHovered,\n        mapState = opts.mapState,\n        interactionConfig = opts.interactionConfig; // if no field size is defined we need to pass fixed radius = false\n\n      var fixedRadius = this.config.visConfig.fixedRadius && Boolean(this.config.sizeField);\n      var radiusScale = this.getRadiusScaleByZoom(mapState, fixedRadius);\n      var layerProps = _objectSpread({\n        stroked: this.config.visConfig.outline,\n        filled: this.config.visConfig.filled,\n        lineWidthScale: this.config.visConfig.thickness,\n        radiusScale: radiusScale\n      }, this.config.visConfig.fixedRadius ? {} : {\n        radiusMaxPixels: 500\n      });\n      var updateTriggers = _objectSpread({\n        getPosition: this.config.columns,\n        getFilterValue: gpuFilter.filterValueUpdateTriggers\n      }, this.getVisualChannelUpdateTriggers());\n      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n      var brushingProps = this.getBrushingExtensionProps(interactionConfig);\n      var getPixelOffset = (0, _layerTextLabel.getTextOffsetByRadius)(radiusScale, data.getRadius, mapState);\n      var extensions = [].concat((0, _toConsumableArray2[\"default\"])(defaultLayerProps.extensions), [brushingExtension]);\n      var sharedProps = _objectSpread({\n        getFilterValue: data.getFilterValue,\n        extensions: extensions,\n        filterRange: defaultLayerProps.filterRange,\n        visible: defaultLayerProps.visible\n      }, brushingProps);\n      var hoveredObject = this.hasHoveredObject(objectHovered);\n      return [new _layers.ScatterplotLayer(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), brushingProps), layerProps), data), {}, {\n        parameters: {\n          // circles will be flat on the map when the altitude column is not used\n          depthTest: ((_this$config$columns$ = this.config.columns.altitude) === null || _this$config$columns$ === void 0 ? void 0 : _this$config$columns$.fieldIdx) > -1\n        },\n        lineWidthUnits: 'pixels',\n        updateTriggers: updateTriggers,\n        extensions: extensions\n      }))].concat((0, _toConsumableArray2[\"default\"])(hoveredObject ? [new _layers.ScatterplotLayer(_objectSpread(_objectSpread(_objectSpread({}, this.getDefaultHoverLayerProps()), layerProps), {}, {\n        data: [hoveredObject],\n        getLineColor: this.config.highlightColor,\n        getFillColor: this.config.highlightColor,\n        getRadius: data.getRadius,\n        getPosition: data.getPosition\n      }))] : []), (0, _toConsumableArray2[\"default\"])(this.renderTextLabelLayer({\n        getPosition: data.getPosition,\n        sharedProps: sharedProps,\n        getPixelOffset: getPixelOffset,\n        updateTriggers: updateTriggers\n      }, opts)));\n    }\n  }], [{\n    key: \"findDefaultLayerProps\",\n    value: function findDefaultLayerProps(_ref3) {\n      var _ref3$fieldPairs = _ref3.fieldPairs,\n        fieldPairs = _ref3$fieldPairs === void 0 ? [] : _ref3$fieldPairs;\n      var props = []; // Make layer for each pair\n\n      fieldPairs.forEach(function (pair) {\n        var latField = pair.pair.lat;\n        var lngField = pair.pair.lng;\n        var layerName = pair.defaultName;\n        var prop = {\n          label: layerName.length ? layerName : 'Point'\n        }; // default layer color for begintrip and dropoff point\n\n        if (latField.value in _defaultSettings.DEFAULT_LAYER_COLOR) {\n          prop.color = (0, _colorUtils.hexToRgb)(_defaultSettings.DEFAULT_LAYER_COLOR[latField.value]);\n        } // set the first layer to be visible\n\n        if (props.length === 0) {\n          prop.isVisible = true;\n        }\n        prop.columns = {\n          lat: latField,\n          lng: lngField,\n          altitude: {\n            value: null,\n            fieldIdx: -1,\n            optional: true\n          }\n        };\n        props.push(prop);\n      });\n      return {\n        props: props\n      };\n    }\n  }]);\n  return PointLayer;\n}(_baseLayer[\"default\"]);\nexports[\"default\"] = PointLayer;","map":{"version":3,"sources":["../../../src/layers/point-layer/point-layer.js"],"names":["pointPosAccessor","lat","lng","altitude","dc","valueAt","d","index","fieldIdx","pointRequiredColumns","pointOptionalColumns","brushingExtension","BrushingExtension","pointVisConfigs","radius","fixedRadius","opacity","outline","thickness","strokeColor","colorRange","strokeColorRange","radiusRange","filled","type","label","defaultValue","property","PointLayer","Layer","props","registerVisConfig","getPositionAccessor","config","columns","dataContainer","PointLayerIcon","defaultPointColumnPairs","color","accessor","condition","visConfig","key","field","scale","domain","range","channelScaleType","CHANNEL_SCALES","size","fixed","dataset","defaultColorField","updateLayerConfig","colorField","updateLayerVisualChannel","fieldPairs","forEach","latField","pair","lngField","layerName","defaultName","prop","length","value","DEFAULT_LAYER_COLOR","isVisible","optional","push","strokeColorField","strokeColorDomain","strokeColorScale","filteredIndex","getPosition","data","i","pos","every","Number","isFinite","position","datasets","oldLayerData","textLabel","gpuFilter","dataId","triggerChanged","updateData","textLabels","accessors","getAttributeAccessors","getFilterValue","filterValueAccessor","bounds","getPointsBounds","updateMeta","opts","objectHovered","mapState","interactionConfig","Boolean","sizeField","radiusScale","getRadiusScaleByZoom","layerProps","stroked","lineWidthScale","radiusMaxPixels","updateTriggers","filterValueUpdateTriggers","getVisualChannelUpdateTriggers","defaultLayerProps","getDefaultDeckLayerProps","brushingProps","getBrushingExtensionProps","getPixelOffset","getRadius","extensions","sharedProps","filterRange","visible","hoveredObject","hasHoveredObject","ScatterplotLayer","parameters","depthTest","lineWidthUnits","getDefaultHoverLayerProps","getLineColor","highlightColor","getFillColor","renderTextLabelLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {BrushingExtension} from '@deck.gl/extensions';\nimport {ScatterplotLayer} from '@deck.gl/layers';\n\nimport Layer from '../base-layer';\nimport {hexToRgb} from 'utils/color-utils';\nimport {findDefaultColorField} from 'utils/dataset-utils';\nimport PointLayerIcon from './point-layer-icon';\nimport {DEFAULT_LAYER_COLOR, CHANNEL_SCALES} from 'constants/default-settings';\n\nimport {getTextOffsetByRadius, formatTextLabelData} from '../layer-text-label';\n\nexport const pointPosAccessor = ({lat, lng, altitude}) => dc => d => [\n  dc.valueAt(d.index, lng.fieldIdx),\n  dc.valueAt(d.index, lat.fieldIdx),\n  altitude && altitude.fieldIdx > -1 ? dc.valueAt(d.index, altitude.fieldIdx) : 0\n];\n\nexport const pointRequiredColumns = ['lat', 'lng'];\nexport const pointOptionalColumns = ['altitude'];\n\nconst brushingExtension = new BrushingExtension();\n\nexport const pointVisConfigs = {\n  radius: 'radius',\n  fixedRadius: 'fixedRadius',\n  opacity: 'opacity',\n  outline: 'outline',\n  thickness: 'thickness',\n  strokeColor: 'strokeColor',\n  colorRange: 'colorRange',\n  strokeColorRange: 'strokeColorRange',\n  radiusRange: 'radiusRange',\n  filled: {\n    type: 'boolean',\n    label: 'layer.fillColor',\n    defaultValue: true,\n    property: 'filled'\n  }\n};\n\nexport default class PointLayer extends Layer {\n  constructor(props) {\n    super(props);\n\n    this.registerVisConfig(pointVisConfigs);\n    this.getPositionAccessor = dataContainer =>\n      pointPosAccessor(this.config.columns)(dataContainer);\n  }\n\n  get type() {\n    return 'point';\n  }\n\n  get isAggregated() {\n    return false;\n  }\n\n  get layerIcon() {\n    return PointLayerIcon;\n  }\n  get requiredLayerColumns() {\n    return pointRequiredColumns;\n  }\n\n  get optionalColumns() {\n    return pointOptionalColumns;\n  }\n\n  get columnPairs() {\n    return this.defaultPointColumnPairs;\n  }\n\n  get noneLayerDataAffectingProps() {\n    return [...super.noneLayerDataAffectingProps, 'radius'];\n  }\n\n  get visualChannels() {\n    return {\n      color: {\n        ...super.visualChannels.color,\n        accessor: 'getFillColor',\n        condition: config => config.visConfig.filled,\n        defaultValue: config => config.color\n      },\n      strokeColor: {\n        property: 'strokeColor',\n        key: 'strokeColor',\n        field: 'strokeColorField',\n        scale: 'strokeColorScale',\n        domain: 'strokeColorDomain',\n        range: 'strokeColorRange',\n        channelScaleType: CHANNEL_SCALES.color,\n        accessor: 'getLineColor',\n        condition: config => config.visConfig.outline,\n        defaultValue: config => config.visConfig.strokeColor || config.color\n      },\n      size: {\n        ...super.visualChannels.size,\n        property: 'radius',\n        range: 'radiusRange',\n        fixed: 'fixedRadius',\n        channelScaleType: 'radius',\n        accessor: 'getRadius',\n        defaultValue: 1\n      }\n    };\n  }\n\n  setInitialLayerConfig(dataset) {\n    const defaultColorField = findDefaultColorField(dataset);\n\n    if (defaultColorField) {\n      this.updateLayerConfig({\n        colorField: defaultColorField\n      });\n      this.updateLayerVisualChannel(dataset, 'color');\n    }\n\n    return this;\n  }\n\n  static findDefaultLayerProps({fieldPairs = []}) {\n    const props = [];\n\n    // Make layer for each pair\n    fieldPairs.forEach(pair => {\n      const latField = pair.pair.lat;\n      const lngField = pair.pair.lng;\n      const layerName = pair.defaultName;\n\n      const prop = {\n        label: layerName.length ? layerName : 'Point'\n      };\n\n      // default layer color for begintrip and dropoff point\n      if (latField.value in DEFAULT_LAYER_COLOR) {\n        prop.color = hexToRgb(DEFAULT_LAYER_COLOR[latField.value]);\n      }\n\n      // set the first layer to be visible\n      if (props.length === 0) {\n        prop.isVisible = true;\n      }\n\n      prop.columns = {\n        lat: latField,\n        lng: lngField,\n        altitude: {value: null, fieldIdx: -1, optional: true}\n      };\n\n      props.push(prop);\n    });\n\n    return {props};\n  }\n\n  getDefaultLayerConfig(props = {}) {\n    return {\n      ...super.getDefaultLayerConfig(props),\n\n      // add stroke color visual channel\n      strokeColorField: null,\n      strokeColorDomain: [0, 1],\n      strokeColorScale: 'quantile'\n    };\n  }\n\n  calculateDataAttribute({filteredIndex}, getPosition) {\n    const data = [];\n\n    for (let i = 0; i < filteredIndex.length; i++) {\n      const index = filteredIndex[i];\n      const pos = getPosition({index});\n\n      // if doesn't have point lat or lng, do not add the point\n      // deck.gl can't handle position = null\n      if (pos.every(Number.isFinite)) {\n        data.push({\n          position: pos,\n          index\n        });\n      }\n    }\n    return data;\n  }\n\n  formatLayerData(datasets, oldLayerData) {\n    const {textLabel} = this.config;\n    const {gpuFilter, dataContainer} = datasets[this.config.dataId];\n    const {data, triggerChanged} = this.updateData(datasets, oldLayerData);\n    const getPosition = this.getPositionAccessor(dataContainer);\n\n    // get all distinct characters in the text labels\n    const textLabels = formatTextLabelData({\n      textLabel,\n      triggerChanged,\n      oldLayerData,\n      data,\n      dataContainer\n    });\n\n    const accessors = this.getAttributeAccessors({dataContainer});\n\n    return {\n      data,\n      getPosition,\n      getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(),\n      textLabels,\n      ...accessors\n    };\n  }\n  /* eslint-enable complexity */\n\n  updateLayerMeta(dataContainer) {\n    const getPosition = this.getPositionAccessor(dataContainer);\n    const bounds = this.getPointsBounds(dataContainer, getPosition);\n    this.updateMeta({bounds});\n  }\n\n  renderLayer(opts) {\n    const {data, gpuFilter, objectHovered, mapState, interactionConfig} = opts;\n\n    // if no field size is defined we need to pass fixed radius = false\n    const fixedRadius = this.config.visConfig.fixedRadius && Boolean(this.config.sizeField);\n    const radiusScale = this.getRadiusScaleByZoom(mapState, fixedRadius);\n\n    const layerProps = {\n      stroked: this.config.visConfig.outline,\n      filled: this.config.visConfig.filled,\n      lineWidthScale: this.config.visConfig.thickness,\n      radiusScale,\n      ...(this.config.visConfig.fixedRadius ? {} : {radiusMaxPixels: 500})\n    };\n\n    const updateTriggers = {\n      getPosition: this.config.columns,\n      getFilterValue: gpuFilter.filterValueUpdateTriggers,\n      ...this.getVisualChannelUpdateTriggers()\n    };\n\n    const defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n    const brushingProps = this.getBrushingExtensionProps(interactionConfig);\n    const getPixelOffset = getTextOffsetByRadius(radiusScale, data.getRadius, mapState);\n    const extensions = [...defaultLayerProps.extensions, brushingExtension];\n\n    const sharedProps = {\n      getFilterValue: data.getFilterValue,\n      extensions,\n      filterRange: defaultLayerProps.filterRange,\n      visible: defaultLayerProps.visible,\n      ...brushingProps\n    };\n    const hoveredObject = this.hasHoveredObject(objectHovered);\n\n    return [\n      new ScatterplotLayer({\n        ...defaultLayerProps,\n        ...brushingProps,\n        ...layerProps,\n        ...data,\n        parameters: {\n          // circles will be flat on the map when the altitude column is not used\n          depthTest: this.config.columns.altitude?.fieldIdx > -1\n        },\n        lineWidthUnits: 'pixels',\n        updateTriggers,\n        extensions\n      }),\n      // hover layer\n      ...(hoveredObject\n        ? [\n            new ScatterplotLayer({\n              ...this.getDefaultHoverLayerProps(),\n              ...layerProps,\n              data: [hoveredObject],\n              getLineColor: this.config.highlightColor,\n              getFillColor: this.config.highlightColor,\n              getRadius: data.getRadius,\n              getPosition: data.getPosition\n            })\n          ]\n        : []),\n      // text label layer\n      ...this.renderTextLabelLayer(\n        {\n          getPosition: data.getPosition,\n          sharedProps,\n          getPixelOffset,\n          updateTriggers\n        },\n        opts\n      )\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}