{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport * as KHR_binary_glTF from './extensions/KHR_binary_gltf';\nvar GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\nvar GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\nvar GLTFV1Normalizer = function () {\n  function GLTFV1Normalizer(gltf) {\n    _classCallCheck(this, GLTFV1Normalizer);\n    this.idToIndexMap = {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    };\n  }\n  _createClass(GLTFV1Normalizer, [{\n    key: \"normalize\",\n    value: function normalize(gltf, options) {\n      this.json = gltf.json;\n      var json = gltf.json;\n      switch (json.asset && json.asset.version) {\n        case '2.0':\n          return;\n        case undefined:\n        case '1.0':\n          break;\n        default:\n          console.warn(\"glTF: Unknown version \".concat(json.asset.version));\n          return;\n      }\n      if (!options.normalize) {\n        throw new Error('glTF v1 is not supported.');\n      }\n      console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n      this._addAsset(json);\n      this._convertTopLevelObjectsToArrays(json);\n      KHR_binary_glTF.decode(gltf, options);\n      this._convertObjectIdsToArrayIndices(json);\n      this._updateObjects(json);\n    }\n  }, {\n    key: \"_addAsset\",\n    value: function _addAsset(json) {\n      json.asset = json.asset || {};\n      json.asset.version = '2.0';\n      json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n    }\n  }, {\n    key: \"_convertTopLevelObjectsToArrays\",\n    value: function _convertTopLevelObjectsToArrays(json) {\n      for (var arrayName in GLTF_ARRAYS) {\n        this._convertTopLevelObjectToArray(json, arrayName);\n      }\n    }\n  }, {\n    key: \"_convertTopLevelObjectToArray\",\n    value: function _convertTopLevelObjectToArray(json, mapName) {\n      var objectMap = json[mapName];\n      if (!objectMap || Array.isArray(objectMap)) {\n        return;\n      }\n      json[mapName] = [];\n      for (var id in objectMap) {\n        var object = objectMap[id];\n        object.id = object.id || id;\n        var index = json[mapName].length;\n        json[mapName].push(object);\n        this.idToIndexMap[mapName][id] = index;\n      }\n    }\n  }, {\n    key: \"_convertObjectIdsToArrayIndices\",\n    value: function _convertObjectIdsToArrayIndices(json) {\n      for (var arrayName in GLTF_ARRAYS) {\n        this._convertIdsToIndices(json, arrayName);\n      }\n      if ('scene' in json) {\n        json.scene = this._convertIdToIndex(json.scene, 'scene');\n      }\n      var _iterator = _createForOfIteratorHelper(json.textures),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var texture = _step.value;\n          this._convertTextureIds(texture);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(json.meshes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var mesh = _step2.value;\n          this._convertMeshIds(mesh);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _iterator3 = _createForOfIteratorHelper(json.nodes),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var node = _step3.value;\n          this._convertNodeIds(node);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var _iterator4 = _createForOfIteratorHelper(json.scenes),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _node = _step4.value;\n          this._convertSceneIds(_node);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"_convertTextureIds\",\n    value: function _convertTextureIds(texture) {\n      if (texture.source) {\n        texture.source = this._convertIdToIndex(texture.source, 'image');\n      }\n    }\n  }, {\n    key: \"_convertMeshIds\",\n    value: function _convertMeshIds(mesh) {\n      var _iterator5 = _createForOfIteratorHelper(mesh.primitives),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var primitive = _step5.value;\n          var attributes = primitive.attributes,\n            indices = primitive.indices,\n            material = primitive.material;\n          for (var attributeName in attributes) {\n            attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n          }\n          if (indices) {\n            primitive.indices = this._convertIdToIndex(indices, 'accessor');\n          }\n          if (material) {\n            primitive.material = this._convertIdToIndex(material, 'material');\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"_convertNodeIds\",\n    value: function _convertNodeIds(node) {\n      var _this = this;\n      if (node.children) {\n        node.children = node.children.map(function (child) {\n          return _this._convertIdToIndex(child, 'node');\n        });\n      }\n    }\n  }, {\n    key: \"_convertSceneIds\",\n    value: function _convertSceneIds(scene) {\n      var _this2 = this;\n      if (scene.nodes) {\n        scene.nodes = scene.nodes.map(function (node) {\n          return _this2._convertIdToIndex(node, 'node');\n        });\n      }\n    }\n  }, {\n    key: \"_convertIdsToIndices\",\n    value: function _convertIdsToIndices(json, topLevelArrayName) {\n      var _iterator6 = _createForOfIteratorHelper(json[topLevelArrayName]),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var object = _step6.value;\n          for (var key in object) {\n            var id = object[key];\n            var index = this._convertIdToIndex(id, key);\n            object[key] = index;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"_convertIdToIndex\",\n    value: function _convertIdToIndex(id, key) {\n      var arrayName = GLTF_KEYS[key];\n      if (arrayName in this.idToIndexMap) {\n        var index = this.idToIndexMap[arrayName][id];\n        if (!Number.isFinite(index)) {\n          throw new Error(\"gltf v1: failed to resolve \".concat(key, \" with id \").concat(id));\n        }\n        return index;\n      }\n      return id;\n    }\n  }, {\n    key: \"_updateObjects\",\n    value: function _updateObjects(json) {\n      var _iterator7 = _createForOfIteratorHelper(this.json.buffers),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var buffer = _step7.value;\n          delete buffer.type;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }]);\n  return GLTFV1Normalizer;\n}();\nexport default function normalizeGLTFV1(gltf) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}","map":{"version":3,"sources":["../../../src/lib/normalize-gltf-v1.js"],"names":["KHR_binary_glTF","GLTF_ARRAYS","accessors","animations","buffers","bufferViews","images","materials","meshes","nodes","samplers","scenes","skins","textures","GLTF_KEYS","accessor","buffer","bufferView","image","material","mesh","node","sampler","scene","skin","texture","GLTFV1Normalizer","gltf","idToIndexMap","options","json","asset","version","undefined","console","warn","normalize","Error","_addAsset","_convertTopLevelObjectsToArrays","decode","_convertObjectIdsToArrayIndices","_updateObjects","generator","arrayName","_convertTopLevelObjectToArray","mapName","objectMap","Array","isArray","id","object","index","length","push","_convertIdsToIndices","_convertIdToIndex","_convertTextureIds","_convertMeshIds","_convertNodeIds","_convertSceneIds","source","primitive","primitives","attributes","indices","attributeName","children","map","child","topLevelArrayName","key","Number","isFinite","type","normalizeGLTFV1"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from './extensions/KHR_binary_gltf';\n\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\n\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\n\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n  constructor(gltf) {\n    this.idToIndexMap = {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    };\n  }\n\n  /**\n   * Convert (normalize) glTF < 2.0 to glTF 2.0\n   * @param {*} gltf - object with json and binChunks\n   * @param {object} options\n   * @param {boolean} [options.normalize] Whether to actually normalize\n   */\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    // Check version\n    switch (json.asset && json.asset.version) {\n      // We are converting to v2 format. Return if there is nothing to do\n      case '2.0':\n        return;\n\n      // This class is written to convert 1.0\n      case undefined:\n      case '1.0':\n        break;\n\n      default:\n        // eslint-disable-next-line no-undef, no-console\n        console.warn(`glTF: Unknown version ${json.asset.version}`);\n        return;\n    }\n\n    if (!options.normalize) {\n      // We are still missing a few conversion tricks, remove once addressed\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    // eslint-disable-next-line no-undef, no-console\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n    this._addAsset(json);\n\n    // In glTF2 top-level fields are Arrays not Object maps\n    this._convertTopLevelObjectsToArrays(json);\n\n    // Extract bufferView indices for images\n    // (this extension needs to be invoked early in the normalization process)\n    KHR_binary_glTF.decode(gltf, options);\n\n    // Convert object references from ids to indices\n    this._convertObjectIdsToArrayIndices(json);\n\n    this._updateObjects(json);\n  }\n\n  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    // We are normalizing to glTF v2, so change version to \"2.0\"\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n\n  _convertTopLevelObjectsToArrays(json) {\n    // TODO check that all arrays are covered\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  /** Convert one top level object to array */\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    // Rewrite the top-level field as an array\n    json[mapName] = [];\n    // Copy the map key into object.id\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id; // Mutates the loaded object\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  /** Go through all objects in all top-level arrays and replace ids with indices */\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    // Convert any index references that are not using array names\n\n    // texture.source (image)\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {attributes, indices, material} = primitive;\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map(child => this._convertIdToIndex(child, 'node'));\n    }\n  }\n\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map(node => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  /** Go through all objects in a top-level array and replace ids with indices */\n  _convertIdsToIndices(json, topLevelArrayName) {\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n        const index = this._convertIdToIndex(id, key);\n        object[key] = index;\n      }\n    }\n  }\n\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n      if (!Number.isFinite(index)) {\n        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n      }\n      return index;\n    }\n    return id;\n  }\n\n  /**\n   *\n   * @param {*} json\n   */\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      // - [x] Removed buffer.type, #786, #629\n      delete buffer.type;\n    }\n  }\n}\n\nexport default function normalizeGLTFV1(gltf, options = {}) {\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}\n"]},"metadata":{},"sourceType":"module"}