{"ast":null,"code":"import { getWebGL2Context, assertWebGL2Context, log } from '@luma.gl/gltools';\nimport Resource from './resource';\nimport Texture2D from './texture-2d';\nimport Renderbuffer from './renderbuffer';\nimport { clear, clearBuffer } from './clear';\nimport { copyToDataUrl } from './copy-and-blit.js';\nimport { getFeatures } from '../features';\nimport { getKey } from '../webgl-utils/constants-to-keys';\nimport { assert } from '../utils/assert';\nconst ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';\nexport default class Framebuffer extends Resource {\n  get [Symbol.toStringTag]() {\n    return 'Framebuffer';\n  }\n  static isSupported(gl) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      colorBufferFloat,\n      colorBufferHalfFloat\n    } = options;\n    let supported = true;\n    if (colorBufferFloat) {\n      supported = Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('WEBGL_color_buffer_float') || gl.getExtension('OES_texture_float'));\n    }\n    if (colorBufferHalfFloat) {\n      supported = supported && Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('EXT_color_buffer_half_float'));\n    }\n    return supported;\n  }\n  static getDefaultFramebuffer(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {\n      id: 'default-framebuffer',\n      handle: null,\n      attachments: {}\n    });\n    return gl.luma.defaultFramebuffer;\n  }\n  get MAX_COLOR_ATTACHMENTS() {\n    const gl2 = assertWebGL2Context(this.gl);\n    return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);\n  }\n  get MAX_DRAW_BUFFERS() {\n    const gl2 = assertWebGL2Context(this.gl);\n    return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);\n  }\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, opts);\n    this.width = null;\n    this.height = null;\n    this.attachments = {};\n    this.readBuffer = 36064;\n    this.drawBuffers = [36064];\n    this.ownResources = [];\n    this.initialize(opts);\n    Object.seal(this);\n  }\n  get color() {\n    return this.attachments[36064] || null;\n  }\n  get texture() {\n    return this.attachments[36064] || null;\n  }\n  get depth() {\n    return this.attachments[36096] || this.attachments[33306] || null;\n  }\n  get stencil() {\n    return this.attachments[36128] || this.attachments[33306] || null;\n  }\n  initialize(_ref) {\n    let {\n      width = 1,\n      height = 1,\n      attachments = null,\n      color = true,\n      depth = true,\n      stencil = false,\n      check = true,\n      readBuffer = undefined,\n      drawBuffers = undefined\n    } = _ref;\n    assert(width >= 0 && height >= 0, 'Width and height need to be integers');\n    this.width = width;\n    this.height = height;\n    if (attachments) {\n      for (const attachment in attachments) {\n        const target = attachments[attachment];\n        const object = Array.isArray(target) ? target[0] : target;\n        object.resize({\n          width,\n          height\n        });\n      }\n    } else {\n      attachments = this._createDefaultAttachments(color, depth, stencil, width, height);\n    }\n    this.update({\n      clearAttachments: true,\n      attachments,\n      readBuffer,\n      drawBuffers\n    });\n    if (attachments && check) {\n      this.checkStatus();\n    }\n  }\n  delete() {\n    for (const resource of this.ownResources) {\n      resource.delete();\n    }\n    super.delete();\n    return this;\n  }\n  update(_ref2) {\n    let {\n      attachments = {},\n      readBuffer,\n      drawBuffers,\n      clearAttachments = false,\n      resizeAttachments = true\n    } = _ref2;\n    this.attach(attachments, {\n      clearAttachments,\n      resizeAttachments\n    });\n    const {\n      gl\n    } = this;\n    const prevHandle = gl.bindFramebuffer(36160, this.handle);\n    if (readBuffer) {\n      this._setReadBuffer(readBuffer);\n    }\n    if (drawBuffers) {\n      this._setDrawBuffers(drawBuffers);\n    }\n    gl.bindFramebuffer(36160, prevHandle || null);\n    return this;\n  }\n  resize() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      width,\n      height\n    } = options;\n    if (this.handle === null) {\n      assert(width === undefined && height === undefined);\n      this.width = this.gl.drawingBufferWidth;\n      this.height = this.gl.drawingBufferHeight;\n      return this;\n    }\n    if (width === undefined) {\n      width = this.gl.drawingBufferWidth;\n    }\n    if (height === undefined) {\n      height = this.gl.drawingBufferHeight;\n    }\n    if (width !== this.width && height !== this.height) {\n      log.log(2, \"Resizing framebuffer \".concat(this.id, \" to \").concat(width, \"x\").concat(height))();\n    }\n    for (const attachmentPoint in this.attachments) {\n      this.attachments[attachmentPoint].resize({\n        width,\n        height\n      });\n    }\n    this.width = width;\n    this.height = height;\n    return this;\n  }\n  attach(attachments) {\n    let {\n      clearAttachments = false,\n      resizeAttachments = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const newAttachments = {};\n    if (clearAttachments) {\n      Object.keys(this.attachments).forEach(key => {\n        newAttachments[key] = null;\n      });\n    }\n    Object.assign(newAttachments, attachments);\n    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);\n    for (const key in newAttachments) {\n      assert(key !== undefined, 'Misspelled framebuffer binding point?');\n      const attachment = Number(key);\n      const descriptor = newAttachments[attachment];\n      let object = descriptor;\n      if (!object) {\n        this._unattach(attachment);\n      } else if (object instanceof Renderbuffer) {\n        this._attachRenderbuffer({\n          attachment,\n          renderbuffer: object\n        });\n      } else if (Array.isArray(descriptor)) {\n        const [texture, layer = 0, level = 0] = descriptor;\n        object = texture;\n        this._attachTexture({\n          attachment,\n          texture,\n          layer,\n          level\n        });\n      } else {\n        this._attachTexture({\n          attachment,\n          texture: object,\n          layer: 0,\n          level: 0\n        });\n      }\n      if (resizeAttachments && object) {\n        object.resize({\n          width: this.width,\n          height: this.height\n        });\n      }\n    }\n    this.gl.bindFramebuffer(36160, prevHandle || null);\n    Object.assign(this.attachments, attachments);\n    Object.keys(this.attachments).filter(key => !this.attachments[key]).forEach(key => {\n      delete this.attachments[key];\n    });\n  }\n  checkStatus() {\n    const {\n      gl\n    } = this;\n    const status = this.getStatus();\n    if (status !== 36053) {\n      throw new Error(_getFrameBufferStatus(status));\n    }\n    return this;\n  }\n  getStatus() {\n    const {\n      gl\n    } = this;\n    const prevHandle = gl.bindFramebuffer(36160, this.handle);\n    const status = gl.checkFramebufferStatus(36160);\n    gl.bindFramebuffer(36160, prevHandle || null);\n    return status;\n  }\n  clear() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      color,\n      depth,\n      stencil,\n      drawBuffers = []\n    } = options;\n    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);\n    if (color || depth || stencil) {\n      clear(this.gl, {\n        color,\n        depth,\n        stencil\n      });\n    }\n    drawBuffers.forEach((value, drawBuffer) => {\n      clearBuffer(this.gl, {\n        drawBuffer,\n        value\n      });\n    });\n    this.gl.bindFramebuffer(36160, prevHandle || null);\n    return this;\n  }\n  readPixels() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.error('Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)')();\n    return null;\n  }\n  readPixelsToBuffer() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.error('Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)')();\n    return null;\n  }\n  copyToDataUrl() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.error('Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)')();\n    return null;\n  }\n  copyToImage() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.error('Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)')();\n    return null;\n  }\n  copyToTexture() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.error('Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})')();\n    return null;\n  }\n  blit() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.error('Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)')();\n    return null;\n  }\n  invalidate(_ref3) {\n    let {\n      attachments = [],\n      x = 0,\n      y = 0,\n      width,\n      height\n    } = _ref3;\n    const gl2 = assertWebGL2Context(this.gl);\n    const prevHandle = gl2.bindFramebuffer(36008, this.handle);\n    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;\n    if (invalidateAll) {\n      gl2.invalidateFramebuffer(36008, attachments);\n    } else {\n      gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);\n    }\n    gl2.bindFramebuffer(36008, prevHandle);\n    return this;\n  }\n  getAttachmentParameter(attachment, pname, keys) {\n    let value = this._getAttachmentParameterFallback(pname);\n    if (value === null) {\n      this.gl.bindFramebuffer(36160, this.handle);\n      value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);\n      this.gl.bindFramebuffer(36160, null);\n    }\n    if (keys && value > 1000) {\n      value = getKey(this.gl, value);\n    }\n    return value;\n  }\n  getAttachmentParameters() {\n    let attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 36064;\n    let keys = arguments.length > 1 ? arguments[1] : undefined;\n    let parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];\n    const values = {};\n    for (const pname of parameters) {\n      const key = keys ? getKey(this.gl, pname) : pname;\n      values[key] = this.getAttachmentParameter(attachment, pname, keys);\n    }\n    return values;\n  }\n  getParameters() {\n    let keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const attachments = Object.keys(this.attachments);\n    const parameters = {};\n    for (const attachmentName of attachments) {\n      const attachment = Number(attachmentName);\n      const key = keys ? getKey(this.gl, attachment) : attachment;\n      parameters[key] = this.getAttachmentParameters(attachment, keys);\n    }\n    return parameters;\n  }\n  show() {\n    if (typeof window !== 'undefined') {\n      window.open(copyToDataUrl(this), 'luma-debug-texture');\n    }\n    return this;\n  }\n  log() {\n    let logLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    if (logLevel > log.level || typeof window === 'undefined') {\n      return this;\n    }\n    message = message || \"Framebuffer \".concat(this.id);\n    const image = copyToDataUrl(this, {\n      targetMaxHeight: 100\n    });\n    log.image({\n      logLevel,\n      message,\n      image\n    }, message)();\n    return this;\n  }\n  bind() {\n    let {\n      target = 36160\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.gl.bindFramebuffer(target, this.handle);\n    return this;\n  }\n  unbind() {\n    let {\n      target = 36160\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.gl.bindFramebuffer(target, null);\n    return this;\n  }\n  _createDefaultAttachments(color, depth, stencil, width, height) {\n    let defaultAttachments = null;\n    if (color) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[36064] = new Texture2D(this.gl, {\n        id: \"\".concat(this.id, \"-color0\"),\n        pixels: null,\n        format: 6408,\n        type: 5121,\n        width,\n        height,\n        mipmaps: false,\n        parameters: {\n          [10241]: 9729,\n          [10240]: 9729,\n          [10242]: 33071,\n          [10243]: 33071\n        }\n      });\n      this.ownResources.push(defaultAttachments[36064]);\n    }\n    if (depth && stencil) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[33306] = new Renderbuffer(this.gl, {\n        id: \"\".concat(this.id, \"-depth-stencil\"),\n        format: 35056,\n        width,\n        height: 111\n      });\n      this.ownResources.push(defaultAttachments[33306]);\n    } else if (depth) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[36096] = new Renderbuffer(this.gl, {\n        id: \"\".concat(this.id, \"-depth\"),\n        format: 33189,\n        width,\n        height\n      });\n      this.ownResources.push(defaultAttachments[36096]);\n    } else if (stencil) {\n      assert(false);\n    }\n    return defaultAttachments;\n  }\n  _unattach(attachment) {\n    const oldAttachment = this.attachments[attachment];\n    if (!oldAttachment) {\n      return;\n    }\n    if (oldAttachment instanceof Renderbuffer) {\n      this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);\n    } else {\n      this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);\n    }\n    delete this.attachments[attachment];\n  }\n  _attachRenderbuffer(_ref4) {\n    let {\n      attachment = 36064,\n      renderbuffer\n    } = _ref4;\n    const {\n      gl\n    } = this;\n    gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);\n    this.attachments[attachment] = renderbuffer;\n  }\n  _attachTexture(_ref5) {\n    let {\n      attachment = 36064,\n      texture,\n      layer,\n      level\n    } = _ref5;\n    const {\n      gl\n    } = this;\n    gl.bindTexture(texture.target, texture.handle);\n    switch (texture.target) {\n      case 35866:\n      case 32879:\n        const gl2 = assertWebGL2Context(gl);\n        gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);\n        break;\n      case 34067:\n        const face = mapIndexToCubeMapFace(layer);\n        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);\n        break;\n      case 3553:\n        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);\n        break;\n      default:\n        assert(false, 'Illegal texture type');\n    }\n    gl.bindTexture(texture.target, null);\n    this.attachments[attachment] = texture;\n  }\n  _setReadBuffer(readBuffer) {\n    const gl2 = getWebGL2Context(this.gl);\n    if (gl2) {\n      gl2.readBuffer(readBuffer);\n    } else {\n      assert(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);\n    }\n    this.readBuffer = readBuffer;\n  }\n  _setDrawBuffers(drawBuffers) {\n    const {\n      gl\n    } = this;\n    const gl2 = assertWebGL2Context(gl);\n    if (gl2) {\n      gl2.drawBuffers(drawBuffers);\n    } else {\n      const ext = gl.getExtension('WEBGL_draw_buffers');\n      if (ext) {\n        ext.drawBuffersWEBGL(drawBuffers);\n      } else {\n        assert(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);\n      }\n    }\n    this.drawBuffers = drawBuffers;\n  }\n  _getAttachmentParameterFallback(pname) {\n    const caps = getFeatures(this.gl);\n    switch (pname) {\n      case 36052:\n        return !caps.WEBGL2 ? 0 : null;\n      case 33298:\n      case 33299:\n      case 33300:\n      case 33301:\n      case 33302:\n      case 33303:\n        return !caps.WEBGL2 ? 8 : null;\n      case 33297:\n        return !caps.WEBGL2 ? 5125 : null;\n      case 33296:\n        return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;\n      default:\n        return null;\n    }\n  }\n  _createHandle() {\n    return this.gl.createFramebuffer();\n  }\n  _deleteHandle() {\n    this.gl.deleteFramebuffer(this.handle);\n  }\n  _bindHandle(handle) {\n    return this.gl.bindFramebuffer(36160, handle);\n  }\n}\nfunction mapIndexToCubeMapFace(layer) {\n  return layer < 34069 ? layer + 34069 : layer;\n}\nfunction _getFrameBufferStatus(status) {\n  const STATUS = Framebuffer.STATUS || {};\n  return STATUS[status] || \"Framebuffer error \".concat(status);\n}\nexport const FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];\nFramebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;","map":{"version":3,"sources":["../../../src/classes/framebuffer.js"],"names":["getWebGL2Context","assertWebGL2Context","log","Resource","Texture2D","Renderbuffer","clear","clearBuffer","copyToDataUrl","getFeatures","getKey","assert","ERR_MULTIPLE_RENDERTARGETS","Framebuffer","Symbol","toStringTag","isSupported","gl","options","colorBufferFloat","colorBufferHalfFloat","supported","Boolean","getExtension","getDefaultFramebuffer","luma","defaultFramebuffer","id","handle","attachments","MAX_COLOR_ATTACHMENTS","gl2","getParameter","MAX_DRAW_BUFFERS","constructor","opts","width","height","readBuffer","drawBuffers","ownResources","initialize","Object","seal","color","texture","depth","stencil","check","undefined","attachment","target","object","Array","isArray","resize","_createDefaultAttachments","update","clearAttachments","checkStatus","delete","resource","resizeAttachments","attach","prevHandle","bindFramebuffer","_setReadBuffer","_setDrawBuffers","drawingBufferWidth","drawingBufferHeight","attachmentPoint","newAttachments","keys","forEach","key","assign","Number","descriptor","_unattach","_attachRenderbuffer","renderbuffer","layer","level","_attachTexture","filter","status","getStatus","Error","_getFrameBufferStatus","checkFramebufferStatus","value","drawBuffer","readPixels","error","readPixelsToBuffer","copyToImage","copyToTexture","blit","invalidate","x","y","invalidateAll","invalidateFramebuffer","getAttachmentParameter","pname","_getAttachmentParameterFallback","getFramebufferAttachmentParameter","getAttachmentParameters","parameters","ATTACHMENT_PARAMETERS","values","getParameters","attachmentName","show","window","open","logLevel","message","image","targetMaxHeight","bind","unbind","defaultAttachments","pixels","format","type","mipmaps","push","oldAttachment","framebufferRenderbuffer","framebufferTexture2D","bindTexture","framebufferTextureLayer","face","mapIndexToCubeMapFace","ext","drawBuffersWEBGL","length","caps","WEBGL2","EXT_sRGB","_createHandle","createFramebuffer","_deleteHandle","deleteFramebuffer","_bindHandle","STATUS","FRAMEBUFFER_ATTACHMENT_PARAMETERS"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {getWebGL2Context, assertWebGL2Context, log} from '@luma.gl/gltools';\nimport Resource from './resource';\nimport Texture2D from './texture-2d';\nimport Renderbuffer from './renderbuffer';\nimport {clear, clearBuffer} from './clear';\nimport {copyToDataUrl} from './copy-and-blit.js';\n\nimport {getFeatures} from '../features';\nimport {getKey} from '../webgl-utils/constants-to-keys';\nimport {assert} from '../utils/assert';\n\nconst ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';\n\nexport default class Framebuffer extends Resource {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'Framebuffer';\n  }\n  static isSupported(gl, options = {}) {\n    const {\n      colorBufferFloat, // Whether floating point textures can be rendered and read\n      colorBufferHalfFloat // Whether half float textures can be rendered and read\n    } = options;\n    let supported = true;\n\n    if (colorBufferFloat) {\n      supported = Boolean(\n        // WebGL 2\n        gl.getExtension('EXT_color_buffer_float') ||\n          // WebGL 1, not exposed on all platforms\n          gl.getExtension('WEBGL_color_buffer_float') ||\n          // WebGL 1, implicitly enables float render targets https://www.khronos.org/registry/webgl/extensions/OES_texture_float/\n          gl.getExtension('OES_texture_float')\n      );\n    }\n\n    if (colorBufferHalfFloat) {\n      supported =\n        supported &&\n        Boolean(\n          // WebGL 2\n          gl.getExtension('EXT_color_buffer_float') ||\n            // WebGL 1\n            gl.getExtension('EXT_color_buffer_half_float')\n        );\n    }\n\n    return supported;\n  }\n\n  // Create a Framebuffer wrapper for the default framebuffer (target === null)\n  static getDefaultFramebuffer(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultFramebuffer =\n      gl.luma.defaultFramebuffer ||\n      new Framebuffer(gl, {\n        id: 'default-framebuffer',\n        handle: null,\n        attachments: {}\n      });\n    // TODO - can we query for and get a handle to the GL.FRONT renderbuffer?\n    return gl.luma.defaultFramebuffer;\n  }\n\n  get MAX_COLOR_ATTACHMENTS() {\n    const gl2 = assertWebGL2Context(this.gl);\n    return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);\n  }\n\n  get MAX_DRAW_BUFFERS() {\n    const gl2 = assertWebGL2Context(this.gl);\n    return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);\n  }\n\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    // Public members\n    this.width = null;\n    this.height = null;\n    this.attachments = {};\n    this.readBuffer = GL.COLOR_ATTACHMENT0;\n    this.drawBuffers = [GL.COLOR_ATTACHMENT0];\n    this.ownResources = [];\n    this.initialize(opts);\n\n    Object.seal(this);\n  }\n\n  get color() {\n    return this.attachments[GL.COLOR_ATTACHMENT0] || null;\n  }\n\n  get texture() {\n    return this.attachments[GL.COLOR_ATTACHMENT0] || null;\n  }\n\n  get depth() {\n    return (\n      this.attachments[GL.DEPTH_ATTACHMENT] || this.attachments[GL.DEPTH_STENCIL_ATTACHMENT] || null\n    );\n  }\n\n  get stencil() {\n    return (\n      this.attachments[GL.STENCIL_ATTACHMENT] ||\n      this.attachments[GL.DEPTH_STENCIL_ATTACHMENT] ||\n      null\n    );\n  }\n\n  initialize({\n    width = 1,\n    height = 1,\n    attachments = null,\n    color = true,\n    depth = true,\n    stencil = false,\n    check = true,\n    readBuffer = undefined,\n    drawBuffers = undefined\n  }) {\n    assert(width >= 0 && height >= 0, 'Width and height need to be integers');\n\n    // Store actual width and height for diffing\n    this.width = width;\n    this.height = height;\n\n    // Resize any provided attachments - note that resize only resizes if needed\n    // Note: A framebuffer has no separate size, it is defined by its attachments (which must agree)\n    if (attachments) {\n      for (const attachment in attachments) {\n        const target = attachments[attachment];\n        const object = Array.isArray(target) ? target[0] : target;\n        object.resize({width, height});\n      }\n    } else {\n      // Create any requested default attachments\n      attachments = this._createDefaultAttachments(color, depth, stencil, width, height);\n    }\n\n    this.update({clearAttachments: true, attachments, readBuffer, drawBuffers});\n\n    // Checks that framebuffer was properly set up, if not, throws an explanatory error\n    if (attachments && check) {\n      this.checkStatus();\n    }\n  }\n\n  delete() {\n    for (const resource of this.ownResources) {\n      resource.delete();\n    }\n    super.delete();\n    return this;\n  }\n\n  update({\n    attachments = {},\n    readBuffer,\n    drawBuffers,\n    clearAttachments = false,\n    resizeAttachments = true\n  }) {\n    this.attach(attachments, {clearAttachments, resizeAttachments});\n\n    const {gl} = this;\n    // Multiple render target support, set read buffer and draw buffers\n    const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n    if (readBuffer) {\n      this._setReadBuffer(readBuffer);\n    }\n    if (drawBuffers) {\n      this._setDrawBuffers(drawBuffers);\n    }\n    // @ts-ignore\n    gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n\n    return this;\n  }\n\n  // Attachment resize is expected to be a noop if size is same\n  resize(options = {}) {\n    let {width, height} = options;\n    // for default framebuffer, just update the stored size\n    if (this.handle === null) {\n      assert(width === undefined && height === undefined);\n      this.width = this.gl.drawingBufferWidth;\n      this.height = this.gl.drawingBufferHeight;\n      return this;\n    }\n\n    if (width === undefined) {\n      width = this.gl.drawingBufferWidth;\n    }\n    if (height === undefined) {\n      height = this.gl.drawingBufferHeight;\n    }\n\n    if (width !== this.width && height !== this.height) {\n      log.log(2, `Resizing framebuffer ${this.id} to ${width}x${height}`)();\n    }\n    for (const attachmentPoint in this.attachments) {\n      this.attachments[attachmentPoint].resize({width, height});\n    }\n    this.width = width;\n    this.height = height;\n    return this;\n  }\n\n  // Attach from a map of attachments\n  attach(attachments, {clearAttachments = false, resizeAttachments = true} = {}) {\n    const newAttachments = {};\n\n    // Any current attachments need to be removed, add null values to map\n    if (clearAttachments) {\n      Object.keys(this.attachments).forEach(key => {\n        newAttachments[key] = null;\n      });\n    }\n\n    // Overlay the new attachments\n    Object.assign(newAttachments, attachments);\n\n    const prevHandle = this.gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n\n    // Walk the attachments\n    for (const key in newAttachments) {\n      // Ensure key is not undefined\n      assert(key !== undefined, 'Misspelled framebuffer binding point?');\n\n      const attachment = Number(key);\n\n      const descriptor = newAttachments[attachment];\n      let object = descriptor;\n      if (!object) {\n        this._unattach(attachment);\n      } else if (object instanceof Renderbuffer) {\n        this._attachRenderbuffer({attachment, renderbuffer: object});\n      } else if (Array.isArray(descriptor)) {\n        const [texture, layer = 0, level = 0] = descriptor;\n        object = texture;\n        this._attachTexture({attachment, texture, layer, level});\n      } else {\n        this._attachTexture({attachment, texture: object, layer: 0, level: 0});\n      }\n\n      // Resize objects\n      if (resizeAttachments && object) {\n        object.resize({width: this.width, height: this.height});\n      }\n    }\n\n    // @ts-ignore\n    this.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n\n    // Assign to attachments and remove any nulls to get a clean attachment map\n    Object.assign(this.attachments, attachments);\n    Object.keys(this.attachments)\n      .filter(key => !this.attachments[key])\n      .forEach(key => {\n        delete this.attachments[key];\n      });\n  }\n\n  checkStatus() {\n    const {gl} = this;\n    const status = this.getStatus();\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n      throw new Error(_getFrameBufferStatus(status));\n    }\n    return this;\n  }\n\n  getStatus() {\n    const {gl} = this;\n    const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n    const status = gl.checkFramebufferStatus(GL.FRAMEBUFFER);\n    // @ts-ignore\n    gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n    return status;\n  }\n\n  clear(options = {}) {\n    const {color, depth, stencil, drawBuffers = []} = options;\n\n    // Bind framebuffer and delegate to global clear functions\n    const prevHandle = this.gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n\n    if (color || depth || stencil) {\n      clear(this.gl, {color, depth, stencil});\n    }\n\n    drawBuffers.forEach((value, drawBuffer) => {\n      clearBuffer(this.gl, {drawBuffer, value});\n    });\n\n    // @ts-ignore\n    this.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n\n    return this;\n  }\n\n  // NOTE: Slow requires roundtrip to GPU\n  // App can provide pixelArray or have it auto allocated by this method\n  // @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,\n  //  newly allocated by this method unless provided by app.\n  readPixels(opts = {}) {\n    log.error(\n      'Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)'\n    )();\n    return null;\n  }\n\n  // Reads data into provided buffer object asynchronously\n  // This function doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n  readPixelsToBuffer(opts = {}) {\n    log.error(\n      'Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)'\n    )();\n    return null;\n  }\n\n  // Reads pixels as a dataUrl\n  copyToDataUrl(opts = {}) {\n    log.error(\n      'Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)'\n    )();\n    return null;\n  }\n\n  // Reads pixels into an HTML Image\n  copyToImage(opts = {}) {\n    log.error('Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)')();\n    return null;\n  }\n\n  // copyToFramebuffer({width, height}) {\n  //   const scaleX = width / this.width;\n  //   const scaleY = height / this.height;\n  //   const scale = Math.min(scaleX, scaleY);\n  //   width = width * scale;\n  //   height = height * scale;\n  //   const scaledFramebuffer = new Framebuffer(this.gl, {width, height});\n  //   this.blit();\n  // }\n\n  // Copy a rectangle from a framebuffer attachment into a texture (at an offset)\n  // NOTE: assumes texture has enough storage allocated\n  // eslint-disable-next-line complexity\n  copyToTexture(opts = {}) {\n    log.error(\n      'Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})'\n    )();\n    return null;\n  }\n\n  // WEBGL2 INTERFACE\n\n  // Copies a rectangle of pixels between framebuffers\n  // eslint-disable-next-line complexity\n  blit(opts = {}) {\n    log.error('Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)')();\n    return null;\n  }\n\n  // signals to the GL that it need not preserve all pixels of a specified region of the framebuffer\n  invalidate({attachments = [], x = 0, y = 0, width, height}) {\n    const gl2 = assertWebGL2Context(this.gl);\n    const prevHandle = gl2.bindFramebuffer(GL.READ_FRAMEBUFFER, this.handle);\n    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;\n    if (invalidateAll) {\n      gl2.invalidateFramebuffer(GL.READ_FRAMEBUFFER, attachments);\n    } else {\n      // TODO - why does type checking fail on this line\n      // @ts-ignore\n      gl2.invalidateFramebuffer(GL.READ_FRAMEBUFFER, attachments, x, y, width, height);\n    }\n    // @ts-ignore\n    gl2.bindFramebuffer(GL.READ_FRAMEBUFFER, prevHandle);\n    return this;\n  }\n\n  // Return the value for `pname` of the specified attachment.\n  // The type returned is the type of the requested pname\n  getAttachmentParameter(attachment, pname, keys) {\n    let value = this._getAttachmentParameterFallback(pname);\n    if (value === null) {\n      this.gl.bindFramebuffer(GL.FRAMEBUFFER, this.handle);\n      value = this.gl.getFramebufferAttachmentParameter(GL.FRAMEBUFFER, attachment, pname);\n      this.gl.bindFramebuffer(GL.FRAMEBUFFER, null);\n    }\n    if (keys && value > 1000) {\n      // @ts-ignore\n      value = getKey(this.gl, value);\n    }\n    return value;\n  }\n\n  getAttachmentParameters(\n    attachment = GL.COLOR_ATTACHMENT0,\n    keys,\n    // @ts-ignore\n    parameters = this.constructor.ATTACHMENT_PARAMETERS || []\n  ) {\n    const values = {};\n    for (const pname of parameters) {\n      const key = keys ? getKey(this.gl, pname) : pname;\n      values[key] = this.getAttachmentParameter(attachment, pname, keys);\n    }\n    return values;\n  }\n\n  getParameters(keys = true) {\n    const attachments = Object.keys(this.attachments);\n    // if (this === this.gl.luma.defaultFramebuffer) {\n    //   attachments = [GL.COLOR_ATTACHMENT0, GL.DEPTH_STENCIL_ATTACHMENT];\n    // }\n    const parameters = {};\n    for (const attachmentName of attachments) {\n      const attachment = Number(attachmentName);\n      const key = keys ? getKey(this.gl, attachment) : attachment;\n      parameters[key] = this.getAttachmentParameters(attachment, keys);\n    }\n    return parameters;\n  }\n\n  // DEBUG\n\n  // Note: Will only work when called in an event handler\n  show() {\n    if (typeof window !== 'undefined') {\n      window.open(copyToDataUrl(this), 'luma-debug-texture');\n    }\n    return this;\n  }\n\n  log(logLevel = 0, message = '') {\n    if (logLevel > log.level || typeof window === 'undefined') {\n      return this;\n    }\n    message = message || `Framebuffer ${this.id}`;\n    const image = copyToDataUrl(this, {targetMaxHeight: 100});\n    // @ts-expect-error\n    log.image({logLevel, message, image}, message)();\n    return this;\n  }\n\n  // WEBGL INTERFACE\n  bind({target = GL.FRAMEBUFFER} = {}) {\n    this.gl.bindFramebuffer(target, this.handle);\n    return this;\n  }\n\n  unbind({target = GL.FRAMEBUFFER} = {}) {\n    this.gl.bindFramebuffer(target, null);\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _createDefaultAttachments(color, depth, stencil, width, height) {\n    let defaultAttachments = null;\n\n    // Add a color buffer if requested and not supplied\n    if (color) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[GL.COLOR_ATTACHMENT0] = new Texture2D(this.gl, {\n        id: `${this.id}-color0`,\n        pixels: null, // reserves texture memory, but texels are undefined\n        format: GL.RGBA,\n        type: GL.UNSIGNED_BYTE,\n        width,\n        height,\n        // Note: Mipmapping can be disabled by texture resource when we resize the texture\n        // to a non-power-of-two dimenstion (NPOT texture) under WebGL1. To have consistant\n        // behavior we always disable mipmaps.\n        mipmaps: false,\n        // Set MIN and MAG filtering parameters so mipmaps are not used in sampling.\n        // Use LINEAR so subpixel algos like fxaa work.\n        // Set WRAP modes that support NPOT textures too.\n        parameters: {\n          [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n          [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n          [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n          [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n        }\n      });\n      // track to delete later\n      this.ownResources.push(defaultAttachments[GL.COLOR_ATTACHMENT0]);\n    }\n\n    if (depth && stencil) {\n      // TODO - handle separate stencil\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[GL.DEPTH_STENCIL_ATTACHMENT] = new Renderbuffer(this.gl, {\n        id: `${this.id}-depth-stencil`,\n        format: GL.DEPTH24_STENCIL8,\n        width,\n        height: 111\n      });\n      // track to delete later\n      this.ownResources.push(defaultAttachments[GL.DEPTH_STENCIL_ATTACHMENT]);\n      // TODO - optional texture\n      // new Texture2D(this.gl, {\n      //   id: `${this.id}-depth-stencil`,\n      //   format: GL.DEPTH24_STENCIL8,\n      //   dataFormat: GL.DEPTH_STENCIL,\n      //   type: GL.UNSIGNED_INT_24_8,\n      //   width,\n      //   height,\n      //   mipmaps: false\n      // });\n    } else if (depth) {\n      // Add a depth buffer if requested and not supplied\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[GL.DEPTH_ATTACHMENT] = new Renderbuffer(this.gl, {\n        id: `${this.id}-depth`,\n        format: GL.DEPTH_COMPONENT16,\n        width,\n        height\n      });\n      // track to delete later\n      this.ownResources.push(defaultAttachments[GL.DEPTH_ATTACHMENT]);\n    } else if (stencil) {\n      // TODO - handle separate stencil\n      assert(false);\n    }\n\n    return defaultAttachments;\n  }\n\n  _unattach(attachment) {\n    const oldAttachment = this.attachments[attachment];\n    if (!oldAttachment) {\n      return;\n    }\n    if (oldAttachment instanceof Renderbuffer) {\n      // render buffer\n      this.gl.framebufferRenderbuffer(GL.FRAMEBUFFER, attachment, GL.RENDERBUFFER, null);\n    } else {\n      // Must be a texture attachment\n      this.gl.framebufferTexture2D(GL.FRAMEBUFFER, attachment, GL.TEXTURE_2D, null, 0);\n    }\n    delete this.attachments[attachment];\n  }\n\n  _attachRenderbuffer({attachment = GL.COLOR_ATTACHMENT0, renderbuffer}) {\n    const {gl} = this;\n    // TODO - is the bind needed?\n    // gl.bindRenderbuffer(GL.RENDERBUFFER, renderbuffer.handle);\n    gl.framebufferRenderbuffer(GL.FRAMEBUFFER, attachment, GL.RENDERBUFFER, renderbuffer.handle);\n    // TODO - is the unbind needed?\n    // gl.bindRenderbuffer(GL.RENDERBUFFER, null);\n\n    this.attachments[attachment] = renderbuffer;\n  }\n\n  // layer = 0 - index into Texture2DArray and Texture3D or face for `TextureCubeMap`\n  // level = 0 - mipmapLevel (must be 0 in WebGL1)\n  _attachTexture({attachment = GL.COLOR_ATTACHMENT0, texture, layer, level}) {\n    const {gl} = this;\n    gl.bindTexture(texture.target, texture.handle);\n\n    switch (texture.target) {\n      case GL.TEXTURE_2D_ARRAY:\n      case GL.TEXTURE_3D:\n        const gl2 = assertWebGL2Context(gl);\n        gl2.framebufferTextureLayer(GL.FRAMEBUFFER, attachment, texture.target, level, layer);\n        break;\n\n      case GL.TEXTURE_CUBE_MAP:\n        // layer must be a cubemap face (or if index, converted to cube map face)\n        const face = mapIndexToCubeMapFace(layer);\n        gl.framebufferTexture2D(GL.FRAMEBUFFER, attachment, face, texture.handle, level);\n        break;\n\n      case GL.TEXTURE_2D:\n        gl.framebufferTexture2D(GL.FRAMEBUFFER, attachment, GL.TEXTURE_2D, texture.handle, level);\n        break;\n\n      default:\n        assert(false, 'Illegal texture type');\n    }\n\n    gl.bindTexture(texture.target, null);\n    this.attachments[attachment] = texture;\n  }\n\n  // Expects framebuffer to be bound\n  _setReadBuffer(readBuffer) {\n    const gl2 = getWebGL2Context(this.gl);\n    if (gl2) {\n      gl2.readBuffer(readBuffer);\n    } else {\n      // Setting to color attachment 0 is a noop, so allow it in WebGL1\n      assert(\n        readBuffer === GL.COLOR_ATTACHMENT0 || readBuffer === GL.BACK,\n        ERR_MULTIPLE_RENDERTARGETS\n      );\n    }\n    this.readBuffer = readBuffer;\n  }\n\n  // Expects framebuffer to be bound\n  _setDrawBuffers(drawBuffers) {\n    const {gl} = this;\n    const gl2 = assertWebGL2Context(gl);\n    if (gl2) {\n      gl2.drawBuffers(drawBuffers);\n    } else {\n      // TODO - is this not handled by polyfills?\n      const ext = gl.getExtension('WEBGL_draw_buffers');\n      if (ext) {\n        ext.drawBuffersWEBGL(drawBuffers);\n      } else {\n        // Setting a single draw buffer to color attachment 0 is a noop, allow in WebGL1\n        assert(\n          drawBuffers.length === 1 &&\n            (drawBuffers[0] === GL.COLOR_ATTACHMENT0 || drawBuffers[0] === GL.BACK),\n          ERR_MULTIPLE_RENDERTARGETS\n        );\n      }\n    }\n    this.drawBuffers = drawBuffers;\n  }\n\n  // Attempt to provide workable defaults for WebGL2 symbols under WebGL1\n  // null means OK to query\n  // TODO - move to webgl1 polyfills\n  /* eslint-disable complexity */\n  _getAttachmentParameterFallback(pname) {\n    const caps = getFeatures(this.gl);\n\n    switch (pname) {\n      case GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: // GLint\n        return !caps.WEBGL2 ? 0 : null;\n      case GL.FRAMEBUFFER_ATTACHMENT_RED_SIZE: // GLint\n      case GL.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: // GLint\n      case GL.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: // GLint\n      case GL.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: // GLint\n      case GL.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: // GLint\n      case GL.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: // GLint\n        return !caps.WEBGL2 ? 8 : null;\n      case GL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: // GLenum\n        return !caps.WEBGL2 ? GL.UNSIGNED_INT : null;\n      case GL.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:\n        return !caps.WEBGL2 && !caps.EXT_sRGB ? GL.LINEAR : null;\n      default:\n        return null;\n    }\n  }\n  /* eslint-enable complexity */\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createFramebuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteFramebuffer(this.handle);\n  }\n\n  _bindHandle(handle) {\n    return this.gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  }\n}\n\n// PUBLIC METHODS\n\n// Map an index to a cube map face constant\nfunction mapIndexToCubeMapFace(layer) {\n  // TEXTURE_CUBE_MAP_POSITIVE_X is a big value (0x8515)\n  // if smaller assume layer is index, otherwise assume it is already a cube map face constant\n  return layer < GL.TEXTURE_CUBE_MAP_POSITIVE_X ? layer + GL.TEXTURE_CUBE_MAP_POSITIVE_X : layer;\n}\n\n// Helper METHODS\n// Get a string describing the framebuffer error if installed\nfunction _getFrameBufferStatus(status) {\n  // Use error mapping if installed\n  // @ts-ignore\n  const STATUS = Framebuffer.STATUS || {};\n  return STATUS[status] || `Framebuffer error ${status}`;\n}\n\nexport const FRAMEBUFFER_ATTACHMENT_PARAMETERS = [\n  GL.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, // WebGLRenderbuffer or WebGLTexture\n  GL.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, // GL.RENDERBUFFER, GL.TEXTURE, GL.NONE\n  // GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE, // GL.TEXTURE_CUBE_MAP_POSITIVE_X, etc.\n  // GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, // GLint\n  // EXT_sRGB or WebGL2\n  GL.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, // GL.LINEAR, GL.SRBG\n  // WebGL2\n  // GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_RED_SIZE, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE, // GLint\n  GL.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE // GLint\n  // GL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE\n  // GL.FLOAT, GL.INT, GL.UNSIGNED_INT, GL.SIGNED_NORMALIZED, OR GL.UNSIGNED_NORMALIZED.\n];\n\nFramebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;\n"]},"metadata":{},"sourceType":"module"}