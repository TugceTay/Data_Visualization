{"ast":null,"code":"import Accessor from './accessor';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { decomposeCompositeGLType } from '../webgl-utils/attribute-utils';\nexport default class ProgramConfiguration {\n  constructor(program) {\n    this.id = program.id;\n    this.attributeInfos = [];\n    this.attributeInfosByName = {};\n    this.attributeInfosByLocation = [];\n    this.varyingInfos = [];\n    this.varyingInfosByName = {};\n    Object.seal(this);\n    this._readAttributesFromProgram(program);\n    this._readVaryingsFromProgram(program);\n  }\n  getAttributeInfo(locationOrName) {\n    const location = Number(locationOrName);\n    if (Number.isFinite(location)) {\n      return this.attributeInfosByLocation[location];\n    }\n    return this.attributeInfosByName[locationOrName] || null;\n  }\n  getAttributeLocation(locationOrName) {\n    const attributeInfo = this.getAttributeInfo(locationOrName);\n    return attributeInfo ? attributeInfo.location : -1;\n  }\n  getAttributeAccessor(locationOrName) {\n    const attributeInfo = this.getAttributeInfo(locationOrName);\n    return attributeInfo ? attributeInfo.accessor : null;\n  }\n  getVaryingInfo(locationOrName) {\n    const location = Number(locationOrName);\n    if (Number.isFinite(location)) {\n      return this.varyingInfos[location];\n    }\n    return this.varyingInfosByName[locationOrName] || null;\n  }\n  getVaryingIndex(locationOrName) {\n    const varying = this.getVaryingInfo();\n    return varying ? varying.location : -1;\n  }\n  getVaryingAccessor(locationOrName) {\n    const varying = this.getVaryingInfo();\n    return varying ? varying.accessor : null;\n  }\n  _readAttributesFromProgram(program) {\n    const {\n      gl\n    } = program;\n    const count = gl.getProgramParameter(program.handle, 35721);\n    for (let index = 0; index < count; index++) {\n      const {\n        name,\n        type,\n        size\n      } = gl.getActiveAttrib(program.handle, index);\n      const location = gl.getAttribLocation(program.handle, name);\n      if (location >= 0) {\n        this._addAttribute(location, name, type, size);\n      }\n    }\n    this.attributeInfos.sort((a, b) => a.location - b.location);\n  }\n  _readVaryingsFromProgram(program) {\n    const {\n      gl\n    } = program;\n    if (!isWebGL2(gl)) {\n      return;\n    }\n    const count = gl.getProgramParameter(program.handle, 35971);\n    for (let location = 0; location < count; location++) {\n      const {\n        name,\n        type,\n        size\n      } = gl.getTransformFeedbackVarying(program.handle, location);\n      this._addVarying(location, name, type, size);\n    }\n    this.varyingInfos.sort((a, b) => a.location - b.location);\n  }\n  _addAttribute(location, name, compositeType, size) {\n    const {\n      type,\n      components\n    } = decomposeCompositeGLType(compositeType);\n    const accessor = {\n      type,\n      size: size * components\n    };\n    this._inferProperties(location, name, accessor);\n    const attributeInfo = {\n      location,\n      name,\n      accessor: new Accessor(accessor)\n    };\n    this.attributeInfos.push(attributeInfo);\n    this.attributeInfosByLocation[location] = attributeInfo;\n    this.attributeInfosByName[attributeInfo.name] = attributeInfo;\n  }\n  _inferProperties(location, name, accessor) {\n    if (/instance/i.test(name)) {\n      accessor.divisor = 1;\n    }\n  }\n  _addVarying(location, name, compositeType, size) {\n    const {\n      type,\n      components\n    } = decomposeCompositeGLType(compositeType);\n    const accessor = new Accessor({\n      type,\n      size: size * components\n    });\n    const varying = {\n      location,\n      name,\n      accessor\n    };\n    this.varyingInfos.push(varying);\n    this.varyingInfosByName[varying.name] = varying;\n  }\n}","map":{"version":3,"sources":["../../../src/classes/program-configuration.js"],"names":["Accessor","isWebGL2","decomposeCompositeGLType","ProgramConfiguration","constructor","program","id","attributeInfos","attributeInfosByName","attributeInfosByLocation","varyingInfos","varyingInfosByName","Object","seal","_readAttributesFromProgram","_readVaryingsFromProgram","getAttributeInfo","locationOrName","location","Number","isFinite","getAttributeLocation","attributeInfo","getAttributeAccessor","accessor","getVaryingInfo","getVaryingIndex","varying","getVaryingAccessor","gl","count","getProgramParameter","handle","index","name","type","size","getActiveAttrib","getAttribLocation","_addAttribute","sort","a","b","getTransformFeedbackVarying","_addVarying","compositeType","components","_inferProperties","push","test","divisor"],"mappings":"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","sourcesContent":["// Contains metadata describing attribute configurations for a program's shaders\n// Much of this is automatically extracted from shaders after program linking\nimport Accessor from './accessor';\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {decomposeCompositeGLType} from '../webgl-utils/attribute-utils';\n\nexport default class ProgramConfiguration {\n  constructor(program) {\n    this.id = program.id;\n    this.attributeInfos = [];\n    this.attributeInfosByName = {};\n\n    // Locations may not be contiguous the case of matrix attributes\n    // so keep a separate location->attribute map.\n    this.attributeInfosByLocation = [];\n    this.varyingInfos = [];\n    this.varyingInfosByName = {};\n    Object.seal(this);\n    this._readAttributesFromProgram(program);\n    this._readVaryingsFromProgram(program);\n  }\n\n  getAttributeInfo(locationOrName) {\n    const location = Number(locationOrName);\n    if (Number.isFinite(location)) {\n      return this.attributeInfosByLocation[location];\n    }\n    return this.attributeInfosByName[locationOrName] || null;\n  }\n\n  // Resolves an attribute name or index to an index\n  getAttributeLocation(locationOrName) {\n    const attributeInfo = this.getAttributeInfo(locationOrName);\n    return attributeInfo ? attributeInfo.location : -1;\n  }\n\n  getAttributeAccessor(locationOrName) {\n    const attributeInfo = this.getAttributeInfo(locationOrName);\n    return attributeInfo ? attributeInfo.accessor : null;\n  }\n\n  getVaryingInfo(locationOrName) {\n    const location = Number(locationOrName);\n    if (Number.isFinite(location)) {\n      return this.varyingInfos[location];\n    }\n    return this.varyingInfosByName[locationOrName] || null;\n  }\n\n  getVaryingIndex(locationOrName) {\n    const varying = this.getVaryingInfo();\n    return varying ? varying.location : -1;\n  }\n\n  getVaryingAccessor(locationOrName) {\n    const varying = this.getVaryingInfo();\n    return varying ? varying.accessor : null;\n  }\n\n  // PRIVATE METHODS\n\n  // linkProgram needs to have been called, although linking does not need to have been successful\n  _readAttributesFromProgram(program) {\n    const {gl} = program;\n    const count = gl.getProgramParameter(program.handle, gl.ACTIVE_ATTRIBUTES);\n\n    for (let index = 0; index < count; index++) {\n      const {name, type, size} = gl.getActiveAttrib(program.handle, index);\n      const location = gl.getAttribLocation(program.handle, name);\n      // Add only user provided attributes, for built-in attributes like\n      // `gl_InstanceID` locaiton will be < 0\n      if (location >= 0) {\n        this._addAttribute(location, name, type, size);\n      }\n    }\n\n    this.attributeInfos.sort((a, b) => a.location - b.location);\n  }\n\n  // linkProgram needs to have been called, although linking does not need to have been successful\n  _readVaryingsFromProgram(program) {\n    const {gl} = program;\n    if (!isWebGL2(gl)) {\n      return;\n    }\n\n    const count = gl.getProgramParameter(program.handle, gl.TRANSFORM_FEEDBACK_VARYINGS);\n    for (let location = 0; location < count; location++) {\n      const {name, type, size} = gl.getTransformFeedbackVarying(program.handle, location);\n      this._addVarying(location, name, type, size);\n    }\n\n    this.varyingInfos.sort((a, b) => a.location - b.location);\n  }\n\n  _addAttribute(location, name, compositeType, size) {\n    const {type, components} = decomposeCompositeGLType(compositeType);\n    const accessor = {type, size: size * components};\n    this._inferProperties(location, name, accessor);\n\n    const attributeInfo = {location, name, accessor: new Accessor(accessor)}; // Base values\n    this.attributeInfos.push(attributeInfo);\n    this.attributeInfosByLocation[location] = attributeInfo; // For quick location based lookup\n    this.attributeInfosByName[attributeInfo.name] = attributeInfo; // For quick name based lookup\n  }\n\n  // Extract additional attribute metadata from shader names (based on attribute naming conventions)\n  _inferProperties(location, name, accessor) {\n    if (/instance/i.test(name)) {\n      // Any attribute containing the word \"instance\" will be assumed to be instanced\n      accessor.divisor = 1;\n    }\n  }\n\n  _addVarying(location, name, compositeType, size) {\n    const {type, components} = decomposeCompositeGLType(compositeType);\n    const accessor = new Accessor({type, size: size * components});\n\n    const varying = {location, name, accessor}; // Base values\n    this.varyingInfos.push(varying);\n    this.varyingInfosByName[varying.name] = varying; // For quick name based lookup\n  }\n}\n"]},"metadata":{},"sourceType":"module"}