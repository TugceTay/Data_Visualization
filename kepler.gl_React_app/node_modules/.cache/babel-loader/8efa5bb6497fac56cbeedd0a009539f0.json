{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport { LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE } from '@loaders.gl/tiles';\nfunction getTileType(tile) {\n  if (!tile.contentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n  var contentUrl = tile.contentUrl;\n  var fileExtension = contentUrl.split('.').pop();\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n    case 'i3dm':\n    case 'b3dm':\n      return TILE_TYPE.SCENEGRAPH;\n    default:\n      return fileExtension;\n  }\n}\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n    default:\n      return refine;\n  }\n}\nexport function normalizeTileData(tile, options) {\n  if (tile.content) {\n    var contentUri = tile.content.uri || tile.content.url;\n    tile.contentUrl = \"\".concat(options.basePath, \"/\").concat(contentUri);\n  }\n  tile.id = tile.contentUrl;\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  tile.type = getTileType(tile);\n  tile.refine = getRefine(tile.refine);\n  return tile;\n}\nexport function normalizeTileHeaders(tileset) {\n  var basePath = tileset.basePath;\n  var root = normalizeTileData(tileset.root, tileset);\n  var stack = [];\n  stack.push(root);\n  while (stack.length > 0) {\n    var tile = stack.pop();\n    var children = tile.children || [];\n    var _iterator = _createForOfIteratorHelper(children),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var childHeader = _step.value;\n        normalizeTileData(childHeader, {\n          basePath: basePath\n        });\n        stack.push(childHeader);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return root;\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-3d-tile-header.js"],"names":["LOD_METRIC_TYPE","TILE_REFINEMENT","TILE_TYPE","getTileType","tile","contentUrl","EMPTY","fileExtension","split","pop","POINTCLOUD","SCENEGRAPH","getRefine","refine","REPLACE","ADD","normalizeTileData","options","content","contentUri","uri","url","basePath","id","lodMetricType","GEOMETRIC_ERROR","lodMetricValue","geometricError","transformMatrix","transform","type","normalizeTileHeaders","tileset","root","stack","push","length","children","childHeader"],"mappings":"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","sourcesContent":["import {LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE} from '@loaders.gl/tiles';\n\nfunction getTileType(tile) {\n  if (!tile.contentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n\n  const contentUrl = tile.contentUrl;\n  const fileExtension = contentUrl.split('.').pop();\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n    case 'i3dm':\n    case 'b3dm':\n      return TILE_TYPE.SCENEGRAPH;\n    default:\n      return fileExtension;\n  }\n}\n\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n    default:\n      return refine;\n  }\n}\n\nexport function normalizeTileData(tile, options) {\n  if (tile.content) {\n    const contentUri = tile.content.uri || tile.content.url;\n    tile.contentUrl = `${options.basePath}/${contentUri}`;\n  }\n  tile.id = tile.contentUrl;\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  tile.type = getTileType(tile);\n  tile.refine = getRefine(tile.refine);\n  return tile;\n}\n\n// normalize tile headers\nexport function normalizeTileHeaders(tileset) {\n  const basePath = tileset.basePath;\n  const root = normalizeTileData(tileset.root, tileset);\n\n  const stack = [];\n  stack.push(root);\n\n  while (stack.length > 0) {\n    const tile = stack.pop();\n    const children = tile.children || [];\n    for (const childHeader of children) {\n      normalizeTileData(childHeader, {basePath});\n      stack.push(childHeader);\n    }\n  }\n\n  return root;\n}\n"]},"metadata":{},"sourceType":"module"}