{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { GL } from '@loaders.gl/math';\nimport { Vector3 } from '@math.gl/core';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport { parse3DTileHeaderSync } from './helpers/parse-3d-tile-header';\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from './helpers/parse-3d-tile-tables';\nimport { normalize3DTileColorAttribute } from './helpers/normalize-3d-tile-colors';\nimport { normalize3DTileNormalAttribute } from './helpers/normalize-3d-tile-normals';\nimport { normalize3DTilePositionAttribute } from './helpers/normalize-3d-tile-positions';\nexport function parsePointCloud3DTile(_x, _x2, _x3, _x4, _x5) {\n  return _parsePointCloud3DTile.apply(this, arguments);\n}\nfunction _parsePointCloud3DTile() {\n  _parsePointCloud3DTile = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tile, arrayBuffer, byteOffset, options, context) {\n    var _parsePointCloudTable, featureTable, batchTable;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n            byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n            byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n            initializeTile(tile);\n            _parsePointCloudTable = parsePointCloudTables(tile), featureTable = _parsePointCloudTable.featureTable, batchTable = _parsePointCloudTable.batchTable;\n            _context.next = 7;\n            return parseDraco(tile, featureTable, batchTable, options, context);\n          case 7:\n            parsePositions(tile, featureTable, options);\n            parseColors(tile, featureTable, batchTable);\n            parseNormals(tile, featureTable);\n            return _context.abrupt(\"return\", byteOffset);\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parsePointCloud3DTile.apply(this, arguments);\n}\nfunction initializeTile(tile) {\n  tile.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n}\nfunction parsePointCloudTables(tile) {\n  var featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  var pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n  featureTable.featuresLength = pointsLength;\n  tile.featuresLength = pointsLength;\n  tile.pointsLength = pointsLength;\n  tile.pointCount = pointsLength;\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n  var batchTable = parseBatchIds(tile, featureTable);\n  return {\n    featureTable: featureTable,\n    batchTable: batchTable\n  };\n}\nfunction parsePositions(tile, featureTable, options) {\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      var positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3);\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3);\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n    }\n  }\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\nfunction parseColors(tile, featureTable, batchTable) {\n  if (!tile.attributes.colors) {\n    var colors = null;\n    if (featureTable.hasProperty('RGBA')) {\n      colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n  }\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n}\nfunction parseNormals(tile, featureTable) {\n  if (!tile.attributes.normals) {\n    var normals = null;\n    if (featureTable.hasProperty('NORMAL')) {\n      normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n  }\n}\nfunction parseBatchIds(tile, featureTable) {\n  var batchTable = null;\n  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    if (tile.batchIds) {\n      var batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n      var batchTableJson = tile.batchTableJson,\n        batchTableBinary = tile.batchTableBinary;\n      batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n  return batchTable;\n}\nfunction parseDraco(_x6, _x7, _x8, _x9, _x10) {\n  return _parseDraco.apply(this, arguments);\n}\nfunction _parseDraco() {\n  _parseDraco = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(tile, featureTable, batchTable, options, context) {\n    var dracoBuffer, dracoFeatureTableProperties, dracoBatchTableProperties, batchTableDraco, featureTableDraco, dracoByteOffset, dracoByteLength, dracoData;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions['3DTILES_draco_point_compression'];\n            if (batchTableDraco) {\n              dracoBatchTableProperties = batchTableDraco.properties;\n            }\n            featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n            if (!featureTableDraco) {\n              _context2.next = 15;\n              break;\n            }\n            dracoFeatureTableProperties = featureTableDraco.properties;\n            dracoByteOffset = featureTableDraco.byteOffset;\n            dracoByteLength = featureTableDraco.byteLength;\n            if (!(!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength)) {\n              _context2.next = 9;\n              break;\n            }\n            throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n          case 9:\n            dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n            tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n            tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);\n            tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n            tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n            tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n          case 15:\n            if (dracoBuffer) {\n              _context2.next = 17;\n              break;\n            }\n            return _context2.abrupt(\"return\", true);\n          case 17:\n            dracoData = {\n              buffer: dracoBuffer,\n              properties: _objectSpread(_objectSpread({}, dracoFeatureTableProperties), dracoBatchTableProperties),\n              featureTableProperties: dracoFeatureTableProperties,\n              batchTableProperties: dracoBatchTableProperties,\n              dequantizeInShader: false\n            };\n            _context2.next = 20;\n            return loadDraco(tile, dracoData, options, context);\n          case 20:\n            return _context2.abrupt(\"return\", _context2.sent);\n          case 21:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _parseDraco.apply(this, arguments);\n}\nexport function loadDraco(_x11, _x12, _x13, _x14) {\n  return _loadDraco.apply(this, arguments);\n}\nfunction _loadDraco() {\n  _loadDraco = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(tile, dracoData, options, context) {\n    var parse, data, decodedPositions, decodedColors, decodedNormals, decodedBatchIds, isQuantizedDraco, isOctEncodedDraco, quantization, range, batchTableAttributes, _i, _Object$keys, attributeName;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            parse = context.parse;\n            _context3.next = 3;\n            return parse(dracoData.buffer, DracoLoader, {\n              draco: {\n                extraAttributes: dracoData.batchTableProperties || {}\n              }\n            });\n          case 3:\n            data = _context3.sent;\n            decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n            decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n            decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n            decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n            isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n            isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n            if (isQuantizedDraco) {\n              quantization = data.POSITION.data.quantization;\n              range = quantization.range;\n              tile.quantizedVolumeScale = new Vector3(range, range, range);\n              tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n              tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n              tile.isQuantizedDraco = true;\n            }\n            if (isOctEncodedDraco) {\n              tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n              tile.isOctEncodedDraco = true;\n            }\n            batchTableAttributes = {};\n            if (dracoData.batchTableProperties) {\n              for (_i = 0, _Object$keys = Object.keys(dracoData.batchTableProperties); _i < _Object$keys.length; _i++) {\n                attributeName = _Object$keys[_i];\n                if (data.attributes[attributeName] && data.attributes[attributeName].value) {\n                  batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;\n                }\n              }\n            }\n            tile.attributes = _objectSpread({\n              positions: decodedPositions,\n              colors: normalize3DTileColorAttribute(tile, decodedColors),\n              normals: decodedNormals,\n              batchIds: decodedBatchIds\n            }, batchTableAttributes);\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _loadDraco.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-3d-tile-point-cloud.js"],"names":["DracoLoader","GL","Vector3","Tile3DFeatureTable","Tile3DBatchTable","parse3DTileHeaderSync","parse3DTileTablesHeaderSync","parse3DTileTablesSync","normalize3DTileColorAttribute","normalize3DTileNormalAttribute","normalize3DTilePositionAttribute","parsePointCloud3DTile","tile","arrayBuffer","byteOffset","options","context","initializeTile","featureTable","batchTable","parsePointCloudTables","parseDraco","parsePositions","parseColors","parseNormals","attributes","positions","colors","normals","batchIds","isQuantized","isTranslucent","isRGB565","isOctEncoded16P","featureTableJson","featureTableBinary","pointsLength","getGlobalProperty","Number","isFinite","Error","featuresLength","pointCount","rtcCenter","FLOAT","parseBatchIds","hasProperty","getPropertyArray","UNSIGNED_SHORT","quantizedRange","quantizedVolumeScale","quantizedVolumeOffset","UNSIGNED_BYTE","constantRGBA","batchFeatureLength","batchTableJson","batchTableBinary","batchTableDraco","extensions","dracoBatchTableProperties","properties","featureTableDraco","getExtension","dracoFeatureTableProperties","dracoByteOffset","dracoByteLength","byteLength","dracoBuffer","slice","hasPositions","POSITION","hasColors","RGB","RGBA","hasNormals","NORMAL","hasBatchIds","BATCH_ID","dracoData","buffer","featureTableProperties","batchTableProperties","dequantizeInShader","loadDraco","parse","data","draco","extraAttributes","decodedPositions","value","decodedColors","COLOR_0","decodedNormals","decodedBatchIds","isQuantizedDraco","quantization","isOctEncodedDraco","range","minValues","quantizationBits","octEncodedRange","batchTableAttributes","attributeName","Object","keys","toLowerCase"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {GL} from '@loaders.gl/math';\nimport {Vector3} from '@math.gl/core';\n\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {normalize3DTileColorAttribute} from './helpers/normalize-3d-tile-colors';\nimport {normalize3DTileNormalAttribute} from './helpers/normalize-3d-tile-normals';\nimport {normalize3DTilePositionAttribute} from './helpers/normalize-3d-tile-positions';\n\nexport async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  initializeTile(tile);\n\n  const {featureTable, batchTable} = parsePointCloudTables(tile);\n\n  await parseDraco(tile, featureTable, batchTable, options, context);\n\n  parsePositions(tile, featureTable, options);\n  parseColors(tile, featureTable, batchTable);\n  parseNormals(tile, featureTable);\n\n  return byteOffset;\n}\n\nfunction initializeTile(tile) {\n  // Initialize point cloud tile defaults\n  tile.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n}\n\nfunction parsePointCloudTables(tile) {\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n  featureTable.featuresLength = pointsLength;\n\n  tile.featuresLength = pointsLength;\n  tile.pointsLength = pointsLength;\n  tile.pointCount = pointsLength;\n\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  const batchTable = parseBatchIds(tile, featureTable);\n\n  return {featureTable, batchTable};\n}\n\nfunction parsePositions(tile, featureTable, options) {\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      const positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n\n      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n\nfunction parseColors(tile, featureTable, batchTable) {\n  if (!tile.attributes.colors) {\n    let colors = null;\n    if (featureTable.hasProperty('RGBA')) {\n      colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n\n    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n  }\n\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n}\n\nfunction parseNormals(tile, featureTable) {\n  if (!tile.attributes.normals) {\n    let normals = null;\n    if (featureTable.hasProperty('NORMAL')) {\n      normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n\n    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n  }\n}\n\nfunction parseBatchIds(tile, featureTable) {\n  let batchTable = null;\n  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n\n    if (tile.batchIds) {\n      const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n      const {batchTableJson, batchTableBinary} = tile;\n      batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n  return batchTable;\n}\n\n// eslint-disable-next-line complexity\nasync function parseDraco(tile, featureTable, batchTable, options, context) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n  const batchTableDraco =\n    tile.batchTableJson &&\n    tile.batchTableJson.extensions &&\n    tile.batchTableJson.extensions['3DTILES_draco_point_compression'];\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n\n    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n    tile.hasColors =\n      Number.isFinite(dracoFeatureTableProperties.RGB) ||\n      Number.isFinite(dracoFeatureTableProperties.RGBA);\n    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n  }\n\n  if (!dracoBuffer) {\n    return true;\n  }\n\n  const dracoData = {\n    buffer: dracoBuffer,\n    properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n    featureTableProperties: dracoFeatureTableProperties,\n    batchTableProperties: dracoBatchTableProperties,\n    dequantizeInShader: false\n  };\n\n  return await loadDraco(tile, dracoData, options, context);\n}\n\n// eslint-disable-next-line complexity, max-statements\nexport async function loadDraco(tile, dracoData, options, context) {\n  const {parse} = context;\n  const data = await parse(dracoData.buffer, DracoLoader, {\n    draco: {\n      extraAttributes: dracoData.batchTableProperties || {}\n    }\n  });\n\n  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n  if (isQuantizedDraco) {\n    // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n    // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n    const quantization = data.POSITION.data.quantization;\n    const range = quantization.range;\n    tile.quantizedVolumeScale = new Vector3(range, range, range);\n    tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n    tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n    tile.isQuantizedDraco = true;\n  }\n  if (isOctEncodedDraco) {\n    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n    tile.isOctEncodedDraco = true;\n  }\n\n  // Extra batch table attributes\n  const batchTableAttributes = {};\n  if (dracoData.batchTableProperties) {\n    for (const attributeName of Object.keys(dracoData.batchTableProperties)) {\n      if (data.attributes[attributeName] && data.attributes[attributeName].value) {\n        batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;\n      }\n    }\n  }\n\n  tile.attributes = {\n    positions: decodedPositions,\n    colors: normalize3DTileColorAttribute(tile, decodedColors),\n    normals: decodedNormals,\n    batchIds: decodedBatchIds,\n    ...batchTableAttributes\n  };\n}\n\n// TODO - this is the remaining code from Cesium's parser\n/*\n  const batchTable = new Tile3DBatchTable(tile);\n\n  // parseDracoBuffer(tile, featureTable, batchTable);\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n/*\n\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n\n  if (!tile.colors) {\n    if (featureTable.hasProperty('RGBA')) {\n      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasPropertry('RGB565')) {\n      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n  }\n\n  if (!tile.attributes.normals) {\n    if (featureTable.getPropertry('NORMAL')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.getProperty('NORMAL_OCT16P')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n  }\n\n  if (!tile.batchIds) {\n    if (featureTable.hasProperty('BATCH_ID')) {\n      tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n\n  if (featureTable.getPropertry('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n\n  if (tile.batchIds) {\n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    if (!defined(batchLength)) {\n      throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  tile.draco = draco;\n}\n\n// Separate parsing and decoding of Draco\nexport function parseDracoBuffer(tile, featureTable, batchTable) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const batchTableDraco = batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !dracoByteOffset || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    tile.hasPositions = dracoFeatureTableProperties.POSITION;\n    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;\n    tile.hasNormals = dracoFeatureTableProperties.NORMAL;\n    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;\n    tile.isTranslucent = dracoFeatureTableProperties.RGBA;\n  }\n\n  if (dracoBuffer) {\n    tile.draco = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    tile.decodingState = DECODING_STATE.NEEDS_DECODE;\n  }\n}\n\n/*\nfunction decodeDraco(tile, context) {\n  if (tile.decodingState === DECODING_STATE.READY) {\n    return false;\n  }\n  if (tile.decodingState === DECODING_STATE.NEEDS_DECODE) {\n    var parsedContent = tile._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      tile.decodingState = DECODING_STATE.DECODING;\n      decodePromise.then(function(result) {\n        tile.decodingState = DECODING_STATE.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          tile._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          tile._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          tile._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          tile._isQuantizedDraco = true;\n        }\n        if (isOctEncodedDraco) {\n          tile._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          tile._isOctEncodedDraco = true;\n        }\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n            styleableProperties[name] = {\n              typedArray : property.array,\n              componentCount : property.data.componentsPerAttribute\n            };\n          }\n        }\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function(error) {\n        tile.decodingState = DECODING_STATE.FAILED;\n        tile._readyPromise.reject(error);\n      });\n    }\n  }\n  return true;\n}\n*/\n"]},"metadata":{},"sourceType":"module"}