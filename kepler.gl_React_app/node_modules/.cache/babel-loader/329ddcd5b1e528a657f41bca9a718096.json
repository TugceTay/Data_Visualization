{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport WorkerThread from './worker-thread';\nvar WorkerPool = function () {\n  function WorkerPool(_ref) {\n    var source = _ref.source,\n      _ref$name = _ref.name,\n      name = _ref$name === void 0 ? 'unnamed' : _ref$name,\n      _ref$maxConcurrency = _ref.maxConcurrency,\n      maxConcurrency = _ref$maxConcurrency === void 0 ? 1 : _ref$maxConcurrency,\n      onMessage = _ref.onMessage,\n      _ref$onDebug = _ref.onDebug,\n      onDebug = _ref$onDebug === void 0 ? function () {} : _ref$onDebug,\n      _ref$reuseWorkers = _ref.reuseWorkers,\n      reuseWorkers = _ref$reuseWorkers === void 0 ? true : _ref$reuseWorkers;\n    _classCallCheck(this, WorkerPool);\n    this.source = source;\n    this.name = name;\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n    this.jobQueue = [];\n    this.idleQueue = [];\n    this.count = 0;\n    this.isDestroyed = false;\n    this.reuseWorkers = reuseWorkers;\n  }\n  _createClass(WorkerPool, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.idleQueue.forEach(function (worker) {\n        return worker.destroy();\n      });\n      this.isDestroyed = true;\n    }\n  }, {\n    key: \"process\",\n    value: function process(data, jobName) {\n      var _this = this;\n      return new Promise(function (resolve, reject) {\n        _this.jobQueue.push({\n          data: data,\n          jobName: jobName,\n          resolve: resolve,\n          reject: reject\n        });\n        _this._startQueuedJob();\n      });\n    }\n  }, {\n    key: \"_startQueuedJob\",\n    value: function () {\n      var _startQueuedJob2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {\n        var worker, job;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.jobQueue.length) {\n                  _context.next = 2;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 2:\n                worker = this._getAvailableWorker();\n                if (worker) {\n                  _context.next = 5;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 5:\n                job = this.jobQueue.shift();\n                this.onDebug({\n                  message: 'processing',\n                  worker: worker.name,\n                  job: job.jobName,\n                  backlog: this.jobQueue.length\n                });\n                _context.prev = 7;\n                _context.t0 = job;\n                _context.next = 11;\n                return worker.process(job.data);\n              case 11:\n                _context.t1 = _context.sent;\n                _context.t0.resolve.call(_context.t0, _context.t1);\n                _context.next = 18;\n                break;\n              case 15:\n                _context.prev = 15;\n                _context.t2 = _context[\"catch\"](7);\n                job.reject(_context.t2);\n              case 18:\n                _context.prev = 18;\n                this._onWorkerDone(worker);\n                return _context.finish(18);\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 15, 18, 21]]);\n      }));\n      function _startQueuedJob() {\n        return _startQueuedJob2.apply(this, arguments);\n      }\n      return _startQueuedJob;\n    }()\n  }, {\n    key: \"_onWorkerDone\",\n    value: function _onWorkerDone(worker) {\n      if (this.isDestroyed) {\n        worker.destroy();\n        return;\n      }\n      if (this.reuseWorkers) {\n        this.idleQueue.push(worker);\n      } else {\n        worker.destroy();\n        this.count--;\n      }\n      this._startQueuedJob();\n    }\n  }, {\n    key: \"_getAvailableWorker\",\n    value: function _getAvailableWorker() {\n      if (this.idleQueue.length > 0) {\n        return this.idleQueue.shift();\n      }\n      if (this.count < this.maxConcurrency) {\n        this.count++;\n        var name = \"\".concat(this.name.toLowerCase(), \" (#\").concat(this.count, \" of \").concat(this.maxConcurrency, \")\");\n        return new WorkerThread({\n          source: this.source,\n          onMessage: this.onMessage,\n          name: name\n        });\n      }\n      return null;\n    }\n  }]);\n  return WorkerPool;\n}();\nexport { WorkerPool as default };","map":{"version":3,"sources":["../../../../src/lib/worker-utils/worker-pool.js"],"names":["WorkerThread","WorkerPool","source","name","maxConcurrency","onMessage","onDebug","reuseWorkers","jobQueue","idleQueue","count","isDestroyed","forEach","worker","destroy","data","jobName","Promise","resolve","reject","push","_startQueuedJob","length","_getAvailableWorker","job","shift","message","backlog","process","_onWorkerDone","toLowerCase"],"mappings":"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","sourcesContent":["import WorkerThread from './worker-thread';\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  constructor({\n    source,\n    name = 'unnamed',\n    maxConcurrency = 1,\n    onMessage,\n    onDebug = () => {},\n    reuseWorkers = true\n  }) {\n    this.source = source;\n    this.name = name;\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n\n    this.jobQueue = [];\n    this.idleQueue = [];\n    this.count = 0;\n    this.isDestroyed = false;\n    this.reuseWorkers = reuseWorkers;\n  }\n\n  destroy() {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  /**\n   * Process binary data in a worker\n   */\n  process(data, jobName) {\n    return new Promise((resolve, reject) => {\n      this.jobQueue.push({data, jobName, resolve, reject});\n      this._startQueuedJob();\n    });\n  }\n\n  // PRIVATE\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const worker = this._getAvailableWorker();\n    if (!worker) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const job = this.jobQueue.shift();\n\n    // @ts-ignore\n    this.onDebug({\n      message: 'processing',\n      worker: worker.name,\n      job: job.jobName,\n      backlog: this.jobQueue.length\n    });\n\n    try {\n      job.resolve(await worker.process(job.data));\n    } catch (error) {\n      job.reject(error);\n    } finally {\n      this._onWorkerDone(worker);\n    }\n  }\n\n  _onWorkerDone(worker) {\n    if (this.isDestroyed) {\n      worker.destroy();\n      return;\n    }\n\n    if (this.reuseWorkers) {\n      this.idleQueue.push(worker);\n    } else {\n      worker.destroy();\n      this.count--;\n    }\n\n    this._startQueuedJob();\n  }\n\n  _getAvailableWorker() {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift();\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this.maxConcurrency) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({source: this.source, onMessage: this.onMessage, name});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}