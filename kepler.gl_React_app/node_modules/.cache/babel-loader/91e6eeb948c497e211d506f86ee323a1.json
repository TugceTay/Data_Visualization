{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport { GL } from '@loaders.gl/math';\nexport function normalize3DTilePositionAttribute(tile, positions, options) {\n  if (!tile.isQuantized) {\n    return positions;\n  }\n  if (options['3d-tiles'] && options['3d-tiles'].decodeQuantizedPositions) {\n    tile.isQuantized = false;\n    return decodeQuantizedPositions(tile, positions);\n  }\n  return {\n    type: GL.UNSIGNED_SHORT,\n    value: positions,\n    size: 3,\n    normalized: true\n  };\n}\nfunction decodeQuantizedPositions(tile, positions) {\n  var scratchPosition = new Vector3();\n  var decodedArray = new Float32Array(tile.pointCount * 3);\n  for (var i = 0; i < tile.pointCount; i++) {\n    scratchPosition.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]).scale(1 / tile.quantizedRange).multiply(tile.quantizedVolumeScale).add(tile.quantizedVolumeOffset).toArray(decodedArray, i * 3);\n  }\n  return decodedArray;\n}","map":{"version":3,"sources":["../../../../../src/lib/parsers/helpers/normalize-3d-tile-positions.js"],"names":["Vector3","GL","normalize3DTilePositionAttribute","tile","positions","options","isQuantized","decodeQuantizedPositions","type","UNSIGNED_SHORT","value","size","normalized","scratchPosition","decodedArray","Float32Array","pointCount","i","set","scale","quantizedRange","multiply","quantizedVolumeScale","add","quantizedVolumeOffset","toArray"],"mappings":"AAAA,SAAQA,OAAR,QAAsB,eAAtB;AACA,SAAQC,EAAR,QAAiB,kBAAjB;AAGA,OAAO,SAASC,gCAAT,CAA0CC,IAA1C,EAAgDC,SAAhD,EAA2DC,OAA3D,EAAoE;EACzE,IAAI,CAACF,IAAI,CAACG,WAAV,EAAuB;IACrB,OAAOF,SAAP;EACD;EAMD,IAAIC,OAAO,CAAC,UAAD,CAAPA,IAAuBA,OAAO,CAAC,UAAD,CAAPA,CAAoBE,wBAA/C,EAAyE;IACvEJ,IAAI,CAACG,WAALH,GAAmB,KAAnBA;IACA,OAAOI,wBAAwB,CAACJ,IAAD,EAAOC,SAAP,CAA/B;EACD;EAID,OAAO;IACLI,IAAI,EAAEP,EAAE,CAACQ,cADJ;IAELC,KAAK,EAAEN,SAFF;IAGLO,IAAI,EAAE,CAHD;IAILC,UAAU,EAAE;EAJP,CAAP;AAMD;AAGD,SAASL,wBAAT,CAAkCJ,IAAlC,EAAwCC,SAAxC,EAAmD;EACjD,IAAMS,eAAe,GAAG,IAAIb,OAAJ,EAAxB;EACA,IAAMc,YAAY,GAAG,IAAIC,YAAJ,CAAiBZ,IAAI,CAACa,UAALb,GAAkB,CAAnC,CAArB;EAEA,KAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,IAAI,CAACa,UAAzB,EAAqCC,CAAC,EAAtC,EAA0C;IAExCJ,eAAe,CACZK,GADHL,CACOT,SAAS,CAACa,CAAC,GAAG,CAAL,CADhBJ,EACyBT,SAAS,CAACa,CAAC,GAAG,CAAJA,GAAQ,CAAT,CADlCJ,EAC+CT,SAAS,CAACa,CAAC,GAAG,CAAJA,GAAQ,CAAT,CADxDJ,CAAAA,CAEGM,KAFHN,CAES,CAAA,GAAIV,IAAI,CAACiB,cAFlBP,CAAAA,CAGGQ,QAHHR,CAGYV,IAAI,CAACmB,oBAHjBT,CAAAA,CAIGU,GAJHV,CAIOV,IAAI,CAACqB,qBAJZX,CAAAA,CAKGY,OALHZ,CAKWC,YALXD,EAKyBI,CAAC,GAAG,CAL7BJ,CAAAA;EAMD;EAED,OAAOC,YAAP;AACD","sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {GL} from '@loaders.gl/math';\n\n// Prepare attribute for positions\nexport function normalize3DTilePositionAttribute(tile, positions, options) {\n  if (!tile.isQuantized) {\n    return positions;\n  }\n\n  // For quantized posititions, either expand to Float32Array or return custom accessor\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/TileFormats/Instanced3DModel/README.md#quantized-positions\n\n  // Optionally decodes quantized positions on GPU, for simpler renderers that don't accept normalized attributes\n  if (options['3d-tiles'] && options['3d-tiles'].decodeQuantizedPositions) {\n    tile.isQuantized = false;\n    return decodeQuantizedPositions(tile, positions);\n  }\n\n  // Default: Use normalized shorts directly, no copying/processing.\n  // NOTE: The \"missing\" offset/scaling operations are automatically added to modelMatrix if `tile.isQuantized === true`\n  return {\n    type: GL.UNSIGNED_SHORT,\n    value: positions,\n    size: 3,\n    normalized: true\n  };\n}\n\n// Pre-scale quantized positions on CPU\nfunction decodeQuantizedPositions(tile, positions) {\n  const scratchPosition = new Vector3();\n  const decodedArray = new Float32Array(tile.pointCount * 3);\n\n  for (let i = 0; i < tile.pointCount; i++) {\n    // POSITION = POSITION_QUANTIZED / 65535.0 * QUANTIZED_VOLUME_SCALE + QUANTIZED_VOLUME_OFFSET\n    scratchPosition\n      .set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2])\n      .scale(1 / tile.quantizedRange)\n      .multiply(tile.quantizedVolumeScale)\n      .add(tile.quantizedVolumeOffset)\n      .toArray(decodedArray, i * 3);\n  }\n\n  return decodedArray;\n}\n"]},"metadata":{},"sourceType":"module"}