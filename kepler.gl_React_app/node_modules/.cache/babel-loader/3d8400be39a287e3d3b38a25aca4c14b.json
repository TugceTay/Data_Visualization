{"ast":null,"code":"import { cloneTextureFrom, readPixelsToArray, getShaderVersion, Buffer, Texture2D, Framebuffer } from '@luma.gl/webgl';\nimport { _transform as transformModule, getPassthroughFS, typeToChannelCount, combineInjects } from '@luma.gl/shadertools';\nimport { updateForTextures, getSizeUniforms } from './transform-shader-utils';\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [10241]: 9728,\n  [10240]: 9728,\n  [10242]: 33071,\n  [10243]: 33071\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\nexport default class TextureTransform {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.id = this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = [];\n    this.resources = {};\n    this._initialize(props);\n    Object.seal(this);\n  }\n  updateModelProps() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n  getDrawOptions() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceBuffers,\n      sourceTextures,\n      framebuffer,\n      targetTexture\n    } = this.bindings[this.currentIndex];\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n    return {\n      attributes,\n      framebuffer,\n      uniforms,\n      discard,\n      parameters\n    };\n  }\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n  update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._setupTextures(opts);\n  }\n  getTargetTexture() {\n    const {\n      targetTexture\n    } = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n  getData() {\n    let {\n      packed = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      framebuffer\n    } = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n    if (!packed) {\n      return pixels;\n    }\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType(pixels.length * channelCount / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n  _initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      _targetTextureVarying,\n      _swapTexture\n    } = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n  _createTargetTexture(props) {\n    const {\n      sourceTextures,\n      textureOrReference\n    } = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n    this._targetRefTexName = textureOrReference;\n    return this._createNewTexture(refTexture);\n  }\n  _setupTextures() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceBuffers,\n      _sourceTextures = {},\n      _targetTexture\n    } = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;\n    this._updateBindings({\n      sourceBuffers,\n      sourceTextures: _sourceTextures,\n      targetTexture\n    });\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {\n          size: 1\n        }\n      });\n    } else {\n      this.elementIDBuffer.setData({\n        data: elementIds\n      });\n    }\n    this.elementCount = elementCount;\n  }\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {\n        sourceTextures,\n        targetTexture\n      } = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n  _updateBinding(binding, opts) {\n    const {\n      sourceBuffers,\n      sourceTextures,\n      targetTexture\n    } = opts;\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n      const {\n        width,\n        height\n      } = targetTexture;\n      const {\n        framebuffer\n      } = binding;\n      if (framebuffer) {\n        framebuffer.update({\n          attachments: {\n            [36064]: targetTexture\n          },\n          resizeAttachments: false\n        });\n        framebuffer.resize({\n          width,\n          height\n        });\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: \"transform-framebuffer\",\n          width,\n          height,\n          attachments: {\n            [36064]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {\n      sourceTextures\n    } = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n    return {\n      sourceTextures,\n      targetTexture\n    };\n  }\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [10241]: 9728,\n        [10240]: 9728,\n        [10242]: 33071,\n        [10243]: 33071\n      },\n      pixelStore: {\n        [37440]: false\n      }\n    });\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n    return texture;\n  }\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n  _processVertexShader() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceTextures,\n      targetTexture\n    } = this.bindings[this.currentIndex];\n    const {\n      vs,\n      uniforms,\n      targetTextureType,\n      inject,\n      samplerTextureMap\n    } = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs = props._fs || getPassthroughFS({\n      version: getShaderVersion(vs),\n      input: this.targetTextureVarying,\n      inputType: targetTextureType,\n      output: FS_OUTPUT_VARIABLE\n    });\n    const modules = this.hasSourceTextures || this.targetTextureVarying ? [transformModule].concat(props.modules || []) : props.modules;\n    return {\n      vs,\n      fs,\n      modules,\n      uniforms,\n      inject: combinedInject\n    };\n  }\n}","map":{"version":3,"sources":["../../../src/transform/texture-transform.js"],"names":["cloneTextureFrom","readPixelsToArray","getShaderVersion","Buffer","Texture2D","Framebuffer","_transform","transformModule","getPassthroughFS","typeToChannelCount","combineInjects","updateForTextures","getSizeUniforms","SRC_TEX_PARAMETER_OVERRIDES","FS_OUTPUT_VARIABLE","TextureTransform","constructor","gl","props","id","currentIndex","_swapTexture","targetTextureVarying","targetTextureType","samplerTextureMap","bindings","resources","_initialize","Object","seal","updateModelProps","updatedModelProps","_processVertexShader","assign","getDrawOptions","opts","sourceBuffers","sourceTextures","framebuffer","targetTexture","attributes","uniforms","parameters","discard","hasSourceTextures","hasTargetTexture","transform_elementID","elementIDBuffer","sampler","textureName","_setSourceTextureParameters","sizeUniforms","sourceTextureMap","viewport","width","height","swap","_getNextIndex","update","_setupTextures","getTargetTexture","getData","packed","pixels","ArrayType","channelCount","packedPixels","length","packCount","i","j","getFramebuffer","currentResources","delete","ownTexture","_targetTextureVarying","_createTargetTexture","textureOrReference","refTexture","_targetRefTexName","_createNewTexture","_sourceTextures","_targetTexture","keys","_updateBindings","_updateElementIDBuffer","elementCount","elementIds","Float32Array","forEach","_","index","array","data","accessor","size","setData","_updateBinding","_swapTextures","nextIndex","binding","attachments","resizeAttachments","resize","name","setParameters","texture","pixelStore","vs","inject","combinedInject","fs","_fs","version","input","inputType","output","modules","concat"],"mappings":"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","sourcesContent":["/** @typedef {import('./transform').TransformProps} TransformProps */\nimport GL from '@luma.gl/constants';\n\nimport {\n  cloneTextureFrom,\n  readPixelsToArray,\n  getShaderVersion,\n  Buffer,\n  Texture2D,\n  Framebuffer\n} from '@luma.gl/webgl';\n\nimport {\n  _transform as transformModule,\n  getPassthroughFS,\n  typeToChannelCount,\n  combineInjects\n} from '@luma.gl/shadertools';\n\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// TODO: move these constants to transform-shader-utils\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class TextureTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.id = this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  updateModelProps(props = {}) {\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions(opts = {}) {\n    const {sourceBuffers, sourceTextures, framebuffer, targetTexture} = this.bindings[\n      this.currentIndex\n    ];\n\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {attributes, framebuffer, uniforms, discard, parameters};\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupTextures(opts);\n  }\n\n  // returns current target texture\n  getTargetTexture() {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData({packed = false} = {}) {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    // @ts-ignore\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Delete owned resources.\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {_targetTextureVarying, _swapTexture} = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n\n  // auto create target texture if requested\n  _createTargetTexture(props) {\n    const {sourceTextures, textureOrReference} = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    // 'targetTexture' is a reference souce texture.\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrReference;\n\n    return this._createNewTexture(refTexture);\n  }\n\n  /** @param {TransformProps} props */\n  _setupTextures(props = {}) {\n    const {sourceBuffers, _sourceTextures = {}, _targetTexture} = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures =\n      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);\n    this._updateBindings({sourceBuffers, sourceTextures: _sourceTextures, targetTexture});\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {sourceBuffers, sourceTextures, targetTexture} = opts;\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n\n      const {width, height} = targetTexture;\n      const {framebuffer} = binding;\n      if (framebuffer) {\n        // First update texture without re-sizing attachments\n        framebuffer.update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: targetTexture},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        framebuffer.resize({width, height});\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `transform-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [GL.COLOR_ATTACHMENT0]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n\n    return {sourceTextures, targetTexture};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // thre can only be one target texture\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  // build and return shader releated parameters\n  _processVertexShader(props = {}) {\n    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];\n    // @ts-ignore TODO - uniforms is not present\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transformModule].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}