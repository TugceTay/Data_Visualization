{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { Vector3 } from 'math.gl';\nimport { Geometry } from '@luma.gl/core';\nimport { COORDINATE_SYSTEM, CompositeLayer } from '@deck.gl/core';\nimport { PointCloudLayer } from '@deck.gl/layers';\nimport { ScenegraphLayer, SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport { log } from '@deck.gl/core';\nimport { load } from '@loaders.gl/core';\nimport { Tileset3D, TILE_TYPE } from '@loaders.gl/tiles';\nimport { Tiles3DLoader } from '@loaders.gl/3d-tiles';\nvar scratchOffset = new Vector3();\nvar defaultProps = {\n  getPointColor: [0, 0, 0],\n  pointSize: 1.0,\n  data: null,\n  loadOptions: {},\n  loader: Tiles3DLoader,\n  onTilesetLoad: function onTilesetLoad(tileset3d) {},\n  onTileLoad: function onTileLoad(tileHeader) {},\n  onTileUnload: function onTileUnload(tileHeader) {},\n  onTileError: function onTileError(tile, message, url) {}\n};\nvar Tile3DLayer = function (_CompositeLayer) {\n  _inherits(Tile3DLayer, _CompositeLayer);\n  function Tile3DLayer() {\n    _classCallCheck(this, Tile3DLayer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Tile3DLayer).apply(this, arguments));\n  }\n  _createClass(Tile3DLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      if ('onTileLoadFail' in this.props) {\n        log.removed('onTileLoadFail', 'onTileError')();\n      }\n      this.state = {\n        layerMap: {},\n        tileset3d: null\n      };\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n        oldProps = _ref2.oldProps,\n        changeFlags = _ref2.changeFlags;\n      if (props.data && props.data !== oldProps.data) {\n        this._loadTileset(props.data);\n      }\n      if (changeFlags.viewportChanged) {\n        var tileset3d = this.state.tileset3d;\n        this._updateTileset(tileset3d);\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info,\n        sourceLayer = _ref3.sourceLayer;\n      var layerMap = this.state.layerMap;\n      var layerId = sourceLayer && sourceLayer.id;\n      if (layerId) {\n        var substr = layerId.substring(this.id.length + 1);\n        var tileId = substr.substring(substr.indexOf('-') + 1);\n        info.object = layerMap[tileId] && layerMap[tileId].tile;\n      }\n      return info;\n    }\n  }, {\n    key: \"_loadTileset\",\n    value: function () {\n      var _loadTileset2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tilesetUrl) {\n        var _this$props, loader, loadOptions, options, preloadOptions, tilesetJson, tileset3d;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$props = this.props, loader = _this$props.loader, loadOptions = _this$props.loadOptions;\n                options = _objectSpread({}, loadOptions);\n                if (!loader.preload) {\n                  _context.next = 7;\n                  break;\n                }\n                _context.next = 5;\n                return loader.preload(tilesetUrl, loadOptions);\n              case 5:\n                preloadOptions = _context.sent;\n                Object.assign(options, preloadOptions);\n              case 7:\n                _context.next = 9;\n                return load(tilesetUrl, loader, options);\n              case 9:\n                tilesetJson = _context.sent;\n                tileset3d = new Tileset3D(tilesetJson, _objectSpread({\n                  onTileLoad: this._onTileLoad.bind(this),\n                  onTileUnload: this._onTileUnload.bind(this),\n                  onTileLoadFail: this.props.onTileError\n                }, options));\n                this.setState({\n                  tileset3d: tileset3d,\n                  layerMap: {}\n                });\n                this._updateTileset(tileset3d);\n                this.props.onTilesetLoad(tileset3d);\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function _loadTileset(_x) {\n        return _loadTileset2.apply(this, arguments);\n      }\n      return _loadTileset;\n    }()\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(tileHeader) {\n      this.props.onTileLoad(tileHeader);\n      this._updateTileset(this.state.tileset3d);\n      this.setNeedsUpdate();\n    }\n  }, {\n    key: \"_onTileUnload\",\n    value: function _onTileUnload(tileHeader) {\n      delete this.state.layerMap[tileHeader.id];\n      this.props.onTileUnload(tileHeader);\n    }\n  }, {\n    key: \"_updateTileset\",\n    value: function _updateTileset(tileset3d) {\n      var _this$context = this.context,\n        timeline = _this$context.timeline,\n        viewport = _this$context.viewport;\n      if (!timeline || !viewport || !tileset3d) {\n        return;\n      }\n      var frameNumber = tileset3d.update(viewport);\n      var tilesetChanged = this.state.frameNumber !== frameNumber;\n      if (tilesetChanged) {\n        this.setState({\n          frameNumber: frameNumber\n        });\n      }\n    }\n  }, {\n    key: \"_create3DTileLayer\",\n    value: function _create3DTileLayer(tileHeader) {\n      if (!tileHeader.content) {\n        return null;\n      }\n      switch (tileHeader.type) {\n        case TILE_TYPE.POINTCLOUD:\n          return this._createPointCloudTileLayer(tileHeader);\n        case TILE_TYPE.SCENEGRAPH:\n          return this._create3DModelTileLayer(tileHeader);\n        case TILE_TYPE.MESH:\n          return this._createSimpleMeshLayer(tileHeader);\n        default:\n          throw new Error(\"Tile3DLayer: Failed to render layer of type \".concat(tileHeader.content.type));\n      }\n    }\n  }, {\n    key: \"_createPointCloudTileLayer\",\n    value: function _createPointCloudTileLayer(tileHeader) {\n      var _tileHeader$content = tileHeader.content,\n        attributes = _tileHeader$content.attributes,\n        pointCount = _tileHeader$content.pointCount,\n        constantRGBA = _tileHeader$content.constantRGBA,\n        cartographicOrigin = _tileHeader$content.cartographicOrigin,\n        modelMatrix = _tileHeader$content.modelMatrix;\n      var positions = attributes.positions,\n        normals = attributes.normals,\n        colors = attributes.colors;\n      if (!positions) {\n        return null;\n      }\n      var _this$props2 = this.props,\n        pointSize = _this$props2.pointSize,\n        getPointColor = _this$props2.getPointColor;\n      var SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n      return new SubLayerClass({\n        pointSize: pointSize\n      }, this.getSubLayerProps({\n        id: 'pointcloud'\n      }), {\n        id: \"\".concat(this.id, \"-pointcloud-\").concat(tileHeader.id),\n        data: {\n          header: {\n            vertexCount: pointCount\n          },\n          attributes: {\n            POSITION: positions,\n            NORMAL: normals,\n            COLOR_0: colors\n          }\n        },\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getColor: constantRGBA || getPointColor\n      });\n    }\n  }, {\n    key: \"_create3DModelTileLayer\",\n    value: function _create3DModelTileLayer(tileHeader) {\n      var _tileHeader$content2 = tileHeader.content,\n        gltf = _tileHeader$content2.gltf,\n        instances = _tileHeader$content2.instances,\n        cartographicOrigin = _tileHeader$content2.cartographicOrigin,\n        modelMatrix = _tileHeader$content2.modelMatrix;\n      var SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n      return new SubLayerClass({\n        _lighting: 'pbr'\n      }, this.getSubLayerProps({\n        id: 'scenegraph'\n      }), {\n        id: \"\".concat(this.id, \"-scenegraph-\").concat(tileHeader.id),\n        data: instances || [{}],\n        scenegraph: gltf,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getTransformMatrix: function getTransformMatrix(instance) {\n          return instance.modelMatrix;\n        },\n        getPosition: function getPosition(instance) {\n          return [0, 0, 0];\n        }\n      });\n    }\n  }, {\n    key: \"_createSimpleMeshLayer\",\n    value: function _createSimpleMeshLayer(tileHeader) {\n      var content = tileHeader.content;\n      var attributes = content.attributes,\n        modelMatrix = content.modelMatrix,\n        cartographicOrigin = content.cartographicOrigin,\n        texture = content.texture;\n      var normals = attributes.normals,\n        texCoords = attributes.texCoords;\n      var positions = new Float32Array(attributes.positions.value.length);\n      for (var i = 0; i < positions.length; i += 3) {\n        scratchOffset.copy(attributes.positions.value.subarray(i, i + 3));\n        positions.set(scratchOffset, i);\n      }\n      var geometry = new Geometry({\n        drawMode: 4,\n        attributes: {\n          positions: positions,\n          normals: normals,\n          texCoords: texCoords\n        }\n      });\n      var SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n      return new SubLayerClass(this.getSubLayerProps({\n        id: 'mesh'\n      }), {\n        id: \"\".concat(this.id, \"-mesh-\").concat(tileHeader.id),\n        mesh: geometry,\n        data: [{}],\n        getPosition: [0, 0, 0],\n        getColor: [255, 255, 255],\n        texture: texture,\n        modelMatrix: modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this = this;\n      var _this$state = this.state,\n        tileset3d = _this$state.tileset3d,\n        layerMap = _this$state.layerMap;\n      if (!tileset3d) {\n        return null;\n      }\n      return tileset3d.tiles.map(function (tile) {\n        var layer = layerMap[tile.id] && layerMap[tile.id].layer;\n        if (tile.selected) {\n          if (!layer) {\n            layer = _this._create3DTileLayer(tile);\n            layerMap[tile.id] = {\n              layer: layer,\n              tile: tile\n            };\n          }\n          if (layer && layer.props && !layer.props.visible) {\n            layer = layer.clone({\n              visible: true\n            });\n            layerMap[tile.id].layer = layer;\n          }\n          return layer;\n        }\n        if (layer && layer.props && layer.props.visible) {\n          layer = layer.clone({\n            visible: false\n          });\n          layerMap[tile.id].layer = layer;\n        }\n        return layer;\n      }).filter(Boolean);\n    }\n  }]);\n  return Tile3DLayer;\n}(CompositeLayer);\nexport { Tile3DLayer as default };\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/tile-3d-layer/tile-3d-layer.js"],"names":["Vector3","Geometry","COORDINATE_SYSTEM","CompositeLayer","PointCloudLayer","ScenegraphLayer","SimpleMeshLayer","log","load","Tileset3D","TILE_TYPE","Tiles3DLoader","scratchOffset","defaultProps","getPointColor","pointSize","data","loadOptions","loader","onTilesetLoad","onTileLoad","onTileUnload","onTileError","tile","message","url","Tile3DLayer","props","removed","state","layerMap","tileset3d","changeFlags","somethingChanged","oldProps","_loadTileset","viewportChanged","_updateTileset","info","sourceLayer","layerId","id","substr","substring","length","tileId","indexOf","object","tilesetUrl","options","preload","preloadOptions","Object","assign","tilesetJson","_onTileLoad","bind","_onTileUnload","onTileLoadFail","setState","tileHeader","setNeedsUpdate","timeline","viewport","context","frameNumber","update","tilesetChanged","content","type","POINTCLOUD","_createPointCloudTileLayer","SCENEGRAPH","_create3DModelTileLayer","MESH","_createSimpleMeshLayer","Error","attributes","pointCount","constantRGBA","cartographicOrigin","modelMatrix","positions","normals","colors","SubLayerClass","getSubLayerClass","getSubLayerProps","header","vertexCount","POSITION","NORMAL","COLOR_0","coordinateSystem","METER_OFFSETS","coordinateOrigin","getColor","gltf","instances","_lighting","scenegraph","getTransformMatrix","instance","getPosition","texture","texCoords","Float32Array","value","i","copy","subarray","set","geometry","drawMode","mesh","tiles","map","layer","selected","_create3DTileLayer","visible","clone","filter","Boolean","layerName"],"mappings":"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","sourcesContent":["import {Vector3} from 'math.gl';\nimport GL from '@luma.gl/constants';\nimport {Geometry} from '@luma.gl/core';\nimport {COORDINATE_SYSTEM, CompositeLayer} from '@deck.gl/core';\nimport {PointCloudLayer} from '@deck.gl/layers';\nimport {ScenegraphLayer, SimpleMeshLayer} from '@deck.gl/mesh-layers';\nimport {log} from '@deck.gl/core';\n\nimport {load} from '@loaders.gl/core';\nimport {Tileset3D, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Tiles3DLoader} from '@loaders.gl/3d-tiles';\n\nconst scratchOffset = new Vector3();\n\nconst defaultProps = {\n  getPointColor: [0, 0, 0],\n  pointSize: 1.0,\n\n  data: null,\n  loadOptions: {},\n  loader: Tiles3DLoader,\n\n  onTilesetLoad: tileset3d => {},\n  onTileLoad: tileHeader => {},\n  onTileUnload: tileHeader => {},\n  onTileError: (tile, message, url) => {}\n};\n\nexport default class Tile3DLayer extends CompositeLayer {\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n    // prop verification\n    this.state = {\n      layerMap: {},\n      tileset3d: null\n    };\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    if (props.data && props.data !== oldProps.data) {\n      this._loadTileset(props.data);\n    }\n\n    if (changeFlags.viewportChanged) {\n      const {tileset3d} = this.state;\n      this._updateTileset(tileset3d);\n    }\n  }\n\n  getPickingInfo({info, sourceLayer}) {\n    const {layerMap} = this.state;\n    const layerId = sourceLayer && sourceLayer.id;\n    if (layerId) {\n      // layerId: this.id-[scenegraph|pointcloud]-tileId\n      const substr = layerId.substring(this.id.length + 1);\n      const tileId = substr.substring(substr.indexOf('-') + 1);\n      info.object = layerMap[tileId] && layerMap[tileId].tile;\n    }\n\n    return info;\n  }\n\n  async _loadTileset(tilesetUrl) {\n    const {loader, loadOptions} = this.props;\n    const options = {...loadOptions};\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n      Object.assign(options, preloadOptions);\n    }\n    const tilesetJson = await load(tilesetUrl, loader, options);\n\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileLoadFail: this.props.onTileError,\n      ...options\n    });\n\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n\n    this._updateTileset(tileset3d);\n    this.props.onTilesetLoad(tileset3d);\n  }\n\n  _onTileLoad(tileHeader) {\n    this.props.onTileLoad(tileHeader);\n    this._updateTileset(this.state.tileset3d);\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tileHeader) {\n    // Was cleaned up from tileset cache. We no longer need to track it.\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n\n  _updateTileset(tileset3d) {\n    const {timeline, viewport} = this.context;\n    if (!timeline || !viewport || !tileset3d) {\n      return;\n    }\n    const frameNumber = tileset3d.update(viewport);\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n    if (tilesetChanged) {\n      this.setState({frameNumber});\n    }\n  }\n\n  _create3DTileLayer(tileHeader) {\n    if (!tileHeader.content) {\n      return null;\n    }\n\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._createPointCloudTileLayer(tileHeader);\n      case TILE_TYPE.SCENEGRAPH:\n        return this._create3DModelTileLayer(tileHeader);\n      case TILE_TYPE.MESH:\n        return this._createSimpleMeshLayer(tileHeader);\n      default:\n        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);\n    }\n  }\n\n  _createPointCloudTileLayer(tileHeader) {\n    const {\n      attributes,\n      pointCount,\n      constantRGBA,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const {positions, normals, colors} = attributes;\n\n    if (!positions) {\n      return null;\n    }\n\n    const {pointSize, getPointColor} = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass(\n      {\n        pointSize\n      },\n      this.getSubLayerProps({\n        id: 'pointcloud'\n      }),\n      {\n        id: `${this.id}-pointcloud-${tileHeader.id}`,\n        data: {\n          header: {\n            vertexCount: pointCount\n          },\n          attributes: {\n            POSITION: positions,\n            NORMAL: normals,\n            COLOR_0: colors\n          }\n        },\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n\n        getColor: constantRGBA || getPointColor\n      }\n    );\n  }\n\n  _create3DModelTileLayer(tileHeader) {\n    const {gltf, instances, cartographicOrigin, modelMatrix} = tileHeader.content;\n\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n\n    return new SubLayerClass(\n      {\n        _lighting: 'pbr'\n      },\n      this.getSubLayerProps({\n        id: 'scenegraph'\n      }),\n      {\n        id: `${this.id}-scenegraph-${tileHeader.id}`,\n        data: instances || [{}],\n        scenegraph: gltf,\n\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getTransformMatrix: instance => instance.modelMatrix,\n        getPosition: instance => [0, 0, 0]\n      }\n    );\n  }\n\n  _createSimpleMeshLayer(tileHeader) {\n    const content = tileHeader.content;\n    const {attributes, modelMatrix, cartographicOrigin, texture} = content;\n    const {normals, texCoords} = attributes;\n    const positions = new Float32Array(attributes.positions.value.length);\n    for (let i = 0; i < positions.length; i += 3) {\n      scratchOffset.copy(attributes.positions.value.subarray(i, i + 3));\n      positions.set(scratchOffset, i);\n    }\n\n    const geometry = new Geometry({\n      drawMode: GL.TRIANGLES,\n      attributes: {\n        positions,\n        normals,\n        texCoords\n      }\n    });\n\n    const SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n\n    return new SubLayerClass(\n      this.getSubLayerProps({\n        id: 'mesh'\n      }),\n      {\n        id: `${this.id}-mesh-${tileHeader.id}`,\n        mesh: geometry,\n        data: [{}],\n        getPosition: [0, 0, 0],\n        getColor: [255, 255, 255],\n        texture,\n        modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS\n      }\n    );\n  }\n\n  renderLayers() {\n    const {tileset3d, layerMap} = this.state;\n    if (!tileset3d) {\n      return null;\n    }\n\n    return tileset3d.tiles\n      .map(tile => {\n        let layer = layerMap[tile.id] && layerMap[tile.id].layer;\n        // render selected tiles\n        if (tile.selected) {\n          // create layer\n          if (!layer) {\n            layer = this._create3DTileLayer(tile);\n            layerMap[tile.id] = {layer, tile};\n          }\n          // update layer visibility\n          if (layer && layer.props && !layer.props.visible) {\n            // Still has GPU resource but visibility is turned off so turn it back on so we can render it.\n            layer = layer.clone({visible: true});\n            layerMap[tile.id].layer = layer;\n          }\n          return layer;\n        }\n\n        // hide non-selected tiles\n        if (layer && layer.props && layer.props.visible) {\n          // Still in tileset cache but doesn't need to render this frame. Keep the GPU resource bound but don't render it.\n          layer = layer.clone({visible: false});\n          layerMap[tile.id].layer = layer;\n        }\n        return layer;\n      })\n      .filter(Boolean);\n  }\n}\n\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}